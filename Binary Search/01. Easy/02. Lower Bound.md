## Lower Bound

**Problem Statement:**  
Given a sorted array of N integers and an integer `x`, write a program to find the lower bound of `x`.

### What is a lower bound?

The lower bound algorithm finds the first or the smallest index in a sorted array where the value at that index is greater than or equal to a given key, i.e., `x`.

- The lower bound is the smallest index, `ind`, where `arr[ind] >= x`.
- If any such index is not found, the lower bound algorithm returns `n`, i.e., the size of the given array.

>### Examples:

#### <ins>Example 1:</ins>

- **Input Format:** `N = 4`, `arr[] = {1,2,2,3}`, `x = 2`
- **Result:** `1`
- **Explanation:** Index 1 is the smallest index such that `arr[1] >= x`.

#### <ins>Example 2:</ins>

- **Input Format:** `N = 5`, `arr[] = {3,5,8,15,19}`, `x = 9`
- **Result:** `3`
- **Explanation:** Index 3 is the smallest index such that `arr[3] >= x`.

#### <ins>Example 3: Corner Cases for Lower Bound:</ins>
| Case Description | Example | `index` | Reason |
| :--- | :--- | :--- | :--- |
| *Target is Smaller than All Elements* | `arr = {10, 20, 30}`, `x = 5` | `0` | Index `0` is the first position where `arr[ind] >= 5`. |
| *Target is Larger than All Elements* | `arr = {10, 20, 30}`, `x = 40` | `3` size of arr | No element is `>= 40`, so the answer is `n`. |
| *Target Exists with Duplicates* | `arr = {2, 5, 5, 8}`, `x = 5` | `1` | Must find the *first* index `ind` where `arr[ind] >= 5`. |
| *Target Falls Between Elements* | `arr = {3, 5, 8, 15}`, `x = 9` | `3` | Index `3` (`arr[3]=15`) is the first position where `arr[ind] >= 9`. |
| *Empty Array* | `arr = {}`, `x = 10` | `0` size of arr | No elements, so the answer is `n=0`. |

---

## Brute Force Approach

### Algorithm:

Let’s understand how we can find the answer using the linear search algorithm. With the knowledge that the array is sorted, 
our approach involves traversing the array starting from the beginning. During this traversal, each element will be compared with the target value, `x`. 
The index, `i`, where the condition `arr[i] >= x` is first satisfied, will be the answer.


``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class containing methods for array operations
class LowerBoundFinder {
public:
    // Function to find lower bound index
    int lowerBound(vector<int> arr, int n, int x) {
        // Traverse the array
        for (int i = 0; i < n; i++) {
            // If the current element is greater than or equal to x
            if (arr[i] >= x) {
                return i;  // Return index of the first such element
            }
        }
        // If all elements are smaller than x
        return n;
    }
};

int main() {
    vector<int> arr = {3, 5, 8, 15, 19};
    int n = arr.size();  // Size of the array
    int x = 9;           // Target value

    LowerBoundFinder finder;                  // Create object
    int ind = finder.lowerBound(arr, n, x);   // Find lower bound index

    cout << "The lower bound is the index: " << ind << "\n";

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N)`, where `N` = size of the given array.
- **Space Complexity:** `O(1)`, no extra space used.

---

## Optimal Approach

### Algorithm:

As the array is sorted, we will apply the Binary Search algorithm to find the index. The steps are as follows:

1.  We will declare the 2 pointers and an `ans` variable initialized to `n`, i.e., the size of the array (as if we don’t find any index, we will return `n`).

2.  *Place the 2 pointers, i.e., `low` and `high`:* Initially, we will place the pointers like this: `low` will point to the first index, and `high` will point to the last index.

3.  *Calculate the `mid`:* Now, we will calculate the value of `mid` using the following formula:
    ```text
    mid = (low+high) // 2 ( ‘//’ refers to integer division)
    ```

4.  *Compare `arr[mid]` with `x`:* With comparing `arr[mid]` to `x`, we can observe 2 different cases:
    -   *Case 1 - If `arr[mid] >= x`:* This condition means that the index `mid` may be an answer. So, we will update the `ans` variable with `mid` and 
          search in the *left half* if there is any smaller index that satisfies the same condition. Here, we are eliminating the right half.
    -   *Case 2 - If `arr[mid] < x`:* In this case, `mid` cannot be our answer, and we need to find a bigger element. So, we will eliminate the 
          left half and search in the *right half* for the answer.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to find the lower bound index in an array
class LowerBoundFinder {
public:
    // Function to find the lower bound using binary search
    int lowerBound(vector<int> arr, int n, int x) {
        int low = 0;           // Start of search range
        int high = n - 1;      // End of search range
        int ans = n;           // Default to n (not found)

        // Binary search loop
        while (low <= high) {
            int mid = (low + high) / 2;  // Middle index

            if (arr[mid] >= x) {
                ans = mid;           // Store possible answer
                high = mid - 1;      // Try to find smaller index on left side
            } else {
                low = mid + 1;       // Move right if current element is less than x
            }
        }
        return ans;  // Return the index of the lower bound
    }
};

int main() {
    vector<int> arr = {3, 5, 8, 15, 19};  // Sorted input array
    int n = arr.size();                  // Size of array
    int x = 9;                           // Target value

    LowerBoundFinder finder;            // Create object of the class
    int ind = finder.lowerBound(arr, n, x);  // Call method to find lower bound

    cout << "The lower bound is the index: " << ind << "\n";  // Output the result
    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** `O(log n)`, used for typical binary search.
- **Space Complexity:** `O(1)`, no extra space used.
