## Search Insert Position (similar to lower bound)

**Problem Statement:**  
You are given a sorted array `arr` of distinct values and a target value `x`. You need to search for the index of the target value in the array.

>### Examples:

#### Example 1:
-   **Input Format:** `arr[] = {1,2,4,7}`, `x = 6`
-   **Result:** `3`
-   **Explanation:** `6` is not present in the array. So, if we insert `6` in the 3rd index(0-based indexing), the array will still be sorted. `{1,2,4,6,7}`.

#### Example 2:
-   **Input Format:** `arr[] = {1,2,4,7}`, `x = 2`
-   **Result:** `1`
-   **Explanation:** 2 is present in the array, and so we will return its index, i.e., 1.

---

## Brute Force Approach

### Algorithm:

Let’s understand how we can find the answer using the linear search algorithm. With the knowledge that the array is sorted, 
our approach involves traversing the array starting from the beginning. During this traversal, each element will be compared with the target value, `x`. 
The index, `i`, where the condition `arr[i] >= x` is first satisfied, will be the answer.


``` cpp
#include <iostream>
#include <vector>
#include <string>

// Class to solve the Search Insert Position problem
class SearchInsertSolver {
public:
    int searchInsert(const std::vector<int>& arr, int n, int x) {
        // Traverse the array from the beginning
        for (int i = 0; i < n; i++) {
            // Find the first element that is greater than or equal to x
            if (arr[i] >= x) {
                // This is the correct position
                return i;
            }
        }
        // If all elements are smaller than x, the insertion position is at the end
        return n;
    }
};

int main() {
    std::vector<int> arr = {1, 3, 5, 6};
    int n = arr.size();
    int x = 5; // Case 1: Target is present

    SearchInsertSolver solver;
    int ind = solver.searchInsert(arr, n, x);
    std::cout << "Target: " << x << " -> The insertion position is at index: " << ind << "\n"; // Expected: 2

    x = 2; // Case 2: Target is not present
    ind = solver.searchInsert(arr, n, x);
    std::cout << "Target: " << x << " -> The insertion position is at index: " << ind << "\n"; // Expected: 1

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N)`, where `N` = size of the given array.
- **Space Complexity:** `O(1)`, no extra space used.

---

## Optimal Approach

### Algorithm:

As the array is sorted, we will apply the Binary Search algorithm to find the index. The steps are as follows:

1.  We will declare the 2 pointers and an `ans` variable initialized to `n`, i.e., the size of the array (as if we don’t find any index, we will return `n`).

2.  *Place the 2 pointers, i.e., `low` and `high`:* Initially, we will place the pointers like this: `low` will point to the first index, and `high` will point to the last index.

3.  *Calculate the `mid`:* Now, we will calculate the value of `mid` using the following formula:
    ```text
    mid = (low+high) // 2 ( ‘//’ refers to integer division)
    ```

4.  *Compare `arr[mid]` with `x`:* With comparing `arr[mid]` to `x`, we can observe 2 different cases:
    -   *Case 1 - If `arr[mid] >= x`:* This condition means that the index `mid` may be an answer. So, we will update the `ans` variable with `mid` and 
          search in the *left half* if there is any smaller index that satisfies the same condition. Here, we are eliminating the right half.
    -   *Case 2 - If `arr[mid] < x`:* In this case, `mid` cannot be our answer, and we need to find a bigger element. So, we will eliminate the 
          left half and search in the *right half* for the answer.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to find the lower bound index in an array
class LowerBoundFinder {
public:
    // Function to find the lower bound using binary search
    int lowerBound(vector<int> arr, int n, int x) {
        int low = 0;           // Start of search range
        int high = n - 1;      // End of search range
        int ans = n;           // Default to n (not found)

        // Binary search loop
        while (low <= high) {
            int mid = (low + high) / 2;  // Middle index

            if (arr[mid] >= x) {
                ans = mid;           // Store possible answer
                high = mid - 1;      // Try to find smaller index on left side
            } else {
                low = mid + 1;       // Move right if current element is less than x
            }
        }
        return ans;  // Return the index of the lower bound
    }
};

int main() {
    vector<int> arr = {3, 5, 8, 15, 19};  // Sorted input array
    int n = arr.size();                  // Size of array
    int x = 9;                           // Target value

    LowerBoundFinder finder;            // Create object of the class
    int ind = finder.lowerBound(arr, n, x);  // Call method to find lower bound

    cout << "The lower bound is the index: " << ind << "\n";  // Output the result
    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** `O(log n)`, used for typical binary search.
- **Space Complexity:** `O(1)`, no extra space used.
