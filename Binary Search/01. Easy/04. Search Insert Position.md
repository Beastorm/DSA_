## Search Insert Position (similar to lower bound)

**Problem Statement:**  
You are given a sorted array `arr` of distinct values and a target value `x`. You need to search for the index of the target value in the array.

>### Examples:

#### Example 1:
-   **Input Format:** `arr[] = {1,2,4,7}`, `x = 6`
-   **Result:** `3`
-   **Explanation:** `6` is not present in the array. So, if we insert `6` in the 3rd index(0-based indexing), the array will still be sorted. `{1,2,4,6,7}`.

#### Example 2:
-   **Input Format:** `arr[] = {1,2,4,7}`, `x = 2`
-   **Result:** `1`
-   **Explanation:** 2 is present in the array, and so we will return its index, i.e., 1.

---

## Brute Force Approach

### Algorithm:

Let’s understand how we can find the answer using the linear search algorithm. With the knowledge that the array is sorted, 
our approach involves traversing the array starting from the beginning. During this traversal, each element will be compared with the target value, `x`. 
The index, `i`, where the condition `arr[i] >= x` is first satisfied, will be the answer.


``` cpp
#include <iostream>
#include <vector>
#include <string>

// Class to solve the Search Insert Position problem
class SearchInsertSolver {
public:
    int searchInsert(const std::vector<int>& arr, int n, int x) {
        // Traverse the array from the beginning
        for (int i = 0; i < n; i++) {
            // Find the first element that is greater than or equal to x
            if (arr[i] >= x) {
                // This is the correct position
                return i;
            }
        }
        // If all elements are smaller than x, the insertion position is at the end
        return n;
    }
};

int main() {
    std::vector<int> arr = {1, 3, 5, 6};
    int n = arr.size();
    int x = 5; // Case 1: Target is present

    SearchInsertSolver solver;
    int ind = solver.searchInsert(arr, n, x);
    std::cout << "Target: " << x << " -> The insertion position is at index: " << ind << "\n"; // Expected: 2

    x = 2; // Case 2: Target is not present
    ind = solver.searchInsert(arr, n, x);
    std::cout << "Target: " << x << " -> The insertion position is at index: " << ind << "\n"; // Expected: 1

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N)`, where `N` = size of the given array.
- **Space Complexity:** `O(1)`, no extra space used.

---

## Optimal Approach

### Algorithm:

As the array is sorted, we will apply the Binary Search algorithm to find the index. The steps are as follows:

1.  We will declare the 2 pointers and an `ans` variable initialized to `n`, i.e., the size of the array (as if we don’t find any index, we will return `n`).

2.  *Place the 2 pointers, i.e., `low` and `high`:* Initially, we will place the pointers like this: `low` will point to the first index, and `high` will point to the last index.

3.  *Calculate the `mid`:* Now, we will calculate the value of `mid` using the following formula:
    ```text
    mid = (low+high) // 2 ( ‘//’ refers to integer division)
    ```

4.  *Compare `arr[mid]` with `x`:* With comparing `arr[mid]` to `x`, we can observe 2 different cases:
    -   *Case 1 - If `arr[mid] >= x`:* This condition means that the index `mid` may be an answer. So, we will update the `ans` variable with `mid` and 
          search in the *left half* if there is any smaller index that satisfies the same condition. Here, we are eliminating the right half.
    -   *Case 2 - If `arr[mid] < x`:* In this case, `mid` cannot be our answer, and we need to find a bigger element. So, we will eliminate the 
          left half and search in the *right half* for the answer.

``` cpp
#include <iostream>
#include <vector>
#include <string>

// Class to find the search insert position in a sorted array
class SearchInsertSolver {
public:

    int searchInsert(const std::vector<int>& arr, int n, int x) {
        int low = 0;           // Start of the search range
        int high = n - 1;      // End of the search range
        int ans = n;           // Default position is at the end if x is larger than all elements

        // Binary search to find the first element >= x
        while (low <= high) {
            // Using a safer way to calculate mid to prevent potential integer overflow
            int mid = low + (high - low) / 2;

            if (arr[mid] >= x) {
                // This is a potential insertion position.
                ans = mid;
                // Try to find an even earlier position to the left.
                high = mid - 1;
            } else {
                // arr[mid] is smaller than x, so the insertion point must be to the right.
                low = mid + 1;
            }
        }
        return ans; // Return the found index or insertion position
    }
};

int main() {
    std::vector<int> arr = {1, 3, 5, 6};    // Sorted input array
    int n = arr.size();                    // Size of array
    
    SearchInsertSolver solver; // Create object of the class

    // Case 1: Target is not present, should be inserted in the middle
    int x1 = 2;
    int ind1 = solver.searchInsert(arr, n, x1);
    std::cout << "For target " << x1 << ", the insertion position is at index: " << ind1 << "\n"; // Expected: 1

    // Case 2: Target is present in the array
    int x2 = 5;
    int ind2 = solver.searchInsert(arr, n, x2);
    std::cout << "For target " << x2 << ", the insertion position is at index: " << ind2 << "\n"; // Expected: 2
    
    // Case 3: Target is larger than all elements
    int x3 = 7;
    int ind3 = solver.searchInsert(arr, n, x3);
    std::cout << "For target " << x3 << ", the insertion position is at index: " << ind3 << "\n"; // Expected: 4

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(log n)`, used for typical binary search.
- **Space Complexity:** `O(1)`, no extra space used.
