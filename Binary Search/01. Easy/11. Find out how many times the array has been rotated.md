## Find out how many times the array has been rotated

**Problem Statement:**   
Given an integer array `arr` of size N, sorted in ascending order (with distinct values). Now the array is rotated between `1 to N` times, which is unknown. Find how many times the array has been rotated.

---

>### Examples:

#### Example 1:

-   **Input:** `arr = [4,5,6,7,0,1,2,3]`
-   **Result:** `4`
-   **Explanation:** The original array should be `[0,1,2,3,4,5,6,7]`. So, we can notice that the array has been rotated 4 times.

#### Example 2:

-   **Input:** `arr = [3,4,5,1,2]`
-   **Output:** `3`
-   **Explanation:** The original array should be `[1,2,3,4,5]`. So, we can notice that the array has been rotated 3 times.

---

## Brute force Approach

### Algorithm:

Imagine you wrote numbers on a circular track in increasing order and then rotated them. If you want to find how many times it’s been rotated, 
the most direct way is to restore it to the original sorted form and see how many positions everything has shifted. In brute force, 
we simply search for the smallest element in the array because it’s the point where the rotation happened; its index directly tells us the rotation count. 
But brute force does this without thinking about sorted array properties—just check every element one by one.

Think of it like standing at the start of the circle and walking forward until you find the smallest number, then count how many steps it took to get there. That step count is your answer.

1.  Store the first element as a reference.
2.  Initialize a variable to track the smallest element's index.
3.  Iterate through every element of the array.
4.  If you find an element smaller than the stored smallest, update the smallest and store its index.
5.  Once the loop ends, return the index of the smallest element—that’s the number of rotations.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the number of rotations in a rotated sorted array
    int findRotations(vector<int>& arr) {
        // Store size of array
        int n = arr.size();

        // Assume the first element is the smallest
        int minVal = arr[0];

        // Index of the smallest element
        int minIndex = 0;

        // Traverse the array
        for (int i = 1; i < n; i++) {
            // If current element is smaller than minVal, update
            if (arr[i] < minVal) {
                minVal = arr[i];
                minIndex = i;
            }
        }

        // The index of smallest element = number of rotations
        return minIndex;
    }
};

int main() {
    Solution obj;

    // Example input
    vector<int> arr = {4,5,6,7,0,1,2,3};

    // Call the function and store the result
    int rotations = obj.findRotations(arr);

    // Print result
    cout << rotations << endl;
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(n)`. We scan the entire array once to find the smallest element, where `n` is the size of the array.
-   **Space Complexity:** `O(1)`. We only use a few extra variables to store the minimum value and its index, so the extra space used is constant.


---

## Better Approach

### Algorithm:

Think of the sorted array as a sorted belt of numbers. Rotation just cuts the belt at one position and reattaches it. 
The spot where the order breaks—where a number is bigger than the next number—is exactly where the cut happened.
So instead of searching for the minimum value by comparing all values to a running minimum, just walk once through the array and 
find the first place where the sequence goes down. The rotation count is the number of steps from the start to that break point. 
If there’s no break, the array wasn’t rotated.

1.  Traverse the array from the first element to the second-last element.
2.  At each step, check if the current element is greater than the next element.
3.  If such a break is found, return the index of the next element (that index is the rotation count).
4.  If no break is found after the full pass, return 0 (array not rotated).


``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to find rotation count using one-pass scan
int findRotationCount(vector<int> &arr) {
    // Get the size of the array
    int n = arr.size();
    // Traverse the array till the second-last element
    for (int i = 0; i < n - 1; i++) {
        // If the current element is greater than the next, a break point is found
        if (arr[i] > arr[i + 1]) {
            // Rotation count is the index of the next element
            return i + 1;
        }
    }
    // If no break point found, array not rotated
    return 0;
}

int main() {
    // Example input
    vector<int> arr = {3, 4, 5, 1, 2};
    // Function call to get rotation count
    int rotations = findRotationCount(arr);
    // Output the result
    cout << rotations << endl;
    return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(n)`. We traverse the array once to find the rotation point, where `n` is the size of the array.
-   **Space Complexity:** `O(1)`. Only a few extra variables are used regardless of input size, so constant space.

---

## Optimal Approach

### Intuition:

A sorted array that has been rotated (e.g., `[0,1,2,3,4,5] → [4,5,0,1,2,3]`) still consists of **two sorted parts**.  
The index of the **minimum element** is exactly the **number of rotations**.

We can use binary search to locate this minimum:

- If the current segment `[low..high]` is already sorted (`arr[low] <= arr[high]`),  
  then `arr[low]` is the smallest in this segment → we can stop.
- Otherwise, **one half is sorted** and the other half contains the rotation point:
  - If `arr[low] <= arr[mid]`, the **left half is sorted** → its smallest is `arr[low]`,  
    but the global minimum (rotation point) must be in the **right half**.
  - Else, the **right half is sorted** → its smallest is `arr[mid]`,  
    but the global minimum must be in the **left half**.

We keep track of the smallest value seen and its index; that index is the rotation count.

---

### Algorithm Steps:

1. Initialize:
   - `low = 0`, `high = n - 1`
   - `ansValue = +∞` (or `INT_MAX`), `ansIndex = 0`

2. While `low <= high`:
   1. Compute `mid = (low + high) / 2`.
   2. If `arr[low] <= arr[high]` (segment `[low..high]` sorted):
      - Update `ansValue` and `ansIndex` with `arr[low]` and `low`.
      - Break (no smaller element in this segment).
   3. Else if `arr[low] <= arr[mid]` (left half sorted):
      - Update answer with `arr[low]` and `low`.
      - Move right: `low = mid + 1`.
   4. Else (right half sorted):
      - Update answer with `arr[mid]` and `mid`.
      - Move left: `high = mid - 1`.

3. Return `ansIndex` as the **rotation count** (index of minimum element).

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find rotation count (index of minimum element)
    int findRotations(vector<int>& arr) {
        int n = arr.size();
        int low = 0, high = n - 1;
        int ansIndex = 0;        // index of minimum
        int ansValue = INT_MAX;  // value of minimum found so far

        while (low <= high) {
            int mid = (low + high) / 2;

            // If the current segment [low..high] is already sorted,
            // then arr[low] is the smallest in this segment.
            if (arr[low] <= arr[high]) {
                if (arr[low] < ansValue) {
                    ansValue = arr[low];
                    ansIndex = low;
                }
                break;  // whole segment sorted; no need to search further
            }

            // Left half [low..mid] is sorted
            if (arr[low] <= arr[mid]) {
                // arr[low] is the smallest in this sorted half
                if (arr[low] < ansValue) {
                    ansValue = arr[low];
                    ansIndex = low;
                }
                // Discard the left half, search in the right half
                low = mid + 1;
            }
            // Right half [mid..high] is sorted
            else {
                // arr[mid] is the smallest in this sorted half
                if (arr[mid] < ansValue) {
                    ansValue = arr[mid];
                    ansIndex = mid;
                }
                // Discard the right half after mid, search in the left half
                high = mid - 1;
            }
        }

        // ansIndex is the index of the minimum element => rotation count
        return ansIndex;
    }
};

int main() {
    Solution sol;
    vector<int> arr = {4, 5, 6, 7, 0, 1, 2, 3};

    int rotations = sol.findRotations(arr);

    cout << rotations << endl;   // Expected output: 4
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(log n)`. The binary search halves the search space each iteration, where `n` is the size of the array.
-   **Space Complexity:** `O(1)`. Only a few variables are used regardless of input size, so constant extra space.
