## Find out how many times the array has been rotated

**Problem Statement:**   
Given an integer array `arr` of size N, sorted in ascending order (with distinct values). Now the array is rotated between `1 to N` times, which is unknown. Find how many times the array has been rotated.

---

>### Examples:

#### Example 1:

-   **Input:** `arr = [4,5,6,7,0,1,2,3]`
-   **Result:** `4`
-   **Explanation:** The original array should be `[0,1,2,3,4,5,6,7]`. So, we can notice that the array has been rotated 4 times.

#### Example 2:

-   **Input:** `arr = [3,4,5,1,2]`
-   **Output:** `3`
-   **Explanation:** The original array should be `[1,2,3,4,5]`. So, we can notice that the array has been rotated 3 times.

---

## Brute force Approach

### Algorithm:

Imagine you wrote numbers on a circular track in increasing order and then rotated them. If you want to find how many times it’s been rotated, 
the most direct way is to restore it to the original sorted form and see how many positions everything has shifted. In brute force, 
we simply search for the smallest element in the array because it’s the point where the rotation happened; its index directly tells us the rotation count. 
But brute force does this without thinking about sorted array properties—just check every element one by one.

Think of it like standing at the start of the circle and walking forward until you find the smallest number, then count how many steps it took to get there. That step count is your answer.

1.  Store the first element as a reference.
2.  Initialize a variable to track the smallest element's index.
3.  Iterate through every element of the array.
4.  If you find an element smaller than the stored smallest, update the smallest and store its index.
5.  Once the loop ends, return the index of the smallest element—that’s the number of rotations.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the number of rotations in a rotated sorted array
    int findRotations(vector<int>& arr) {
        // Store size of array
        int n = arr.size();

        // Assume the first element is the smallest
        int minVal = arr[0];

        // Index of the smallest element
        int minIndex = 0;

        // Traverse the array
        for (int i = 1; i < n; i++) {
            // If current element is smaller than minVal, update
            if (arr[i] < minVal) {
                minVal = arr[i];
                minIndex = i;
            }
        }

        // The index of smallest element = number of rotations
        return minIndex;
    }
};

int main() {
    Solution obj;

    // Example input
    vector<int> arr = {4,5,6,7,0,1,2,3};

    // Call the function and store the result
    int rotations = obj.findRotations(arr);

    // Print result
    cout << rotations << endl;
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(n)`. We scan the entire array once to find the smallest element, where `n` is the size of the array.
-   **Space Complexity:** `O(1)`. We only use a few extra variables to store the minimum value and its index, so the extra space used is constant.


---

## Better Approach

### Algorithm:

Think of the sorted array as a sorted belt of numbers. Rotation just cuts the belt at one position and reattaches it. 
The spot where the order breaks—where a number is bigger than the next number—is exactly where the cut happened.
So instead of searching for the minimum value by comparing all values to a running minimum, just walk once through the array and 
find the first place where the sequence goes down. The rotation count is the number of steps from the start to that break point. 
If there’s no break, the array wasn’t rotated.

1.  Traverse the array from the first element to the second-last element.
2.  At each step, check if the current element is greater than the next element.
3.  If such a break is found, return the index of the next element (that index is the rotation count).
4.  If no break is found after the full pass, return 0 (array not rotated).


``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to find rotation count using one-pass scan
int findRotationCount(vector<int> &arr) {
    // Get the size of the array
    int n = arr.size();
    // Traverse the array till the second-last element
    for (int i = 0; i < n - 1; i++) {
        // If the current element is greater than the next, a break point is found
        if (arr[i] > arr[i + 1]) {
            // Rotation count is the index of the next element
            return i + 1;
        }
    }
    // If no break point found, array not rotated
    return 0;
}

int main() {
    // Example input
    vector<int> arr = {3, 4, 5, 1, 2};
    // Function call to get rotation count
    int rotations = findRotationCount(arr);
    // Output the result
    cout << rotations << endl;
    return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(n)`. We traverse the array once to find the rotation point, where `n` is the size of the array.
-   **Space Complexity:** `O(1)`. Only a few extra variables are used regardless of input size, so constant space.

---
## Optimal Approach

### Algorithm:

Think of the rotated sorted array as two sorted halves—the rotation “break” point is where the smallest element lives. Using binary search, we can efficiently zoom in on the smallest element by comparing middle elements to the rightmost element. If the middle element is greater than the rightmost element, the rotation point is to the right. Otherwise, it's to the left or could be the middle itself. This way, we reduce the search space by half each time, getting the rotation count in `O(log n)`.

Imagine searching for the break in a long, sorted belt by cutting it in half repeatedly instead of scanning all the way through.

1.  Initialize `low = 0` and `high = n - 1`.
2.  While `low` is less than `high`:
    -   Find `mid` index.
    -   If the element at `mid` is greater than the element at `high`, the rotation point is after `mid`, so update `low = mid + 1`.
    -   Else, the rotation point is at `mid` or before it, so update `high = mid`.
3.  When `low` meets `high`, that index is the rotation count (index of the smallest element).

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find rotation count using binary search
    int findRotations(vector<int>& arr) {
        // Initialize low and high pointers
        int low = 0;
        int high = arr.size() - 1;

        // Loop until low meets high
        while (low < high) {
            // Find mid index
            int mid = low + (high - low) / 2;

            // If mid element is greater than the element at high,
            // smallest element lies to the right of mid
            if (arr[mid] > arr[high]) {
                low = mid + 1;
            } else {
                // Else the smallest element is at mid or to the left
                high = mid;
            }
        }

        // When low == high, we found the smallest element
        return low;
    }
};

int main() {
    Solution sol;
    vector<int> arr = {4,5,6,7,0,1,2,3};

    int rotations = sol.findRotations(arr);

    cout << rotations << endl;
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(log n)`. The binary search halves the search space each iteration, where `n` is the size of the array.
-   **Space Complexity:** `O(1)`. Only a few variables are used regardless of input size, so constant extra space.
