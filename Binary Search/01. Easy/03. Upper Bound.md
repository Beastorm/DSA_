## Upper Bound

**Problem Statement:**  
Given a sorted array of N integers and an integer x, write a program to find the upper bound of x.

### What is Upper Bound?

The upper bound algorithm finds the first or the smallest index in a sorted array where the value at that index is **greater than** the given key i.e. x.

The upper bound is the smallest index, `ind`, where `arr[ind] > x`.

---

>### Examples:

#### Example 1:

-   **Input Format:** `N = 4`, `arr[] = {1,2,2,3}`, `x = 2`
-   **Result:** `3`
-   **Explanation:** Index 3 is the smallest index such that `arr[3] > x`.

#### Example 2:

-   **Input Format:** `N = 6`, `arr[] = {3,5,8,9,15,19}`, `x = 9`
-   **Result:** `4`
-   **Explanation:** Index 4 is the smallest index such that `arr[4] > x`.

#### Example 4:

Let's use `arr[] = {10, 20, 20, 20, 30, 40}` and search for `x = 20`.

| Bound | Result (Index) | Visual Representation |
| :--- | :--- | :--- |
| **Lower Bound (`>= 20`)** | `1` | `{10,` **`20`**`, 20, 20, 30, 40}` <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `^` |
| **Upper Bound (`> 20`)** | `4` | `{10, 20, 20, 20,` **`30`**`, 40}` <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `^` |


#### Example 4: Corner Cases for Upper Bound

| Case Description | Example | `ind` | Reason |
| :--- | :--- | :--- | :--- |
| *Target is Smaller than All Elements* | `arr = {10, 20, 30}`, `x = 5` | `0` | Index `0` is the first position where `arr[ind] > 5`. |
| *Target is Larger than All Elements* | `arr = {10, 20, 30}`, `x = 40` | `3` (size of array) | No element is `> 40`, so the answer is `n`. |
| *Target is Equal to an Element* | `arr = {2, 5, 5, 8}`, `x = 5` | `3` | Index `3` (`arr[3]=8`) is the first position where `arr[ind] > 5`. |
| *Target is Equal to Last Element* | `arr = {10, 20, 30}`, `x = 30` | `3` (size of array) | No element is `> 30`, so the answer is `n`. |
| *Target Falls Between Elements* | `arr = {3, 5, 8, 15}`, `x = 9` | `3` | Index `3` (`arr[3]=15`) is the first position where `arr[ind] > 9`. |
| *Empty Array* | `arr = {}`, `x = 10` | `0` (size of array) | No elements, so the answer is `n=0`. |

---

### Lower Bound vs Upper Bound:

| Feature | Lower Bound | Upper Bound |
| :--- | :--- | :--- |
| **Condition** | Finds the first element **`>= x`** | Finds the first element **`> x`** |
| **If `x` is in array** | Points to the **first** occurrence of `x`. | Points **after the last** occurrence of `x`. |
| **If `x` not in array**| Points to the next greater element. | Points to the next greater element (same as lower bound).|
| **C++ STL Function**| `std::lower_bound` | `std::upper_bound` |


#### Key Takeaway:

A simple way to remember the difference and a powerful use case:

-   **Lower Bound**: "Where does the range of elements equal to `x` begin?"
-   **Upper Bound**: "Where does the range of elements equal to `x` end?"

This leads to a formula to *count the occurrences* of `x`:
`count = upper_bound(x) - lower_bound(x)`

In our example: `count = 4 - 1 = 3`. There are three `20`s in the array.

---

## Brute Force Approach

### Algorithm:
Let’s understand how we can find the answer using the linear search algorithm. With the knowledge that the array is sorted, our approach involves traversing 
the array starting from the beginning. During this traversal, each element will be compared with the target value, `x`. The index, `i`, where the condition `arr[i] > x` is
first satisfied, will be the answer.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to find the upper bound index in an array
class UpperBoundFinder {
public:
    // Linear search method to find the upper bound
    int upperBound(vector<int> &arr, int x, int n) {
        for (int i = 0; i < n; i++) {
            if (arr[i] > x) {
                return i; // First element strictly greater than x
            }
        }
        return n; // If no such element exists, return n
    }
};

int main() {
    vector<int> arr = {3, 5, 8, 9, 15, 19}; // Sorted input array
    int n = arr.size();                    // Size of the array
    int x = 9;                             // Target value

    UpperBoundFinder finder;              // Create object of class
    int ind = finder.upperBound(arr, x, n); // Call method

    cout << "The upper bound is the index: " << ind << "\n"; // Output result
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N)`, where `N` = size of the given array.
- **Space Complexity:** `O(1)`, no extra space used.

---

## Optimal Approach

### Algorithm:

As the array is sorted, we will apply the Binary Search algorithm to find the index. The steps are as follows:

1.  We will declare 2 pointers and an `ans` variable initialized to `n`, i.e., the size of the array (as if we don’t find any index, we will return `n`).
2.  *Place the 2 pointers, i.e., `low` and `high`:* Initially, we will place the pointers like this: `low` will point to the first index, and `high` will point to the last index.
3.  *Calculate the `mid`:* Now, we will calculate the value of `mid` using the following formula:
    ```text
    mid = (low + high) // 2    // ‘//’ refers to integer division
    ```
4.  *Compare `arr[mid]` with `x`:*With comparing `arr[mid]` to `x`, we can observe 2 different cases:
    -   *Case 1 - If `arr[mid] > x`:* This condition means that the index `mid` may be an answer. So, we will update the `ans` variable with `mid` and search in the *left half* if there is any smaller index that satisfies the same condition. Here, we are eliminating the right half.
    -   *Case 2 - If `arr[mid] <= x`:* In this case, `mid` cannot be our answer, and we need to find a bigger element. So, we will eliminate the left half and search in the *right half* for the answer.


``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to compute upper bound
class UpperBoundFinder {
public:
    // Function to find the upper bound using binary search
    int upperBound(vector<int> &arr, int x, int n) {
        int low = 0, high = n - 1;
        int ans = n;  // Default answer if x is >= all elements

        while (low <= high) {
            int mid = (low + high) / 2;

            if (arr[mid] > x) {
                ans = mid;        // Potential answer found
                high = mid - 1;   // Try to find a smaller valid index on the left
            } else {
                low = mid + 1;    // Move right if mid is <= x
            }
        }
        return ans;  // Index of the first element > x
    }
};

int main() {
    vector<int> arr = {3, 5, 8, 9, 15, 19};  // Sorted input array
    int n = arr.size();                     // Size of the array
    int x = 9;                              // Target value

    UpperBoundFinder finder;               // Create object
    int ind = finder.upperBound(arr, x, n);  // Call method

    cout << "The upper bound is the index: " << ind << "\n";  // Output result
    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O(log n)`, used for typical binary search.
-   **Space Complexity:** `O(1)`, no extra space used.
