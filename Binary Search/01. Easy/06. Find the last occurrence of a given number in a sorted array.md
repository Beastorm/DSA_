## Find the last occurrence of a given number in a sorted array (Similar to Upper Bound)

**Problem Statement:**  
Given a sorted array of `N` integers, write a program to find the index of the *last occurrence* of the target key. If the target is not found, then return `-1`.


>### Examples:

#### Example 1:

-   **Input:** `N = 7`, `target = 13`, `array[] = {3, 4, 13, 13, 13, 20, 40}`
-   **Output:** `4`
-   **Explanation:** The target value 13 has its last occurrence at index 4.

#### Example 2:

-   **Input:** `N = 7`, `target = 60`, `array[] = {3, 4, 13, 13, 13, 20, 40}`
-   **Output:** `-1`
-   **Explanation:** The target value 60 is not present in the array, so the output is -1.

---

## Brute Force

### Algorithm:
1.  Start traversing the array from the back using a for loop, starting from the last index and moving towards the first.
2.  Check if the current element matches the `target` element.
3.  If the `target` element is found, break out of the loop and print the resulting index where the target was found.
4.  If the `target` element is not found after traversing the entire array, print `-1` to indicate that the element is not present.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// find last index of key by scanning from right
int solve(int n, int key, vector<int>& v) {
  // initialize result as not found
  int res = -1;
  // scan from the end toward the start
  for (int i = n - 1; i >= 0; i--) {
    // update and stop when match found
    if (v[i] == key) {
      res = i;
      break;
    }
  }
  // return index or -1
  return res;
}

// program entry
int main() {
  // set size
  int n = 7;
  // set key to search
  int key = 13;
  // define input array
  vector<int> v = {3, 4, 13, 13, 13, 20, 40};
  // print last occurrence index (or -1)
  cout << solve(n, key, v) << "\n";
  // exit
  return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(N)`, where `N` is the size of the array. This is because we are traversing the array once to find the last occurrence of the target element.

-   **Space Complexity:** `O(1)`, as we are using a constant amount of space for the result variable and the loop index. We are not using any additional data structures that grow with the input size.

---
## Optimal Approach

### Algorithm:

Given that the array is sorted, we can use binary search to efficiently search for the target element.

1.  Initially, set two pointers: `start = 0` and `end = n-1`, where `n` is the size of the array. Also, initialize the `result` variable to `-1`.

2.  While `start` is less than or equal to `end`, compute the `mid` index as:
    ```
    mid = (start + end) / 2
    ```

3.  Check if the `mid` element is equal to the target `key`:
    -   If they are equal, store the `mid` value in the `result` and move the `start` pointer to `mid + 1` to continue searching in the *right half*.
    -   If the `key` value is less than the `mid` element, update the `end` pointer to `mid - 1` to search the *left half*.
    -   If the `key` value is greater than the `mid` element, update the `start` pointer to `mid + 1` to search the *right half*.

4.  Repeat the process until the `start` pointer crosses the `end` pointer or the element is found.

5.  If the element is found, the `result` will store its index; otherwise, it will remain `-1`, indicating that the target is not present in the array.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// find last index of key using binary search
int solve(int n, int key, vector<int>& v) {
  // initialize search bounds and result
  int start = 0;
  int end = n - 1;
  int res = -1;

  // binary search loop
  while (start <= end) {
    // compute mid safely
    int mid = start + (end - start) / 2;
    
    // when match found, store index and move right
    if (v[mid] == key) {
      res = mid;       // Store this index as a potential answer
      
      start = mid + 1; // IMPORTANT: Keep searching for a later occurrence on the right
    }
    // when key is smaller, move left
    else if (key < v[mid]) {
      end = mid - 1;
    }
    // otherwise move right
    else {
      start = mid + 1;
    }
  }
  // return last occurrence or -1
  return res;
}

// program entry
int main() {
  // define input size and key
  int n = 7;
  int key = 13;
  // define sorted array
  vector<int> v = {3, 4, 13, 13, 13, 20, 40};
  // print last occurrence index (or -1)
  cout << solve(n, key, v) << "\n";
  // exit
  return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(log N)`, where `N` is the size of the array. This is because we are using binary search, which reduces the search space by half in each iteration.

-   **Space Complexity:** `O(1)`, as we are using a constant amount of space for the result variable and the loop indices. We are not using any additional data structures that grow with the input size.
