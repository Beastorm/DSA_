## Find the last occurrence of a given number in a sorted array (Similar to Upper Bound)

**Problem Statement:**  
Given a sorted array of `N` integers, write a program to find the index of the *last occurrence* of the target key. If the target is not found, then return `-1`.


>### Examples:

#### Example 1:

-   **Input:** `N = 7`, `target = 13`, `array[] = {3, 4, 13, 13, 13, 20, 40}`
-   **Output:** `4`
-   **Explanation:** The target value 13 has its last occurrence at index 4.

#### Example 2:

-   **Input:** `N = 7`, `target = 60`, `array[] = {3, 4, 13, 13, 13, 20, 40}`
-   **Output:** `-1`
-   **Explanation:** The target value 60 is not present in the array, so the output is -1.

---

## Brute Force

### Algorithm:
1.  Start traversing the array from the back using a for loop, starting from the last index and moving towards the first.
2.  Check if the current element matches the `target` element.
3.  If the `target` element is found, break out of the loop and print the resulting index where the target was found.
4.  If the `target` element is not found after traversing the entire array, print `-1` to indicate that the element is not present.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// find last index of key by scanning from right
int solve(int n, int key, vector<int>& v) {
  // initialize result as not found
  int res = -1;
  // scan from the end toward the start
  for (int i = n - 1; i >= 0; i--) {
    // update and stop when match found
    if (v[i] == key) {
      res = i;
      break;
    }
  }
  // return index or -1
  return res;
}

// program entry
int main() {
  // set size
  int n = 7;
  // set key to search
  int key = 13;
  // define input array
  vector<int> v = {3, 4, 13, 13, 13, 20, 40};
  // print last occurrence index (or -1)
  cout << solve(n, key, v) << "\n";
  // exit
  return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(N)`, where `N` is the size of the array. This is because we are traversing the array once to find the last occurrence of the target element.

-   **Space Complexity:** `O(1)`, as we are using a constant amount of space for the result variable and the loop index. We are not using any additional data structures that grow with the input size.

---

## Optimal Approach

### Intuition:

The `upper_bound(key)` finds the index of the first element that is *strictly greater* than the `key`. This means the element at the index just before it (`upper_bound - 1`) must be the rightmost element that is less than or equal to the `key`.

If that element is our `key`, we've found its last occurrence.


### Algorithm:

1.  *Find Upper Bound:* Use binary search to find the index of the `upper_bound(key)`. Let's call this `idx`.

2.  *Step Back:* Move one index to the left to `idx - 1`.

3.  *Verify:*
    -   Check if `idx > 0` (to avoid going out of bounds) AND if the element at `arr[idx - 1]` is actually equal to the `key`.
    -   If both are true, return `idx - 1`.
    -   Otherwise, the `key` was not found. Return `-1`.

    
``` cpp
#include <bits/stdc++.h>
using namespace std;

// This function behaves like upper_bound
// It finds the FIRST index where v[i] > key
int solve_as_upper_bound(int n, int key, const vector<int>& v) {
  int start = 0;
  int end = n - 1;
  int res = n; // Default answer is n

  while (start <= end) {
    int mid = start + (end - start) / 2;
    if (v[mid] > key) {
      res = mid;
      end = mid - 1; // Search left for an even earlier index
    } else {
      start = mid + 1; // Search right
    }
  }
  return res;
}

// NEW FUNCTION: Finds last occurrence using the upper_bound logic
int findLastOccurrence(int n, int key, const vector<int>& v) {
    // 1. Find the upper bound of the key
    int upperBoundIndex = solve_as_upper_bound(n, key, v);

    // 2. Handle Edge Case: If the upper bound is the first element (index 0),
    //    it means no element is <= key, so key is not in the array.
    if (upperBoundIndex == 0) {
        return -1;
    }

    // 3. Check the element at the previous index
    //    If arr[upperBoundIndex - 1] is our key, that's the last occurrence.
    if (v[upperBoundIndex - 1] == key) {
        return upperBoundIndex - 1;
    }

    // 4. Otherwise, the key was not found.
    return -1;
}

int main() {
  int n = 7;
  vector<int> v = {3, 4, 13, 13, 13, 20, 40};

  // Find last occurrence of 13
  int key1 = 13;
  // upper_bound(13) will be 5 (index of 20)
  // 5 - 1 = 4. arr[4] is 13. Correct.
  cout << "Last occurrence of " << key1 << " is at index: " << findLastOccurrence(n, key1, v) << "\n"; // Expected: 4

  // Find last occurrence of 3
  int key2 = 3;
  // upper_bound(3) will be 1 (index of 4)
  // 1 - 1 = 0. arr[0] is 3. Correct.
  cout << "Last occurrence of " << key2 << " is at index: " << findLastOccurrence(n, key2, v) << "\n"; // Expected: 0

  // Find last occurrence of 15 (not in array)
  int key3 = 15;
  // upper_bound(15) will be 5 (index of 20)
  // 5 - 1 = 4. arr[4] is 13, which is not 15. The function returns -1. Correct.
  cout << "Last occurrence of " << key3 << " is at index: " << findLastOccurrence(n, key3, v) << "\n"; // Expected: -1

  return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(log N)`, where `N` is the size of the array. This is because we are using binary search, which reduces the search space by half in each iteration.

-   **Space Complexity:** `O(1)`, as we are using a constant amount of space for the result variable and the loop indices. We are not using any additional data structures that grow with the input size.
