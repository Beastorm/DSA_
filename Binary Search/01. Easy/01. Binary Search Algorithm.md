## Binary Search:

**Problem Statement:**  
You are given a **sorted array of integers** and a **target**; your task is to search for the target in the given array.  
Assume the given array does not contain any duplicate numbers.

---

## Approach - I (Iterative):

### Search Space:
The entire area between the `low` and the `high` pointer (including them) is considered the *search space*.  
Here, the search space is *sorted*.

### Intuition:
The array is *sorted*, so we don’t need to check every element.

We repeatedly:  

- Look at the *middle element*.
- If it equals the target → *return its index*.
- If it’s *smaller* than the target → discard the *left half*.
- If it’s *larger* than the target → discard the *right half*.

``` cpp

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to perform Binary Search on sorted array
    int binarySearch(vector& nums, int target) {
        int n = nums.size(); // size of the array
        int low = 0, high = n - 1;

        // Keep searching until low crosses high
        while (low <= high) {
            int mid = (low + high) / 2; // Find the middle index
            if (nums[mid] == target) return mid;       // Target found
            else if (target > nums[mid]) low = mid + 1; // Search in right half
            else high = mid - 1;                        // Search in left half
        }
        return -1; // Target not found
    }
};

int main()
{
    vector a = {3, 4, 6, 7, 9, 12, 16, 17}; // sorted array
    int target = 6; // target element to search

    Solution obj; // Create object of Solution class
    int ind = obj.binarySearch(a, target);

    if (ind == -1) cout << "The target is not present." << endl;
    else cout << "The target is at index: " << ind << endl;

    return 0;
}

```
### Complexity Analysis:

**Time Complexity:**  

- **Best case:** `O(1)`  
  - The target is found at the middle index on the first comparison.

- **Average case:** `O(log n)`  
  - Each iteration halves the search space (`n → n/2 → n/4 → ...`), so the number of steps is proportional to `log₂(n)`.

- **Worst case:** `O(log n)`  
  - Even if the target is not present, we keep halving the array until the search space becomes empty.

**Space Complexity:**  

- **Iterative version (this code):** `O(1)`  
  - Uses a constant amount of extra space (`low`, `high`, `mid`, a few integers).

- **Recursive version (if implemented):** `O(log n)`  
  - Due to the call stack depth, which follows the number of recursive calls (one per level of halving).

---

## Approach - II (Recursive):

### Intuition:

The logic is the same as the iterative approach:

- The array is *sorted*, so we can repeatedly:
  - Look at the *middle element*.
  - If it equals the target → return its index.
  - If it’s smaller than the target → search in the *right half*.
  - If it’s larger than the target → search in the *left half*.
- Instead of a loop, we use *recursion* and pass `low` and `high` as parameters.
- At each recursive call, the search space shrinks until:
  - We find the target, or
  - The search space becomes invalid (`low > high`).


```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Recursive Binary Search on sorted array
    int binarySearch(vector<int>& nums, int low, int high, int target) {
        // Base case: invalid search space
        if (low > high) return -1;

        int mid = (low + high) / 2; // Find the middle index

        if (nums[mid] == target) 
            return mid; // Target found

        else if (target > nums[mid]) 
            // Search in the right half
            return binarySearch(nums, mid + 1, high, target);
        else 
            // Search in the left half
            return binarySearch(nums, low, mid - 1, target);
    }
};

int main()
{
    vector<int> a = {3, 4, 6, 7, 9, 12, 16, 17}; // sorted array
    int target = 6; // target element to search

    Solution obj; // Create object of Solution class
    int ind = obj.binarySearch(a, 0, a.size() - 1, target);

    if (ind == -1) cout << "The target is not present." << endl;
    else cout << "The target is at index: " << ind << endl;

    return 0;
}
```

### Complexity Analysis:

**Time Complexity:**

- **Best case:** `O(1)`  
  - Target is found at the middle index in the first call.
- **Average case:** `O(log n)`  
  - Each recursive call halves the search space.
- **Worst case:** `O(log n)`  
  - We keep halving until the search space becomes empty (or the target is found near the end).

**Space Complexity:**

- **Recursive version:** `O(log n)`  
  - Due to the recursion call stack (one frame per level of halving).
