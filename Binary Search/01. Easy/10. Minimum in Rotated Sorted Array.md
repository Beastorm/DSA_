## Minimum in Rotated Sorted Array

**Problem Statement:**   
Given an integer array `arr` of size N, sorted in ascending order (with distinct values), the array is rotated at any unknown index. Find the minimum element in the array.

**Pre-requisites:**  
Search in Rotated Sorted Array I, Search in Rotated Sorted Array II & Binary Search algorithm

---

>### Examples:

#### Example 1:

-   **Input:** `arr = [4,5,6,7,0,1,2,3]`
-   **Output:** `0`
-   **Explanation:** The minimum element in the array is 0.

#### Example 2:

-   **Input:** `arr = [3,4,5,1,2]`
-   **Output:** `1`
-   **Explanation:** The minimum element in the array is 1.

---

## Brute-Force Approach

### Algorithm:

#### How does rotation occur?

Let's consider a sorted array: `{1, 2, 3, 4, 5}`. If we rotate this array at index 3, it will become: `{4, 5, 1, 2, 3}`. In essence, 
we moved the element at the last index to the front, while shifting the remaining elements to the right. We performed this process twice.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the minimum element using linear search
    int findMin(vector<int>& nums) {

        // Initialize answer with a large number
        int minVal = INT_MAX;

        // Traverse each element
        for (int i = 0; i < nums.size(); i++) {

            // Update minimum value
            minVal = min(minVal, nums[i]);
        }

        // Return the result
        return minVal;
    }
};

int main() {

    // Input array
    vector<int> nums = {4, 5, 6, 7, 0, 1, 2};

    // Create object of Solution
    Solution sol;

    // Call function and store result
    int result = sol.findMin(nums);

    // Output the result
    cout << "Minimum element is " << result << endl;

    return 0;
}

```
### Complexity Analysis:
-   **Time Complexity:** `O(N)`, we check every element once.
-   **Space Complexity:** `O(1)`, constant additional space is used.

---

## Optimal Approach [Unique Elements]

### Intuition:

- The array is **sorted and then rotated**. The minimum element is the **rotation point**.
- In any current range `[low..high]`:
  - If `arr[low] <= arr[high]`, the range is **already sorted** ⇒ the **minimum is `arr[low]`**.
  - Otherwise, **one half is sorted** and the other contains the rotation (and thus the true minimum).
    - If `arr[low] <= arr[mid]`, the **left half is sorted** ⇒ its minimum is `arr[low]`, but the overall minimum may lie in the **right half**.
    - Else, the **right half is sorted** ⇒ its minimum is `arr[mid]`, but the overall minimum may lie in the **left half**.

We keep tracking the best candidate `ans` and shrink the search space with binary search.


### Algorithm Steps:

1. Initialize:
   - `low = 0`, `high = n - 1`, `ans = +∞` (or `INT_MAX`).
2. While `low <= high`:
   1. Compute `mid = (low + high) / 2`.
   2. If `arr[low] <= arr[high]`:
      - The whole segment is sorted ⇒ `ans = min(ans, arr[low])`, `break`.
   3. If `arr[low] <= arr[mid]` (left half sorted):
      - `ans = min(ans, arr[low])`
      - Move right: `low = mid + 1`
   4. Else (right half sorted):
      - `ans = min(ans, arr[mid])`
      - Move left: `high = mid - 1`
3. Return `ans` as the minimum element.

``` cpp
#include <bits/stdc++.h>
using namespace std;

int findMin(vector<int>& arr) {
    int low = 0, high = arr.size() - 1;
    int ans = INT_MAX;

    while (low <= high) {
        int mid = (low + high) / 2;

        // If the current search space [low..high] is already sorted,
        // then arr[low] is the smallest element in this range.
        if (arr[low] <= arr[high]) {
            ans = min(ans, arr[low]);
            break;
        }

        // Left half [low..mid] is sorted
        if (arr[low] <= arr[mid]) {
            ans = min(ans, arr[low]);  // arr[low] is the smallest in this half
            low = mid + 1;             // discard left half
        }
        // Right half [mid..high] is sorted
        else {
            high = mid - 1;            // discard right half after mid
            ans = min(ans, arr[mid]);  // arr[mid] could be the minimum
        }
    }

    return ans;
}

// Driver code
int main() {
    // Example 1: rotated sorted array
    vector<int> arr1 = {4, 5, 6, 7, 0, 1, 2};
    cout << "Minimum element in arr1: " << findMin(arr1) << endl;  // Expected: 0

    // Example 2: not rotated (purely sorted) array
    vector<int> arr2 = {1, 2, 3, 4, 5};
    cout << "Minimum element in arr2: " << findMin(arr2) << endl;  // Expected: 1

    // Example 3: single element
    vector<int> arr3 = {10};
    cout << "Minimum element in arr3: " << findMin(arr3) << endl;  // Expected: 10

    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(logN)`, at every step, the search space is reduced to half using binary search.
-   **Space Complexity:** `O(1)`, constant additional space is used.
