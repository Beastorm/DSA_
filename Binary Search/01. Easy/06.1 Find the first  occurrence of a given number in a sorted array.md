## First Occurrence in a Sorted Array (Similar to Lower Bound)

**Problem Statement:**  
Given a sorted array of `N` integers that may contain duplicates, write a program to find the index of the *first occurrence* of a target key. If the target is not found, return `-1`.

---

>## Examples:

#### Example 1:

-   **Input:** `N = 7`, `target = 13`, `array[] = {3, 4, 13, 13, 13, 20, 40}`
-   **Output:** `2`
-   **Explanation:** The first occurrence of the target value `13` is at index `2`.

#### Example 2:

-   **Input:** `N = 7`, `target = 60`, `array[] = {3, 4, 13, 13, 13, 20, 40}`
-   **Output:** `-1`
-   **Explanation:** The target value `60` is not present in the array, so the output is `-1`.

---

## Brute Force Approach (Linear Search)

### Intuition:

The most straightforward way to find the *first* occurrence of an element is to scan the array from the beginning. We will traverse the array from left to right (from index 0 to the end).

The moment we encounter the `target` element for the first time, we know that it is our answer because we are starting from the leftmost position. If we finish traversing the whole array without finding the `target`, it means the element is not present.

### Algorithm:

1.  Use a loop to iterate through the array from index `i = 0` to `n - 1`, where `n` is the size of the array.
2.  Inside the loop, for each element `arr[i]`, check if it is equal to the `target`.
3.  If `arr[i] == target`, we have found the first occurrence. Return the current index `i` immediately.
4.  If the loop completes without finding the `target`, it means the element is not in the array. Return `-1`.

```cpp
#include <iostream>
#include <vector>

class Solution {
public:
    int findFirstOccurrence_brute(const std::vector<int>& nums, int target) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            // As soon as we find the target, we return the index.
            // Since we are scanning from the left, this is the first occurrence.
            if (nums[i] == target) {
                return i;
            }
        }
        // If the loop finishes, the target was not in the array.
        return -1;
    }
};

int main() {
    Solution sol;
    std::vector<int> arr = {3, 4, 13, 13, 13, 20, 40};
    int target1 = 13;
    int target2 = 60;

    // Case 1: Target is present
    int result1 = sol.findFirstOccurrence_brute(arr, target1);
    std::cout << "Brute Force: For target " << target1 << ", the first occurrence is at index: " << result1 << std::endl; 
    // Output: 2

    // Case 2: Target is not present
    int result2 = sol.findFirstOccurrence_brute(arr, target2);
    std::cout << "Brute Force: For target " << target2 << ", the first occurrence is at index: " << result2 << std::endl; 
    // Output: -1

    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(N)`, where `N` is the size of the array. This is because in the worst-case scenario (if the target is at the end of the array or not present at all), we have to traverse the entire array.

-   **Space Complexity:** `O(1)`, as we are using a constant amount of space for the loop index. We are not using any additional data structures that grow with the input size.

---

### Optimal Approach (Using Binary Search)

#### Intuition:

A standard binary search stops when it finds *any* match for the target. To find the *first* occurrence, we need to modify this behavior.

The key idea is:
-   When we find an occurrence of the `target` at index `mid`, we know it's a *possible* answer.
-   However, there might be an even earlier occurrence to its *left*.
-   So, we store this index (`mid`) as our potential answer and *continue our search in the left half* (`high = mid - 1`) to see if we can find a better (smaller) index.

This ensures that the search continues until we've found the leftmost possible match.

```cpp
#include <iostream>
#include <vector>

class Solution {
public:
 
    int findFirstOccurrence(const std::vector<int>& nums, int target) {
        int low = 0;
        int high = nums.size() - 1;
        int first = -1; // Initialize result to -1 (target not found)

        while (low <= high) {
            // Calculate mid safely to prevent integer overflow
            int mid = low + (high - low) / 2;

            if (nums[mid] == target) {
                // This is a potential answer.
                first = mid;
                // But we must look for an earlier occurrence on the left side.
                high = mid - 1;
            } else if (nums[mid] < target) {
                // Target must be in the right half.
                low = mid + 1;
            } else { // nums[mid] > target
                // Target must be in the left half.
                high = mid - 1;
            }
        }
        return first;
    }
};

int main() {
    Solution sol;
    std::vector<int> arr = {3, 4, 13, 13, 13, 20, 40};
    int target1 = 13;
    int target2 = 60;

    // Case 1: Target is present
    int result1 = sol.findFirstOccurrence(arr, target1);
    std::cout << "For target " << target1 << ", the first occurrence is at index: " << result1 << std::endl;
    // Output: 2

    // Case 2: Target is not present
    int result2 = sol.findFirstOccurrence(arr, target2);
    std::cout << "For target " << target2 << ", the first occurrence is at index: " << result2 << std::endl;
    // Output: -1

    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(log N)`
    -   We perform a single binary search, which reduces the search space by half in each iteration.

-   **Space Complexity:** `O(1)`
    -   The algorithm uses a constant amount of extra space for pointers and variables, regardless of the input array size.
