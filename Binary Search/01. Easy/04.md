## Search Insert Position

**Problem Statement:**  
You are given a sorted array `arr` of distinct values and a target value `x`. You need to search for the index of the target value in the array.

>### Examples:

#### Example 1:
-   **Input Format:** `arr[] = {1,2,4,7}`, `x = 6`
-   **Result:** `3`
-   **Explanation:** `6` is not present in the array. So, if we insert `6` in the 3rd index(0-based indexing), the array will still be sorted. `{1,2,4,6,7}`.

#### Example 2:
-   **Input Format:** `arr[] = {1,2,4,7}`, `x = 2`
-   **Result:** `1`
-   **Explanation:** 2 is present in the array, and so we will return its index, i.e., 1.

## Approach

### Algorithm

1.  We will declare 2 pointers and an `ans` variable initialized to `n`, i.e., the size of the array (as if we don’t find any index, we will return `n`).

2.  **Place the 2 pointers, i.e., `low` and `high`:** Initially, we will place the pointers like this: `low` will point to the first index, and `high` will point to the last index.

3.  **Calculate the `mid`:** Now, we will calculate the value of `mid` using the following formula:
    ```text
    mid = (low + high) // 2    // ‘//’ refers to integer division
    ```

4.  **Compare `arr[mid]` with `x`:** With comparing `arr[mid]` to `x`, we can observe 2 different cases:
    -   **Case 1 - If `arr[mid] >= x`:** This condition means that the index `mid` may be an answer. So, we will update the `ans` variable with `mid` and search in the **left half** if there is any smaller index that satisfies the same condition. Here, we are eliminating the right half.
    -   **Case 2 - If `arr[mid] < x`:** In this case, `mid` cannot be our answer, and we need to find a bigger element. So, we will eliminate the left half and search in the **right half** for the answer.

The above process will continue until the pointer `low` crosses `high`.
