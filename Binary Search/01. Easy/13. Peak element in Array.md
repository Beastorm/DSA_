## Peak element in Array

**Problem Statement:**  
Given an array of length N, a peak element is defined as the element greater than both of its neighbors. Formally, if `arr[i]` is the peak element, `arr[i - 1] < arr[i]` and `arr[i + 1] < arr[i]`. 
Find the index(0-based) of a peak element in the array. If there are multiple peak numbers, return the index of any peak number.

---

>### Examples:

#### Example 1: Standard Peak in the Middle

-   **Input:** `arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 5, 1}`.
-   **Output:** `7`
-   **Explanation:** The element `8` at index `7` is a peak because it is greater than its left neighbor (`7`) and its right neighbor (`5`).

#### Example 2: Multiple Peaks

-   **Input:** `arr[] = {1, 2, 1, 3, 5, 6, 4}`.
-   **Output:** `1` or `5`.
-   **Explanation:** There are two peak elements:
    -   `2` at index `1` (since `1 < 2 > 1`).
    -   `6` at index `5` (since `5 < 6 > 4`).
    Returning the index of either one is a correct answer.


---

## Brute Force Approach

### Algorithm:

A peak element in an array refers to the element that is greater than both of its neighbors. Basically, if `arr[i]` is the peak element, `arr[i] > arr[i-1]` and `arr[i] > arr[i+1]`.
Now, if we want to visualize an array with the peak elements from the graphical point of view, there can be 4 cases:

**Corner Case 1:** Strictly Increasing Array

-   *Input:* `arr[] = {1, 2, 3, 4, 5}`
-   *Output:* `4`
-   *Explanation:* The last element, `5`, is considered a peak because it is greater than its only neighbor (`4`).

**Corner Case 2:** Strictly Decreasing Array

-   *Input:* `arr[] = {5, 4, 3, 2, 1}`
-   *Output:* `0`
-   *Explanation:* The first element, `5`, is considered a peak because it is greater than its only neighbor (`4`).

**Corner Case 3:** Array with a Single Element

-   *Input:* `arr[] = {42}`
-   *Output:* `0`
-   *Explanation:* A single element is always considered a peak as it has no neighbors to be smaller than.

**Corner Case 4:** Array with Two Elements

-   *Input:* `arr[] = {5, 10}`
-   *Output:* `1`
-   *Explanation:* `10` at index `1` is the peak.

-   *Input:* `arr[] = {10, 5}`
-   *Output:* `0`
-   *Explanation:* `10` at index `0` is the peak.

The brute force approach to finding a peak element is to traverse the entire array and compare the current element with both of its neighbors. If it is greater than both of its neighbors, we can simply return it as our peak element.
For the elements at the first and last index, since neither neighbor is available, we can just check their only neighbor element and return if it's a peak element or not.


``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find a peak element in the array
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        
        // Traverse the array
        for (int i = 0; i < n; i++) {
            // Check left neighbor if exists
            bool left = (i == 0) || (nums[i] >= nums[i - 1]);
            // Check right neighbor if exists
            bool right = (i == n - 1) || (nums[i] >= nums[i + 1]);
            
            // If both sides are valid, return index
            if (left && right) return i;
        }

        // In case no peak found (shouldn't happen)
        return -1;
    }
};

// Driver
int main() {
    Solution sol;
    vector<int> nums = {1, 3, 20, 4, 1, 0};
    int index = sol.findPeakElement(nums);
    cout << "Peak at index: " << index << " with value: " << nums[index] << endl;
    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O(N)`, we traverse the entire array once to find the peak element.
-   **Space Complexity:** `O(1)`, constant additional space is used.

---

## Optimal Approach - (With 1 Peak Element)

### Intuition (The Hill-Climbing Analogy):

Think of the array as a mountain range with hills and valleys. Our goal is to find the top of any hill (a peak).

Instead of checking every spot, we use binary search to quickly decide which direction to go:

1.  *Stand in the middle* (at index `mid`).
2.  *Look at the element to your right (`arr[mid + 1]`)*:
    -   *If you are on an uphill slope* (`arr[mid] < arr[mid + 1]`): A peak is *guaranteed* to be on your right, because the array can't go up forever. So, you can completely ignore the left half.
    -   *If you are on a downhill slope* (`arr[mid] > arr[mid + 1]`): This current spot *might* be a peak, or a peak is to your left. In either case, you can safely ignore the right half.

By repeatedly eliminating half the mountain range, we quickly zero in on a peak.


### Algorithm:

1.  *Initialize Pointers:* Set `low = 0` and `high = n - 1`.

2.  *Loop:* While `low < high`:
    -   Find the middle index: `mid = (low + high) / 2`.
    -   *Check the slope:*
        -   If `arr[mid] < arr[mid + 1]` (uphill): The peak is on the right.  
            Set `low = mid + 1`.
        -   Else (downhill or at a peak): The peak is on the left or you're on it.  
            Set `high = mid`.

3.  *Return Result:* The loop ends when `low` and `high` meet. This meeting point is guaranteed to be a peak. Return `low` (or `high`).

*This simplified logic naturally handles all edge cases, including strictly increasing or decreasing arrays.*


``` cpp
#include <iostream>
#include <vector>

int findPeakElement(const std::vector<int>& arr) {
    int n = arr.size();

    // 1. Handle edge case: single-element array
    if (n == 1) {
        return 0;
    }

    // 2. Check if the first element is a peak
    // Note: The image incorrectly shows `return 1`. The correct index for the first element is 0.
    if (arr[0] > arr[1]) {
        return 0;
    }

    // 3. Check if the last element is a peak
    if (arr[n - 1] > arr[n - 2]) {
        return n - 1;
    }

    // 4. Binary search on the interior elements of the array
    int low = 1;
    int high = n - 2;

    while (low <= high) {
        int mid = low + (high - low) / 2; // Safer way to calculate mid

        // Case 1: The middle element is a peak
        // It's greater than both its left and right neighbors.
        if (arr[mid] > arr[mid - 1] && arr[mid] > arr[mid + 1]) {
            return mid;
        }

        // Case 2: We are on an "uphill" slope (arr[mid] > arr[mid - 1])
        // Since we are not at a peak, arr[mid] must be <= arr[mid+1].
        // This means a peak must exist to the right.
        else if (arr[mid] > arr[mid - 1]) {
            low = mid + 1; // Eliminate the left half
        }

        // Case 3: We are on a "downhill" slope or in a valley (arr[mid] <= arr[mid - 1])
        // A peak must exist to the left.
        else {
            high = mid - 1; // Eliminate the right half
        }
    }

    // This line should be unreachable given the problem constraints
    // that a peak always exists.
    return -1;
}

// Main function to demonstrate usage
int main() {
    std::vector<int> arr1 = {1, 2, 3, 4, 5, 6, 7, 8, 5, 1};
    std::cout << "A peak in {1,2,3,4,5,6,7,8,5,1} is at index: " << findPeakElement(arr1) << std::endl;
    // Expected: 7

    std::vector<int> arr2 = {1, 2, 1, 3, 5, 6, 4};
    std::cout << "A peak in {1,2,1,3,5,6,4} is at index: " << findPeakElement(arr2) << std::endl;
    // Expected: 1 or 5

    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(log N)`, we reduce the search space to half at every step using binary search.
-   **Space Complexity:** `O(1)`, constant additional space is used.

---

## Optimal Approach - (With multiple Peak Elements)

The code's purpose is to find the index of any "peak" element in an array. A peak is an element that is strictly greater than its neighbors.

### Intuition (The Hill-Climbing Analogy):

Think of the array as a terrain of hills and valleys. The code uses binary search to efficiently "climb" to the top of any hill.

1.  *Start in the middle* (at index `mid`).
2.  *Check your surroundings:*
    -   If you are on a *peak* (`mid` is greater than both neighbors), you're done!
    -   If you are on an *uphill slope* (rising from the left), a peak must be to your right. So, you can ignore the left half.
    -   If you are on a *downhill slope* or in a *valley*, a peak must be to your left. So, you can ignore the right half.

By repeatedly eliminating half the terrain, we quickly find a peak.

### Algorithm Steps:

1.  *Handle Edges:* The code first checks if the very first or very last elements are peaks. This simplifies the main search.

2.  *Binary Search:* It then searches the inner part of the array (`low = 1` to `high = n-2`).
    -   Find the middle element `mid`.
    -   *If `arr[mid]` is a peak:* Return `mid`.
    -   *If `arr[mid]` is on an uphill slope (from the left):* Move right by setting `low = mid + 1`.
    -   *Otherwise (downhill or in a valley):* Move left by setting `high = mid - 1`.

3.  *Loop:* This process repeats until a peak is found.


``` cpp
#include <iostream>
#include <vector>


int findPeakElement_from_image(const std::vector<int>& arr, int n) {
    // Edge case: single-element array
    if (n == 1) {
        return 0;
    }

    // Check if the first element is a peak
    // NOTE: The image shows "return 1;", which is incorrect. The index of the first element is 0.
    // This transcription follows the image exactly.
    if (arr[0] > arr[1]) {
        return 1; // As written in the image.
    }

    // Check if the last element is a peak
    if (arr[n - 1] > arr[n - 2]) {
        return n - 1;
    }

    // Set search bounds for the interior of the array
    int low = 1;
    int high = n - 2;

    while (low <= high) {
        int mid = (low + high) / 2;

        // Case 1: The middle element is a peak
        if (arr[mid] > arr[mid - 1] && arr[mid] > arr[mid + 1]) {
            return mid;
        }
        // Case 2: On an "uphill" slope
        else if (arr[mid] > arr[mid - 1]) {
            low = mid + 1;
        }
        // Case 3: On a "downhill" slope
        else if (arr[mid] > arr[mid + 1]) {
            high = mid - 1;
        }
        // Case 4: In a valley (covers arr[mid] <= arr[mid-1] && arr[mid] <= arr[mid+1])
        // NOTE: This last 'else' block from the second image makes the logic slightly
        // different from a standard implementation, but is transcribed as shown.
        else {
            low = mid + 1;
        }
    }

    // Return -1 if no peak is found (as shown in the yellow box)
    return -1;
}

// Main function to demonstrate the transcribed code's behavior
int main() {
    std::vector<int> arr = {1, 2, 1, 3, 5, 6, 4};
    int n = arr.size();

    int peak_index = findPeakElement_from_image(arr, n);

    std::cout << "The peak element found using the transcribed code is at index: " << peak_index << std::endl;

    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(log N)` because the search space is halved at each step.
-   **Space Complexity:** `O(1)` because only a few variables are used.
