## Peak element in Array

**Problem Statement:**  
Given an array of length N, a peak element is defined as the element greater than both of its neighbors. Formally, if `arr[i]` is the peak element, `arr[i - 1] < arr[i]` and `arr[i + 1] < arr[i]`. 
Find the index(0-based) of a peak element in the array. If there are multiple peak numbers, return the index of any peak number.

>### Examples:

#### Example 1: Standard Peak in the Middle

-   **Input:** `arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 5, 1}`.
-   **Output:** `7`
-   **Explanation:** The element `8` at index `7` is a peak because it is greater than its left neighbor (`7`) and its right neighbor (`5`).

#### Example 2: Multiple Peaks

-   **Input:** `arr[] = {1, 2, 1, 3, 5, 6, 4}`.
-   **Output:** `1` or `5`.
-   **Explanation:** There are two peak elements:
    -   `2` at index `1` (since `1 < 2 > 1`).
    -   `6` at index `5` (since `5 < 6 > 4`).
    Returning the index of either one is a correct answer.


---

## Brute Force Approach

### Algorithm:

A peak element in an array refers to the element that is greater than both of its neighbors. Basically, if `arr[i]` is the peak element, `arr[i] > arr[i-1]` and `arr[i] > arr[i+1]`.
Now, if we want to visualize an array with the peak elements from the graphical point of view, there can be 4 cases:
#### Corner Case 1: Strictly Increasing Array

-   **Input:** `arr[] = {1, 2, 3, 4, 5}`
-   **Output:** `4`
-   **Explanation:** The last element, `5`, is considered a peak because it is greater than its only neighbor (`4`).

#### Corner Case 2: Strictly Decreasing Array

-   **Input:** `arr[] = {5, 4, 3, 2, 1}`
-   **Output:** `0`
-   **Explanation:** The first element, `5`, is considered a peak because it is greater than its only neighbor (`4`).

#### Corner Case 3: Array with a Single Element

-   **Input:** `arr[] = {42}`
-   **Output:** `0`
-   **Explanation:** A single element is always considered a peak as it has no neighbors to be smaller than.

#### Corner Case 4: Array with Two Elements

-   **Input:** `arr[] = {5, 10}`
-   **Output:** `1`
-   **Explanation:** `10` at index `1` is the peak.

-   **Input:** `arr[] = {10, 5}`
-   **Output:** `0`
-   **Explanation:** `10` at index `0` is the peak.

The brute force approach to finding a peak element is to traverse the entire array and compare the current element with both of its neighbors. If it is greater than both of its neighbors, we can simply return it as our peak element.
For the elements at the first and last index, since neither neighbor is available, we can just check their only neighbor element and return if it's a peak element or not.


``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find a peak element in the array
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        
        // Traverse the array
        for (int i = 0; i < n; i++) {
            // Check left neighbor if exists
            bool left = (i == 0) || (nums[i] >= nums[i - 1]);
            // Check right neighbor if exists
            bool right = (i == n - 1) || (nums[i] >= nums[i + 1]);
            
            // If both sides are valid, return index
            if (left && right) return i;
        }

        // In case no peak found (shouldn't happen)
        return -1;
    }
};

// Driver
int main() {
    Solution sol;
    vector<int> nums = {1, 3, 20, 4, 1, 0};
    int index = sol.findPeakElement(nums);
    cout << "Peak at index: " << index << " with value: " << nums[index] << endl;
    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O(N)`, we traverse the entire array once to find the peak element.
-   **Space Complexity:** `O(1)`, constant additional space is used.

---

## Optimal Approach

### Algorithm:

To optimize our solution even further, we can use the binary search algorithm. The primary objective of the Binary Search algorithm is to efficiently 
determine the appropriate half to eliminate, thereby reducing the search space by half. It does this by determining a specific condition that ensures that the target is not present in that half.

To know how to eliminate the half efficiently, we can clearly notice a striking distinction between the left and right halves of the peak element in the array. 
The left half of the peak element has an *increasing order*, whereas the right half of the peak element has a *decreasing order*.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find a peak element using binary search
    int findPeakElement(vector<int>& nums) {
        // Set left and right bounds
        int low = 0, high = nums.size() - 1;

        // Binary search loop
        while (low < high) {
            // Find midpoint
            int mid = (low + high) / 2;

            // If mid element is greater than next
            if (nums[mid] > nums[mid + 1]) {
                // Move to the left half
                high = mid;:
            } else {
                // Move to the right half
                low = mid + 1;
            }
        }

        // Return peak index
        return low;
    }
};

int main() {
    // Input array
    vector<int> nums = {1, 2, 1, 3, 5, 6, 4};

    // Create object
    Solution obj;

    // Output result
    cout << obj.findPeakElement(nums) << endl;

    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(log N)`, we reduce the search space to half at every step using binary search.
-   **Space Complexity:** `O(1)`, constant additional space is used.

