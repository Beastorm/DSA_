## Floor and Ceil in Sorted Array

**Problem Statement:**  
You're given a sorted array `arr` of `n` integers and an integer `x`. Find the floor and ceiling of `x` in `arr[0..n-1]`.

- *The floor of x* is the largest element in the array that is smaller than or equal to `x`.
- *The ceiling of x* is the smallest element in the array greater than or equal to `x`.

---

>### Examples:

#### Example 1:

- **Input Format:** `n = 6`, `arr[] = {3, 4, 4, 7, 8, 10}`, `x = 5`
- **Result:** `4, 7`.
- **Explanation:** The floor of 5 in the array is 4, and the ceiling of 5 in the array is 7.

#### Example 2:

-   **Input Format:** `n = 6`, `arr[] = {3, 4, 4, 7, 8, 10}`, `x = 8`
-   **Result:** `8, 8`.
-   **Explanation:** The floor of 8 in the array is 8, and the ceiling of 8 in the array is also 8.

---

### Visualization:
**For Example:** `arr[] = {3, 4, 7, 8, 10}`.


**Case 1:** Target is between elements `(x = 5)`
```


       <--- Floor (<= x)           Ceil (>= x) --->
       
-------[3]----[4]------v-----[7]----[8]----------[10]-------
                     (x=5)
                     
Floor: The largest element <= 5 is 4.
Ceil: The smallest element >= 5 is 7.

```
**Case 2:** Target is an element in the array `(x = 8)`
```

    <-- Floor & Ceil -->

-------[3]----[4]------[7]----[8]----------[10]-------
                               ^
                             (x=8)

Floor: The largest element <= 8 is 8.
Ceil: The smallest element >= 8 is 8.

```

**Case 3:** Target is smaller than all elements `(x = 2)`
```
  Floor: None           Ceil (>= x) --->

---v---[3]----[4]------[7]----[8]----------[10]-------
 (x=2)

Floor: There is no element <= 2, so there is no floor. (Result: -1)
Ceil: The smallest element >= 2 is 3.

```
**Case 4:** Target is larger than all elements `(x = 11)`
```
       <--- Floor (<= x)                   Ceil: None

-------[3]----[4]------[7]----[8]----------[10]----v-------
                                                 (x=11)

Floor: The largest element <= 11 is 10.
Ceil: There is no element >= 11, so there is no ceiling. (Result: -1)

```
---

## Brute-Force Approach (Linear Search)

### Intuition:

The most straightforward way to solve this is to iterate through the array and check each element one by one. Since the array is **sorted**, we can use this property to make our linear scan a little smarter.

-   **For the Floor:** We are looking for the *largest* number that is `<= x`. As we scan from left to right, we can keep track of the most recent number that satisfies this condition. Because the array is sorted, the last number we find will be the largest.

-   **For the Ceil:** We are looking for the *smallest* number that is `>= x`. Because the array is sorted, the very **first** number we find that meets this condition will automatically be the smallest possible one. We can stop our search and return it immediately.

---

### Algorithm:

We will create two separate functions, one for finding the floor and one for the ceiling.

#### To find the `floor` of `x`:

1.  Initialize a variable `floor = -1`. This will be our answer if no floor is found.
2.  Iterate through the array from the beginning (`i = 0` to `n-1`).
3.  For each element `arr[i]`:
    -   If `arr[i] <= x`, this is a possible answer. We update our potential result: `floor = arr[i]`.
    -   If `arr[i] > x`, we can stop the loop immediately. Since the array is sorted, all subsequent elements will also be greater than `x` and cannot be the floor.
4.  After the loop finishes, return the value stored in `floor`.

#### To find the `ceil` of `x`:

1.  Initialize a variable `ceil = -1`.
2.  Iterate through the array from the beginning (`i = 0` to `n-1`).
3.  For each element `arr[i]`:
    -   If `arr[i] >= x`, we have found our answer. It's the first element that satisfies the condition, so it must be the smallest. Return `arr[i]` immediately.
4.  If the loop completes without finding any such element, it means all elements were smaller than `x`. Return the initial `ceil` value (`-1`).

``` cpp
#include <iostream>
#include <vector>

class Solution {
public:
    /**
     * @brief Finds the floor of x using a linear scan.
     * @return The largest element <= x, or -1 if none exists.
     */
    int findFloor(const std::vector<int>& arr, int n, int x) {
        int floor = -1;
        for (int i = 0; i < n; ++i) {
            if (arr[i] <= x) {
                // This is a potential answer.
                floor = arr[i];
            } else {
                // Since the array is sorted, no other element can be the floor.
                break;
            }
        }
        return floor;
    }

    /**
     * @brief Finds the ceil of x using a linear scan.
     * @return The smallest element >= x, or -1 if none exists.
     */
    int findCeil(const std::vector<int>& arr, int n, int x) {
        for (int i = 0; i < n; ++i) {
            if (arr[i] >= x) {
                // First element that is >= x is the smallest.
                return arr[i];
            }
        }
        // If loop finishes, no element was >= x.
        return -1;
    }
};

// Main function to demonstrate usage
int main() {
    Solution sol;
    std::vector<int> arr = {3, 4, 7, 8, 10};
    int n = arr.size();

    // Case 1: Target is between elements
    int x1 = 5;
    std::cout << "For target " << x1 << ":" << std::endl;
    std::cout << "Floor is: " << sol.findFloor(arr, n, x1) << std::endl; // Expected: 4
    std::cout << "Ceil is: " << sol.findCeil(arr, n, x1) << std::endl;  // Expected: 7
    std::cout << "---------------------" << std::endl;

    // Case 2: Target is in the array
    int x2 = 8;
    std::cout << "For target " << x2 << ":" << std::endl;
    std::cout << "Floor is: " << sol.findFloor(arr, n, x2) << std::endl; // Expected: 8
    std::cout << "Ceil is: " << sol.findCeil(arr, n, x2) << std::endl;  // Expected: 8
    std::cout << "---------------------" << std::endl;
    
    // Case 3: Target is smaller than all elements
    int x3 = 2;
    std::cout << "For target " << x3 << ":" << std::endl;
    std::cout << "Floor is: " << sol.findFloor(arr, n, x3) << std::endl; // Expected: -1
    std::cout << "Ceil is: " << sol.findCeil(arr, n, x3) << std::endl;  // Expected: 3

    return 0;
}
```

### Complexity Analysis:
-   **Time Complexity:** `O(N)`
    -   In the worst case for both `findFloor` and `findCeil`, we might have to iterate through the entire array. For example, finding the floor of a number larger than all elements in the array.
-   **Space Complexity:** `O(1)`
    -   The algorithm uses a constant amount of extra space for variables, regardless of the input array size.

---

## Optimized Approach

### Intuition:

Since the array is sorted, we can use **binary search** to find the floor and ceil much faster than checking every element.

-   **Finding the Floor (`<= x`):**
    -   We want the **largest** possible number that is still less than or equal to `x`.
    -   When we look at a middle element `mid`, if it's `<= x`, it's a good candidate for the floor. We **store it** and then search the **right half** to see if we can find an even larger number that still works.

-   **Finding the Ceil (`>= x`):**
    -   We want the **smallest** possible number that is greater than or equal to `x`.
    -   When we look at a middle element `mid`, if it's `>= x`, it's a good candidate for the ceil. We **store it** and then search the **left half** to see if we can find an even smaller number that still works.

This is a classic "Binary Search on Answers" problem where we adjust our search based on whether `mid` is a potential answer.

### Algorithm:

#### To Find the Floor (`findFloor` function):

1.  Initialize `ans = -1`, `low = 0`, `high = n - 1`.
2.  While `low <= high`:
    -   Calculate `mid`.
    -   If `arr[mid] <= x`:
        -   This is a potential floor. Store it: `ans = arr[mid]`.
        -   Try to find a larger floor on the right: `low = mid + 1`.
    -   Else (`arr[mid] > x`):
        -   `mid` is too large. The floor must be on the left: `high = mid - 1`.
3.  Return `ans`.

#### To Find the Ceil (`findCeil` function):

1.  Initialize `ans = -1`, `low = 0`, `high = n - 1`.
2.  While `low <= high`:
    -   Calculate `mid`.
    -   If `arr[mid] >= x`:
        -   This is a potential ceil. Store it: `ans = arr[mid]`.
        -   Try to find a smaller ceil on the left: `high = mid - 1`.
    -   Else (`arr[mid] < x`):
        -   `mid` is too small. The ceil must be on the right: `low = mid + 1`.
3.  Return `ans`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class FloorCeilFinder {
public:
    // Function to find the floor of x
    int findFloor(int arr[], int n, int x) {
        int low = 0, high = n - 1;
        int ans = -1;

        while (low <= high) {
            int mid = (low + high) / 2;
            if (arr[mid] <= x) {
                ans = arr[mid];     // Potential floor
                low = mid + 1;      // Search right side
            } else {
                high = mid - 1;     // Search left side
            }
        }
        return ans;
    }

    // Function to find the ceiling of x
    int findCeil(int arr[], int n, int x) {
        int low = 0, high = n - 1;
        int ans = -1;

        while (low <= high) {
            int mid = (low + high) / 2;
            if (arr[mid] >= x) {
                ans = arr[mid];     // Potential ceil
                high = mid - 1;     // Search left side
            } else {
                low = mid + 1;      // Search right side
            }
        }
        return ans;
    }

    // Function to return both floor and ceil
    pair<int, int> getFloorAndCeil(int arr[], int n, int x) {
        int f = findFloor(arr, n, x);
        int c = findCeil(arr, n, x);
        return make_pair(f, c);
    }
};

int main() {
    int arr[] = {3, 4, 4, 7, 8, 10};
    int n = 6, x = 5;
    FloorCeilFinder finder;
    pair<int, int> ans = finder.getFloorAndCeil(arr, n, x);
    cout << "The floor and ceil are: " << ans.first << " " << ans.second << endl;
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(logN)`, where `N` = size of the given array. We are using the Binary Search algorithm.
-   **Space Complexity:** `O(1)`. No extra space used.
