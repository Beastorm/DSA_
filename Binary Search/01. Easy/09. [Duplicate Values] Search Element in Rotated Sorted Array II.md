## Search Element in Rotated Sorted Array II [With Duplicate Values]  

**Problem Statement:**  
Given an integer array `arr` of size N, sorted in ascending order (may contain duplicate values), and a target value `k`. Now, the array is rotated at some pivot point that is unknown to you. Return `True` if `k` is present and otherwise, return `False`.

---

>### Examples:

#### Example 1:

-   **Input Format:** `arr = [7, 8, 1, 2, 3, 3, 3, 4, 5, 6]`, `k = 3`
-   **Result:** `True`
-   **Explanation:** Element 3 is present in the array. So, the answer is True.

#### Example 2:

-   **Input Format:** `arr = [7, 8, 1, 2, 3, 3, 3, 4, 5, 6]`, `k = 10`
-   **Result:** `False`
-   **Explanation:** Element 10 is not present in the array. So, the answer is False.

---

## Brute Force

### Algorithm:

We will traverse the array and check every element if it is equal to `k`. If we find any element, we will return `True`. Otherwise, we will return `False`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to encapsulate search logic
class Solution {
public:
    // Linear search in a rotated sorted array (with duplicates)
    bool searchInARotatedSortedArrayII(vector<int>& arr, int k) {
        int n = arr.size(); // size of the array
        for (int i = 0; i < n; i++) {
            if (arr[i] == k) return true; // if found, return true
        }
        return false; // not found
    }
};

int main() {
    vector<int> arr = {7, 8, 1, 2, 3, 3, 3, 4, 5, 6};
    int k = 3;

    // Create object of Solution class
    Solution obj;
    bool ans = obj.searchInARotatedSortedArrayII(arr, k);

    // Print result
    if (!ans)
        cout << "Target is not present.\n";
    else
        cout << "Target is present in the array.\n";

    return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(N)`, where `N` = size of the given array.
-   **Space Complexity:** `O(1)`, no extra space used.

---

## Optimized Approach
### Intuition:

1.  First, we identify the sorted half of the array.
2.  Once found, we determine if the target is located within this sorted half.
    -   If not, we eliminate that half from further consideration.
    -   Conversely, if the target does exist in the sorted half, we eliminate the other half.

We basically compare `arr[mid]` with `arr[low]` and `arr[high]` in the following way:

-   *If `arr[low] <= arr[mid]`:* In this case, we identified that the left half is sorted.
-   *If `arr[mid] <= arr[high]`:* In this case, we identified that the right half is sorted.


### The Problem Introduced by Duplicates:

In the original problem (with unique elements), we can **always** determine which half is sorted by comparing `arr[mid]` with `arr[low]`. One side will be strictly increasing.

However, when duplicates are allowed, you can run into this situation:

**`arr[low] == arr[mid] == arr[high]`**

Let's look at an example:
-   `arr = {3, 1, 3, 3, 3, 3, 3}`.
-   `low = 0` (`arr[low] = 3`)
-   `high = 6` (`arr[high] = 3`)
-   `mid = 3` (`arr[mid] = 3`)

Here, `arr[low]`, `arr[mid]`, and `arr[high]` are all `3`.

Now, the algorithm gets stuck.
-   Is the left half sorted? We check `arr[low] <= arr[mid]` (`3 <= 3`). This is **true**.
-   Is the right half sorted? We check `arr[mid] <= arr[high]` (`3 <= 3`). This is also **true**.

The algorithm **cannot determine** which half is properly sorted and which half contains the "pivot" or rotation point. For example, the `1` in our array could be on the left side of `mid` or the right side.

-   If the array were `{3, 3, 3, 1, 3}`, the pivot is on the right.
-   If the array were `{3, 1, 3, 3, 3}`, the pivot is on the left.

Since `arr[low] == arr[mid]`, we can't tell which of these is the case. This ambiguity breaks our ability to confidently eliminate one half of the search space.


``` cpp
#include <bits/stdc++.h>
using namespace std;

bool searchInARotatedSortedArrayII(vector<int>& arr, int k) {
    int n = arr.size();
    int low = 0, high = n - 1;

    while (low <= high) {
        int mid = (low + high) / 2;

        // If mid points to the target
        if (arr[mid] == k) return true;

        // Edge case: all three are equal, we cannot determine which side is sorted
        // Shrink the Search Space
        if (arr[low] == arr[mid] && arr[mid] == arr[high]) {
            low++;
            high--;
            continue;
        }

        // If the left half is sorted
        if (arr[low] <= arr[mid]) {
            if (arr[low] <= k && k <= arr[mid]) {
                high = mid - 1; // Target lies in left
            } else {
                low = mid + 1;  // Target lies in right
            }
        } else {
            // Right half is sorted
            if (arr[mid] <= k && k <= arr[high]) {
                low = mid + 1;  // Target lies in right
            } else {
                high = mid - 1; // Target lies in left
            }
        }
    }

    return false;
}

int main() {
    vector<int> arr = {7, 8, 1, 2, 3, 3, 3, 4, 5, 6};
    int k = 3;
    bool ans = searchInARotatedSortedArrayII(arr, k);
    if (ans)
        cout << "Target is present in the array.\n";
    else
        cout << "Target is not present.\n";
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(logN)` for the best and average case. `O(N/2)` for the worst case. Here, `N` = size of the given array.
-   **Space Complexity:** `O(1)`, no extra space used.
