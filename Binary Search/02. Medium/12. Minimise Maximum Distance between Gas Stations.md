## Minimise Maximum Distance between Gas Stations

**Problem Statement:**  

You are given a sorted array `arr` of length `n`, which contains positive integer positions of `n` gas stations on the X-axis. You are also given an integer `k`.
You have to place `k` new gas stations on the X-axis. You can place them anywhere on the non-negative side of the X-axis, 
even on non-integer positions. Let `dist` be the maximum value of the distance between adjacent gas stations after adding `k` new gas stations. Find the minimum value of `dist`.

---
### Conditions:

1. **Existing stations are fixed**
   - You cannot move or remove the original `n` stations at positions `arr[i]`.
   - They are sorted and stay where they are.

2. **You can add exactly `k` new stations**
   - New stations can be placed **anywhere on the X‑axis ≥ 0**, including non‑integer positions.
   - You must not add more than `k` stations.

3. **Distance is measured between adjacent stations**
   - After adding the `k` stations, sort all positions.
   - Let `dist` be the **maximum gap** between two neighboring stations in this final list.
   - Goal: **minimize this `dist`**.

---

>### Examples:

**Example 1:**  

- #### Input:
  - `arr = [1, 2, 3, 4, 5]`.
  - `k = 4` (new gas stations)

Current adjacent gaps:

- Between 1 and 2 → `1`
- Between 2 and 3 → `1`
- Between 3 and 4 → `1`
- Between 4 and 5 → `1`

We want to place 4 new stations to *minimize the maximum gap* between any two neighboring stations.

One optimal way:

- Place new stations at: `1.5, 2.5, 3.5, 4.5`

Final positions:  
`[1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5]`

All gaps are now `0.5`.

- *Maximum gap (dist) = 0.5*
- *Output:* `0.5`

---

**Example 2**  

- #### Input:
  - `arr = [1, 10]`
  - `k = 1`

Current gap:

- Between 1 and 10 → `9`

We can place 1 new station anywhere between 1 and 10.

Best choice: put it in the *middle*, at `5.5`.

New positions: `[1, 5.5, 10]`

New gaps:

- `5.5 - 1 = 4.5`
- `10 - 5.5 = 4.5`

So the maximum gap is now `4.5`, and this is the minimum possible.

- *Output:* `4.5`

---

**Example 3:**

- #### Input:
  - `arr = [0, 10, 20]`
  - `k = 2`

Current gaps:

- Between 0 and 10 → `10`
- Between 10 and 20 → `10`

We can place 2 new stations. The best strategy is to *split each large gap evenly*.

Place:

- One new station at `5` (between 0 and 10)
- One new station at `15` (between 10 and 20)

Final positions: `[0, 5, 10, 15, 20]`

New gaps:

- `5 - 0 = 5`
- `10 - 5 = 5`
- `15 - 10 = 5`
- `20 - 15 = 5`

Maximum gap = `5`, and this is the smallest possible value for `dist`.

- *Output:* `5`
---

## Brute Force

### Algorithm:

1.  First, we will declare an array `howMany[]` of size `n-1`, to keep track of the number of placed gas stations.
2.  Next, using a loop, we will pick `k` gas stations one at a time.
3.  Then, using another loop, we will find the index 'i' where the distance `(arr[i+1] - arr[i])` is the maximum and insert the current gas station between `arr[i]` and `arr[i+1]` (i.e., `howMany[i]++`).
4.  Finally, after placing all the new stations, we will find the distance between two consecutive gas stations. For a particular section, the distance is calculated as:
    `distance = section_length / (number_of_stations_inserted + 1) = (arr[i+1] - arr[i]) / (howMany[i] + 1)`
5.  Among all the distances, the maximum one will be the answer.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the gas station placement problem
class GasStationSolver {
public:
    // Function to minimize the maximum distance after placing k gas stations
    long double minimiseMaxDistance(vector<int>& arr, int k) {
        int n = arr.size();
        vector<int> howMany(n - 1, 0); // howMany[i]: extra stations between arr[i] and arr[i+1]

        // Place k gas stations one at a time
        for (int gasStations = 1; gasStations <= k; gasStations++) {
            long double maxSection = -1;
            int maxInd = -1;

            // Find the segment with the current largest section length
            for (int i = 0; i < n - 1; i++) {
                long double diff = arr[i + 1] - arr[i];
                long double sectionLength = diff / (howMany[i] + 1.0);

                if (sectionLength > maxSection) {
                    maxSection = sectionLength;
                    maxInd = i;
                }
            }

            // Add a gas station in the largest segment
            howMany[maxInd]++;
        }

        // Find the final maximum distance after placing all gas stations
        long double maxAns = -1;
        for (int i = 0; i < n - 1; i++) {
            long double diff = arr[i + 1] - arr[i];
            long double sectionLength = diff / (howMany[i] + 1.0);
            maxAns = max(maxAns, sectionLength);
        }

        return maxAns;
    }
};

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int k = 4;

    GasStationSolver solver;
    long double ans = solver.minimiseMaxDistance(arr, k);

    cout << "The answer is: " << ans << "\n";
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(k*n) + O(n)`, where `n` = size of the given array, `k` = no. of gas stations to be placed.
-   **Space Complexity:** `O(n-1)` as we are using an array to keep track of placed gas stations.

---
## Better Approach

### Intuition:

In the previous approach, for every gas station, we were finding the index `i` for which the distance between `arr[i+1]` and `arr[i]` is maximum. After that, our job was to place the gas station. Instead of using a loop to find the maximum distance, we can simply use the heap data structure, i.e., the priority queue.

### Approach:

1.  First, we will declare an array `howMany[]` of size `n-1`, to keep track of the number of placed gas stations, and a priority queue that uses a max heap.
2.  We will insert the first `n-1` indices with the respective distance value, `arr[i+1] - arr[i]`, for every index.
3.  Next, using a loop, we will pick `k` gas stations one at a time.
4.  Then we will pick the first element of the priority queue, as this is the element with the maximum distance. Let’s call the index `secInd`.
5.  Now we will place the current gas station at `secInd` (`howMany[secInd]++`) and calculate the new section length:
    ```
    new_section_length = initial_section_length / (number_of_stations_inserted + 1) 
                       = (arr[secInd+1] - arr[secInd]) / (howMany[i] + 1)
    ```
6.  After that, we will again insert the pair into the priority queue for further consideration.
7.  After performing all the steps for `k` gas stations, the distance at the top of the priority queue will be the answer, as we want the maximum distance.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the gas station placement problem
class Solution {
public:
    // Function to minimize the maximum distance between gas stations
    long double minimiseMaxDistance(vector<int> &arr, int k) {
        int n = arr.size();
        vector<int> howMany(n - 1, 0); // Tracks how many stations in each segment
        priority_queue<pair<long double, int>> pq; // Max-heap

        // Initially insert all segments into the heap with their lengths
        for (int i = 0; i < n - 1; i++) {
            long double length = arr[i + 1] - arr[i];
            pq.push({length, i});
        }

        // Place k additional gas stations
        for (int gasStations = 1; gasStations <= k; gasStations++) {
            auto top = pq.top();
            pq.pop();
            int segmentIndex = top.second;

            // Add a station to the segment and recompute its length
            howMany[segmentIndex]++;
            long double totalDist = arr[segmentIndex + 1] - arr[segmentIndex];
            long double newLen = totalDist / (howMany[segmentIndex] + 1);
            pq.push({newLen, segmentIndex});
        }

        // Final answer is the max segment length at the top of the heap
        return pq.top().first;
    }
};

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int k = 4;
    Solution obj;
    long double ans = obj.minimiseMaxDistance(arr, k);
    cout << "The answer is: " << ans << "\n";
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(n*log(n) + k*log(n))`, where `n` = size of the given array, `k` = no. of gas stations to be placed.
-   **Space Complexity:** `O(n)`. This complexity arises from using an array of size `n-1` to track placed gas stations and a priority queue, which also stores up to `n-1` elements.

---

## Optimal Approach

### Algorithm:

1.  First, we will find the maximum distance between two consecutive gas stations, i.e., `max(dist)`.
2.  **Place the 2 pointers, i.e., `low` and `high`:** Initially, we will place the pointers. The pointer `low` will point to `0` and the `high` will point to `max(dist)`.
3.  Now, we will use the `while` loop like this: `while(high - low > 10^(-6))`.
4.  **Calculate the `mid`:** Now, inside the loop, we will calculate the value of `mid` using the following formula:
    ```
    mid = (low + high) / 2.0
    ```
5.  **Eliminate the halves based on the number of stations returned by `numberOfGasStationsRequired()`:** We will pass the potential value of `dist`, represented by the variable `mid`, to the `numberOfGasStationsRequired()` function. This function will return the number of gas stations we can place.
    -   **If `result > k`:** On satisfying this condition, we can conclude that the number `mid` is smaller than our answer. So, we will eliminate the left half and consider the right half (i.e., `low = mid`).
    -   **Otherwise:** The value `mid` is one of the possible answers. But we want the minimum value. So, we will eliminate the right half and consider the left half (i.e., `high = mid`).
6.  Finally, outside the loop, we can return either `low` or `high` as their difference is beyond 10^(-6). They both can be the possible answer. Here, we have returned the `high`.


``` cpp
class GasStationOptimizer {
  // Calculates the number of gas stations required for a given max distance
  numberOfGasStationsRequired(dist, arr) {
    let count = 0;
    for (let i = 1; i < arr.length; i++) {
      let numberInBetween = Math.floor((arr[i] - arr[i - 1]) / dist);
      if ((arr[i] - arr[i - 1]) === dist * numberInBetween) {
        numberInBetween--; //Decrement the numberInBetween
      }
      count += numberInBetween;
    }
    return count;  //total number of additional gas stations required
  }

  // Finds the minimum possible maximum distance using binary search
  minimiseMaxDistance(arr, k) {
    let low = 0;
    let high = 0;

    // Find initial upper bound for binary search
    for (let i = 0; i < arr.length - 1; i++) {
      high = Math.max(high, arr[i + 1] - arr[i]);
    }

    const diff = 1e-6;

    // Binary search loop
    while (high - low > diff) {
      const mid = (low + high) / 2.0;
      const count = this.numberOfGasStationsRequired(mid, arr);
      if (count > k) {
        low = mid;
      } else {
        high = mid;
      }
    }

    return high;
  }
}

// Example usage
const arr = [1, 2, 3, 4, 5];
const k = 4;

const optimizer = new GasStationOptimizer();
const result = optimizer.minimiseMaxDistance(arr, k);

console.log("The answer is:", result);

```

### Complexity Analysis:
-   **Time Complexity:** `O(n*log(Len)) + O(n)`, where `n` = size of the given array, `Len` = length of the answer space.

-   **Space Complexity:** `O(1)`, as we are using no extra space to solve this problem.
