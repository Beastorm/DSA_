# Theory

## Qestion 1: "Opposite Polarity" in Binary Search


"Opposite polarity" is not a standard academic term for binary search, but it's an excellent way to describe a very important concept, 
especially for **"Binary Search on Answers"** problems. It refers to the two fundamentally opposite ways you handle a "successful" `mid` value, depending on your ultimate goal.

The "polarity" is determined by whether you are trying to **minimize** a value or **maximize** a value.

Let's use a simple analogy. Imagine your search space is a sorted array of `false` and `true` values.

-   **Polarity 1:** `[F, F, F, F, T, T, T, T]` -> Your goal is to find the **first `T`**.
-   **Polarity 2:** `[T, T, T, T, F, F, F, F]` -> Your goal is to find the **last `T`**.

The logic you use to shrink the search space is opposite in these two cases.

### <ins>Polarity 1: Minimize the Value (Find the First `true`)</ins>

This is the most common pattern.

-   **Goal:** Find the **minimum** possible value that satisfies a condition.
-   **Example Problems:**
    -   Koko Eating Bananas (Minimum speed `k`).
    -   Allocate Books / Split Array (Minimum of the largest sum).
    -   Smallest Divisor.

> **Intuition:** When you test a `mid` value and it **works (succeeds)**, you have found a potential answer. But your goal is to find the smallest one, so you must try to find an even *better* (smaller) answer in the **left half**.

#### The Logic:

```cpp
if (condition_is_met_for(mid)) { // The speed 'mid' works!
    // This is a potential answer. Store it.
    ans = mid;
    // But now, try to find an even smaller speed that works.
    // Search in the left half.
    high = mid - 1;
}
else { // The speed 'mid' is too slow (fails).
    // 'mid' and anything smaller is useless.
    // The answer MUST be in the right half.
    low = mid + 1;
}

```
### <ins>Polarity 2: Maximize the Value (Find the Last `true`)</ins>

This is the "opposite polarity."

-   **Goal:** Find the **maximum** possible value that satisfies a condition.

-   **Example Problems:**
    -   Aggressive Cows (Maximum of the minimum distance).
    -   (Cutting wood into `k` pieces of at least `x` length, find max `x`).

> **Intuition:** When you test a `mid` value and it **works (succeeds)**, you have found a potential answer. But your goal is to find the largest one, so you must try to find an even *better* (larger) answer in the **right half**.


**The Logic:**
``` cpp
if (condition_is_met_for(mid)) { // The distance 'mid' works!
    // This is a potential answer. Store it.
    ans = mid;
    // But now, try to find an even larger distance that works.
    // Search in the right half.
    low = mid + 1;
}
else { // The distance 'mid' is too large (fails).
    // 'mid' and anything larger is useless.
    // The answer MUST be in the left half.
    high = mid - 1;
}
```
>Key Action: On success, you store the answer and search right (low = mid + 1).

### Summary Table:

| Feature | Polarity 1 | Polarity 2 (Opposite Polarity) |
| :--- | :--- | :--- |
| **Goal** | **Minimize** the value | **Maximize** the value |
| **Analogy** | Find the first `true` in `[F, F, T, T]` | Find the last `true` in `[T, T, F, F]` |
| **Example Problems**| Koko Eating Bananas, Allocate Books | Aggressive Cows |
| **Logic on Success**| `mid` is a potential answer. A better answer might be **smaller**. | `mid` is a potential answer. A better answer might be **larger**. |
| **Code Pattern**| `ans = mid; high = mid - 1;` | `ans = mid; low = mid + 1;` |


>Understanding this "opposite polarity" is the key to solving almost any "Binary Search on Answers" problem. You first identify whether you need to minimize or maximize, which then tells you exactly how to adjust your `low` and `high` pointers.

