# Theory
## 1. Binary Search on Answer (Binary Search on Range):

**Normal binary search:**
- You have a *sorted array*.
- You search *in the array* for a value.

**Binary search on answer:**
- You *donâ€™t* search inside the array.
- You search on a *range of possible answers* (a number line).
- For each guess `mid`, you ask:  
  *â€œIs this `mid` a valid answer?â€*
- Based on YES/NO, you move *left or right* on that range.

### Example: Koko Eating Bananas

- Possible speeds: `k âˆˆ [1, max(piles)]`.
- For a guess `mid`:
  - We check: â€œIf Koko eats at speed = `mid`, can she finish in `h` hours?â€
- If she *can*, maybe a *smaller* speed also works â†’ search *left*.
- If she *cannot*, speed is too small â†’ search *right*.

Here, the â€œarrayâ€ is really the *range of answers* `[1..maxPile]`, not an actual array.

---

## 2. Opposite Polarity:

This is about what you do when your guessed `mid` *works* (condition is true).

There are *two types of goals*:

### Polarity 1 â€“ Minimize the Value (smallest valid `mid`)

- **Goal:** Find the *smallest* `mid` that is valid.
- If `mid` works:
  - Save it as a *candidate answer*.
  - Try to find an even *smaller* one â†’ go *left*:
    ```cpp
    ans = mid;
    high = mid - 1;
    ```
- **Examples:**  
  Koko Eating Bananas, Allocate Books, Split Array â€“ Largest Sum, Smallest Divisor.

---

### Polarity 2 â€“ Maximize the Value (largest valid `mid`)

- **Goal:** Find the *largest* `mid` that is valid.
- If `mid` works:
  - Save it as a *candidate answer*.
  - Try to find an even *larger* one â†’ go *right*:
    ```cpp
    ans = mid;
    low = mid + 1;
    ```
- **Examples:**  
  Aggressive Cows (maximize the minimum distance between cows).

---

## 3. Why We Need These Ideas:

- Many problems donâ€™t have a direct formula for the answer, but:
  - We can *guess* a value `mid`.
  - We can test a function `can(mid)` â†’ is it *possible* or not?
  - The set of valid `mid` values is *monotonic*:
    - For minimize: if `mid` works, all *larger* might also work.
    - For maximize: if `mid` works, all *smaller* might also work.
- This monotonic pattern lets us use *binary search on the answer range*.

>[!Note]
>So, in short:
- **Binary search on answer** = binary search on a *number line of possible answers*.
- **Opposite polarity** = how you move `low`/`high` after a successful `mid`,
  depending on whether you want the *smallest* or *largest* valid value.

---

## Why Sometimes the Answer Is `low`, `high`, or `ans` in Binary Search

There are two common binary-search patterns.  
Which variable you return (`low`, `high`, or `ans`) depends on **how you write the loop**.

---

### Pattern 1 â€“ Use `ans` and `while (low <= high)`.

**Idea:** Keep a separate `ans` to remember the *best valid answer so far*.

```cpp
int low = L, high = R;
int ans = -1;

while (low <= high) {
    int mid = (low + high) / 2;

    if (ok(mid)) {        // mid works
        ans = mid;        // remember this candidate
        high = mid - 1;   // try to find a smaller one (for minimize)
    } else {
        low = mid + 1;    // need a larger value
    }
}
return ans;  
```
- During the loop, low and high move around the range.
- ans always stores the last successful mid.
- When the loop ends (low > high), ans is the correct answer.
  You return: ans.



### Pattern 2 â€“ No ans, use while (low < high) and Return low/high
**Idea:** Always keep the true answer inside [low, high], and shrink that range.
``` cpp
int low = L, high = R;

while (low < high) {
    int mid = (low + high) / 2;

    if (ok(mid)) {
        // mid could be the answer, or the answer is smaller
        high = mid;        // answer is in [low, mid]
    } else {
        // mid is too small (for minimize case)
        low = mid + 1;     // answer is in [mid+1, high]
    }
}
// here low == high, only one candidate left
return low;  // or return high; same value

```
- Invariant: answer is always between low and high (inclusive).
- When low == high, there is only one possible answer left.
  You return: low (or high â€” theyâ€™re equal).


**Simple Rule of Thumb:**   
If you use ans and update it when ok(mid) is true â†’
ðŸ‘‰ Return ans.

If you donâ€™t use ans and your loop is while (low < high) with the invariant
â€œthe answer is inside [low, high]â€ â†’
ðŸ‘‰ Return low (or high) when the loop ends.

Both styles are correct; just be consistent with the logic and the invariant you maintain.


---

## What is a Loop Invariant? 

A *loop invariant* is a statement that is:

> True before the loop starts, true before each iteration, and true after each iteration.

Itâ€™s like a *promise* the loop always keeps while it runs.  
We use it to reason about *correctness* of the algorithm.


### Example: Binary Search on Answer (Pattern 2)

Consider this pattern:

```cpp
int low = L, high = R;

while (low < high) {
    int mid = (low + high) / 2;

    if (ok(mid)) {
        high = mid;        // answer is in [low, mid]
    } else {
        low = mid + 1;     // answer is in [mid+1, high]
    }
}
// low == high
return low;
```
Here, the *loop invariant* is:  
> At every moment, the true answer is guaranteed to lie inside `[low, high]`.

**Before the loop starts:**   
- We set `low = L`, `high = R`, and we choose `L` and `R` so that the real answer is between them.


**Each iteration:**   
- If `ok(mid)` is *true* â†’ we set `high = mid`, so the answer is in `[low, mid]`.
- If `ok(mid)` is *false* â†’ we set `low = mid + 1`, so the answer is in `[mid+1, high]`.
- In both cases, we *keep the promise*:  
  the answer stays inside `[low, high]`.


**When the loop ends (`low == high`)**:  
- The range `[low, high]` has only *one value* left,  
  So that value *must be the answer*.
