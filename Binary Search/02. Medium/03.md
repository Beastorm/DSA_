## Koko Eating Bananas

**Problem Statement:**

A monkey Koko is given ‘n’ piles of bananas, whereas the 'ith' pile has ‘a[i]’ bananas. An integer ‘h’ is also given, which denotes the time (in hours) for all the bananas to be eaten.
Each hour, the monkey chooses a non-empty pile of bananas and eats ‘k’ bananas. If the pile contains fewer than ‘k’ bananas, then the monkey consumes all the bananas and won’t eat any more bananas in that hour.
Find the minimum number of bananas ‘k’ to eat per hour so that the monkey can eat all the bananas within ‘h’ hours.


>### Examples:

#### Example 1:

-   **Input:** `N = 4`, `a[] = {7, 15, 6, 3}`, `h = 8`
-   **Output:** `5`
-   **Explanation:** If Koko eats 5 bananas/hr, he will take 2, 3, 2, and 1 hours to eat the piles accordingly. So, he will take 8 hours to complete all the piles.

#### Example 2:

-   **Input:** `N = 5`, `a[] = {25, 12, 8, 14, 19}`, `h = 5`
-   **Output:** `25`
-   **Explanation:** If Koko eats 25 bananas/hr, he will take 1, 1, 1, 1, and 1 hour to eat the piles accordingly.

---

## Brute-Force Approach

### Algorithm:

The problem is about finding the minimum eating speed such that Koko can finish all bananas within `h` hours. The extremely naive approach is to check all possible answers from 1 to `max(a[])`. The minimum number for which the required time is less than or equal to `h` is our answer.

1.  Find the largest pile size (`max` of the array).
2.  Loop through all possible speeds from 1 to this maximum value.
3.  For each speed, calculate the total hours needed. For each pile, compute the time as `ceil(pile/speed)`.
4.  Sum up the hours for all piles.
5.  If the total hours are less than or equal to the allowed hours, return this speed as the answer.


``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate total hours for given speed
    int calculateTotalHours(vector<int>& a, int hourly) {
        int totalHours = 0;
        for (int pile : a) {
            // Add hours using ceil
            totalHours += (pile + hourly - 1) / hourly;
        }
        return totalHours;
    }

    // Function to find minimum eating speed
    int minEatingSpeed(vector<int>& a, int h) {
        // Find maximum pile size
        int maxVal = *max_element(a.begin(), a.end());

        // Try every possible speed
        for (int i = 1; i <= maxVal; i++) {
            int hours = calculateTotalHours(a, i);

            // If hours fit within h
            if (hours <= h) {
                return i;
            }
        }
        return maxVal;
    }
};

int main() {
    // Input array
    vector<int> a = {3, 6, 7, 11};
    // Hours allowed
    int h = 8;

    Solution obj;
    cout << obj.minEatingSpeed(a, h);
    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O(N * max(a[]))`, since for each possible speed we go through all the piles.
-   **Space Complexity:** `O(1)`, since the algorithm does not use any additional space or data structures.
