## Nth Root of a Number using Binary Search

**Problem Statement:**  
Given two numbers `N` and `M`, find the `Nth` root of `M`. The `nth` root of a number `M` is defined as a number `X` when raised to the power `N` equals `M`. If the `nth` root is not an integer, return `-1`.

---

>### Examples:

#### Example 1:

-   **Input:** `N = 3`, `M = 27`
-   **Output:** `3`
-   **Explanation:** The cube root of 27 is equal to 3.

#### Example 2:

-   **Input:** `N = 4`, `M = 69`
-   **Output:** `-1`
-   **Explanation:** The 4th root of 69 does not exist. So, the answer is -1.

---

## Brute-Force Approach

### Algorithm:

To find the nth root of a number m, we want to find a number x such that x^n = m. The naive approach to solving this is to linearly search for every possible number. Using linear search, we start from 1 and gradually try increasing values, checking if raising them to the power `n` gets us close to or exactly equals `m`.

1.  Start a loop from 1 to `m` for linear search.
2.  For each value in the loop, compute the value raised to the power `n`.
3.  If the result equals `m`, return that value.
4.  If the result exceeds `m`, break the loop as the nth root does not exist as an integer.
5.  If no exact match is found, return -1 to indicate failure.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find Nth root of M
    int nthRoot(int n, int m) {
        // Loop from 1 to m
        for (int i = 1; i <= m; i++) {
            // Compute i^n
            long long power = pow(i, n);

            // If equal to m, return i
            if (power == m) return i;

            // If exceeds m, break
            if (power > m) break;
        }

        // If not found, return -1
        return -1;
    }
};

int main() {
    Solution sol;
    int n = 3, m = 27;

    // Find nth root
    cout << "Nth Root: " << sol.nthRoot(n, m) << endl;

    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O(M)`, we search for every possible number from 1 to M to check if it is the Nth root.
-   **Space Complexity:** `O(1)`, constant additional space is used.

---

## Optimal Approach

### Algorithm:

To find the N-th root of a number M, instead of checking every number from 1 to M (which is inefficient), we use binary search to efficiently reduce the search space. Since the N-th root lies between 1 and M, we start with a search range from 1 to M. For each middle value in this range, we compute its N-th power by multiplying it with itself N times, without using built-in power functions (to avoid integer overflow). During this multiplication, if the result exceeds M, we stop early to save time. If the final result equals M, weâ€™ve found the N-th root. Otherwise, we adjust our search range accordingly to continue the binary search. This method significantly speeds up the process by halving the range at each step.

1.  Start binary search with `low` as 1 and `high` as `M`.
2.  Find the mid` of the range and multiply it by itself `N` times to get the Nth power of `mid`.
3.  If the Nth power of `mid` equals `M`, return `mid` as the N-th root.
4.  If the Nth power of `mid` is less than `M`, shift the search to the right half.
5.  If the Nth power of `mid` is greater than `M`, shift the search to the left half.
6.  If no integer root is found after the loop, return -1.

``` cpp
#include <bits/stdc++.h>
using namespace std;
        
class Solution {
public:
    // Function to find N-th root of M using binary search
    int nthRoot(int n, int m) {
        // Set low and high for binary search
        int low = 1, high = m;

        // Start binary search
        while (low <= high) {
            // Calculate mid
            int mid = (low + high) / 2;

            // Store result of mid^n
            long long ans = 1;
            for (int i = 0; i < n; i++) {
                ans *= mid;
                if (ans > m) break;
            }

            // If mid^n equals m
            if (ans == m) return mid;

            // If mid^n is less than m
            if (ans < m) low = mid + 1;

            // If mid^n is more than m
            else high = mid - 1;
        }

        // Return -1 if not found
        return -1;
    }
};

// Main function
int main() {
    Solution obj;
    int result = obj.nthRoot(3, 27);
    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O(logM)`, we search for every possible number from 1 to M to check if it is the Nth root.
-   **Space Complexity:** `O(1)`, constant additional space is used.
