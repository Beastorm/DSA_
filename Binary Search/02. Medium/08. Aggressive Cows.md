## Aggressive Cows: Detailed Solution

**Problem Statement:**  
You are given an array `arr` of size `n`, which denotes the position of stalls. You are also given an integer `k` which denotes the number of aggressive cows.

You are given the task of assigning stalls to `k` cows such that the minimum distance between any two of them is the maximum possible. Find the maximum possible minimum distance.


>### Examples:

#### Example 1:

-   **Input Format:** `N = 6`, `k = 4`, `arr[] = {0,3,4,7,10,9}`
-   **Result:** `3`
-   **Explanation:** The maximum possible minimum distance between any two cows will be `3` when `4` cows are placed at positions `{0, 3, 7, 10}`. Here, the distances between cows are `3`, `4`, and `3`, respectively. We cannot make the minimum distance greater than `3` in any way.

#### Example 2:

-   **Input Format:** `N = 5`, `k = 2`, `arr[] = {4,2,1,3,6}`
-   **Result:** `5`
-   **Explanation:** The maximum possible minimum distance between any two cows will be `5` when `2` cows are placed at positions `{1, 6}`.

---

## Brute Force Approach

#### Intuition:

The basic idea is to test every possible distance between 1 and the difference between the farthest and nearest stalls. The largest distance for which `canWePlace()` returns true will be our answer.

#### Algorithm:

1.  Sort the `stalls` array in increasing order.
2.  Use a loop to check every possible distance one by one.
3.  For each distance, call the `canWePlace()` function to see if all cows can be placed:
    -   If `canWePlace()` returns `false` for a distance, return the previous distance (current distance - 1), as that was the largest distance where placement was possible.
4.  If the loop finishes without failure, return the largest possible distance (difference between farthest and nearest stalls).

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the Aggressive Cows problem
class Solution {
public:
    // Function to check if we can place all cows with at least distance 'd'
    bool canPlace(vector<int>& stalls, int cows, int d) {
        // Place the first cow at the first stall
        int count = 1;
        int lastPos = stalls[0];

        // Try placing the remaining cows
        for (int i = 1; i < stalls.size(); i++) {
            // If current stall is at least 'd' away from last cow
            if (stalls[i] - lastPos >= d) {
                // Place a cow here
                count++;
                lastPos = stalls[i];
            }
            // If all cows are placed successfully, return true
            if (count >= cows) return true;
        }
        // Not possible to place all cows
        return false;
    }

    // Function to find maximum minimum distance using brute force
    int aggressiveCows(vector<int>& stalls, int cows) {
        // Step 1: Sort stall positions
        sort(stalls.begin(), stalls.end());

        // Step 2: Get the maximum possible distance
        int n = stalls.size();
        int maxDist = stalls[n - 1] - stalls[0];

        // Step 3: Variable to store answer
        int ans = 0;

        // Step 4: Try all possible distances from 1 to maxDist
        for (int d = 1; d <= maxDist; d++) {
            // If cows can be placed with distance d
            if (canPlace(stalls, cows, d)) {
                // Update answer
                ans = d;
            }
        }
        // Step 5: Return the maximum valid distance
        return ans;
    }
};

// Driver code
int main() {
    // Example input
    vector<int> stalls = {1, 2, 8, 4, 9};
    int cows = 3;

    // Create object of Solution class
    Solution obj;
    // Call function and print result
    cout << obj.aggressiveCows(stalls, cows) << endl;

    return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(N*logN) + O(N * (max(stalls[]) - min(stalls[])))`, where N = size of the array, `max(stalls[])` = maximum element in `stalls[]` array, `min(stalls[])` = minimum element in `stalls[]` array.
-   **Space Complexity:** `O(1)` as we are not using any extra space to solve this problem.

---
