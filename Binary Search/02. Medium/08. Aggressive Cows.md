## Aggressive Cows: Detailed Solution

**Problem Statement:**  
You are given an array `arr` of size `n`, which denotes the position of stalls. You are also given an integer `k` which denotes the number of aggressive cows.

You are given the task of assigning stalls to `k` cows such that the minimum distance between any two of them is the maximum possible. Find the maximum possible minimum distance.

---

>### Examples:
**Example 1:**    

- #### Input:
  - `arr = [1, 2, 4, 8, 9]`.
  - `k = 3` cows

We need to place 3 cows so that the *minimum distance* between any two cows is as *large as possible*.

Try some placements:

- Place cows at stalls: `1, 4, 8`
  - Distances: `4 - 1 = 3`, `8 - 4 = 4` → minimum distance = `3`
- Place cows at stalls: `1, 4, 9`
  - Distances: `4 - 1 = 3`, `9 - 4 = 5` → minimum distance = `3`
- Place cows at stalls: `1, 2, 9`
  - Distances: `2 - 1 = 1`, `9 - 2 = 7` → minimum distance = `1` (worse)
- Place cows at stalls: `1, 8, 9`
  - Distances: `8 - 1 = 7`, `9 - 8 = 1` → minimum distance = `1` (worse)

The best we can do is a *minimum distance of 3*.

- *Output:* `3`

---

**Example 2:**    

- #### Input:  
  - `arr = [0, 3, 4, 7, 10, 9]`.
  - `k = 4` cows

Sorted stall positions: `[0, 3, 4, 7, 9, 10]`.

One optimal placement:

- Place cows at: `0, 3, 7, 10`
  - Distances: `3 - 0 = 3`, `7 - 3 = 4`, `10 - 7 = 3`
  - Minimum distance = `3`

Try to get a minimum distance `> 3`:

- If we try distance `4`, we might try `0, 4, 9`:  
  - Only 3 cows can be placed, but we need 4 → not enough.
- So `4` is not possible.

Therefore, the maximum possible *minimum distance* is `3`.

- *Output:* `3`

---

**Example 3:**  

- #### Input:
  - `arr = [1, 2, 8, 12, 17]`.
  - `k = 2` cows

We only need to place 2 cows as far apart as possible.

- Place cows at stalls: `1` and `17`
  - Distance: `17 - 1 = 16`
- Any other pair will have a smaller distance (for example, `1` and `12` → 11, `2` and `17` → 15).

So the maximum possible minimum distance is simply the distance between the *first* and the *last* stall.

- *Output:* `16`
---

>### Cases:
**Test Case 1:** Minimum Distance = 1

```
Stalls:  0   3   4   7   9   10
Cows:    C1  C2  C3  C4

```
Placement: We can place the 4 cows at {0, 3, 4, 7}.  
Distances between them:  
C1 to C2: 3  
C2 to C3: 1  
C3 to C4: 3  
Minimum Distance: The smallest gap is 1.  
Result: It's possible to place the cows with a minimum distance of at least 1. The diagram shows -> 1, likely meaning the minimum distance achieved is 1 (or that it is possible for distance 1).  

**Test Case 2:** Minimum Distance = 4 (or a higher value)  
This corresponds to the middle arrangement.  

```
Stalls:  0   3   4   7   9   10
Cows:    C1          C2
```
Placement:  
Place C1 at stall 0.  
To place C2, we need a stall at least 4 units away. 
The next available stall is 4, which is 4-0=4 away. So place C2 at 4.  

To place C3, we need a stall at least 4 units away from 4.   
The next is 9 (9-4=5). Place C3 at 9.   
To place C4, we need a stall at least 4 units away from 9.   
There are no more stalls.   

Result: We could only place 3 cows, not 4. So, a minimum distance of 4 is not possible.   
The diagram likely shows the distances if we could place them, but the conclusion is that it fails.     
The diagram shows -> 1 again, perhaps indicating this configuration is invalid or just a different attempt.    

**Test Case 3:** Minimum Distance = 3 (The Optimal Answer)    
This is the bottom arrangement and the correct solution.   
```
Stalls:  0   3   4   7   9   10
Cows:    C1  C2      C3      C4

```
Placement (Greedy Strategy):  
Place C1 at the first stall, 0.    
Find the next stall for C2 that is at least 3 units away. Stall 3 works (3 - 0 = 3). Place C2 at 3.   
Find the next stall for C3 that is at least 3 units away from 3. Stall 4 is too close. Stall 7 works (7 - 3 = 4). Place C3 at 7.    
Find the next stall for C4 that is at least 3 units away from 7. Stall 9 is too close. Stall 10 works (10 - 7 = 3). Place C4 at 10.    

Result: We successfully placed all 4 cows.   
Distances between them: {3, 4, 3}.   
Minimum Distance: The smallest gap is 3.   

Conclusion: It is possible to have a minimum distance of 3.  

---


## Brute Force Approach

#### Intuition:

The basic idea is to test every possible distance between 1 and the difference between the farthest and nearest stalls. The largest distance for which `canWePlace()` returns true will be our answer.

#### Algorithm:

1.  Sort the `stalls` array in increasing order.
2.  Use a loop to check every possible distance one by one.
3.  For each distance, call the `canWePlace()` function to see if all cows can be placed:
    -   If `canWePlace()` returns `false` for a distance, return the previous distance (current distance - 1), as that was the largest distance where placement was possible.
4.  If the loop finishes without failure, return the largest possible distance (difference between farthest and nearest stalls).

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the Aggressive Cows problem
class Solution {
public:
    // Function to check if we can place all cows with at least distance 'd'
    bool canPlace(vector<int>& stalls, int cows, int d) {
        // Place the first cow at the first stall
        int count = 1;
        int lastPos = stalls[0];

        // Try placing the remaining cows
        for (int i = 1; i < stalls.size(); i++) {
            // If current stall is at least 'd' away from last cow
            if (stalls[i] - lastPos >= d) {
                // Place a cow here
                count++;
                lastPos = stalls[i];
            }
            // If all cows are placed successfully, return true
            if (count >= cows) return true;
        }
        // Not possible to place all cows
        return false;
    }

    // Function to find maximum minimum distance using brute force
    int aggressiveCows(vector<int>& stalls, int cows) {
        // Step 1: Sort stall positions
        sort(stalls.begin(), stalls.end());

        // Step 2: Get the maximum possible distance
        int n = stalls.size();
        int maxDist = stalls[n - 1] - stalls[0];

        // Step 3: Variable to store answer
        int ans = 0;

        // Step 4: Try all possible distances from 1 to maxDist
        for (int d = 1; d <= maxDist; d++) {
            // If cows can be placed with distance d
            if (canPlace(stalls, cows, d)) {
                // Update answer
                ans = d;
            }
        }
        // Step 5: Return the maximum valid distance
        return ans;
    }
};

// Driver code
int main() {
    // Example input
    vector<int> stalls = {1, 2, 8, 4, 9};
    int cows = 3;

    // Create object of Solution class
    Solution obj;
    // Call function and print result
    cout << obj.aggressiveCows(stalls, cows) << endl;

    return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(N*logN) + O(N * (max(stalls[]) - min(stalls[])))`, where N = size of the array, `max(stalls[])` = maximum element in `stalls[]` array, `min(stalls[])` = minimum element in `stalls[]` array.
-   **Space Complexity:** `O(1)` as we are not using any extra space to solve this problem.

---

## Optimal Approach

### Algorithm:

We use **Binary Search** to optimize the solution by reducing the answer space in half each time.

The main idea of Binary Search is to determine which half of the search space can be eliminated based on a specific condition, thus minimizing unnecessary checks.

The answer space is sorted: 1 to the difference between the max and min values. We can divide this space into two parts:

-   One containing valid answers.
-   The other contains non-viable options.

For example, with `stalls = {1, 2, 8, 4, 9}`:

1.  **Sort the stalls:** Arrange the stalls in ascending order.
2.  **Set the search range:**
    -   Start with the smallest possible distance.
    -   The largest possible distance is the gap between the farthest and nearest stalls.
3.  **Use Binary Search:** Repeat the process until the search range is exhausted:
    -   Pick the middle distance: Test this distance as a possible answer.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the Aggressive Cows problem
class Solution {
public:
    // Function to check if we can place all cows with at least 'd' distance
    bool canPlace(vector<int>& stalls, int cows, int d) {
        // Place the first cow at the first stall
        int count = 1;
        int lastPos = stalls[0];

        // Loop through all stalls
        for (int i = 1; i < stalls.size(); i++) {
            // Check if this stall is at least 'd' away from the last placed cow
            if (stalls[i] - lastPos >= d) {
                // Place the cow here
                count++;
                // Update the last placed cow position
                lastPos = stalls[i];
            }
            // If all cows are placed successfully
            if (count >= cows) return true;
        }
        // Return false if we could not place all cows
        return false;
    }

    // Function to maximize minimum distance between cows
    int aggressiveCows(vector<int>& stalls, int cows) {
        // Sort the stalls
        sort(stalls.begin(), stalls.end());

        // Define search space
        int low = 1;
        int high = stalls.back() - stalls.front();
        int ans = 0;

        // Apply binary search
        while (low <= high) {
            // Find mid distance
            int mid = low + (high - low) / 2;

            // If placing cows is possible with mid-distance
            if (canPlace(stalls, cows, mid)) {
                // Store this as a potential answer
                ans = mid;
                // Try to find a larger minimum distance
                low = mid + 1;
            }
            else {
                // Otherwise, try a smaller distance
                high = mid - 1;
            }
        }
        // Return the largest minimum distance
        return ans;
    }
};

// Driver function
int main() {
    // Input stalls
    vector<int> stalls = {1, 2, 8, 4, 9};
    // Number of cows
    int cows = 3;

    // Create object
    Solution obj;
    // Print result
    cout << obj.aggressiveCows(stalls, cows) << endl;
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(N*logN) + O(N * log(max(stalls[])-min(stalls[])))`, where `N` = size of the array, `max(stalls[])` = maximum element in stalls[] array, `min(stalls[])` = minimum element in stalls[] array.
-   **Space Complexity:** `O(1)` as we are not using any extra space to solve this problem.
