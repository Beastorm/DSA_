## Allocate Minimum Number of Pages

**Problem Statement:**   

Given an array `arr` of integer numbers, `arr[i]` represents the number of pages in the `i-th` book. There are an `m` number of students, and the task is to allocate all the books to the students.
Allocate books in such a way that:

1.  Each student gets at least one book.
2.  Each book should be allocated to only one student.
3.  Book allocation should be in a contiguous manner.

You have to allocate the books to `m` students such that the maximum number of pages assigned to a student is minimum. If the allocation of books is not possible, return `-1`.


>### Examples:

#### Example 1:

-   **Input Format:** `n = 4`, `m = 2`, `arr[] = {12, 34, 67, 90}`
-   **Result:** `113`
-   **Explanation:** The allocation of books will be `12, 34, 67 | 90`. One student will get the first 3 books and the other will get the last one.

#### Example 2:

-   **Input Format:** `n = 5`, `m = 4`, `arr[] = {25, 46, 28, 49, 24}`
-   **Result:** `71`
-   **Explanation:** The allocation of books will be `25, 46 | 28 | 49 | 24`.

---

## Brute Force Approach

### Algorithm:

1.  **If `m > n`:** In this case, book allocation is not possible, and so, we will return -1.
2.  Next, we will find the maximum element and the summation of the given array.
3.  We will use a loop (say `pages`) to check all possible pages from `max(arr[])` to `sum(arr[])`.
4.  Next, inside the loop, we will send each `pages` to the function `countStudents()` to get the number of students to whom we can allocate the books.
5.  The first number of pages, `pages`, for which the number of students will be equal to `m`, will be our answer. So, we will return those particular `pages`.
6.  Finally, if we are out of the loop, we will return `max(arr[])` as there cannot exist any answer smaller than that.

``` cpp
#include <bits/stdc++.h>
using namespace std;
class Solution{
int countStudents(vector<int> &arr, int pages) {
    int n = arr.size(); //size of array.
    int students = 1;
    long long pagesStudent = 0;
    for (int i = 0; i < n; i++) {
        if (pagesStudent + arr[i] <= pages) {
            //add pages to current student
            pagesStudent += arr[i];
        }
        else {
            //add pages to next student
            students++;
            pagesStudent = arr[i];
        }
    }
    return students;
}

int findPages(vector<int>& arr, int n, int m) {
    //book allocation impossible:
    if (m > n) return -1;

    int low = *max_element(arr.begin(), arr.end());
    int high = accumulate(arr.begin(), arr.end(), 0);

    for (int pages = low; pages <= high; pages++) {
        if (countStudents(arr, pages) == m) {
            return pages;
        }
    }
    return low;
}

int main()
{
    vector<int> arr = {25, 46, 28, 49, 24};
    int n = 5;
    int m = 4;
    int ans = findPages(arr, n, m);
    cout << "The answer is: " << ans << "\n";
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(N * (sum(arr[]) - max(arr[]) + 1))`, where `N` = size of the array, `sum(arr[])` = sum of all array elements, and `max(arr[])` = maximum element in the array.
-   **Space Complexity:** `O(1)` as we are not using any extra space to solve this problem.

---

## Optimal Approach

### Algorithm:

This problem is solved using **Binary Search** to efficiently find the best way to distribute books among students.

The main idea is to cut the search range in half each time by checking whether a certain number of pages per student is possible or not.

The possible range of answers lies between the largest book (since no student can receive less than the largest book) and the total number of pages (which means giving all books to one student).

1.  First, if there are more students than books, it's impossible to assign at least one book to each student, so we return -1.

2.  Next, we search between the minimum and maximum possible values:
    -   The **minimum possible** is the largest single book (because every student must get at least one complete book).
    -   The **maximum possible** is the sum of all pages (if one student reads all books).

3.  We perform Binary Search:
    -   We try a middle value of pages per student.
    -   We check how many students would be required if no student gets more than that value.
    -   If it takes more students than allowed, that value is too low, so we try a higher one.
    -   If it fits within the allowed number of students, we store it and try a smaller one to find an even better option.

4.  Eventually, we land on the smallest value that worksâ€”this is our answer.

> **Note:** After the binary search loop ends, the pointer will be on the smallest possible maximum number of pages per student. That's why it gives the correct result directly.

``` cpp
#include <bits/stdc++.h>
using namespace std;
class Solution{
int countStudents(vector<int> &arr, int pages) {
    int n = arr.size(); //size of array.
    int students = 1;
    long long pagesStudent = 0;
    for (int i = 0; i < n; i++) {
        if (pagesStudent + arr[i] <= pages) {
            //add pages to current student
            pagesStudent += arr[i];
        }
        else {
            //add pages to next student
            students++;
            pagesStudent = arr[i];
        }
    }
    return students;
}

int findPages(vector<int>& arr, int n, int m) {
    //book allocation impossible:
    if (m > n) return -1;

    int low = *max_element(arr.begin(), arr.end());
    int high = accumulate(arr.begin(), arr.end(), 0);
    while (low <= high) {
        int mid = (low + high) / 2;
        int students = countStudents(arr, mid);
        if (students > m) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
    return low;
}

int main()
{
    vector<int> arr = {25, 46, 28, 49, 24};
    int n = 5;
    int m = 4;
    int ans = findPages(arr, n, m);
    cout << "The answer is: " << ans << "\n";
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(N * log(sum(arr[]) - max(arr[]) + 1))`, where `N` = size of the array, `sum(arr[])` = sum of all array elements, and `max(arr[])` = maximum of all array elements.
-   **Space Complexity:** `O(1)` as we are not using any extra space to solve this problem.
