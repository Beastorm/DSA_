## Median of Two Sorted Arrays of Different Sizes

**Problem Statement:**  
Given two sorted arrays `arr1` and `arr2` of size `m` and `n` respectively, return the median of the two sorted arrays. The median is defined as the middle value of a sorted list of numbers. In case the length of the list is even, the median is the average of the two middle elements.

---

>### Examples:

### <ins>Example 1: Total Even Length, Interleaved Elements</ins>

-   **Input:**
    -   `arr1[] = {1, 3, 4, 7, 10, 12}` (size m = 6)
    -   `arr2[] = {2, 6, 15, 20}` (size n = 4)

-   **Thought Process:**
    1.  **Conceptual Merged Array:** `{1, 2, 3, 4, 6, 7, 10, 12, 15, 20}`.
    2.  **Total Length:** `m + n = 6 + 4 = 10` (an even number).
    3.  **Middle Elements:** For an even length, the median is the average of the two middle elements. The indices of the middle elements are `(10/2) - 1 = 4` and `10/2 = 5`.
    4.  **Values at Middle Indices:**
        -   The element at index 4 is `6`.
        -   The element at index 5 is `7`.
    5.  **Calculate Median:** `(6 + 7) / 2.0 = 6.5`

-   **Result:** `6.5`  

---
  
### <ins>Example 2: Total Odd Length, Interleaved Elements</ins>

-   **Input:**
    -   `arr1[] = {2, 5, 6, 9}` (size m = 4)
    -   `arr2[] = {1, 3, 7}` (size n = 3)

-   **Thought Process:**
    1.  **Conceptual Merged Array:** `{1, 2, 3, 5, 6, 7, 9}`.
    2.  **Total Length:** `m + n = 4 + 3 = 7` (an odd number).
    3.  **Middle Element:** For an odd length, the median is the single middle element. The index of the middle element is `7 / 2 = 3`.
    4.  **Value at Middle Index:** The element at index 3 is `5`.

-   **Result:** `5`    

---

### <ins>Example 3: Edge Case - No Overlap</ins>

-   **Input:**
    -   `arr1[] = {1, 2, 3}` (size m = 3)
    -   `arr2[] = {10, 20, 30, 40}` (size n = 4)

-   **Thought Process:**
    1.  **Conceptual Merged Array:** `{1, 2, 3, 10, 20, 30, 40}`.
    2.  **Total Length:** `m + n = 3 + 4 = 7` (an odd number).
    3.  **Middle Element:** The index of the middle element is `7 / 2 = 3`.
    4.  **Value at Middle Index:** The element at index 3 is `10`. Notice that the median comes entirely from `arr2`.

-   **Result:** `10`  

---

### <ins>Example 4: Edge Case - One Array is Empty</ins>

-   **Input:**
    -   `arr1[] = {}` (size m = 0)
    -   `arr2[] = {10, 20, 30, 40, 50}` (size n = 5)

-   **Thought Process:**
    1.  **Conceptual Merged Array:** The merged array is just `arr2`: `{10, 20, 30, 40, 50}`.
    2.  **Total Length:** `m + n = 0 + 5 = 5` (an odd number).
    3.  **Middle Element:** The problem reduces to finding the median of `arr2`. The middle index is `5 / 2 = 2`.
    4.  **Value at Middle Index:** The element at index 2 is `30`.

-   **Result:** `30`  

---

### <ins>Example 5: Another No Overlap Case (Even Length)</ins>

-   **Input:**
    -   `arr1[] = {100, 200}` (size m = 2)
    -   `arr2[] = {1, 5, 10, 20, 30, 50}` (size n = 6)

-   **Thought Process:**
    1.  **Conceptual Merged Array:** `{1, 5, 10, 20, 30, 50, 100, 200}`.
    2.  **Total Length:** `m + n = 2 + 6 = 8` (an even number).
    3.  **Middle Elements:** The indices of the middle elements are `(8/2) - 1 = 3` and `8/2 = 4`.
    4.  **Values at Middle Indices:**
        -   The element at index 3 is `20`.
        -   The element at index 4 is `30`.
    5.  **Calculate Median:** `(20 + 30) / 2.0 = 25`. This is a great example showing that the median can be a value that is not present in either of the original arrays.

-   **Result:** `25`

---

## Brute-Force Approach

### Algorithm:

The extremely naive approach is to merge the two sorted arrays and then find the median in that merged array.

To merge the two arrays, we will be applying the merge step of the merge sort algorithm. In that step, we perform the same actions as required by this solution. By using two pointers on two given arrays, we fill the elements into a third array.

After merging, if the length of the new array is even, we return the average of the two middle elements; otherwise, we return the middle element as the median.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        // Create a merged vector to store sorted elements
        vector<int> merged;
        
        // Initialize two pointers
        int i = 0, j = 0;
        
        // Merge both arrays in sorted order
        while (i < nums1.size() && j < nums2.size()) {
            // Push the smaller element into the merged
            if (nums1[i] < nums2[j]) {
                merged.push_back(nums1[i]);
                i++;
            } else {
                merged.push_back(nums2[j]);
                j++;
            }
        }
        
        // Add remaining elements from nums1
        while (i < nums1.size()) {
            merged.push_back(nums1[i]);
            i++;
        }

        // Add remaining elements from nums2
        while (j < nums2.size()) {
            merged.push_back(nums2[j]);
            j++;
        }

        // Find median based on size
        int n = merged.size();
        if (n % 2 == 1)
            return merged[n / 2];
        else
            return (merged[n / 2 - 1] + merged[n / 2]) / 2.0;
    }
};

int main() {
    Solution sol;
    vector<int> nums1 = {1, 3};
    vector<int> nums2 = {2};
    cout << sol.findMedianSortedArrays(nums1, nums2) << endl;
    return 0;
}

```
### Complexity Analysis:
-   **Time Complexity:** `O(N1 + N2)`, as every element of both arrays is visited once.
-   **Space Complexity:** `O(N1 + N2)`, to store the merged array.

---

## Better Approach

### Algorithm:

To optimize the space used in the previous approach, we can eliminate the third array used to store the final merged result. After closer examination, we realize that we only need the two middle elements, rather than the entire merged array, to solve the problem effectively.

We will stick to the same basic approach, but instead of storing elements in a separate array, we will use a **counter** to represent the imaginary third array's index. As we traverse through the arrays, when the counter reaches the middle index, we will store that particular element. This way, we can achieve the same goal without using any extra space.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to find the median of two sorted arrays
double median(vector<int>& a, vector<int>& b) {

    // Get sizes of both arrays
    int n1 = a.size(), n2 = b.size();

    // Calculate total size
    int n = n1 + n2;

    // Calculate the middle indices
    int ind2 = n / 2;
    int ind1 = ind2 - 1;

    // Initialize pointers and counters
    int cnt = 0, i = 0, j = 0;
    int ind1el = -1, ind2el = -1;

    // Traverse both arrays like the merge step of merge sort
    while (i < n1 && j < n2) {

        // Check which element is smaller and pick it
        if (a[i] < b[j]) {
            if (cnt == ind1) ind1el = a[i];
            if (cnt == ind2) ind2el = a[i];
            i++;
        } else {
            if (cnt == ind1) ind1el = b[j];
            if (cnt == ind2) ind2el = b[j];
            j++;
        }
        cnt++;
    }

    // Copy remaining elements from first array if any
    while (i < n1) {
        if (cnt == ind1) ind1el = a[i];
        if (cnt == ind2) ind2el = a[i];
        cnt++;
        i++;
    }

    // Copy remaining elements from the second array if any
    while (j < n2) {
        if (cnt == ind1) ind1el = b[j];
        if (cnt == ind2) ind2el = b[j];
        cnt++;
        j++;
    }

    // Return median depending on even or odd size
    if (n % 2 == 1) return (double)ind2el;
    return (ind1el + ind2el) / 2.0;
}

// Driver function
int main() {
    vector<int> a = {1, 4, 7, 10, 12};
    vector<int> b = {2, 3, 6, 15};
    cout << fixed << setprecision(1);
    cout << "The median is " << median(a, b) << '\n';
}

```

## Optimal Approach

### Algorithm:

To find the median of two sorted arrays efficiently, we use **binary search** on the smaller array to minimize time complexity. The key idea is to partition both arrays such that the left half contains the smaller elements and the right half contains the larger elements. This way, the median lies at the boundary between the two halves.

We choose a cut (partition) in the first array, and accordingly calculate the cut in the second array such that the total number of elements on the left side equals the number of elements on the right (or differs by one if the total number is odd). For the correct partition, the **maximum of the left parts** should be less than or equal to the **minimum of the right parts**.

To check this, we compare the maximum of the left side of both arrays with the minimum of the right side. If the condition is not met, we move the binary search window either left or right, depending on which condition fails. This process continues until we find the right partition.

Once the correct partition is found, the median is calculated based on the total number of elements.
- If the total is **even**, we take the average of the two middle values (i.e., max of the left part and min of the right part).
- If the total is **odd**, the median is the max of the left part, since it would be the middle element.

```  cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    double findMedianSortedArrays(vector<int>& a, vector<int>& b) {
        // Ensure `a` is the smaller array to minimize binary search scope
        if (a.size() > b.size()) return findMedianSortedArrays(b, a);

        int n1 = a.size(), n2 = b.size();
        int low = 0, high = n1;

        // Binary search on the smaller array
        while (low <= high) {
            // Calculate the cut positions for both arrays
            int mid1 = (low + high) / 2;
            int mid2 = (n1 + n2 + 1) / 2 - mid1;

            // Handle boundary elements using INT_MIN and INT_MAX
            int l1 = (mid1 == 0) ? INT_MIN : a[mid1 - 1];
            int l2 = (mid2 == 0) ? INT_MIN : b[mid2 - 1];
            int r1 = (mid1 == n1) ? INT_MAX : a[mid1];
            int r2 = (mid2 == n2) ? INT_MAX : b[mid2];

            // If the correct partition is found
            if (l1 <= r2 && l2 <= r1) {
                // Total even => average of max left and min right
                if ((n1 + n2) % 2 == 0)
                    return (max(l1, l2) + min(r1, r2)) / 2.0;
                else
                    // Total odd => max of left half
                    return max(l1, l2);
            }
            else if (l1 > r2) {
                // Shift left in a
                high = mid1 - 1;
            }
            else {
                // Shift right in a
                low = mid2 + 1;
            }
        }

        return 0.0;
    }
};

int main() {
    Solution sol;
    vector<int> a = {1, 3};
    vector<int> b = {2};
    cout << "Median is: " << sol.findMedianSortedArrays(a, b) << endl;
    return 0;
}


```
### Complexity Analysis:

-   **Time Complexity:** `O(log(min(n1, n2)))`, as we are applying binary search on the range `[0, min(n1, n2)]`.
-   **Space Complexity:** `O(1)`, as only constant variables are used.
