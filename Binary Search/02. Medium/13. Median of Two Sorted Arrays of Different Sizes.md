## Median of Two Sorted Arrays of Different Sizes

**Problem Statement:**  
Given two sorted arrays `arr1` and `arr2` of size `m` and `n` respectively, return the median of the two sorted arrays. The median is defined as the middle value of a sorted list of numbers. In case the length of the list is even, the median is the average of the two middle elements.

---

>### Examples:

### Example 1: Total Even Length, Interleaved Elements

-   **Input:**
    -   `arr1[] = {1, 3, 4, 7, 10, 12}` (size m = 6)
    -   `arr2[] = {2, 6, 15, 20}` (size n = 4)

-   **Thought Process:**
    1.  **Conceptual Merged Array:** `{1, 2, 3, 4, 6, 7, 10, 12, 15, 20}`
    2.  **Total Length:** `m + n = 6 + 4 = 10` (an even number).
    3.  **Middle Elements:** For an even length, the median is the average of the two middle elements. The indices of the middle elements are `(10/2) - 1 = 4` and `10/2 = 5`.
    4.  **Values at Middle Indices:**
        -   The element at index 4 is `6`.
        -   The element at index 5 is `7`.
    5.  **Calculate Median:** `(6 + 7) / 2.0 = 6.5`

-   **Result:** `6.5`

---

### Example 2: Total Odd Length, Interleaved Elements

-   **Input:**
    -   `arr1[] = {2, 5, 6, 9}` (size m = 4)
    -   `arr2[] = {1, 3, 7}` (size n = 3)

-   **Thought Process:**
    1.  **Conceptual Merged Array:** `{1, 2, 3, 5, 6, 7, 9}`
    2.  **Total Length:** `m + n = 4 + 3 = 7` (an odd number).
    3.  **Middle Element:** For an odd length, the median is the single middle element. The index of the middle element is `7 / 2 = 3`.
    4.  **Value at Middle Index:** The element at index 3 is `5`.

-   **Result:** `5`

---

### Example 3: Edge Case - No Overlap

-   **Input:**
    -   `arr1[] = {1, 2, 3}` (size m = 3)
    -   `arr2[] = {10, 20, 30, 40}` (size n = 4)

-   **Thought Process:**
    1.  **Conceptual Merged Array:** `{1, 2, 3, 10, 20, 30, 40}`
    2.  **Total Length:** `m + n = 3 + 4 = 7` (an odd number).
    3.  **Middle Element:** The index of the middle element is `7 / 2 = 3`.
    4.  **Value at Middle Index:** The element at index 3 is `10`. Notice that the median comes entirely from `arr2`.

-   **Result:** `10`

---

### Example 4: Edge Case - One Array is Empty

-   **Input:**
    -   `arr1[] = {}` (size m = 0)
    -   `arr2[] = {10, 20, 30, 40, 50}` (size n = 5)

-   **Thought Process:**
    1.  **Conceptual Merged Array:** The merged array is just `arr2`: `{10, 20, 30, 40, 50}`.
    2.  **Total Length:** `m + n = 0 + 5 = 5` (an odd number).
    3.  **Middle Element:** The problem reduces to finding the median of `arr2`. The middle index is `5 / 2 = 2`.
    4.  **Value at Middle Index:** The element at index 2 is `30`.

-   **Result:** `30`

---

### Example 5: Another No Overlap Case (Even Length)

-   **Input:**
    -   `arr1[] = {100, 200}` (size m = 2)
    -   `arr2[] = {1, 5, 10, 20, 30, 50}` (size n = 6)

-   **Thought Process:**
    1.  **Conceptual Merged Array:** `{1, 5, 10, 20, 30, 50, 100, 200}`
    2.  **Total Length:** `m + n = 2 + 6 = 8` (an even number).
    3.  **Middle Elements:** The indices of the middle elements are `(8/2) - 1 = 3` and `8/2 = 4`.
    4.  **Values at Middle Indices:**
        -   The element at index 3 is `20`.
        -   The element at index 4 is `30`.
    5.  **Calculate Median:** `(20 + 30) / 2.0 = 25`. This is a great example showing that the median can be a value that is not present in either of the original arrays.

-   **Result:** `25`

---

## Brute-Force Approach

### Algorithm:

The extremely naive approach is to merge the two sorted arrays and then find the median in that merged array.

To merge the two arrays, we will be applying the merge step of the merge sort algorithm. In that step, we perform the same actions as required by this solution. By using two pointers on two given arrays, we fill the elements into a third array.

After merging, if the length of the new array is even, we return the average of the two middle elements; otherwise, we return the middle element as the median.

``` cpp
class Solution {
    findMedianSortedArrays(nums1, nums2) {
        // Initialize merged array
        let merged = [];
        let i = 0, j = 0;

        // Merge both arrays
        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] < nums2[j]) {
                merged.push(nums1[i]);
                i++;
            } else {
                merged.push(nums2[j]);
                j++;
            }
        }

        // Add remaining elements
        while (i < nums1.length) merged.push(nums1[i++]);
        while (j < nums2.length) merged.push(nums2[j++]);

        // Find median
        const n = merged.length;
        if (n % 2 === 1)
            return merged[Math.floor(n / 2)];
        else
            return (merged[n / 2 - 1] + merged[n / 2]) / 2;
    }
}

```
### Complexity Analysis:
-   **Time Complexity:** `O(N1 + N2)`, as every element of both arrays is visited once.
-   **Space Complexity:** `O(N1 + N2)`, to store the merged array.

---

## Better Approach

### Algorithm:

To optimize the space used in the previous approach, we can eliminate the third array used to store the final merged result. After closer examination, we realize that we only need the two middle elements, rather than the entire merged array, to solve the problem effectively.

We will stick to the same basic approach, but instead of storing elements in a separate array, we will use a **counter** to represent the imaginary third array's index. As we traverse through the arrays, when the counter reaches the middle index, we will store that particular element. This way, we can achieve the same goal without using any extra space.

``` cpp
function findMedianSortedArrays(a, b) {
    // Ensure a is the smaller array to minimize binary search scope
    if (a.length > b.length) return findMedianSortedArrays(b, a);

    let n1 = a.length, n2 = b.length;
    let low = 0, high = n1;

    // Binary search on the smaller array
    while (low <= high) {
        // Calculate the cut positions for both arrays
        let cut1 = Math.floor((low + high) / 2);
        let cut2 = Math.floor((n1 + n2 + 1) / 2) - cut1;

        // Handle boundary elements
        let l1 = (cut1 === 0) ? -Infinity : a[cut1 - 1];
        let l2 = (cut2 === 0) ? -Infinity : b[cut2 - 1];
        let r1 = (cut1 === n1) ? Infinity : a[cut1];
        let r2 = (cut2 === n2) ? Infinity : b[cut2];

        // If correct partition
        if (l1 <= r2 && l2 <= r1) {
            // Total even => average of max left and min right
            if ((n1 + n2) % 2 === 0)
                return (Math.max(l1, l2) + Math.min(r1, r2)) / 2;
            else
                // Total odd => max of left half
                return Math.max(l1, l2);
        } else if (l1 > r2) {
            // Shift left in a[]
            high = cut1 - 1;
        } else {
            // Shift right in a[]
            low = cut1 + 1;
        }
    }

    return 0.0; 
}

```

## Optimal Approach

### Algorithm:

To find the median of two sorted arrays efficiently, we use **binary search** on the smaller array to minimize time complexity. The key idea is to partition both arrays such that the left half contains the smaller elements and the right half contains the larger elements. This way, the median lies at the boundary between the two halves.

We choose a cut (partition) in the first array, and accordingly calculate the cut in the second array such that the total number of elements on the left side equals the number of elements on the right (or differs by one if the total number is odd). For the correct partition, the **maximum of the left parts** should be less than or equal to the **minimum of the right parts**.

To check this, we compare the maximum of the left side of both arrays with the minimum of the right side. If the condition is not met, we move the binary search window either left or right, depending on which condition fails. This process continues until we find the right partition.

Once the correct partition is found, the median is calculated based on the total number of elements.
- If the total is **even**, we take the average of the two middle values (i.e., max of the left part and min of the right part).
- If the total is **odd**, the median is the max of the left part, since it would be the middle element.

``` function findMedianSortedArrays(a, b) {
    // Ensure a is the smaller array to minimize binary search scope
    if (a.length > b.length) return findMedianSortedArrays(b, a);

    let n1 = a.length, n2 = b.length;
    let low = 0, high = n1;

    // Binary search on the smaller array
    while (low <= high) {
        // Calculate the cut positions for both arrays
        let cut1 = Math.floor((low + high) / 2);
        let cut2 = Math.floor((n1 + n2 + 1) / 2) - cut1;

        // Handle boundary elements
        let l1 = (cut1 === 0) ? -Infinity : a[cut1 - 1];
        let l2 = (cut2 === 0) ? -Infinity : b[cut2 - 1];
        let r1 = (cut1 === n1) ? Infinity : a[cut1];
        let r2 = (cut2 === n2) ? Infinity : b[cut2];

        // If correct partition
        if (l1 <= r2 && l2 <= r1) {
            // Total even => average of max left and min right
            if ((n1 + n2) % 2 === 0)
                return (Math.max(l1, l2) + Math.min(r1, r2)) / 2;
            else
                // Total odd => max of left half
                return Math.max(l1, l2);
        } else if (l1 > r2) {
            // Shift left in a[]
            high = cut1 - 1;
        } else {
            // Shift right in a[]
            low = cut1 + 1;
        }
    }

    return 0.0; 
}

```
### Complexity Analysis:

-   **Time Complexity:** `O(log(min(n1, n2)))`, as we are applying binary search on the range `[0, min(n1, n2)]`.
-   **Space Complexity:** `O(1)`, as only constant variables are used.
