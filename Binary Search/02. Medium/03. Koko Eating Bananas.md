## Koko Eating Bananas

**Problem Statement:**
A monkey Koko is given `n` piles of bananas, whereas the `ith` pile has `a[i]` bananas. An integer `h` is also given, which denotes the time (in hours) for all the bananas to be eaten.
Each hour, the monkey chooses a non-empty pile of bananas and eats `k` bananas. If the pile contains fewer than `k` bananas, then the monkey consumes all the bananas and wonâ€™t eat any more bananas in that hour.
Find the minimum number of bananas `k` to eat per hour so that the monkey can eat all the bananas within `h` hours.

---

>### Examples:

#### Example 1:

-   **Input:** `N = 4`, `a[] = {7, 15, 6, 3}`, `h = 8`
-   **Output:** `5`
-   **Explanation:** If Koko eats 5 bananas/hr, he will take 2, 3, 2, and 1 hours to eat the piles accordingly. So, he will take 8 hours to complete all the piles.

#### Example 2:

-   **Input:** `N = 5`, `a[] = {25, 12, 8, 14, 19}`, `h = 5`
-   **Output:** `25`
-   **Explanation:** If Koko eats 25 bananas/hr, he will take 1, 1, 1, 1, and 1 hour to eat the piles accordingly.

---

## Brute-Force Approach

### Algorithm:

The problem is about finding the minimum eating speed such that Koko can finish all bananas within `h` hours. The extremely naive approach is to check all possible answers from 1 to `max(a[])`. The minimum number for which the required time is less than or equal to `h` is our answer.

1.  Find the largest pile size (`max` of the array).
2.  Loop through all possible speeds from 1 to this maximum value.
3.  For each speed, calculate the total hours needed. For each pile, compute the time as `ceil(pile/speed)`.
4.  Sum up the hours for all piles.
5.  If the total hours are less than or equal to the allowed hours, return this speed as the answer.


``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate total hours for given speed
    int calculateTotalHours(vector<int>& a, int hourly) {
        int totalHours = 0;
        for (int pile : a) {
            // Add hours using ceil
            totalHours += (long long)ceil((double)pile / (double)hourly);
        }
        return totalHours;
    }

    // Function to find minimum eating speed
    int minEatingSpeed(vector<int>& a, int h) {
        // Find maximum pile size
        int maxVal = *max_element(a.begin(), a.end());

        // Try every possible speed
        for (int i = 1; i <= maxVal; i++) {
            int hours = calculateTotalHours(a, i);

            // If hours fit within h
            if (hours <= h) {
                return i;
            }
        }
        return maxVal;
    }
};

int main() {
    // Input array
    vector<int> a = {3, 6, 7, 11};
    // Hours allowed
    int h = 8;

    Solution obj;
    cout << obj.minEatingSpeed(a, h);
    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O(N * max(a[]))`, since for each possible speed we go through all the piles.
-   **Space Complexity:** `O(1)`, since the algorithm does not use any additional space or data structures.

---

## Optimal Approach

### Algorithm:

The naive method checks every speed, which is slow if the piles are large. But the possible answer space (from 1 to the maximum pile size) is sorted, meaning if a certain speed works, then all higher speeds will also work. This allows us to apply **Binary Search** on the answer space to efficiently find the minimum speed at which Koko can finish the bananas within the given hours.

1.  First, identify the largest pile size, since the eating speed cannot be more than that.
2.  Set the search range with the lowest speed as 1 and the highest speed as the maximum pile size.
3.  Use binary search within this range to check possible speeds.
4.  At each step, take the middle value as the current speed and calculate how many hours it would take to finish all piles at this speed.
    -   If the total hours are less than or equal to the allowed hours, this speed is a candidate, so try to see if a lower speed also works by moving **left**.
    -   If the total hours exceed the allowed hours, then the speed is too slow, so move **right** to try higher speeds.
5.  Continue this process until the range closes, and the smallest valid speed found will be the answer.


``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate total hours at given speed
    int calculateTotalHours(vector<int>& piles, int speed) {
        int totalH = 0;
        for (int bananas : piles) {
            totalH += ceil((double)bananas / speed);
        }
        return totalH;
    }

    // Function to find minimum eating speed
    int minEatingSpeed(vector<int>& piles, int h) {
        // Find maximum element
        int maxPile = *max_element(piles.begin(), piles.end());

        // Initialize low and high pointers
        int low = 1, high = maxPile;
        int ans = maxPile;

        // Binary search on answer space
        while (low <= high) {
            int mid = (low + high) / 2;
            int totalH = calculateTotalHours(piles, mid);

            // If possible, try a lower speed 
            if (totalH <= h) {
                ans = mid;
                high = mid - 1; 
            }
            // Otherwise, try a larger speed
            else {
                low = mid + 1;
            }
        }
        return ans;
    }
};

int main() {
    vector<int> piles = {3, 6, 7, 11};
    int h = 8;

    Solution obj;
    cout << obj.minEatingSpeed(piles, h);
    return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(N * log(max(a[])))`. We apply binary search on our search space, and for each check, we iterate through the `N` piles.
-   **Space Complexity:** `O(1)`, since the algorithm does not use any additional space or data structures.
