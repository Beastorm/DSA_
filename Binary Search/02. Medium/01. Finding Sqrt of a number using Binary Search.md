## Finding Sqrt of a number using Binary Search

**Problem Statement:**  

You are given a positive integer `n`. Your task is to find and return its square root. If ‘n’ is not a perfect square, then return the floor value of `sqrt(n)`.

### Examples:

#### Example 1:

-   **Input:** `N = 36`
-   **Output:** `6`
-   **Explanation:** Square root of 36 is 6.

#### Example 2:

-   **Input:** `N = 28`
-   **Output:** `5`
-   **Explanation:** Square root of 28 is approximately 5.292. So, the floor value will be 5.

---

## Brute-Force Approach

### Algorithm:

The idea is that the square root of a number `n` will always lie between 1 and `n`. So, we can linearly search in this range to find the largest integer `x` such that the square of `x` is less than or equal to the number `n`.

1.  Start by creating a variable called `ans` to hold the result and run a loop from 1 up to `n`.
2.  While the square of the current number is less than or equal to `n`, keep updating `ans` with that number.
3.  As soon as the square of the number becomes greater than `n`, stop the loop because no bigger number can be the answer.
4.  At the end, the value stored in `ans` will be the integer square root of `n`.


``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the floor of the square root using linear search
    int floorSqrt(int n) {
        // Variable to store answer
        int ans = 0;

        // Run loop from 1 to n
        for (int i = 1; i <= n; i++) {
            // Check if i*i <= n
            if ((long long)i * i <= n) {
                // Update answer
                ans = i;
            } else {
                // Break when i*i > n
                break;
            }
        }
        // Return final answer
        return ans;
    }
};

int main() {
    // Example input
    int n = 27;

    // Create object of Solution
    Solution sol;

    // Call function and print result
    cout << sol.floorSqrt(n) << endl;

    return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(N)`, we check for every number from 1 to N.
-   **Space Complexity:** `O(1)`, since the algorithm does not use any additional space or data structures

---

## Optimal Approach

### Algorithm:

The naive method tries every number, which is slow when `n` is large. But our possible answer space (from 1 to `n`) is sorted, meaning if a certain number squared is less than or equal to `n`, then all smaller numbers will also work. This allows us to apply Binary Search on the answer space to efficiently find the largest number whose square is less than or equal to `n`.

1.  First, note that the answer lies between 1 and the given number `n`.
2.  Set the search range with the smallest value as 1 and the largest value as `n`.
3.  Use binary search within this range to test possible numbers.
4.  At each step, take the middle number and check if its square is less than or equal to `n`.
    -   If it is, record this number as a candidate and move right to check for a larger number.
    -   If the square is greater than `n`, move left to check smaller numbers.
5.  Continue this process until the range closes, and the largest recorded number will be the square root.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // This function returns the floor value of the square root of a number
    int mySqrt(int x) {
        // Handle small numbers directly
        if (x < 2) return x;

        // Initialize binary search range
        int left = 1, right = x / 2, ans = 0;

        // Perform binary search
        while (left <= right) {
            // Find the middle point
            long long mid = left + (right - left) / 2;

            // Check if mid*mid is less than or equal to x
            if (mid * mid <= x) {
                // Store mid as potential answer
                ans = mid;
                // Move to the right half
                left = mid + 1;
            } else {
                // Move to the left half
                right = mid - 1;
            }
        }

        // Return final answer
        return ans;
    }
};

int main() {
    Solution s;
    cout << s.mySqrt(8) << endl;
    return 0;
}

```
### Complexity Analysis:

-   **Time Complexity:** `O(log N)`, we apply binary search on our search space to reduce it into half at every step.
-   **Space Complexity:** `O(1)`, since the algorithm does not use any additional space or data structures.
