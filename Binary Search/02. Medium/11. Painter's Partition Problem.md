## Painter's Partition Problem

**Problem Statement:**  

Given an array of length `N`, where the array represents the boards and each element of the given array represents the length of each board. Some `K` numbers of painters are available to paint these boards. 
Consider that each unit of a board takes `1` unit of time to paint.

You are supposed to return the area of the minimum time to get this job done of painting all the `N` boards under the constraint that any painter will only paint the continuous sections of boards.

---

### Conditions:

1. **All boards must be painted**
   - Every board length in the array must be assigned to *exactly one* painter.
   - No board can be skipped or split between painters.

2. **Exactly `K` painters (or fewer)**
   - We have `K` painters available.
   - Each painter can paint *one or more* boards.
   - If `K > N` (more painters than boards), some painters may remain idle, but
     each board is still assigned to exactly one painter.

3. **Contiguous assignment**
   - The segment of boards assigned to each painter must be *continuous* in the array.
   - If a painter paints boards from index `i` to `j`, they must paint:
     `boards[i], boards[i+1], ..., boards[j]` with no gaps and no reordering.
   - Example of valid split: `[10,20] | [30,40] | [50]`
   - Invalid: `[10,30] | [20,40,50]` (not contiguous with respect to original order).

4. **Objective: Minimize the maximum time**
   - Time taken by a painter = *sum of board lengths* assigned to that painter.
   - For a given partitioning of boards among painters, let:
     ```text
     maxTime = max(time_of_painter_1, ..., time_of_painter_K)
     ```
   - We want to choose a partition so that this `maxTime` is as *small as possible*.

---

>### Examples:
**Example 1:**  
- #### Input:
  - `boards = [10, 20, 30, 40]`.
  - `K = 2` painters

Each painter paints *contiguous* boards, and time = sum of board lengths they paint.  
We want to minimize the *maximum time* any painter takes.

Try possible splits:

1. Painter 1: `[10]`, Painter 2: `[20, 30, 40]`
   - Times: `10`, `20+30+40 = 90` → max = *90*

2. Painter 1: `[10, 20]`, Painter 2: `[30, 40]`
   - Times: `10+20 = 30`, `30+40 = 70` → max = *70*

3. Painter 1: `[10, 20, 30]`, Painter 2: `[40]`
   - Times: `10+20+30 = 60`, `40` → max = *60*

We want the *minimum* possible maximum time → `min(90, 70, 60) = 60`.

- *Output:* `60`

---

**Example 2:**  

- #### Input:
  - `boards = [5, 5, 5, 5]`.
  - `K = 2` painters

Try contiguous splits:

1. `[5] | [5, 5, 5]`.
   - Times: `5`, `15` → max = *15*

2. `[5, 5] | [5, 5]`
   - Times: `10`, `10` → max = *10*

3. `[5, 5, 5] | [5]`
   - Times: `15`, `5` → max = *15*

Best (minimum of maximums) is `10`.

- *Output:* `10`

---

**Example 3:**   

- #### Input:
  - `boards = [10, 10, 10, 10, 10]`.
  - `K = 3` painters

We need to split into 3 contiguous parts:

One good partition is:
- Painter 1: `[10, 10]` → time = `20`
- Painter 2: `[10, 10]` → time = `20`
- Painter 3: `[10]` → time = `10`

Maximum time among painters = `20`.

Can we do better?

- Any painter must paint at least one board of length `10`,  
  and the total is `50`; even perfectly balanced, the average load is ≈ `16.67`,
  So some painter will have to paint at least `20` units (because boards are in chunks of 10).

So `20` is optimal.

- *Output:* `20`
---

## Brute Force Approach

### Algorithm:

1.  First, we will find the maximum element and the summation of the given array.
2.  We will use a loop (say `time`) to check all possible answers from `max(arr[])` to `sum(arr[])`.
3.  Next, inside the loop, we will send `time` to the function `countPainters()` to get the number of painters to whom we can allocate the boards.
4.  The first value of `time`, for which the number of painters will be less than or equal to `k`, will be our answer. So, we will return that particular value of `time`.
5.  Finally, if we are out of the loop, we will return `max(arr[])` as there cannot exist any answer smaller than that.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the Painter Partition Problem
class PainterPartition {
public:
    // Helper function to count how many painters are required to paint the boards within the given time limit
    int countPainters(vector<int> &boards, int time) {
        int n = boards.size();
        int painters = 1; // Start with one painter
        long long boardsPainter = 0; // Current total board length assigned to a painter

        for (int i = 0; i < n; i++) {
            if (boardsPainter + boards[i] <= time) {
                // If the current board can be assigned to the same painter
                boardsPainter += boards[i];
            } else {
                // Otherwise, assign it to the next painter
                painters++;
                boardsPainter = boards[i];
            }
        }
        return painters;
    }

    // Function to find the minimum time to paint all boards using at most k painters
    int findLargestMinDistance(vector<int> &boards, int k) {
        int low = *max_element(boards.begin(), boards.end()); // Min possible time = largest board
        int high = accumulate(boards.begin(), boards.end(), 0); // Max time = total sum of boards

        for (int time = low; time <= high; time++) {
            if (countPainters(boards, time) <= k) {
                return time;
            }
        }
        return low;
    }
};

int main() {
    vector<int> boards = {10, 20, 30, 40};
    int k = 2;

    PainterPartition obj;
    int ans = obj.findLargestMinDistance(boards, k);
    cout << "The answer is: " << ans << "\n";

    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O(N * (sum(arr[]) - max(arr[]) + 1))`, where `N` = size of the array, `sum(arr[])` = sum of all array elements, `max(arr[])` = maximum of all array elements.
-   **Space Complexity:** `O(1)`, no extra space used.

---
## Optimal Approach

### Algorithm:

1.  **Place the 2 pointers, i.e., `low` and `high`:** Initially, we will place the pointers. The pointer `low` will point to `max(arr[])` and the `high` will point to `sum(arr[])`.

2.  **Calculate the `mid`:** Now, inside the loop, we will calculate the value of `mid` using the following formula:
    ```text
    mid = (low + high) // 2   // ‘//’ refers to integer division
    ```

3.  **Eliminate the halves based on the number of painters returned by `countPainters()`:** We will pass the potential value of time, represented by the variable `mid`, to the `countPainters()` function. This function will return the number of painters we need to paint all the boards.
    -   **If `painters > k`:** On satisfying this condition, we can conclude that the number `mid` is smaller than our answer. So, we will eliminate the left half and consider the right half (i.e., `low = mid + 1`).
    -   **Otherwise:** The value `mid` is one of the possible answers. But we want the minimum value. So, we will eliminate the right half and consider the left half (i.e., `high = mid - 1`).

4.  Finally, outside the loop, we will return the value of `low` as the pointer will be pointing to the answer.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the Painter Partition Problem using Binary Search
class PainterPartition {
public:
    // Helper function: counts how many painters are needed if each can paint at most 'time' units
    int countPainters(vector<int> &boards, int time) {
        int painters = 1;
        long long boardsPainter = 0;

        for (int i = 0; i < boards.size(); i++) {
            if (boardsPainter + boards[i] <= time) {
                // Allocate board to current painter
                boardsPainter += boards[i];
            } else {
                // Allocate board to new painter
                painters++;
                boardsPainter = boards[i];
            }
        }

        return painters;
    }

    // Main function: finds the minimum max time using binary search
    int findLargestMinDistance(vector<int> &boards, int k) {
        int low = *max_element(boards.begin(), boards.end());      // At least the largest board
        int high = accumulate(boards.begin(), boards.end(), 0);    // At most the total sum

        int result = high;

        while (low <= high) {
            int mid = (low + high) / 2;  // Mid time to test
            int painters = countPainters(boards, mid);

            if (painters > k) {
                low = mid + 1; // Too few painters → increase time
            } else {
                result = mid;  // Valid solution → try to minimize
                high = mid - 1;
            }
        }

        return result;
    }
};

int main() {
    vector<int> boards = {10, 20, 30, 40};
    int k = 2;

    PainterPartition pp;
    int ans = pp.findLargestMinDistance(boards, k);
    cout << "The answer is: " << ans << "\n"; // Expected: 60
    return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(N * log(sum(arr[]) - max(arr[]) + 1))`, where `N` = size of the array, `sum(arr[])` = sum of all array elements, `max(arr[])` = maximum of all array elements.
-   **Space Complexity:** `O(1)` since no extra space is required.
