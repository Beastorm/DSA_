## Painter's Partition Problem

**Problem Statement:**  

Given an array/list of length `N`, where the array/list represents the boards and each element of the given array/list represents the length of each board. Some `K` numbers of painters are available to paint these boards. 
Consider that each unit of a board takes `1` unit of time to paint.

You are supposed to return the area of the minimum time to get this job done of painting all the `N` boards under the constraint that any painter will only paint the continuous sections of boards.


>### Examples:

#### Example 1:

-   **Input Format:** `N = 4`, `boards[] = {5, 5, 5, 5}`, `k = 2`
-   **Result:** `10`
-   **Explanation:** We can divide the boards into 2 equal-sized partitions, so each painter gets 10 units of the board, and the total time taken is 10.

#### Example 2:

-   **Input Format:** `N = 4`, `boards[] = {10, 20, 30, 40}`, `k = 2`
-   **Result:** `60`
-   **Explanation:** We can divide the first 3 boards for one painter and the last board for the second painter.

---

## Brute Force Approach

### Algorithm:

1.  First, we will find the maximum element and the summation of the given array.
2.  We will use a loop (say `time`) to check all possible answers from `max(arr[])` to `sum(arr[])`.
3.  Next, inside the loop, we will send `time` to the function `countPainters()` to get the number of painters to whom we can allocate the boards.
4.  The first value of `time`, for which the number of painters will be less than or equal to `k`, will be our answer. So, we will return that particular value of `time`.
5.  Finally, if we are out of the loop, we will return `max(arr[])` as there cannot exist any answer smaller than that.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the Painter Partition Problem
class PainterPartition {
public:
    // Helper function to count how many painters are required to paint the boards within the given time limit
    int countPainters(vector<int> &boards, int time) {
        int n = boards.size();
        int painters = 1; // Start with one painter
        long long boardsPainter = 0; // Current total board length assigned to a painter

        for (int i = 0; i < n; i++) {
            if (boardsPainter + boards[i] <= time) {
                // If the current board can be assigned to the same painter
                boardsPainter += boards[i];
            } else {
                // Otherwise, assign it to the next painter
                painters++;
                boardsPainter = boards[i];
            }
        }
        return painters;
    }

    // Function to find the minimum time to paint all boards using at most k painters
    int findLargestMinDistance(vector<int> &boards, int k) {
        int low = *max_element(boards.begin(), boards.end()); // Min possible time = largest board
        int high = accumulate(boards.begin(), boards.end(), 0); // Max time = total sum of boards

        for (int time = low; time <= high; time++) {
            if (countPainters(boards, time) <= k) {
                return time;
            }
        }
        return low;
    }
};

int main() {
    vector<int> boards = {10, 20, 30, 40};
    int k = 2;

    PainterPartition obj;
    int ans = obj.findLargestMinDistance(boards, k);
    cout << "The answer is: " << ans << "\n";

    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O(N * (sum(arr[]) - max(arr[]) + 1))`, where `N` = size of the array, `sum(arr[])` = sum of all array elements, `max(arr[])` = maximum of all array elements.
-   **Space Complexity:** `O(1)`, no extra space used.

---
## Optimal Approach

### Algorithm:

1.  **Place the 2 pointers, i.e., `low` and `high`:** Initially, we will place the pointers. The pointer `low` will point to `max(arr[])` and the `high` will point to `sum(arr[])`.

2.  **Calculate the `mid`:** Now, inside the loop, we will calculate the value of `mid` using the following formula:
    ```text
    mid = (low + high) // 2   // ‘//’ refers to integer division
    ```

3.  **Eliminate the halves based on the number of painters returned by `countPainters()`:** We will pass the potential value of time, represented by the variable `mid`, to the `countPainters()` function. This function will return the number of painters we need to paint all the boards.
    -   **If `painters > k`:** On satisfying this condition, we can conclude that the number `mid` is smaller than our answer. So, we will eliminate the left half and consider the right half (i.e., `low = mid + 1`).
    -   **Otherwise:** The value `mid` is one of the possible answers. But we want the minimum value. So, we will eliminate the right half and consider the left half (i.e., `high = mid - 1`).

4.  Finally, outside the loop, we will return the value of `low` as the pointer will be pointing to the answer.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the Painter Partition Problem using Binary Search
class PainterPartition {
public:
    // Helper function: counts how many painters are needed if each can paint at most 'time' units
    int countPainters(vector<int> &boards, int time) {
        int painters = 1;
        long long boardsPainter = 0;

        for (int i = 0; i < boards.size(); i++) {
            if (boardsPainter + boards[i] <= time) {
                // Allocate board to current painter
                boardsPainter += boards[i];
            } else {
                // Allocate board to new painter
                painters++;
                boardsPainter = boards[i];
            }
        }

        return painters;
    }

    // Main function: finds the minimum max time using binary search
    int findLargestMinDistance(vector<int> &boards, int k) {
        int low = *max_element(boards.begin(), boards.end());      // At least the largest board
        int high = accumulate(boards.begin(), boards.end(), 0);    // At most the total sum

        int result = high;

        while (low <= high) {
            int mid = (low + high) / 2;  // Mid time to test
            int painters = countPainters(boards, mid);

            if (painters > k) {
                low = mid + 1; // Too few painters → increase time
            } else {
                result = mid;  // Valid solution → try to minimize
                high = mid - 1;
            }
        }

        return result;
    }
};

int main() {
    vector<int> boards = {10, 20, 30, 40};
    int k = 2;

    PainterPartition pp;
    int ans = pp.findLargestMinDistance(boards, k);
    cout << "The answer is: " << ans << "\n"; // Expected: 60
    return 0;
}
```

### Complexity Analysis:

-   **Time Complexity:** `O(N * log(sum(arr[]) - max(arr[]) + 1))`, where `N` = size of the array, `sum(arr[])` = sum of all array elements, `max(arr[])` = maximum of all array elements.
-   **Space Complexity:** `O(1)` since no extra space is required.
