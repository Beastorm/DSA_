## Minimum days to make M bouquets

**Problem Statement:**  
You are given `N` roses, and you are also given an array `arr` where `arr[i]` denotes that the `ith` rose will bloom on the `arr[i]th` day. 
You can only pick already bloomed roses that are adjacent to make a bouquet. You are also told that you require exactly `k` adjacent bloomed roses to make a single bouquet.

Find the minimum number of days required to make at least `m` bouquets, each containing `k` roses. Return `-1` if it is not possible.

---

### Key Conditions for “Minimum Days to Make M Bouquets.”
Here, m is the bouquet, k is the number of roses per bouquet, and N is the number of roses.
1. **Feasibility Check:**  
   - You need `m * k` roses total.
   - If `m * k > N` (where `N = arr.size()`), it is **impossible** → return `-1`.

2. **Bloom Condition (for a given day `D`):**   
   - Rose `i` can be used only if:
     ```text
     arr[i] <= D
     ```

3. **Adjacency Condition:**
   - Each bouquet must use **exactly `k` adjacent** bloomed roses (consecutive indices).

4. **Bouquet Count Condition (inside `canMakeBouquets(D)`):**   
   - Scan the array:
     - Count consecutive bloomed roses (`arr[i] <= D`).
     - Every time the count reaches `k`, form a bouquet and reset the count.
   - After the scan, check:
     ```text
     bouquets >= m
     ```
   - If true → day `D` is sufficient; if false → too early.

---

>### Examples:

**<ins>Example 1:</ins>**  

- #### Input:
  - `arr = [1, 10, 3, 10, 2]`.
  - `m = 3` bouquets
  - `k = 1` rose per bouquet

- #### Explanation:
  - We need `m * k = 3` roses.
  - Each bouquet needs only 1 rose, and roses can be from anywhere (no adjacency issue since `k = 1`).
  - By *day 2*, roses at indices `0` (day 1) and `4` (day 2) have bloomed → 2 roses.
  - We still need one more.
  - By *day 3*, the rose at index `2` (day 3) has also bloomed → 3 roses total.
  - So we can make 3 bouquets by *day 3*.

- _Output_: `3`


**<ins>Example 2:</ins>**   

- #### Input:
  - `arr = [1, 10, 3, 10, 2]`.
  - `m = 3` bouquets
  - `k = 2` roses per bouquet

- #### Explanation:
  - We need `m * k = 3 * 2 = 6` roses, but we only have 5 roses in total.
  - It's *impossible* to make 3 bouquets of 2 roses each.

- *Output:* `-1`


**<ins>Example 3:</ins>**   

- #### Input:
  - `arr = [7, 7, 7, 7, 13, 11, 12, 7]`.
  - `m = 2` bouquets
  - `k = 3` roses per bouquet

- #### Explanation:
  - We need `m * k = 6` roses, and we have 8 roses available.
  - But they must be taken in *adjacent groups of 3*.

  Check days:

  - *By day 7:*
    - Bloomed roses (day ≤ 7): `[7,7,7,7, -, -, -,7]`
    - Possible adjacent groups of 3:
      - indices `[0,1,2]` → 1 bouquet
      - indices `[1,2,3]` → 2nd bouquet
    - We can already make *2 bouquets* of 3 roses each.
  - We are asked for the *minimum* day, but if we check smaller days:
    - *By day 6* or earlier, not enough roses (or adjacency) are ready.

- *Output:* `7`


**<ins>Example 4:</ins>**   

- #### Input:
  - `arr = [1, 2, 4, 9, 3, 4, 1]`.
  - `m = 2` bouquets
  - `k = 2` roses per bouquet

- #### Explanation:
  - We need `m * k = 4` roses, in two groups of 2 adjacent bloomed roses.

  Check days:

  - *By day 2:*
    - Bloomed roses (≤ 2): `[1, 2, -, -, -, -, 1]`
    - Adjacent bloomed pairs:
      - indices `[0,1]` → 1 bouquet
    - Only 1 bouquet possible.

  - *By day 3:*
    - Bloomed roses (≤ 3): `[1, 2, -, -, 3, -, 1]`
    - Adjacent bloomed pairs:
      - `[0,1]` → 1 bouquet
      - `[4,5]` not valid, since index 5 is not bloomed yet.
    - Still only 1 bouquet.

  - *By day 4:*
    - Bloomed roses (≤ 4): `[1, 2, 4, -, 3, 4, 1]`
    - Adjacent bloomed pairs:
      - `[0,1]` → 1 bouquet
      - `[2,3]` no (3 not bloomed)
      - `[4,5]` → 2nd bouquet (`3` & `4`)
    - Now we can form *2 bouquets* of 2 adjacent roses.

- *Output:* `4`

---

## Brute Force Approach

### Algorithm:

1.  If the total number of flowers required to make all bouquets is more than the number of flowers available, it is not possible to make the bouquets. So, return `-1`.
2.  Loop through each day, starting from the earliest bloom day to the latest bloom day, to test all possible answers.
3.  For each day, check if it's possible to make the required number of bouquets using the flowers that have bloomed by that day. If yes, return that day as the answer.
4.  If no suitable day is found after checking all possibilities, it means it's impossible to make the bouquets. So, return `-1`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to handle bouquet formation logic
class RoseGarden {
public:
    // Function to check if we can form 'm' bouquets by 'day'.
    bool isPossible(vector<int>& bloomDays, int day, int m, int k) {
        int count = 0;  // consecutive flowers that bloomed by 'day'
        int bouquets = 0;

        for (int bloom : bloomDays) {
            if (bloom <= day) {
                count++;
                if (count == k) {
                    bouquets++;
                    count = 0;
                }
            } else {
                count = 0;
            }
        }

        return bouquets >= m;
    }

    // Main function to find the minimum day to form 'm' bouquets
    int minDaysToMakeBouquets(vector<int>& bloomDays, int m, int k) {
        long long totalFlowers = 1LL * m * k;
        if (totalFlowers > bloomDays.size()) return -1; // Not enough flowers

        int low = *min_element(bloomDays.begin(), bloomDays.end());
        int high = *max_element(bloomDays.begin(), bloomDays.end());

        // Brute-force search from min to max bloom day
        for (int day = low; day <= high; ++day) {
            if (isPossible(bloomDays, day, m, k)) {
                return day;
            }
        }

        return -1; // Not possible to make bouquets
    }
};

int main() {
    vector<int> bloomDays = {7, 7, 7, 7, 13, 11, 12, 7};
    int k = 3;
    int m = 2;

    RoseGarden garden;
    int result = garden.minDaysToMakeBouquets(bloomDays, m, k);

    if (result == -1)
        cout << "We cannot make m bouquets.\n";
    else
        cout << "We can make bouquets on day " << result << "\n";

    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O((max(arr[]) - min(arr[]) + 1) * N)`, where `{max(arr[]) -> maximum element of the array, min(arr[]) -> minimum element of the array, N = size of the array}`.
-   **Space Complexity:** `O(1)` as we are not using any extra space to solve this problem.

---
## Optimal Approach

### Algorithm:

1.  **If `m * k > arr.size`:** This means we have insufficient flowers. So, it is impossible to make `m` bouquets, and we will return -1.

2.  Next, we will find the maximum element, i.e., `max(arr[])`, and the minimum element, i.e., `min(arr[])`, in the array.

3.  **Place the 2 pointers i.e,. `low` and `high`:** Initially, we will place the pointers. The pointer `low` will point to `min(arr[])` and the `high` will point to `max(arr[])`.

4.  **Calculate the `mid`:** Now, inside the loop, we will calculate the value of `mid` using the following formula:
    ```text
    mid = (low + high) // 2   // ‘//’ refers to integer division
    ```

5.  **Eliminate the halves based on the value returned by `possible()`:** We will pass the potential answer, represented by the variable 'mid' (which corresponds to a specific day), to the `possible()` function.
    -   **If `possible()` returns true:** On satisfying this condition, we can conclude that the number `mid` is one of our possible answers. But we want the minimum number. So, we will eliminate the right half and consider the left half (i.e., `high = mid - 1`).
    -   **Otherwise:** The value `mid` is smaller than the number we want. This means the numbers greater than `mid` should be considered, and the right half of `mid` consists of such numbers. So, we will eliminate the left half and consider the right half (i.e., `low = mid + 1`).

6.  Finally, outside the loop, we will return the value of `low` as the pointer will be pointing to the answer.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Helper function to check if it's possible to make m bouquets on or before a given day
    bool possible(vector<int>& arr, int day, int m, int k) {
        int n = arr.size();         // Total number of flowers
        int cnt = 0;                // Counter for consecutive bloomed flowers
        int bouquets = 0;           // Count of bouquets made

        for (int i = 0; i < n; i++) {
            if (arr[i] <= day) {
                // Flower bloomed, increment consecutive count
                cnt++;
                if (cnt == k) {
                    // We have k consecutive bloomed flowers — make 1 bouquet
                    bouquets++;
                    cnt = 0; // reset for next bouquet
                }
            } else {
                // Flower not bloomed, reset consecutive count
                cnt = 0;
            }
        }

        // Check if at least m bouquets can be made
        return bouquets >= m;
    }

    // Main function to find the minimum day to make m bouquets
    int roseGarden(vector<int>& arr, int k, int m) {
        long long total = 1LL * k * m; // Total flowers required

        // If total required flowers > available flowers, it's impossible
        if (total > arr.size()) return -1;

        // Find minimum and maximum bloom days from the array
        int mini = *min_element(arr.begin(), arr.end());
        int maxi = *max_element(arr.begin(), arr.end());

        // Apply binary search on the number of days
        int low = mini, high = maxi;
        int result = -1;

        while (low <= high) {
            int mid = (low + high) / 2;

            if (possible(arr, mid, m, k)) {
                // If it's possible to make bouquets on this day, try to find an earlier day
                result = mid;
                high = mid - 1;
            } else {
                // Otherwise, try with a later day
                low = mid + 1;
            }
        }

        return result;
    }
};

int main() {
    vector<int> arr = {7, 7, 7, 7, 13, 11, 12, 7};
    int k = 3; // number of flowers needed per bouquet
    int m = 2; // number of bouquets to make

    Solution sol;
    int ans = sol.roseGarden(arr, k, m);

    if (ans == -1)
        cout << "We cannot make m bouquets.\n";
    else
        cout << "We can make bouquets on day " << ans << "\n";

    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(log(max(arr[]) - min(arr[]) + 1) * N)`, where `{max(arr[]) -> maximum element of the array, min(arr[]) -> minimum element of the array, N = size of the array}`.
-   **Space Complexity:** `O(1)` as we are not using any extra space to solve this problem.
