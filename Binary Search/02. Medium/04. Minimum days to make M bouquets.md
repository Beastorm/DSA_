## Minimum days to make M bouquets

**Problem Statement:**  

You are given `N` roses, and you are also given an array `arr` where `arr[i]` denotes that the `ith` rose will bloom on the `arr[i]th` day. 
You can only pick already bloomed roses that are adjacent to make a bouquet. You are also told that you require exactly `k` adjacent bloomed roses to make a single bouquet.

Find the minimum number of days required to make at least `m` bouquets, each containing `k` roses. Return `-1` if it is not possible.


### Examples:

#### Example 1:

-   **Input Format:** `N = 8`, `arr[] = {7, 7, 7, 7, 13, 11, 12, 7}`, `m = 2`, `k = 3`
-   **Result:** `12`
-   **Explanation:** On the 12th day, the first 4 flowers and the last 3 flowers would have already bloomed. So, we can easily make 2 bouquets, one with the first 3 and another with the last 3 flowers.

#### Example 2:

-   **Input Format:** `N = 5`, `arr[] = {1, 10, 3, 10, 2}`, `m = 3`, `k = 2`
-   **Result:** `-1`
-   **Explanation:** If we want to make 3 bouquets of 2 flowers each, we need at least 6 flowers. But we are given only 5 flowers, so we cannot make the bouquets.

---

## Brute Force Approach

### Algorithm:

1.  If the total number of flowers required to make all bouquets is more than the number of flowers available, it is not possible to make the bouquets. So, return `-1`.
2.  Loop through each day, starting from the earliest bloom day to the latest bloom day, to test all possible answers.
3.  For each day, check if it's possible to make the required number of bouquets using the flowers that have bloomed by that day. If yes, return that day as the answer.
4.  If no suitable day is found after checking all possibilities, it means it's impossible to make the bouquets. So, return `-1`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to handle bouquet formation logic
class RoseGarden {
public:
    // Function to check if we can form 'm' bouquets by 'day'.
    bool isPossible(vector<int>& bloomDays, int day, int m, int k) {
        int count = 0;  // consecutive flowers that bloomed by 'day'
        int bouquets = 0;

        for (int bloom : bloomDays) {
            if (bloom <= day) {
                count++;
                if (count == k) {
                    bouquets++;
                    count = 0;
                }
            } else {
                count = 0;
            }
        }

        return bouquets >= m;
    }

    // Main function to find the minimum day to form 'm' bouquets
    int minDaysToMakeBouquets(vector<int>& bloomDays, int m, int k) {
        long long totalFlowers = 1LL * m * k;
        if (totalFlowers > bloomDays.size()) return -1; // Not enough flowers

        int low = *min_element(bloomDays.begin(), bloomDays.end());
        int high = *max_element(bloomDays.begin(), bloomDays.end());

        // Brute-force search from min to max bloom day
        for (int day = low; day <= high; ++day) {
            if (isPossible(bloomDays, day, m, k)) {
                return day;
            }
        }

        return -1; // Not possible to make bouquets
    }
};

int main() {
    vector<int> bloomDays = {7, 7, 7, 7, 13, 11, 12, 7};
    int k = 3;
    int m = 2;

    RoseGarden garden;
    int result = garden.minDaysToMakeBouquets(bloomDays, m, k);

    if (result == -1)
        cout << "We cannot make m bouquets.\n";
    else
        cout << "We can make bouquets on day " << result << "\n";

    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O((max(arr[]) - min(arr[]) + 1) * N)`, where `{max(arr[]) -> maximum element of the array, min(arr[]) -> minimum element of the array, N = size of the array}`.
-   **Space Complexity:** `O(1)` as we are not using any extra space to solve this problem.
