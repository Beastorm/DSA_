## Minimum days to make M bouquets

**Problem Statement:**  

You are given `N` roses, and you are also given an array `arr` where `arr[i]` denotes that the `ith` rose will bloom on the `arr[i]th` day. 
You can only pick already bloomed roses that are adjacent to make a bouquet. You are also told that you require exactly `k` adjacent bloomed roses to make a single bouquet.

Find the minimum number of days required to make at least `m` bouquets, each containing `k` roses. Return `-1` if it is not possible.


### Examples:

#### Example 1:

-   **Input Format:** `N = 8`, `arr[] = {7, 7, 7, 7, 13, 11, 12, 7}`, `m = 2`, `k = 3`
-   **Result:** `12`
-   **Explanation:** On the 12th day, the first 4 flowers and the last 3 flowers would have already bloomed. So, we can easily make 2 bouquets, one with the first 3 and another with the last 3 flowers.

#### Example 2:

-   **Input Format:** `N = 5`, `arr[] = {1, 10, 3, 10, 2}`, `m = 3`, `k = 2`
-   **Result:** `-1`
-   **Explanation:** If we want to make 3 bouquets of 2 flowers each, we need at least 6 flowers. But we are given only 5 flowers, so we cannot make the bouquets.

---

## Brute Force Approach

### Algorithm:

1.  If the total number of flowers required to make all bouquets is more than the number of flowers available, it is not possible to make the bouquets. So, return `-1`.
2.  Loop through each day, starting from the earliest bloom day to the latest bloom day, to test all possible answers.
3.  For each day, check if it's possible to make the required number of bouquets using the flowers that have bloomed by that day. If yes, return that day as the answer.
4.  If no suitable day is found after checking all possibilities, it means it's impossible to make the bouquets. So, return `-1`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to handle bouquet formation logic
class RoseGarden {
public:
    // Function to check if we can form 'm' bouquets by 'day'.
    bool isPossible(vector<int>& bloomDays, int day, int m, int k) {
        int count = 0;  // consecutive flowers that bloomed by 'day'
        int bouquets = 0;

        for (int bloom : bloomDays) {
            if (bloom <= day) {
                count++;
                if (count == k) {
                    bouquets++;
                    count = 0;
                }
            } else {
                count = 0;
            }
        }

        return bouquets >= m;
    }

    // Main function to find the minimum day to form 'm' bouquets
    int minDaysToMakeBouquets(vector<int>& bloomDays, int m, int k) {
        long long totalFlowers = 1LL * m * k;
        if (totalFlowers > bloomDays.size()) return -1; // Not enough flowers

        int low = *min_element(bloomDays.begin(), bloomDays.end());
        int high = *max_element(bloomDays.begin(), bloomDays.end());

        // Brute-force search from min to max bloom day
        for (int day = low; day <= high; ++day) {
            if (isPossible(bloomDays, day, m, k)) {
                return day;
            }
        }

        return -1; // Not possible to make bouquets
    }
};

int main() {
    vector<int> bloomDays = {7, 7, 7, 7, 13, 11, 12, 7};
    int k = 3;
    int m = 2;

    RoseGarden garden;
    int result = garden.minDaysToMakeBouquets(bloomDays, m, k);

    if (result == -1)
        cout << "We cannot make m bouquets.\n";
    else
        cout << "We can make bouquets on day " << result << "\n";

    return 0;
}
```
### Complexity Analysis:
-   **Time Complexity:** `O((max(arr[]) - min(arr[]) + 1) * N)`, where `{max(arr[]) -> maximum element of the array, min(arr[]) -> minimum element of the array, N = size of the array}`.
-   **Space Complexity:** `O(1)` as we are not using any extra space to solve this problem.

---
## Optimal Approach

### Algorithm:

1.  **If `m * k > arr.size`:** This means we have insufficient flowers. So, it is impossible to make `m` bouquets, and we will return -1.

2.  Next, we will find the maximum element, i.e., `max(arr[])`, and the minimum element, i.e., `min(arr[])`, in the array.

3.  **Place the 2 pointers i.e,. `low` and `high`:** Initially, we will place the pointers. The pointer `low` will point to `min(arr[])` and the `high` will point to `max(arr[])`.

4.  **Calculate the `mid`:** Now, inside the loop, we will calculate the value of `mid` using the following formula:
    ```text
    mid = (low + high) // 2   // ‘//’ refers to integer division
    ```

5.  **Eliminate the halves based on the value returned by `possible()`:** We will pass the potential answer, represented by the variable 'mid' (which corresponds to a specific day), to the `possible()` function.
    -   **If `possible()` returns true:** On satisfying this condition, we can conclude that the number `mid` is one of our possible answers. But we want the minimum number. So, we will eliminate the right half and consider the left half (i.e., `high = mid - 1`).
    -   **Otherwise:** The value `mid` is smaller than the number we want. This means the numbers greater than `mid` should be considered, and the right half of `mid` consists of such numbers. So, we will eliminate the left half and consider the right half (i.e., `low = mid + 1`).

6.  Finally, outside the loop, we will return the value of `low` as the pointer will be pointing to the answer.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Helper function to check if it's possible to make m bouquets on or before a given day
    bool possible(vector<int>& arr, int day, int m, int k) {
        int n = arr.size();         // Total number of flowers
        int cnt = 0;                // Counter for consecutive bloomed flowers
        int bouquets = 0;           // Count of bouquets made

        for (int i = 0; i < n; i++) {
            if (arr[i] <= day) {
                // Flower bloomed, increment consecutive count
                cnt++;
                if (cnt == k) {
                    // We have k consecutive bloomed flowers — make 1 bouquet
                    bouquets++;
                    cnt = 0; // reset for next bouquet
                }
            } else {
                // Flower not bloomed, reset consecutive count
                cnt = 0;
            }
        }

        // Check if at least m bouquets can be made
        return bouquets >= m;
    }

    // Main function to find the minimum day to make m bouquets
    int roseGarden(vector<int>& arr, int k, int m) {
        long long total = 1LL * k * m; // Total flowers required

        // If total required flowers > available flowers, it's impossible
        if (total > arr.size()) return -1;

        // Find minimum and maximum bloom days from the array
        int mini = *min_element(arr.begin(), arr.end());
        int maxi = *max_element(arr.begin(), arr.end());

        // Apply binary search on the number of days
        int low = mini, high = maxi;
        int result = -1;

        while (low <= high) {
            int mid = (low + high) / 2;

            if (possible(arr, mid, m, k)) {
                // If it's possible to make bouquets on this day, try to find an earlier day
                result = mid;
                high = mid - 1;
            } else {
                // Otherwise, try with a later day
                low = mid + 1;
            }
        }

        return result;
    }
};

int main() {
    vector<int> arr = {7, 7, 7, 7, 13, 11, 12, 7};
    int k = 3; // number of flowers needed per bouquet
    int m = 2; // number of bouquets to make

    Solution sol;
    int ans = sol.roseGarden(arr, k, m);

    if (ans == -1)
        cout << "We cannot make m bouquets.\n";
    else
        cout << "We can make bouquets on day " << ans << "\n";

    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(log(max(arr[]) - min(arr[]) + 1) * N)`, where `{max(arr[]) -> maximum element of the array, min(arr[]) -> minimum element of the array, N = size of the array}`.
-   **Space Complexity:** `O(1)` as we are not using any extra space to solve this problem.
