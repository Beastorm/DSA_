## Median of Row-Wise Sorted Matrix

**Problem Statement:**  [ref](https://www.youtube.com/watch?v=Ul8zBtVFXOo)  

Given a row-wise sorted matrix of size `M*N`, where `M` is the number of rows and `N` is the number of columns, find the median in the given matrix.

>**Note:** `M*N` is odd.

---

>### Examples:
### <ins>Example 1:</ins>

-   **Input Matrix:**
    ```
    [
      [1, 3, 5],
      [2, 6, 9],
      [3, 6, 9]
    ]
    ```
-   **Size:** 3x3 (Total elements = 9)
-   **Thought Process:**
    1.  Flatten and sort the elements: `{1, 2, 3, 3, **5**, 6, 6, 9, 9}`
    2.  The middle element (at index 4) is `5`.
-   **Result:** `5`

---

### <ins>Example 2:</ins>

-   **Input Matrix:**
    ```
    [
      [1, 10, 20],
      [15, 25, 35],
      [5, 30, 40]
    ]
    ```
-   **Size:** 3x3 (Total elements = 9)
-   **Thought Process:**
    1.  Flatten and sort the elements: `{1, 5, 10, 15, **20**, 25, 30, 35, 40}`
    2.  The middle element is `20`.
-   **Result:** `20`

---

### <ins>Example 3 (Different Dimensions):</ins>

-   **Input Matrix:**
    ```
    [
      [2, 6, 8, 10, 11]
    ]
    ```
-   **Size:** 1x5 (Total elements = 5)
-   **Thought Process:**
    1.  The array is already flat and sorted: `{2, 6, **8**, 10, 11}`
    2.  The middle element is `8`.
-   **Result:** `8`

---

### <ins>Example 4 (Another Different Dimension):</ins>

-   **Input Matrix:**
    ```
    [
      [1],
      [2],
      [3]
    ]
    ```
-   **Size:** 3x1 (Total elements = 3)
-   **Thought Process:**
    1.  Flatten and sort: `{1, **2**, 3}`
    2.  The middle element is `2`.
-   **Result:** `2`

---

## Brute-Force Approach

### Algorithm:

The extremely naive approach is to use a linear array or list to store the elements of the given matrix and then sort that list. We can return the middle element of the sorted list to find the median.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the median of a row-wise sorted matrix
    int findMedian(vector<vector<int>>& matrix) {
        
        // Create a list to store all elements
        vector<int> elements;

        // Traverse each row of the matrix
        for (auto& row : matrix) {

            // Traverse each element in the current row
            for (int val : row) {

                // Add the element to the list
                elements.push_back(val);
            }
        }

        // Sort the collected elements
        sort(elements.begin(), elements.end());

        // Return the middle element (median)
        int n = elements.size();
        return elements[n / 2];
    }
};

int main() {
    Solution obj;

    // Define the matrix
    vector<vector<int>> matrix = {
        {1, 3, 5},
        {2, 6, 9},
        {3, 6, 9}
    };

    // Print the median
    cout << obj.findMedian(matrix) << endl;

    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(M*N * log(M*N))`. Storing elements in a linear array takes `O(M*N)` time, and sorting that array takes `O(M*N * log(M*N))`.
-   **Space Complexity:** `O(M*N)`, to create the linear array.

---

## Optimal Approach

### Algorithm:

In a row-wise sorted matrix, each row is individually sorted, but the entire matrix isn’t globally sorted. Hence, we can’t just pick the middle element directly to get the median. If we flatten and sort the entire matrix, it would take `O(N*M * log(N*M))` time, which is inefficient. Instead, we can take advantage of the sorted rows and apply a more optimized method using **binary search on the value space** (i.e., the range of possible numbers in the matrix).

We start by finding the minimum and maximum elements in the matrix. The smallest element will be in the first column, and the largest element will be in the last column. We then binary search within this range to find the median value.

In each iteration of the binary search, we choose a middle value and count how many elements in the matrix are less than or equal to it. Since each row is sorted, we can do this efficiently using binary search (**upper bound**) on each row.

-   If the count is less than or equal to half of the total number of elements, we move our search range to the **right**.
-   Otherwise, we move it to the **left**.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to count elements less than or equal to mid in a row
    int countLessEqual(vector<int>& row, int mid) {
        // Using upper_bound to find count efficiently
        return upper_bound(row.begin(), row.end(), mid) - row.begin();
    }

    // Function to find median
    int findMedian(vector<vector<int>>& matrix) {
        // Number of rows and columns
        int rows = matrix.size();
        int cols = matrix[0].size();

        // Minimum possible element in matrix
        int low = matrix[0][0];

        // Maximum possible element in matrix
        int high = matrix[0][cols - 1];
        for (int i = 1; i < rows; i++) {
            low = min(low, matrix[i][0]);
            high = max(high, matrix[i][cols - 1]);
        }

        // Binary search over the value range
        while (low < high) {
            int mid = (low + high) / 2;

            // Count elements ≤ mid
            int count = 0;
            for (int i = 0; i < rows; i++) {
                count += countLessEqual(matrix[i], mid);
            }

            // If count is less than half, median is greater
            if (count < (rows * cols + 1) / 2)
                low = mid + 1;
            else
                high = mid;
        }

        // Final low is the median
        return low;
    }
};

int main() {
    Solution obj;
    vector<vector<int>> matrix = {
        {1, 3, 5},
        {2, 6, 9},
        {3, 6, 9}
    };
    cout << "Median: " << obj.findMedian(matrix) << endl;
    return 0;
}
```
### Complexity Analysis:

-   **Time Complexity:** `O(rows * log(cols) * log(max - min))`
    -   The main binary search runs on the value space from the `min` to `max` element of the matrix, which takes `O(log(max - min))` iterations.
    -   Inside each iteration, we count how many numbers are less than or equal to the `mid` value. To do this, we iterate through all `rows`.
    -   For each row, we use another binary search (`upper_bound`) to find this count in `O(log(cols))` time.
-   **Space Complexity:** `O(1)`, as constant extra space is used.


### Dry Run:

```
5x5 Matrix:
[
  [11,  22,  33,  44,  55],
  [23,  34,  45,  56,  67],
  [100, 200, 300, 400, 500],
  [1,   2,   3,   4,   5],
  [10,  20,  30,  40,  50]
]

Median Position = 13th in 1-based indexing, so there should be 12 values will comes before this.   
**Note:** If more than or equal to 13 are coming, we have to discard the right half and search in the left half.  
          Otherwise, we have to discard the left half and search in the right half.
```

| Iteration | `low` | `high` | `mid` | Elements `<= mid` (by row) | Total Count | Condition (`count >= 13`) | Action (Next `low`, `high`) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| Initial | 1 | 500 | - | - | - | - | `[1, 500]` |
| **1** | 1 | 500 | **250** | `5 + 5 + 2 + 5 + 5` | **22** | **True** (`22 >= 13`) | `mid` is a possible answer. Search left. `high = 249` |
| **2** | 1 | 249 | **125** | `5 + 5 + 1 + 5 + 5` | **21** | **True** (`21 >= 13`) | `mid` is a possible answer. Search left. `high = 124` |
| **3** | 1 | 124 | **62** | `5 + 4 + 0 + 5 + 5` | **19** | **True** (`19 >= 13`) | `mid` is a possible answer. Search left. `high = 61` |
| **4** | 1 | 61 | **31** | `2 + 1 + 0 + 5 + 3` | **11** | **False** (`11 < 13`) | `mid` is too small. Search right. `low = 32` |
| **5** | 32 | 61 | **46** | `4 + 3 + 0 + 5 + 4` | **16** | **True** (`16 >= 13`) | `mid` is a possible answer. Search left. `high = 45` |
| **6** | 32 | 45 | **38** | `3 + 2 + 0 + 5 + 3` | **13** | **True** (`13 >= 13`) | `mid` is a possible answer. Search left. `high = 37` |
| **7** | 32 | 37 | **34** | `3 + 2 + 0 + 5 + 3` | **13** | **True** (`13 >= 13`) | `mid` is a possible answer. Search left. `high = 33` |
| **8** | 32 | 33 | **32** | `2 + 1 + 0 + 5 + 3` | **11** | **False** (`11 < 13`) | `mid` is too small. Search right. `low = 33` |
| **9** | 33 | 33 | **33** | `3 + 1 + 0 + 5 + 3` | **12** | **False** (`12 < 13`) | `mid` is too small. Search right. `low = 34` |
