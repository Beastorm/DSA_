## Find Peak Element (2D Matrix)

**Problem Statement:**  
Given a 0-indexed `n x m` matrix `mat` where no two adjacent cells are equal, find any peak element `mat[i][j]` and return the array `[i, j]`. A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbours to the left, right, top, and bottom.

Assume that the entire matrix is surrounded by an outer perimeter with the value `-1` in each cell.

> **Note:** As there can be many peak values, `1` is given as output if the returned index is a peak number, otherwise `0`.

---

>### Examples:

#### Example 1:

-   **Input:**
    ```
    mat = [[5, 10, 8], 
           [4, 25, 7], 
           [3, 9, 6]]
    ```
-   **Output:** `[1, 1]`
-   **Explanation:** The value at index `[1, 1]` is 25, which is a peak because all its neighbors (10, 7, 4, 9) are smaller.

#### Example 2:

-   **Input:**
    ```
    mat = [[1, 2, 3], 
           [6, 5, 4], 
           [7, 8, 9]]
    ```
-   **Output:** `[2, 2]`
-   **Explanation:** The value at index `[2, 2]` is 9, which is a peak as it is greater than its neighbors (8, 4).

---

## Brute Force Approach

### Intuition:

The most straightforward way to find a peak is to check every single cell in the matrix. For each cell, we can verify if it satisfies the definition of a peak element by comparing it to all its adjacent neighbors.

The definition of a peak at `mat[i][j]` is that it must be strictly greater than its neighbors:
-   `mat[i-1][j]` (top)
-   `mat[i+1][j]` (bottom)
-   `mat[i][j-1]` (left)
-   `mat[i][j+1]` (right)

The first cell we find that meets this condition is a valid answer, and we can immediately return its coordinates.

### Algorithm:

1.  Use nested loops to iterate through each cell `mat[i][j]` of the matrix, where `i` is the row index and `j` is the column index.
2.  For each cell, get the values of its four neighbors: top, bottom, left, and right.
3.  We must handle the boundary conditions for cells on the edges and corners. The problem statement simplifies this by assuming the matrix is surrounded by `-1`. So:
    -   If a neighbor is outside the matrix bounds, its value is considered `-1`.
    -   For any positive number in the matrix, it will always be greater than this imaginary `-1`.
4.  Compare `mat[i][j]` with the values of its four neighbors.
5.  If `mat[i][j]` is strictly greater than all of them, we have found a peak. Return the coordinates `[i, j]`.
6.  Since the problem guarantees that a peak always exists, the loops will always find a peak and return before completion.

``` cpp
#include <iostream>
#include <vector>
#include <algorithm> // For std::max_element

// Helper function to print a vector
void printVector(const std::vector<int>& vec) {
    if (vec.empty() || vec[0] == -1) {
        std::cout << "[-1, -1]" << std::endl;
    } else {
        std::cout << "[" << vec[0] << ", " << vec[1] << "]" << std::endl;
    }
}

class Solution {
public:
    /**
     * @brief Brute-force approach to find a peak in a 2D matrix.
     * Iterates through every cell and checks its neighbors.
     * Time Complexity: O(N * M)
     * Space Complexity: O(1)
     */
    std::vector<int> findPeakGrid_BruteForce(const std::vector<std::vector<int>>& mat) {
        int n = mat.size();
        if (n == 0) return {-1, -1};
        int m = mat[0].size();

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                int currentVal = mat[i][j];

                // Get neighbor values, assuming -1 for out-of-bounds
                int top = (i > 0) ? mat[i - 1][j] : -1;
                int bottom = (i < n - 1) ? mat[i + 1][j] : -1;
                int left = (j > 0) ? mat[i][j - 1] : -1;
                int right = (j < m - 1) ? mat[i][j + 1] : -1;

                // Check if current element is a peak
                if (currentVal > top && currentVal > bottom && currentVal > left && currentVal > right) {
                    return {i, j};
                }
            }
        }
        // Should be unreachable as a peak is guaranteed to exist
        return {-1, -1};
    }
};

// Main function for brute-force demonstration
int main_brute() {
    Solution solver;
    std::vector<std::vector<int>> mat1 = {{5, 10, 8}, {4, 25, 7}, {3, 9, 6}};
    std::vector<std::vector<int>> mat2 = {{1, 2, 3}, {6, 5, 4}, {7, 8, 9}};

    std::cout << "--- Brute-Force Approach ---" << std::endl;
    std::cout << "Example 1 Peak: ";
    printVector(solver.findPeakGrid_BruteForce(mat1)); // Expected: [1, 1]

    std::cout << "Example 2 Peak: ";
    printVector(solver.findPeakGrid_BruteForce(mat2)); // Expected: [2, 2]
    
    return 0;
}
```

### Complexity Analysis

-   **Time Complexity:** `O(N * M)`, where `N` is the number of rows and `M` is the number of columns. In the worst case, we might have to visit every cell to find a peak.
-   **Space Complexity:** `O(1)`, as no additional space is used beyond a few variables to store neighbor values.

---
## Optimized Approach

### Algorithm:

To solve this problem, we use the binary search approach.

The key idea comes from how we find a peak in a 1-D array:

-   For any middle position (`mid`), we check if it’s larger than both its neighbors; if it is, we’ve found a peak.
-   If `mid` is smaller than the element on its left, that means a peak must be somewhere to the left, so we can discard the right half.
-   If `mid` is smaller than the element on its right, then a peak must lie to the right, allowing us to discard the left half.

This method reduces the number of elements we need to consider in every step, improving efficiency.

**For a 2-D array:**

1.  The search will cover the column range from `0` to `col-1`, where `col` is the total number of columns.
2.  We choose a middle column and identify the row with the largest element in that column.
3.  We apply similar logic as in 1-D: if this element is bigger than both its side neighbors, we’ve found the peak.
4.  If the left neighbor is bigger, we only search the left part; if the right neighbor is bigger, we search the right part.


#### Why Pick the Max?
Choosing the maximum element in the middle column gives us a critical guarantee:  
That element is already greater than its top and bottom neighbors.  
This instantly simplifies the problem. We no longer have to worry about moving up or down. Our decision is reduced to a simple 1D check on its left and right neighbors.  
If the element is also greater than its left and right neighbors, we've found a 2D peak.  
If a side neighbor is larger (e.g., the right one), it gives us a clear "uphill" direction. A peak is guaranteed to exist in that half of the matrix.  
This guarantee allows us to confidently eliminate half the matrix in every step, which is the fundamental requirement for binary search to work.  


``` cpp
#include <bits/stdc++.h>
using namespace std;
  
  class Solution {
  public:
      // Function to find the index of the row 
      // with the maximum element in a given column
      int maxElement(vector<vector<int>>& arr, int col) {
          int n = arr.size();
          int max_val = INT_MIN;
          int index = -1;
  
          // Iterate through each row to find the maximum element 
          // in the particular column
          for (int i = 0; i < n; i++) {
              if (arr[i][col] > max_val) {
                  max_val = arr[i][col];
                  index = i;
              }
          }
          return index;
      }
  
      // Function to find a peak element in the 2D matrix 
      // using binary search
      vector<int> findPeakGrid(vector<vector<int>>& arr) {
          int n = arr.size();     
          int m = arr[0].size();  
  
          // Initialize the lower and upper bounds for binary search
          int low = 0;           
          int high = m - 1;      
  
          // Perform binary search on columns
          while (low <= high) {
              int mid = (low + high) / 2;
  
              // Find the index of the row with the maximum element 
              // in the middle column
              int row = maxElement(arr, mid);
  
              // Determine the elements to the left and right of 
              // the middle element in the found row
              int left = mid - 1 >= 0 ? arr[row][mid - 1] : INT_MIN;
              int right = mid + 1 < m ? arr[row][mid + 1] : INT_MIN;
  
              // Check if the middle element is greater than its neighbors
              if (arr[row][mid] > left && arr[row][mid] > right) {
                  return {row, mid};
              } 
              else if (left > arr[row][mid]) {
                  high = mid - 1;
              } 
              else {
                  low = mid + 1;
              }
          }
  
          // Return {-1, -1} if no peak element is found
          return {-1, -1};
      }
  };
  
  int main() {
      // Example usage
      vector<vector<int>> mat = {
          {4, 2, 5, 1, 4, 5},
          {2, 9, 3, 2, 3, 2},
          {1, 7, 6, 0, 1, 3},
          {3, 6, 2, 3, 7, 2}
      };
  
      // Create an instance of the Solution class
      Solution sol;
  
      // Call the findPeakGrid function and print the result
      vector<int> peak = sol.findPeakGrid(mat);
      cout << "The row of peak element is " << peak[0]
           << " and column of the peak element is " << peak[1] << endl;
  
      return 0;
  }
  ```
  ### Complexity Analysis:

-   **Time Complexity:** `O(N * logM)`, where `N` is the number of rows in the matrix and `M` is the number of columns. The complexity arises because binary search is performed on the columns, and for each `mid` column, a linear search through the `N` rows is executed to find the maximum element.
-   **Space Complexity:** `O(1)` as no additional space is used.
