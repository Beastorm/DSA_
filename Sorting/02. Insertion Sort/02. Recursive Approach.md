## Insertion Sort Recursive Approach:

### Intuition (Recursive Insertion Sort)
Insertion sort keeps the left part of the array sorted and inserts the next element into its correct position.

In recursion, we do the same idea but in a top-down way:
- First, recursively sort the first `n-1` elements.
- Then take the last element (the `n`th element) and **insert** it into the correct position in that already-sorted prefix.

So each recursive call solves a smaller problem, and the insertion step fixes the last element.

### Algorithm Steps
1. **Base case:** If `n <= 1`, the array is already sorted → return.
2. Recursively sort the subarray `nums[0 .. n-2]` by calling `insertionSortRec(nums, n-1)`.
3. Now `nums[0 .. n-2]` is sorted. Insert `nums[n-1]` into the correct position:
   - Store `key = nums[n-1]`
   - Move left from index `j = n-2` while `nums[j] > key`:
     - shift `nums[j]` to `nums[j+1]`
   - Place `key` at `nums[j+1]`
4. After insertion, `nums[0 .. n-1]` becomes sorted.
5. Return to previous calls until the full array is sorted.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Insert nums[i] into the sorted part nums[0..i-1]
    void insertAtCorrectPos(vector<int>& nums, int i) {
        int key = nums[i];
        int j = i - 1;

        while (j >= 0 && nums[j] > key) {
            nums[j + 1] = nums[j];
            j--;
        }
        nums[j + 1] = key;
    }

    // Recursive insertion sort: sorts nums[0..n-1]
    void insertionSortRec(vector<int>& nums, int n) {
        // Base case: 0 or 1 element is already sorted
        if (n <= 1) return;

        // Sort first n-1 elements
        insertionSortRec(nums, n - 1);

        // Insert the last element into its correct position in the sorted prefix
        insertAtCorrectPos(nums, n - 1);
    }
};

int main() {
    Solution solution;

    vector<int> nums = {13, 46, 24, 52, 20, 9};

    cout << "Before Using Recursive Insertion Sort:\n";
    for (int x : nums) cout << x << " ";
    cout << "\n";

    solution.insertionSortRec(nums, (int)nums.size());

    cout << "After Using Recursive Insertion Sort:\n";
    for (int x : nums) cout << x << " ";
    cout << "\n";

    return 0;
}
```
## Complexity Analysis (Recursive Insertion Sort)

Recursive insertion sort performs the same comparisons/shifts as iterative insertion sort.
Recursion only changes *how* it is written, not the total work.

Let `n` be the number of elements.

---

### 1) Best Case — Already Sorted
**Example:** `[1, 2, 3, 4, 5]`

- In every insertion step, the last element is already in the correct position.
- The inner shifting loop does **0 shifts** each time.

**Time:** `O(n)`  
- Comparisons: about `n-1`
- Shifts: `0`

---

### 2) Worst Case — Reverse Sorted
**Example:** `[5, 4, 3, 2, 1]`

- Every new element must be inserted at the beginning.
- For size `k`, insertion shifts `k-1` elements.

Total shifts/comparisons:
\[
1 + 2 + 3 + \dots + (n-1) = \frac{n(n-1)}{2}
\]

**Time:** `O(n^2)`  
- Comparisons: `n(n-1)/2`
- Shifts: `n(n-1)/2`

---

### 3) Average Case — Random Order
**Example:** `[13, 46, 24, 52, 20, 9]`

- On average, each element moves about halfway back into the sorted prefix.
- Expected total work is still proportional to `n^2`.

**Time:** `O(n^2)` (average)

---

## Space Complexity (Important Difference Because of Recursion)
- Iterative insertion sort: `O(1)` extra space.
- Recursive insertion sort: uses a recursion call stack of depth `n`.

**Space:** `O(n)` (due to recursion stack)

---

## Summary Table

| Case    | Example            | Time     |
|---------|---------------------|----------|
| Best    | `[1,2,3,4,5]`       | `O(n)`   |
| Average | random order        | `O(n^2)` |
| Worst   | `[5,4,3,2,1]`       | `O(n^2)` |

Extra space: `O(n)` (recursion stack).
