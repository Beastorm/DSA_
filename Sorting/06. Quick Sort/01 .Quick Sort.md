## Quick Sort

### Intuition (Quick Sort)
Quick sort works on **divide and conquer**:
- Pick one element as a **pivot**.
- Rearrange the array so:
  - all elements `<= pivot` come to the **left**
  - all elements `> pivot` come to the **right**
- Now the pivot is in its **final correct position**.
- Recursively apply the same process to the left and right parts.

In your code, the **last element** is chosen as the pivot (`arr[end]`).

### Algorithm Steps (as per your code)

**A) `partition(arr, start, end)`** 
1. Choose pivot as `arr[end]`.
2. Set `pos = start` (this marks where the next `<= pivot` element should go).
3. Traverse `i` from `start` to `end`:
   - If `arr[i] <= pivot`:
     - swap `arr[pos]` and `arr[i]`
     - increment `pos`
4. After the loop, pivot will be placed at index `pos - 1`.
5. Return `pos - 1` as the pivot’s final position.

**B) `QuickSort(arr, start, end)`** 
1. Base case: if `start >= end`, return (0 or 1 element is already sorted).
2. Find pivot position using `partition`.
3. Recursively sort left part: `QuickSort(arr, start, pivot-1)`.
4. Recursively sort right part: `QuickSort(arr, pivot+1, end)`.

**Key Point:**  
After each `partition`, the pivot is **fixed** in its correct sorted location, and we only sort the remaining two sides.

``` cpp
// Quick sort for ascending order
#include <iostream>
#include <vector>
using namespace std;
// `pos` will help to put less value than pivot, and `i` will keep moving to the other remaining elements.
int partition(vector<int> &arr, int start, int end)
{
    int pos = start;
    for (int i = start; i <= end; i++)
    {
        if (arr[i] <= arr[end])
            swap(arr[pos++], arr[i]);
    }
    return pos - 1; // position of pivot element after sorting
}
void QuickSort(vector<int> &arr, int start, int end)
{
    if (start >= end)
        return;
    int pivot = partition(arr, start, end);
    QuickSort(arr, start, pivot - 1);
    QuickSort(arr, pivot + 1, end);
}

int main()
{
    vector<int> arr = {12, 11, 10, 9, 7, 5, 4, 2, 0};
    QuickSort(arr, 0, arr.size() - 1);
    for (int i = 0; i < arr.size(); i++)
        cout << arr[i] << " " << std::endl;
}
```

## Complexity Analysis (Quick Sort with last element as pivot)

Let `n` be the number of elements.

### Partition Cost
In every call, `partition()` scans the current subarray once.
So partition takes **O(k)** time for a subarray of size `k`.

The total time depends on how balanced the pivot split is.

---

## 1) Best Case (Balanced partitions)
**Example:** pivot always splits array into two equal halves  
Example input where this tends to happen: `[4, 2, 6, 1, 3, 5, 7]` (pivot ends near middle often)

Recurrence:
\[
T(n) = 2T(n/2) + O(n)
\]
Solution:
\[
T(n) = O(n \log n)
\]

**Best case time = O(n log n)**

---

## 2) Average Case (Random order)
**Example:** `[13, 46, 24, 52, 20, 9]`

On average, the pivot splits reasonably (not always perfect, not always terrible).

Expected:
**Average time = O(n log n)**

---

## 3) Worst Case (Highly unbalanced partitions)
With **last element as pivot**, the worst case happens when the array is already sorted (ascending or descending), because the pivot ends up at an extreme end each time.

### Worst-case examples
- Ascending: `[0, 1, 2, 3, 4, 5]`  
  Pivot = last = largest → left side has `n-1`, right side has `0`
- Descending: `[5, 4, 3, 2, 1, 0]`  
  Pivot = last = smallest → left side has `0`, right side has `n-1`

Recurrence:
\[
T(n) = T(n-1) + O(n)
\]
Solution:
\[
T(n) = O(n^2)
\]

**Worst case time = O(n^2)**

---

## Space Complexity (Recursion stack)
- Best/Average (balanced): recursion depth ≈ `log n`  
  **Space = O(log n)**
- Worst (unbalanced): recursion depth ≈ `n`  
  **Space = O(n)**

---

## Summary Table

| Case    | Example input              | Time          | Stack Space |
|---------|----------------------------|---------------|------------|
| Best    | balanced splits            | `O(n log n)`  | `O(log n)` |
| Average | random order               | `O(n log n)`  | `O(log n)` |
| Worst   | sorted / reverse-sorted    | `O(n^2)`      | `O(n)`     |
