## Radix Sort

### Intuition (Radix Sort)
Radix sort sorts numbers **digit by digit** instead of comparing whole numbers.

- First, sort all numbers by the **ones** digit.
- Then sort by the **tens** digit.
- Then by the **hundreds** digit, and so on…
- If each digit-sort is **stable** (keeps the relative order of equal digits), the final result becomes fully sorted.

In this code, each digit pass uses **Counting Sort** (base 10) because digits are in the range `0..9`.

### Algorithm Steps

**A) `countingsort(array, size, place)`**  (sort by one digit)  
1. Create `output[size]` and `tempcount[10] = {0}`.
2. For each number `array[i]`:
   - Extract the digit at `place`:
     - `digit = (array[i] / place) % 10`
   - Increment `tempcount[digit]`.
3. Convert `tempcount` into cumulative counts:
   - `tempcount[d]` becomes the ending position index (1-based) for digit `d` in `output`.
4. Build `output` from right to left (to keep it **stable**):
   - Put each number into its correct position based on its digit.
5. Copy `output` back into `array`.

**B) `radixsort(array, size)`**  (digit-by-digit sorting)  
1. Find the maximum value `maxVal` in the array.
2. For `place = 1, 10, 100, ...` while `maxVal / place > 0`:
   - Call `countingsort(array, size, place)` to sort by that digit.
3. After the last digit pass, the array is fully sorted.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class RadixSort
{
public:
    void countingsort(vector<int> &array, int size, int place)
    {
        vector<int> output(size);
        int tempcount[10] = {0};

        // count occurrences of digits
        for (int i = 0; i < size; i++)
            tempcount[(array[i] / place) % 10]++;

        // cumulative sum
        for (int i = 1; i < 10; i++)
            tempcount[i] = tempcount[i] + tempcount[i - 1];

        // place elements into output (stable sort)
        for (int i = size - 1; i >= 0; i--)
        {
            int digit = (array[i] / place) % 10;
            output[tempcount[digit] - 1] = array[i];
            tempcount[digit]--;
        }

        // copy back to array
        for (int i = 0; i < size; i++)
            array[i] = output[i];
    }

    void radixsort(vector<int> &array, int size)
    {
        // find max
        int maxVal = array[0];
        for (int i = 1; i < size; i++)
            if (array[i] > maxVal)
                maxVal = array[i];

        // sorting digit by digit
        for (int place = 1; maxVal / place > 0; place *= 10)
            countingsort(array, size, place);
    }
};

int main()
{
    vector<int> data = {122, 431, 565, 22, 1, 47, 787};
    int size = data.size();

    cout << "Before sorting:\n";
    for (int x : data)
        cout << x << " ";
    cout << endl;

    RadixSort rs;
    rs.radixsort(data, size);

    cout << "After sorting:\n";
    for (int x : data)
        cout << x << " ";
    cout << endl;

    return 0;
}
```
## Complexity Analysis (Radix Sort + Counting Sort, base 10)

Let:
- `n` = number of elements
- `d` = number of digits in the maximum element (e.g., max = 787 ⇒ `d = 3`)
- `k` = base (here `k = 10` because digits are `0..9`)

---

## Time Complexity

### Work in one digit pass (Counting Sort)
For a fixed `place`:
1. Count digits over all elements: `O(n)`
2. Prefix sum over 10 digits: `O(k)` = `O(10)` = constant
3. Build output (stable) over all elements: `O(n)`
4. Copy back to array: `O(n)`

So one pass = `O(n + k)`.

### Total work (Radix Sort)
We do this for `d` digit positions:

\[
T(n) = d \cdot O(n + k)
\]

With base 10 (`k=10` constant):

\[
T(n) = O(d \cdot n)
\]

---

## Best / Average / Worst Cases (Radix Sort)
Unlike comparison sorts, radix sort time is mostly determined by:
- how many digits `d` you process,
- and how many numbers `n` you have,
not by whether the array is already sorted.

So **best, average, and worst are the same** (for fixed `d` and base).

### Example (same time behavior)
- Best-case-looking input (already sorted): `[1, 22, 47, 122, 431, 565, 787]`
- Random input: `[122, 431, 565, 22, 1, 47, 787]`
- Reverse input: `[787, 565, 431, 122, 47, 22, 1]`

All still require:
- `d` passes (here `d = 3`: ones, tens, hundreds)
- scanning all `n` elements each pass

So in all cases:

**Time = O(d · (n + 10)) = O(d · n)**

> If numbers are bounded (e.g., all < 1,000,000), then `d` is a small constant and it behaves almost like **O(n)**.

---

## Space Complexity
Per pass:
- `output[n]` → `O(n)`
- `tempcount[10]` → `O(1)`

Total extra space:

**Space = O(n)**

---

## Summary Table

| Case    | Example Input                         | Passes `d` | Time          | Space |
|---------|----------------------------------------|-----------:|---------------|-------|
| Best    | `[1, 22, 47, 122, 431, 565, 787]`      | 3          | `O(d·n)`      | `O(n)`|
| Average | `[122, 431, 565, 22, 1, 47, 787]`      | 3          | `O(d·n)`      | `O(n)`|
| Worst   | `[787, 565, 431, 122, 47, 22, 1]`      | 3          | `O(d·n)`      | `O(n)`|
