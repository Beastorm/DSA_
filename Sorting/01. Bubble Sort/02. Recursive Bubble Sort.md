## Recursive Bubble Sort

### Intuition (Recursive Bubble Sort)
Bubble sort repeatedly does a **pass** over the array:
- compare adjacent elements
- swap if they are in the wrong order  
This moves the **largest element** of the current range to the **end** (it “bubbles up”).

In recursion:
- one recursive function performs **one full pass** (like the inner loop)
- another recursive call reduces the problem size from `n` to `n-1` (like the outer loop), because the last element is now fixed.

### Algorithm Steps
**A) Recursive pass (like inner loop)**  
1. Start at index `j = 0`.
2. Compare `arr[j]` and `arr[j+1]`:
   - if `arr[j] > arr[j+1]`, swap them and mark `swapped = true`.
3. Recurse for `j+1`.
4. Stop when `j == n-1` (pass finished).  
After this pass, the largest element in `arr[0..n-1]` is at `arr[n-1]`.

**B) Recursive sort (like outer loop)**  
1. Base case: if `n <= 1`, return.
2. Run one recursive pass on the first `n` elements.
3. If no swaps happened, the array is already sorted → return early.
4. Otherwise, recurse on the first `n-1` elements (since `arr[n-1]` is fixed).

``` cpp
#include <bits/stdc++.h>
using namespace std;

// One pass (bubble the largest element of [0..n-1] to the end)
static void bubblePass(vector<int>& a, int n, int j, bool& swapped) {
    if (j == n - 1) return;                 // finished this pass
    if (a[j] > a[j + 1]) {
        swap(a[j], a[j + 1]);
        swapped = true;
    }
    bubblePass(a, n, j + 1, swapped);       // next adjacent pair
}

// Recursive Bubble Sort
static void bubbleSortRec(vector<int>& a, int n) {
    if (n <= 1) return;                     // base: already sorted
    bool swapped = false;

    bubblePass(a, n, 0, swapped);           // do one full pass

    if (!swapped) return;                   // optimization: already sorted
    bubbleSortRec(a, n - 1);                // largest is fixed at end, sort remaining
}

int main() {
    vector<int> arr = {5, 1, 4, 2, 8};

    cout << "Before Sorting: ";
    for (int x : arr) cout << x << " ";
    cout << "\n";

    bubbleSortRec(arr, (int)arr.size());

    cout << "After Sorting:  ";
    for (int x : arr) cout << x << " ";
    cout << "\n";

    return 0;
}
```
## Complexity Analysis (Recursive Bubble Sort)

Let `n` be the number of elements.

**Time Complexity:**
Bubble sort logic is the same whether iterative or recursive.

- Pass 1 does `(n-1)` comparisons  
- Pass 2 does `(n-2)` comparisons  
- ...
- Pass (n-1) does `1` comparison  

Total comparisons:
\[
(n-1) + (n-2) + \dots + 1 = \frac{n(n-1)}{2}
\]

So:
- **Worst case:** `O(n^2)` (example: `[5,4,3,2,1]`, swaps happen everywhere)
- **Average case:** `O(n^2)` (random order)
- **Best case (with swapped optimization):** `O(n)`  
  Example: `[1,2,3,4,5]` → first pass makes 0 swaps, stop.

**Space Complexity:**
- Iterative bubble sort uses `O(1)` extra space.
- Recursive version uses a recursion stack:
  - `bubbleSortRec` depth up to `n`
  - `bubblePass` depth up to `n` during a pass

At any moment, the maximum call stack depth is `O(n)`, so:

**Space = O(n)** (due to recursion stack)
