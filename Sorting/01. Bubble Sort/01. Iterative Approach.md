## Bubble Sort(Iterative Approach):

### Intuition:
Bubble Sort works like **bubbles rising to the top**:
- We repeatedly compare **adjacent** elements.
- If two adjacent elements are in the wrong order, we **swap** them.
- After one full pass, the **largest** element "bubbles up" to the **end** of the array.

The `swapped` flag is an optimization:
- If in any pass we do **no swaps**, the array is already sorted, so we stop early.

### Algorithm Steps:
1. Do `n-1` passes (for `i = 0` to `n-2`):
2. Set `swapped = false`.
3. Traverse the unsorted part (for `j = 0` to `n-i-2`):
   - If `arr[j] > arr[j+1]`:
     - swap them
     - set `swapped = true`
4. After each pass, the largest element of the remaining unsorted part is placed at index `n-i-1`.
5. If `swapped == false` after a pass, break (already sorted).
6. The array is sorted.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Bubble Sort Function
void bubbleSort(vector<int> &arr, int n)
{
    bool swapped;

    // n-1 passes
    for (int i = 0; i < n - 1; i++)
    {
        swapped = false;

        // After every pass, the largest element settles at the end
        for (int j = 0; j < n - i - 1; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }

        // If no swap → array is already sorted → break early
        if (!swapped)
            break;
    }
}

int main()
{
    vector<int> arr = {5, 1, 4, 2, 8};
    int n = arr.size();

    cout << "Before Sorting: ";
    for (int x : arr)
        cout << x << " ";
    cout << endl;

    bubbleSort(arr, n);

    cout << "After Sorting:  ";
    for (int x : arr)
        cout << x << " ";
    cout << endl;

    return 0;
}
```

## Complexity Analysis (Bubble Sort with `swapped` optimization)

Let `n` be the number of elements.

### 1) Best Case
**Case:** Array is already sorted (or becomes sorted early).  
Example: `[1, 2, 3, 4, 5]`

- Pass 1:
  - Compare adjacent pairs (`n-1` comparisons)
  - No swaps happen → `swapped = false` → break immediately

**Time: `O(n)`** (only one pass worth of comparisons)  
**Comparisons:** `n-1`  
**Swaps:** `0`  
**Space:** `O(1)`

---

### 2) Worst Case
**Case:** Array is sorted in reverse order.  
Example: `[5, 4, 3, 2, 1]`

- Every comparison causes a swap.
- No early stopping; all passes run.

Total comparisons:
\[
(n-1) + (n-2) + ... + 1 = \frac{n(n-1)}{2}
\]

**Time: `O(n^2)`**  
**Comparisons:** `n(n-1)/2`  
**Swaps:** `n(n-1)/2`  
**Space:** `O(1)`

---

### 3) Average Case
**Case:** Random order.  
Example: `[3, 1, 4, 2, 5]`

- Usually, many passes are needed.
- Early stopping may or may not trigger, but the average behavior is still quadratic.

Expected comparisons are still on the order of:
\[
\frac{n(n-1)}{2}
\]

**Time: `O(n^2)`**  
**Space:** `O(1)`

---

## Summary Table

| Case        | Example            | Time     | Comparisons                | Swaps                     | Space |
|-------------|--------------------|----------|----------------------------|---------------------------|-------|
| Best        | `[1,2,3,4,5]`      | `O(n)`   | `n-1`                      | `0`                       | `O(1)`|
| Average     | `[3,1,4,2,5]`      | `O(n^2)` | about `n(n-1)/2`           | depends (often many)      | `O(1)`|
| Worst       | `[5,4,3,2,1]`      | `O(n^2)` | `n(n-1)/2`                 | `n(n-1)/2`                | `O(1)`|
