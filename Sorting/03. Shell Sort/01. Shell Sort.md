## Shell Sort

### Intuition (Shell Sort)
Insertion sort is fast when elements are already close to their correct positions, but slow when elements must move far.

Shell sort improves this by:
- first sorting elements that are **far apart** (using a gap/interval),
- which quickly moves elements closer to their correct place,
- then gradually reducing the gap until it becomes `1`, where it finishes with a normal insertion sort on an almost-sorted array.

So it’s like doing “rough sorting” first, then “fine sorting”.

### Algorithm Steps
1. Choose an initial gap `interval = n/2`.
2. While `interval > 0`:
   1. For each index `i` from `interval` to `n-1`:
      - Store `temp = arr[i]`
      - Set `j = i`
      - Shift elements that are `interval` positions behind:
        - While `j >= interval` and `arr[j - interval] > temp`:
          - move `arr[j - interval]` to `arr[j]`
          - set `j = j - interval`
      - Place `temp` at position `arr[j].`
   2. Reduce the gap: `interval = interval / 2.`
3. When `interval` becomes `1`, the process becomes standard insertion sort, completing the final ordering.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class ShellSort
{
public:
    void shellSort(int arr[], int n)
    {
        // Start with a half gap, then reduce
        for (int interval = n / 2; interval > 0; interval /= 2)
        {

            for (int i = interval; i < n; i++)
            {
                int temp = arr[i];
                int j;

                // Insertion sort with gap = interval
                for (j = i; j >= interval && arr[j - interval] > temp; j -= interval)
                {
                    arr[j] = arr[j - interval];
                }

                arr[j] = temp;
            }
        }
    }
};

int main()
{
    int data[] = {9, 8, 3, 7, 5, 6, 4, 1};
    int n = sizeof(data) / sizeof(data[0]);

    ShellSort ss;

    cout << "Problem Array\n";
    for (int x : data)
        cout << x << " ";
    cout << endl;

    ss.shellSort(data, n);

    cout << "Sorted Array\n";
    for (int x : data)
        cout << x << " ";
    cout << endl;

    return 0;
}
```

## Complexity Analysis (Shell Sort with gap sequence: n/2, n/4, ..., 1)

Shell sort’s time depends heavily on the **gap sequence** and the data order.  
For the common halving gaps used in your code (`n/2` then `/2`), these are the typical results.

---

### Space Complexity
- Uses a constant number of extra variables (`temp`, `j`, `interval`)

**Space = O(1)**

---

## Time Complexity (All Cases)

### 1) Best Case
**Example:** already sorted array  
`[1, 2, 3, 4, 5, 6, 7, 8]`

- For each gap, the inner “gapped insertion sort” finds almost no shifts.
- Still, the algorithm must scan through the array for each gap value.

Number of gaps ≈ `log2(n)` (because we keep halving).

So work ≈ `n` per gap × `log n` gaps:

**Best case time ≈ O(n log n)**

---

### 2) Worst Case
**Example:** reverse sorted array  
`[8, 7, 6, 5, 4, 3, 2, 1]`

- For many gaps, gapped insertion sort can still do lots of shifts.
- With the simple halving gap sequence, the known worst-case bound is quadratic.

**Worst case time = O(n^2)**

---

### 3) Average Case
**Example:** random array  
`[9, 8, 3, 7, 5, 6, 4, 1]`

- Usually much faster than plain insertion sort because early passes move elements closer quickly.
- But with halving gaps, the common practical/expected bound is still around:

**Average case ≈ O(n^2)** (often noticeably faster than insertion sort in practice)

---

## Summary Table

| Case    | Example                     | Time Complexity |
|---------|------------------------------|-----------------|
| Best    | `[1,2,3,4,5,6,7,8]`          | `O(n log n)`    |
| Average | random order                  | ~`O(n^2)`       |
| Worst   | `[8,7,6,5,4,3,2,1]`          | `O(n^2)`        |
| Space   | —                            | `O(1)`          |

> Note: Different gap sequences (like Knuth, Sedgewick) can give better proven average/worst performance than simple halving.
