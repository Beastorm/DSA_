## Bucket Sort

### Intuition (Bucket Sort)
Bucket sort works well when numbers are **uniformly distributed** in a known range (here `[0, 1)`).

Idea:
- Split the range `[0,1)` into `n` equal buckets.
- Put each number into its bucket based on its value.
- Since each bucket contains numbers from a small range, each bucket is small and easy to sort (here using insertion sort).
- Finally, merge buckets in order to get the sorted array.

### Algorithm Steps
1. If `n <= 0`, return.
2. Create `n` empty buckets: `buckets[0..n-1]`.
3. Distribute elements into buckets:
   - For each `arr[i]`, compute bucket index:
     - `bucketIdx = arr[i] * n`
   - Insert `arr[i]` into `buckets[bucketIdx]`.
4. Sort each bucket individually (using insertion sort in this code).
5. Merge buckets back into `arr` in order from bucket `0` to bucket `n-1`.
6. The array becomes sorted.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Insertion Sort for individual buckets
void insertionSort(vector<float> &bucket)
{
    for (int i = 1; i < bucket.size(); i++)
    {
        float key = bucket[i];
        int j = i - 1;

        while (j >= 0 && bucket[j] > key)
        {
            bucket[j + 1] = bucket[j];
            j--;
        }
        bucket[j + 1] = key;
    }
}

void bucketSort(float arr[], int n)
{
    if (n <= 0)
        return;

    // Step 1: Create buckets
    vector<float> buckets[n];

    // Step 2: Insert elements into buckets
    for (int i = 0; i < n; i++)
    {
        int bucketIdx = arr[i] * n; // value in range [0,1)
        buckets[bucketIdx].push_back(arr[i]);
    }

    // Step 3: Sort each bucket using insertion sort
    for (int i = 0; i < n; i++)
    {
        insertionSort(buckets[i]);
    }

    // Step 4: Merge all buckets back into arr
    int index = 0;
    for (int i = 0; i < n; i++)
    {
        for (float val : buckets[i])
        {
            arr[index++] = val;
        }
    }
}

int main()
{
    float arr[] = {0.43, 0.32, 0.23, 0.52, 0.25, 0.73, 0.51};
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Original: ";
    for (float x : arr)
        cout << x << " ";
    cout << endl;

    bucketSort(arr, n);

    cout << "Sorted:   ";
    for (float x : arr)
        cout << x << " ";
    cout << endl;

    return 0;
}

```

## Complexity Analysis (Bucket Sort + Insertion Sort inside buckets)

Let:
- `n` = number of elements
- We create `n` buckets
- Values are assumed in `[0, 1)` (so `bucketIdx = arr[i] * n` works)

---

## Space Complexity
- Buckets store all `n` elements in total: `O(n)`
- Extra variables are constant

**Space = O(n)**

---

## Time Complexity (All Cases)

Bucket sort has 3 main costs:
1. **Distribute into buckets:** `O(n)` (one bucket push per element)
2. **Sort each bucket:** depends on bucket sizes
3. **Merge buckets back:** `O(n)`

Let bucket sizes be `b1, b2, ..., bn` where `b1 + b2 + ... + bn = n`.

Insertion sort cost for one bucket of size `bi` is:
- Best: `O(bi)` (already sorted inside bucket)
- Worst: `O(bi^2)` (reverse order inside bucket)

- Total sorting cost across buckets:  
  `O(b1^2 + b2^2 + ... + bn^2)`

- Overall time:  
  - distribute into buckets: `O(n)`  
  - sort buckets: `O(b1^2 + b2^2 + ... + bn^2)`  
  - merge buckets back: `O(n)`

- Total:  
  `O(n + (b1^2 + b2^2 + ... + bn^2))`

---

### 1) Best Case
**Scenario:** Elements are evenly spread and each bucket has ≤ 1 element (or each bucket’s content is already sorted).  
**Example:** `n=5`, values like `[0.05, 0.25, 0.45, 0.65, 0.85]`  
Each goes to a different bucket ⇒ all buckets size 0 or 1.

Then:
- Sorting each bucket is trivial
- \(\sum b_i^2 = 1^2 + 1^2 + ... = n\)

**Time = O(n)**

---

### 2) Average Case
**Scenario:** Numbers are **uniformly distributed** in `[0,1)`.  
**Example:** `[0.43, 0.32, 0.23, 0.52, 0.25, 0.73, 0.51]` (roughly spread out)

With uniform distribution and `n` buckets:
- Expected bucket size ≈ 1
- \(\sum b_i^2\) stays linear on average

**Average Time ≈ O(n)**  
(Practically very fast for uniform data.)

---

### 3) Worst Case
**Scenario:** All elements land in the same bucket.  
**Example:** for `n=5`, values like `[0.11, 0.12, 0.13, 0.14, 0.15]`  
All map to `bucketIdx = 0` (since `arr[i]*n` is still < 1).

Then:
- One bucket has size `n`
- Insertion sort on that bucket takes `O(n^2)`
- Other steps are `O(n)`

**Worst Time = O(n^2)**

---

## Summary Table

| Case    | Example distribution | Bucket sizes idea     | Time |
|---------|----------------------|-----------------------|------|
| Best    | spread out           | mostly 0/1 per bucket | `O(n)` |
| Average | uniform in `[0,1)`   | small buckets         | `≈ O(n)` |
| Worst   | all in one bucket    | one bucket size `n`   | `O(n^2)` |

> Note: Bucket sort’s “fast” performance depends on the assumption of reasonably uniform distribution.
