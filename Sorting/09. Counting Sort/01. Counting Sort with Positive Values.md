## Counting Sort with Positive Values

### Intuition (Counting Sort)
Counting sort works when the array values are integers in a **limited range**.

Instead of comparing elements, we:
- count how many times each value appears,
- use prefix sums to know the final positions,
- then place each value directly into the correct position in the output array.

So it “sorts by counting”, not by swapping/comparing.

### Algorithm Steps
1. Find `maxVal` (the maximum element in the input).
2. Create a frequency array `aux` of size `maxVal + 1`, initialized with 0.
3. Count frequencies:
   - For each element `x` in input, do `aux[x]++`.
4. Convert frequency array to prefix sum (cumulative count):
   - For `i = 1..maxVal`, set `aux[i] = aux[i] + aux[i-1]`.
   - Now `aux[v]` tells the **ending position (1-based)** of value `v` in the sorted array.
5. Build the `output` array:
   - For each element `x` in input:
     - place it at index `aux[x] - 1` in `output`
     - decrement `aux[x]` (next same value goes to the previous slot)
6. Copy `output` back to input.
7. Return/print the sorted array.

### Notes: How Prefix Sum Gives Position (Example)

Input: `[4, 3, 3, 8, 2, 1, 2]`  
After prefix sum (values `0..8`):  
`aux = [0, 1, 3, 5, 6, 6, 6, 6, 7]`

### Meaning of prefix sum
- `aux[v] = number of elements ≤ v`
- So the **last index** where value `v` should be placed in the sorted output is:
  - `lastPos(v) = aux[v] - 1` (0-based)

### Positions from this example
- `v = 1`: `aux[1] = 1` → last position `= 0`  
  ⇒ `1` goes to `output[0]`

- `v = 2`: `aux[2] = 3` → last position `= 2`  
  ⇒ the two `2`s occupy `output[2]` and `output[1]`

- `v = 3`: `aux[3] = 5` → last position `= 4`  
  ⇒ the two `3`s occupy `output[4]` and `output[3]`

- `v = 4`: `aux[4] = 6` → last position `= 5`  
  ⇒ `4` goes to `output[5]`

- `v = 8`: `aux[8] = 7` → last position `= 6`  
  ⇒ `8` goes to `output[6]`

### Why we do `aux[v]--` after placing
- It shifts the placement pointer left.
- So duplicates fill the correct block of positions one by one.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class CountingSort
{
public:
    void countsort(vector<int> &inp, int size)
    {
        vector<int> output(size);

        // find the largest value
        int maxVal = inp[0];
        for (int i = 1; i < size; i++)
        {
            if (inp[i] > maxVal)
                maxVal = inp[i];
        }

        // auxiliary count array
        vector<int> aux(maxVal + 1, 0);

        // count each element
        for (int i = 0; i < size; i++)
        {
            aux[inp[i]]++;
        }

        // cumulative sum
        for (int i = 1; i <= maxVal; i++)
        {
            aux[i] = aux[i] + aux[i - 1];
        }

        // place elements into output array
        for (int i = 0; i < size; i++)
        {
            output[aux[inp[i]] - 1] = inp[i];
            aux[inp[i]]--;
        }

        // print aux for debugging (same as Java)
        for (int x : aux)
            cout << x << " ";
        cout << endl;

        // copy output to input
        for (int i = 0; i < size; i++)
        {
            inp[i] = output[i];
        }
    }
};

int main()
{
    vector<int> input = {4, 3, 3, 8, 2, 1, 2};
    int size = input.size();

    cout << "Original: ";
    for (int x : input)
        cout << x << " ";
    cout << endl;

    CountingSort cs;
    cs.countsort(input, size);

    cout << "Sorted:   ";
    for (int x : input)
        cout << x << " ";
    cout << endl;

    return 0;
}
```
## Complexity Analysis (Counting Sort)

Let:
- `n` = number of elements
- `k` = range of values = `maxVal + 1` (values assumed from `0` to `maxVal`)

Counting sort time depends mainly on `n` and `k`, **not** on the input order.

---

## Time Complexity (Best / Average / Worst)

Counting sort does these steps:
1. Find `maxVal`: `O(n)`
2. Build frequency array: `O(n)`
3. Prefix sums over `aux[0..maxVal]`: `O(k)`
4. Place elements into output: `O(n)`
5. Copy back: `O(n)`

Total:
\[
O(n) + O(n) + O(k) + O(n) + O(n) = O(n + k)
\]

So in all cases:

**Best = Average = Worst = `O(n + k)`**

### Examples (same time behavior)
- Best-looking (already sorted): `[1, 2, 2, 3, 3, 4, 8]`
- Random: `[4, 3, 3, 8, 2, 1, 2]`
- Reverse: `[8, 4, 3, 3, 2, 2, 1]`

All do the same passes over:
- `n` elements
- `k` count array entries

Order does not reduce comparisons because counting sort does no comparisons.

---

## Space Complexity
- `output` array of size `n`: `O(n)`
- `aux` array of size `k`: `O(k)`

**Space = `O(n + k)`**

---

## Practical Note (Important)
Counting sort is very fast when `k` is not too large.

Example:
- `n = 10^5`, `maxVal = 1000` ⇒ `k = 1001`  
  Time ≈ `O(10^5 + 10^3)` → good.

Bad case:
- `n = 10^5`, `maxVal = 10^9` ⇒ `k = 10^9 + 1`  
  Memory/time becomes impossible.
