## Counting Sort with Negative Numbers

### Intuition 
Normal counting sort uses the value itself as an index (like `count[value]`), so it only works directly for non-negative values.

To support negatives, we **shift** all values so that the smallest value becomes `0`.
This is done using an offset:
- `offset = -minVal`
- index for a value `x` becomes `x - minVal`

Then, counting sort works the same way: count frequencies, build prefix sums, and place elements into their correct sorted positions.

### Algorithm Steps
1. Find:
   - `minVal` = minimum element in array
   - `maxVal` = maximum element in array
2. Compute `range = maxVal - minVal + 1`.
3. Create:
   - `cnt[range]` initialized to `0`
   - `output[n]`
4. Count frequencies using offset indexing:
   - For each element `x`, do `cnt[x - minVal]++`
5. Convert `cnt` to prefix sums:
   - For `i = 1..range-1`, `cnt[i] += cnt[i-1]`
   - Now `cnt[idx]` tells the ending position (1-based) of that value in sorted order.
6. Build `output` (stable):
   - Traverse input from right to left:
     - `idx = a[i] - minVal`
     - place `a[i]` at `output[cnt[idx] - 1]`
     - decrement `cnt[idx]`
7. Copy `output` back to the original array.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Counting sort that supports negative integers as well.
void countingSortWithNegatives(vector<int>& a) {
    if (a.empty()) return;

    int minVal = a[0], maxVal = a[0];
    for (int x : a) {
        if (x < minVal) minVal = x;
        if (x > maxVal) maxVal = x;
    }

    int range = maxVal - minVal + 1;          // total distinct values possible
    vector<int> cnt(range, 0);
    vector<int> output(a.size());

    // Frequency count with offset
    for (int x : a) cnt[x - minVal]++;

    // Prefix sums
    for (int i = 1; i < range; i++) cnt[i] += cnt[i - 1];

    // Stable placement (right to left)
    for (int i = (int)a.size() - 1; i >= 0; i--) {
        int idx = a[i] - minVal;
        output[cnt[idx] - 1] = a[i];
        cnt[idx]--;
    }

    a = output;
}

int main() {
    vector<int> a = {4, -1, 3, -2, 0, -1, 2};

    cout << "Original: ";
    for (int x : a) cout << x << " ";
    cout << "\n";

    countingSortWithNegatives(a);

    cout << "Sorted:   ";
    for (int x : a) cout << x << " ";
    cout << "\n";

    return 0;
}
```
## Complexity Analysis (Counting Sort with Negative Numbers)

Let:
- `n` = number of elements
- `minVal` = minimum element
- `maxVal` = maximum element
- `k = maxVal - minVal + 1` (range size)

This version supports negatives by using offset indexing (`x - minVal`), but the complexity pattern is the same as normal counting sort.

---

## Time Complexity (Best / Average / Worst)
Steps:
1. Find `minVal` and `maxVal`: `O(n)`
2. Build frequency array: `O(n)`
3. Prefix sums over `k` values: `O(k)`
4. Place elements into output: `O(n)`
5. Copy output back: `O(n)`

Total:
\[
O(n) + O(n) + O(k) + O(n) + O(n) = O(n + k)
\]

So **best, average, and worst are the same**:

**Time = O(n + k)**

### Examples (order doesn’t matter)
- Sorted: `[-2, -1, -1, 0, 2, 3, 4]`
- Random: `[4, -1, 3, -2, 0, -1, 2]`
- Reverse: `[4, 3, 2, 0, -1, -1, -2]`

All take the same `O(n + k)` time because counting sort does not depend on element order.

---

## Space Complexity
- `output` array of size `n` → `O(n)`
- `cnt` array of size `k` → `O(k)`

**Space = O(n + k)**

---

## Practical Note (Important)
Counting sort is efficient only when the range `k` is not too large.

### Good Example
`n = 7`, values in `[-2..4]`  
`k = 4 - (-2) + 1 = 7` → very efficient.

### Bad Example
`n = 10^5`, values in `[-10^9..10^9]`  
`k = 2*10^9 + 1` → memory/time becomes impractical.
