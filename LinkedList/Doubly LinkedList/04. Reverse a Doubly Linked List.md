## Reverse a Doubly Linked List

**Problem Statement:**  
Given a doubly linked list of size ‘N’ consisting of positive integers, your task is to reverse it and return the head of the modified doubly linked list.

---
>### Examples:

- **Input:** DLL - 1 <-> 2 <-> 3 <-> 4  
  **Output:** DLL - 4 <-> 3 <-> 2 <-> 1  
  **Explanation:** The doubly linked list is reversed, and its last node is returned at the new head pointer.

- **Input:** DLL - 10 <-> 20 <-> 30  
  **Output:** DLL - 30 <-> 20 <-> 10  
  **Explanation:** In this case, the doubly linked list is reversed and its former tail is returned as its new head.

---

## Brute Force Approach

### Algorithm:

A brute-force approach involves replacing data in a doubly linked list. First, we traverse the list and store node data in a stack. Then, in a second pass, we assign elements from the stack to nodes, ensuring a reverse order replacement since stacks follow the Last-In-First-Out (LIFO) principle.

1. Initialize a `temp` pointer to the head of the doubly linked list and a stack data structure to store the values from the list.
2. Traverse the doubly linked list with the `temp` pointer and, while traversing, push the value at the current node (`temp`) onto the stack. Move `temp` to the next node, continuing until `temp` reaches null, indicating the end of the list.
3. Reset the `temp` pointer back to the head of the list. In this second iteration, pop the element from the stack, replace the data at the current node with the popped value from the top of the stack, and move `temp` to the next node. Repeat this step until `temp` reaches null or the stack becomes empty.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class representing a Node in a doubly linked list
class Node {
public:
    // Data stored in the node
    int data;

    // Pointer to the next node
    Node* next;

    // Pointer to the previous node
    Node* back;

    // Constructor with data, next, and back references
    Node(int data1, Node* next1, Node* back1) {
        data = data1;
        next = next1;
        back = back1;
    }

    // Constructor with only data, next and back are null
    Node(int data1) {
        data = data1;
        next = nullptr;
        back = nullptr;
    }
};

// Function to convert a vector into a doubly linked list
Node* convertArr2DLL(vector<int> arr) {
    // Create head node using the first array element
    Node* head = new Node(arr[0]);

    // Initialize previous node as head
    Node* prev = head;

    // Iterate through the remaining elements
    for (int i = 1; i < arr.size(); i++) {
        // Create new node with current value and back link to prev
        Node* temp = new Node(arr[i], nullptr, prev);

        // Set the next pointer of the previous node to the new node
        prev->next = temp;

        // Move prev to the new node
        prev = temp;
    }

    // Return the head of the DLL
    return head;
}

// Function to print elements of a doubly linked list
void print(Node* head) {
    // Traverse till the end of the list
    while (head != nullptr) {
        // Print current node's data
        cout << head->data << " ";

        // Move to the next node
        head = head->next;
    }
}

// Function to reverse a doubly linked list using a stack (brute force)
Node* reverseDLL(Node* head) {
    // If the list is empty or has only one node, return as-is
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    // Stack to store node data
    stack<int> st;

    // Pointer to traverse the list
    Node* temp = head;

    // Push all node values to the stack
    while (temp != nullptr) {
        st.push(temp->data);
        temp = temp->next;
    }

    // Reset temp to head for second pass
    temp = head;

    // Replace node values with those from the stack
    while (temp != nullptr) {
        temp->data = st.top();
        st.pop();
        temp = temp->next;
    }

    // Return head of reversed list
    return head;
}

// Alternative approach
Node* reverseDLL(Node* head)
{
    // If the list is empty or has only one node, return head as is
    if(head == NULL || head->next == NULL) {
        return head;
    }
    
    Node* prev = NULL;           // To keep track of the previous node
    Node* current = head;        // Start from the head of the list

    // Traverse the list and swap next and prev pointers for each node
    while(current != NULL) {
        prev = current->prev;            // Store the previous pointer
        current->prev = current->next;   // Swap prev and next pointers
        current->next = prev;            // Swap next and prev pointers
        current = current->prev;         // Move to the next node (which is previous before swap)
    }

    // After the loop, prev points to the previous node of the last node processed
    // So, prev->prev will be the new head of the reversed list
    return prev->prev;
}

// Driver code
int main() {
    // Input array
    vector<int> arr = {12, 5, 8, 7, 4};

    // Convert array to doubly linked list
    Node* head = convertArr2DLL(arr);

    // Print original DLL
    cout << endl << "Doubly Linked List Initially: " << endl;
    print(head);

    // Reverse the DLL
    head = reverseDLL(head);

    // Print reversed DLL
    cout << endl << "Doubly Linked List After Reversing: " << endl;
    print(head);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(2N)  
  During the first traversal, each node's value is pushed into the stack once, which requires O(N) time. Then, during the second iteration, the values are popped from the stack and used to update the nodes.

- **Space Complexity:** O(N)  
  This is because we are using an external stack data structure. At the end of the first iteration, the stack will hold all N values of the doubly linked list; therefore, the space required for the stack is directly proportional to the size of the input doubly linked list.

  ---
  
## Optimal Approach

### Algorithm:

Instead of performing two separate traversals of the linked list and storing its node values in an external data structure, we can optimize our approach by directly modifying the links between the nodes within the doubly linked list. We need to traverse every node, and for each node, change the next pointer and back pointer. If we do this for all nodes, at the end of traversal, the doubly linked list will be reversed.

1. **Initialize two pointers needed for the reversal:**
   - Initialize a `current` pointer to the head of the linked list. This pointer will traverse the list as we reverse it.
   - Initialize a second pointer `last` to `null`. This pointer will be used for temporary storage during pointer swapping, as we need a third variable while swapping two data.

2. **Traverse through the DLL by looping over all the nodes.**

3. **While iterating over all nodes in the linked list:**
   - Update the current node's back pointer to point to the next node (`current->back = current->next`). This step reverses the direction of the backward pointer.
   - Update the current node's next pointer to point to the previous node (`current->next = last`). This step reverses the direction of the forward pointer.
   - Move the `last` pointer to the current node.
   - Move the `current` pointer one step forward (`current = current->back`). This allows us to continue the reversal process.

4. **After completing the traversal:**
   - The `last` pointer will be at the new head of the reversed doubly linked list.

5. **Return the `last` pointer as the new head of the reversed list.**

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class representing a Node in a doubly linked list
class Node {
public:
     // To store value of the node
    int data;  
    // Pointer to the next node    
    Node* next;    
    // Pointer to the previous node
    Node* back; 

    // Constructor with data, next, and back references
    Node(int data1, Node* next1, Node* back1) {
        data = data1;
        next = next1;
        back = back1;
    }

    // Constructor with only data (default next and back to null)
    Node(int data1) {
        data = data1;
        next = nullptr;
        back = nullptr;
    }
};

// Function to convert an array into a doubly linked list
Node* convertArr2DLL(vector<int> arr) {
    // Create the head node using first array element
    Node* head = new Node(arr[0]);

    // Maintain a reference to the last node inserted (previous node)
    Node* prev = head;

    // Loop through the remaining array and link nodes
    for (int i = 1; i < arr.size(); i++) {
        // Create a new node with current array element
        // Set its back to prev
        Node* temp = new Node(arr[i], nullptr, prev);

        // Link previous node's next to current node
        prev->next = temp;

        // Update prev to current node
        prev = temp;
    }

    // Return the head of the DLL
    return head;
}

// Function to print the doubly linked list
void print(Node* head) {
    // Traverse from head to end and print each node's data
    while (head != nullptr) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

// Function to reverse the doubly linked list in-place
Node* reverseDLL(Node* head) {
    // If list is empty or has one node, nothing to reverse
    if (head == nullptr || head->next == nullptr) return head;

    // Pointer to track the current node
    Node* curr = head;

    // Traverse the DLL
    while (curr != nullptr) {
        // Swap next and back pointers of current node
        Node* temp = curr->next;
        curr->next = curr->back;
        curr->back = temp;

        // Move to the next node in original order
        head = curr;          
        curr = temp;          
    }

    // Return new head after full reversal
    return head;
}

// Driver code
int main() {
    // Sample input array
    vector<int> arr = {10, 20, 30, 40};

    // Convert array to DLL
    Node* head = convertArr2DLL(arr);

    // Reverse the DLL
    head = reverseDLL(head);

    // Print the reversed DLL
    print(head);

    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** O(N)  
  We only have to traverse the doubly linked list once, hence our time complexity is O(N).

- **Space Complexity:** O(1)  
  The reversal is done in place, so no extra space is used.

  
