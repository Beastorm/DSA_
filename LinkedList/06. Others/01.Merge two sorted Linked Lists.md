## Merge two sorted Linked Lists

**Problem Statement:**  
Given the `heads` of `two` singly linked lists, merge them into a single sorted linked list. The merged list should contain all the nodes from both lists in sorted order.

---

>### Example:

**Input:**  
```
List 1: 1 -> 4 -> 5  
List 2: 2 -> 3 -> 6  
```
**Output:** `1 -> 2 -> 3 -> 4 -> 5 -> 6`

---

## Approach

### Algorithm:
- Traverse both linked lists and collect all node values into an array.
- Sort the array.
- Convert the sorted array back into a linked list.
- Return the head of the new sorted linked list.

### Steps:

1. Initialize an empty array.
2. Traverse the first linked list and add each node's data to the array.
3. Traverse the second linked list and add each node's data to the array.
4. Sort the array.
5. Create a new linked list from the sorted array.
6. Return the head of the new linked list.

### C++ Code:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int v) : data(v), next(nullptr) {}
};

// Convert sorted array to linked list
Node* convertToLinkedList(const vector<int>& arr) {
    if (arr.empty()) return nullptr;
    Node* head = new Node(arr[0]);
    Node* temp = head;
    for (size_t i = 1; i < arr.size(); ++i) {
        temp->next = new Node(arr[i]);
        temp = temp->next;
    }
    return head;
}

// Merge two lists using an array
Node* mergeLists(Node* head1, Node* head2) {
    vector<int> arr;
    Node* temp1 = head1;
    Node* temp2 = head2;
    while (temp1 != nullptr) {
        arr.push_back(temp1->data);
        temp1 = temp1->next;
    }
    while (temp2 != nullptr) {
        arr.push_back(temp2->data);
        temp2 = temp2->next;
    }
    sort(arr.begin(), arr.end());
    return convertToLinkedList(arr);
}

// Print linked list
void printList(Node* head) {
    while (head) {
        cout << head->data;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// Driver code
int main() {
    // List 1: 1 -> 4 -> 5
    Node* head1 = new Node(1);
    head1->next = new Node(4);
    head1->next->next = new Node(5);

    // List 2: 2 -> 3 -> 6
    Node* head2 = new Node(2);
    head2->next = new Node(3);
    head2->next->next = new Node(6);

    Node* mergedHead = mergeLists(head1, head2);
    printList(mergedHead);

    // Free memory (not shown for brevity)
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(N1)$ + $O(N2)$ + $O(NlogN)$ + $O(N)$  
  where `N1` and `N2` are the lengths of the two lists and `N` = `N1 + N2`.  
  - $O(N1)$ to traverse the first list  
  - $O(N2)$ to traverse the second list  
  - $O(NlogN)$ to sort the combined array  
  - $O(N)$ to convert the sorted array back to a linked list  
  The overall time complexity is dominated by $O(NlogN)$.

- **Space Complexity:** $O(N)$ + $O(N)$ = $O(N)$  
  - $O(N)$ for storing all elements in the array  
  - $O(N)$ for the new linked list created from the array  
  Both the array and the new linked list exist simultaneously, so the total space used is $O(N)$.

---

## Approach

### Algo:
Merge two sorted linked lists by comparing their nodes one by one and building a new sorted list by linking the smaller node at each step. Use a dummy node to simplify edge cases.


### Steps:

1. Initialize two pointers, `t1` and `t2`, to the heads of the two lists.
2. Create a dummy node and a `temp` pointer to build the merged list.
3. While both `t1` and `t2` are not null:
    - Compare `t1->data` and `t2->data`.
    - Link the smaller node to `temp->next` and move the corresponding pointer forward.
    - Move `temp` forward.
4. After the loop, link the remaining nodes (if any) from either list to the merged list.
5. Return `dummyNode->next` as the head of the merged list.


### C++ Code:

```cpp
#include <iostream>
using namespace std;

template<typename T>
struct Node {
    T data;
    Node* next;
    Node(T v) : data(v), next(nullptr) {}
};

Node<int>* sortTwoLists(Node<int>* list1, Node<int>* list2) {
    Node<int>* t1 = list1;
    Node<int>* t2 = list2;

    Node<int>* dummyNode = new Node<int>(-1);
    Node<int>* temp = dummyNode;

    while (t1 != NULL && t2 != NULL) {
        if (t1->data < t2->data) {
            temp->next = t1;
            temp = t1;
            t1 = t1->next;

        } else {
            temp->next = t2;
            temp = t2;
            t2 = t2->next;
        }
    }
    if (t1) temp->next = t1;
    else temp->next = t2;

    Node<int>* head = dummyNode->next;
    delete dummyNode;

    return head;
}

// Helper to print list
void printList(Node<int>* head) {
    while (head) {
        cout << head->data;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// Driver code
int main() {
    // List 1: 1 -> 3 -> 5
    Node<int>* list1 = new Node<int>(1);
    list1->next = new Node<int>(3);
    list1->next->next = new Node<int>(5);

    // List 2: 2 -> 4 -> 6
    Node<int>* list2 = new Node<int>(2);
    
    list2->next = new Node<int>(4);
    list2->next->next = new Node<int>(6);

    Node<int>* merged = sortTwoLists(list1, list2);
    printList(merged);

    // Free memory (not shown for brevity)
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N1 + N2)  
  where `N1` and `N2` are the lengths of the two lists. Each node is visited once.

- **Space Complexity:** $O(1)$  
  As merging is done in-place without the use of extra data structures (excluding the dummy node).
