## Merge K Sorted Lists | Multiple Approaches

**Problem Statement:**

Given an array of k singly linked lists, merge all the lists into one sorted linked list and return its head.

---

>### Example:

**Input:**  
lists = [1->4->5, 1->3->4, 2->6]

**Output:**  
1->1->2->3->4->4->5->6

---

## Bruteforce Approach

### Algo:
- Traverse all k linked lists and collect all node values into an array.
- Sort the array.
- Convert the sorted array back into a linked list.
- Return the head of the new sorted linked list.

### Steps:

1. Initialize an empty array.
2. For each linked list in the input array:
    - Traverse the list and add each node's value to the array.
3. Sort the array.
4. Create a new linked list from the sorted array.
5. Return the head of the new linked list.


## C++ Code:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Node {
    int val;
    Node* next;
    Node(int v) : val(v), next(nullptr) {}
};

// Convert sorted array to linked list
Node* convertToLinkedList(const vector<int>& arr) {
    if (arr.empty()) return nullptr;
    Node* head = new Node(arr[0]);
    Node* temp = head;
    for (size_t i = 1; i < arr.size(); ++i) {
        temp->next = new Node(arr[i]);
        temp = temp->next;
    }
    return head;
}

// Merge k lists using an array
Node* mergeKLists(vector<Node*>& lists) {
    vector<int> arr;
    for (Node* list : lists) {
        Node* temp = list;
        while (temp != nullptr) {
            arr.push_back(temp->val);
            temp = temp->next;
        }
    }
    sort(arr.begin(), arr.end());
    return convertToLinkedList(arr);
}

// Print linked list
void printList(Node* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// Driver code
int main() {
    // List 1: 1 -> 4 -> 5
    Node* l1 = new Node(1);
    l1->next = new Node(4);
    l1->next->next = new Node(5);

    // List 2: 1 -> 3 -> 4
    Node* l2 = new Node(1);
    l2->next = new Node(3);
    l2->next->next = new Node(4);

    // List 3: 2 -> 6
    Node* l3 = new Node(2);
    l3->next = new Node(6);

    vector<Node*> lists = {l1, l2, l3};
    Node* mergedHead = mergeKLists(lists);
    printList(mergedHead);

    // Free memory (not shown for brevity)
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N) + O(N log N) + O(N), where N is the total number of nodes in all lists.
  - O(N) to traverse all lists and collect values.
  - O(N log N) to sort the array.
  - O(N) to create the new linked list.

- **Space Complexity:** O(N) for the array and O(N) for the new linked list.

---

## Better Approach

### Algo:
Iteratively merge k sorted linked lists by merging two lists at a time. Start with the first list, then merge it with the second, then merge the result with the third, and so on, until all lists are merged into one.

### Steps:

1. Initialize `head` as the first list in the array.
2. For each remaining list in the array:
    - Merge the current `head` with the next list using the two-list merge function.
    - Update `head` to the merged result.
3. Return `head` as the merged sorted list.


### C++ Code:

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct Node {
    int val;
    Node* next;
    Node(int v) : val(v), next(nullptr) {}
};

// Merge two sorted lists
Node* mergeTwoLists(Node* l1, Node* l2) {
    Node dummy(-1);
    Node* temp = &dummy;
    while (l1 && l2) {
        if (l1->val < l2->val) {
            temp->next = l1;
            l1 = l1->next;
        } else {
            temp->next = l2;
            l2 = l2->next;
        }
        temp = temp->next;
    }
    temp->next = l1 ? l1 : l2;
    return dummy.next;
}

// Merge k lists iteratively
Node* mergeKLists(vector<Node*>& lists) {
    if (lists.empty()) return nullptr;
    Node* head = lists[0];
    for (size_t i = 1; i < lists.size(); ++i) {
        head = mergeTwoLists(head, lists[i]);
    }
    return head;
}

// Print linked list
void printList(Node* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// Driver code
int main() {
    // List 1: 1 -> 4 -> 5
    Node* l1 = new Node(1);
    l1->next = new Node(4);
    l1->next->next = new Node(5);

    // List 2: 1 -> 3 -> 4
    Node* l2 = new Node(1);
    l2->next = new Node(3);
    l2->next->next = new Node(4);

    // List 3: 2 -> 6
    Node* l3 = new Node(2);
    l3->next = new Node(6);

    vector<Node*> lists = {l1, l2, l3};
    Node* mergedHead = mergeKLists(lists);
    printList(mergedHead);

    // Free memory (not shown for brevity)
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  O(N1 + N2) + (N1 + N2 + N3) + ... + (N1 + N2 + ... + Nk)  
  - Here, N1, N2, ..., Nk are the lengths of the k lists.
  - The first merge takes O(N1 + N2) time.
  - The second merge takes O(N1 + N2 + N3) time (since the merged list so far is of length N1 + N2).
  - The third merge takes O(N1 + N2 + N3 + N4), and so on.
  - In total, this is O(kN), where N is the total number of nodes across all lists and k is the number of lists.
  - This is less efficient than the optimal heap-based approach, but it is simple to implement.

- **Space Complexity:**  
  O(1), as merging is done in-place without using any extra data structures (excluding the dummy node used for merging).
  - No additional arrays, heaps, or lists are used.
  - Only a constant number of pointers are maintained during the merging process.

---

## Optimized Approach:

### Algorithm:

1. Use a min-heap (priority queue) to always extract the node with the smallest value among the heads of all lists.
2. Push the head of each non-empty list into the min-heap.
3. While the heap is not empty:
    - Extract the node with the smallest value.
    - Add it to the merged list.
    - If the extracted node has a next node, push it into the heap.
4. Return the head of the merged list.


### C++ Code:

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int v) : data(v), next(nullptr) {}
};

Node* mergeKLists(vector<Node*> listArray) {
    // Min-heap to store (node value, node pointer)
    priority_queue<pair<int, Node*>, vector<pair<int, Node*>>, greater<pair<int, Node*>>> pq;
    // Push head of each list into the heap
    for (int i = 0; i < listArray.size(); i++) {
        if (listArray[i]) {
            pq.push({listArray[i]->data, listArray[i]});
        }
    }
    Node* dummyNode = new Node(-1);
    Node* temp = dummyNode;
    while (!pq.empty()) {
        auto it = pq.top(); pq.pop();
        temp->next = it.second;
        temp = temp->next;
        if (it.second->next) {
            pq.push({it.second->next->data, it.second->next});
        }
    }
    return dummyNode->next;
}

// Print linked list
void printList(Node* head) {
    while (head) {
        cout << head->data;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << endl;
}

// Driver code
int main() {
    // List 1: 1 -> 4 -> 5
    Node* l1 = new Node(1);
    l1->next = new Node(4);
    l1->next->next = new Node(5);

    // List 2: 1 -> 3 -> 4
    Node* l2 = new Node(1);
    l2->next = new Node(3);
    l2->next->next = new Node(4);

    // List 3: 2 -> 6
    Node* l3 = new Node(2);
    l3->next = new Node(6);

    vector<Node*> lists = {l1, l2, l3};
    Node* mergedHead = mergeKLists(lists);
    printList(mergedHead);

    // Free memory (not shown for brevity)
    return 0;
}

```
### Complexity Analysis

- **Time Complexity:** O(N log k)  
  - N is the total number of nodes across all lists.
  - k is the number of linked lists.
  - Each node is inserted and extracted from the min-heap exactly once.
  - Each heap operation (insert or extract-min) takes O(log k) time.
  - Therefore, for N nodes, the total time is O(N log k).

- **Space Complexity:** O(k)  
  - The min-heap (priority queue) stores at most one node from each of the k lists at any time.
  - Thus, the maximum size of the heap is k.
  - No additional data structures are used apart from the output list and the heap.
