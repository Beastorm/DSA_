## Delete Last Node of a Doubly Linked List

**Problem Statement:**  
Given a Doubly Linked List, delete the last node of the Doubly Linked List.

---

>### Examples:

### Example 1:
  **Input:** DLL: 1 <-> 3 <-> 4 <-> 1  
  **Output:** DLL: 1 <-> 3 <-> 4  
  **Explanation:** The last node of the Doubly Linked List to be deleted is 1.

### Example 2:
  **Input:** DLL: 7 <-> 5  
  **Output:** DLL: 7  
  **Explanation:** The last node of the Doubly Linked List to be deleted is 5.

---

## Approach

### Algorithm:

1. To delete the tail of a doubly linked list, update the linkage between its last node and its second last node. Since a doubly linked list is bidirectional, set the second last node's next pointer and the last node's back pointer to null. Then, return the head of the doubly linked list as the result.

2. **Edge Cases:**
   - If the list is empty, return immediately as there is nothing to delete.
   - If the list has only one node, delete the node and return an empty list.

3. Traverse the doubly linked list to the last node and keep track of it using the tail pointer.

4. Access the second last node using the tail's back pointer.

5. Set the next pointer of the second last node to null. This step effectively disconnects the initial tail node from the list in the forward direction, making the second last node the new tail node.

6. Set the back pointer of the tail node to null. This ensures that the tail node no longer points back to the second last node.

7. Return the head of the doubly linked list as the result.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Node structure for DLL
struct Node {
    int data;
    Node* prev;
    Node* next;
    Node(int val) {
        data = val;
        prev = NULL;
        next = NULL;
    }
};

class Solution {
public:
    // Function to delete the tail of the DLL
    Node* deleteTail(Node* head) {
        // If the list is empty
        if (head == NULL) return NULL;

        // If only one node is present
        if (head->next == NULL) {
            delete head;
            return NULL;
        }

        // Traverse to the last node
        Node* temp = head;
        while (temp->next != NULL) {
            temp = temp->next;
        }

        // Update the second last node's next to NULL
        temp->prev->next = NULL;

        // Delete tail node
        delete temp;

        // Return head
        return head;
    }
};

int main() {
    // Create a sample DLL: 1 <-> 2 <-> 3
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->prev = head;
    head->next->next = new Node(3);
    head->next->next->prev = head->next;

    Solution obj;
    head = obj.deleteTail(head);

    // Print list after deletion
    Node* curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
    }
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N), we traverse the entire linked list once to delete the tail of the list.
- **Space Complexity:** O(1), constant amount of extra space is used.

