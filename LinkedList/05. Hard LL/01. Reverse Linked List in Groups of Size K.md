## Reverse Linked List in Groups of Size K

**Problem Statement:**  
Given the head of a singly linked list containing integers, reverse the nodes of the list in groups of `k` and return the head of the modified list. If the number of nodes is not a multiple of `k`, then the remaining nodes at the end should be kept as is and not reversed.  
Do not change the values of the nodes; only change the links between nodes.

---

>### Examples:

**Input:** `head -> 1 -> 2 -> 3 -> 4 -> 5`, `k = 2`  
**Output:** `head -> 2 -> 1 -> 4 -> 3 -> 5`  
**Explanation:** The groups `1 -> 2` and `3 -> 4` were reversed as `2 -> 1` and `4 -> 3`.

**Input:** `head -> 1 -> 2 -> 3 -> 4 -> 5`, `k = 3`  
**Output:** `head -> 3 -> 2 -> 1 -> 4 -> 5`  
**Explanation:** The group `1 -> 2 -> 3` was reversed as `3 -> 2 -> 1`. Note that `4 -> 5` was not reversed.

---

## Approach

### Algorithm:

For reversing nodes in a linked list in groups of size `k`, instead of flipping the whole list, we break it into groups of `k` nodes and reverse each group separately. If any group at the end has fewer than `k` nodes, we just leave it as is. To make this easier to understand and implement, we break the process into 3 helper functions:

- **reverseLinkedList:** Reverses a linked list segment using the basic `3-pointer` method (prev, curr, next). You reverse pointers one by one until the whole segment is flipped.
- **getKthNode:** Given a starting node, it walks forward `k` steps and returns the `k-th` node. If fewer than `k` nodes exist, it returns null. This helps us slice the list into groups of size `k`.
- **kReverse:** The main function that keeps calling get `Kth` Node to find valid `k-sized` segments, reverses them using reverseLinkedList, and connects everything back together.

### Steps:
1. Start with a dummy node pointing to the head of the list to simplify edge cases.
2. Set a pointer `groupPrev` to dummy (this keeps track of the end of the previous reversed group).
3. While at least `k` nodes are remaining:
    - Use `getKthNode` from `groupPrev` to find the end of the current `k-sized` group.
    - If `getKthNode` returns `null` (less than `k` nodes left), break the loop.
    - Keep track of the next group’s start using `kth.next`.
    - Temporarily break the link after the `k-th` node so we can reverse this segment cleanly.
    - Call reverseLinkedList on the current group’s head to reverse this `k-segment`.
    - Connect the previous group’s tail (`groupPrev`) to the head of the reversed segment.
    - Connect the tail of the reversed segment to the start of the next group.
    - Update groupPrev to point to the tail of the reversed segment.
4. Once done, return the new head of the list (i.e., `dummy.next`).

### C++ Code:
``` cpp
#include <iostream>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;

    Node(int x) {
        data = x;
        next = NULL;
    }
};

// Function to reverse a linked list
Node* reverseLinkedList(Node* head) {
    Node* prev = NULL;
    Node* curr = head;

    // Standard linked list reversal
    while (curr != NULL) {
        Node* nextNode = curr->next; // store next node
        curr->next = prev;           // reverse link
        prev = curr;                 // move prev forward
        curr = nextNode;             // move curr forward
    }
    return prev; // new head
}

// Function to get the k-th node from the current position
Node* getKthNode(Node* temp, int k) {
    k -= 1; // move k-1 steps
    while (temp != NULL && k > 0) {
        temp = temp->next;
        k--;
    }
    return temp; // returns NULL if less than k nodes
}

// Function to reverse a linked list in groups of size k
Node* kReverse(Node* head, int k) {

    // temp is the start of the current group
    Node* temp = head;       // current group start
    
    // prevLast is the tail of the already processed group
    Node* prevLast = NULL;   // last node of previous group

    while (temp != NULL) {

        // Find the k-th node of the current group
        Node* kThNode = getKthNode(temp, k);

        // If fewer than k nodes remain, connect and stop
        if (kThNode == NULL) {
            if (prevLast)
                prevLast->next = temp;
            break;
        }

        // Store next group's start
        Node* nextNode = kThNode->next;

        // Break the list to isolate the current group
        kThNode->next = NULL;

        // Reverse the current group
        reverseLinkedList(temp);

        // If first group, update head
        if (temp == head) {
            head = kThNode;
        } 
        // Otherwise, connect the previous group
        else {
            prevLast->next = kThNode;
        }

        // Update prevLast and temp for next iteration
        prevLast = temp;
        temp = nextNode;
    }

    return head;
}

// Function to print the linked list
void printList(Node* head) {
    while (head != NULL) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

// Driver code
int main() {

    int n, k;
    cin >> n; // number of nodes

    Node* head = NULL;
    Node* tail = NULL;

    // Input linked list
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        Node* newNode = new Node(x);

        if (head == NULL) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }

    cin >> k; // group size

    // Perform k-group reversal
    head = kReverse(head, k);

    // Print result
    printList(head);

    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** $O(N)$  
  We visit each node exactly once during reversal and during group detection (getKthNode). So the total operations are linear with respect to the number of nodes in the list.
- **Space Complexity:** $O(1)$  
  The algorithm uses a constant amount of extra memory for pointers and the dummy node. No additional data structures like arrays or stacks are used.
