## Clone Linked List with Random and Next Pointer

**Problem Statement:**   
Given a linked list where every node in the linked list contains two pointers:
- `next` which points to the next node in the list.
- `random`, which points to a random node in the list or `null`.

Create a **deep copy** of the given linked list and return it.

---

>### Examples:

**Example 1:**  
**Input:** `[[1, -1], [2, 0], [3, 4], [4, 1], [5, 2]]`  
**Output:** `1 2 3 4 5, true`  
**Explanation:**  
- All the nodes in the new list have the same corresponding values as the original nodes.
- All the random pointers point to their corresponding nodes in the new list.
- `'true'` represents that the nodes and references were newly created.

**Example 2:**  
**Input:** `[[5, -1], [3, -1], [2, 1], [1, 1]]`  
**Output:** `5 3 2 1, true`  
**Explanation:**  
- All the nodes in the new list have the same corresponding values as the original nodes.
- All the random pointers point to their corresponding nodes in the new list.
- `'true'` represents that the nodes and references were newly created.

**Note:**    
`[[5, -1], [3, -1], [2, -1], [1, -1]]` will be incorrect, although it has the same values, because the random pointers are not set correctly.

---

## Brute Force Approach

### Algorithm:

To create a deep copy of the original linked list, we can use a map to establish a relationship between the original nodes and their copied nodes.

1. Initialize a variable `temp` as a pointer to the head of the original linked list to traverse it. Create an empty `unordered_map` to map original nodes to their corresponding copied nodes.
2. Iterate through the original linked list and for each node, create a new node with the same data value as the original node. Map the original node to its copied node in the map.
3. Iterate through the original list again, but this time connect the pointers of the copied nodes in the same arrangement as the original nodes:
    - Get the copied node corresponding to the original node using the map.
    - Set the `next` pointer of the copied node to the copied node mapped to the original node’s `next` node.
    - Set the `random` pointer of the copied node to the copied node mapped to the original node’s `random` node.
4. Return the head of the deep-copied list, which is obtained by retrieving the copied node mapped to the original head from the map.   

<img src="https://static.takeuforward.org/content/1.png-UtgNZnhE" width="420">

### C++ Code:

``` cpp

#include <iostream>
using namespace std;

// Node class to represent elements in the linked list
class Node {
public:
    // Data stored in the node
    int data;           
     // Pointer to the next node
    Node *next;        
    // Pointer to a random node in the list
    Node *random;       

    // Constructors for Node class
    Node() : data(0), next(nullptr), random(nullptr){}; 
    
    Node(int x) : data(x), next(nullptr), random(nullptr) {} 
    
    // Constructor with data, next, and random pointers
    Node(int x, Node *nextNode, Node *randomNode) : data(x), next(nextNode), random(randomNode) {}  
};

// Function to insert a copy of each node in between the original nodes
void insertCopyInBetween(Node* head){
    Node* temp = head;
    while(temp != NULL){
        Node* nextElement = temp->next;
        // Create a new node with the same data
        Node* copy = new Node(temp->data);  
        
        // Point the copy's next to the original node's next
        copy->next = nextElement;  
        
        // Point the original node's next to the copy
        temp->next = copy;         

        // Move to the next original node
        temp = nextElement;         
    }
}

// Function to connect random pointers of the copied nodes
void connectRandomPointers(Node* head){
    Node* temp = head;
    while(temp != NULL){
        // Access the copied node
        Node* copyNode = temp->next;    
        
        // If the original node has a random pointer
        if(temp->random){   
             // Point the copied node's random to the corresponding copied random node
            copyNode->random = temp->random->next; 
        }
        else{
             // Set the copied node's random to null if the original random is null
            copyNode->random = NULL;   
        }
        
         // Move to the next original node
        temp = temp->next->next;   
    }
}

// Function to retrieve the deep copy of the linked list
Node* getDeepCopyList(Node* head){
    Node* temp = head;
     // Create a dummy node
    Node* dummyNode = new Node(-1);   
    // Initialize a result pointer
    Node* res = dummyNode;             

    while(temp != NULL){
        // Creating a new List by pointing to copied nodes
        res->next = temp->next;
        res = res->next;

        // Disconnect and revert to the initial state of the original linked list
        temp->next = temp->next->next;
        temp = temp->next;
    }
    
     // Return the deep copy of the list starting from the dummy node
    return dummyNode->next;   
}

// Function to clone the linked list
Node *cloneLL(Node *head){
    // If the original list is empty, return null
    if(!head) return nullptr;   
    
     // Step 1: Insert a copy of the nodes in between
    insertCopyInBetween(head); 
    // Step 2: Connect random pointers of copied nodes
    connectRandomPointers(head);  
    // Step 3: Retrieve the deep copy of the linked list
    return getDeepCopyList(head); 
}

// Function to print the cloned linked list
void printClonedLinkedList(Node *head) {
    while (head != nullptr) {
        cout << "Data: " << head->data;
        if (head->random != nullptr) {
            cout << ", Random: " << head->random->data;
        } else {
            cout << ", Random: nullptr";
        }
        cout << endl;
         // Move to the next node
        head = head->next;  
    }
}

// Main function
int main() {
    // Example linked list: 7 -> 14 -> 21 -> 28
    Node* head = new Node(7);
    head->next = new Node(14);
    head->next->next = new Node(21);
    head->next->next->next = new Node(28);

    // Assigning random pointers
    head->random = head->next->next;
    head->next->random = head;
    head->next->next->random = head->next->next->next;
    head->next->next->next->random = head->next;

    cout << "Original Linked List with Random Pointers:" << endl;
    printClonedLinkedList(head);

    // Clone the linked list
    Node* clonedList = cloneLL(head);

    cout << "\nCloned Linked List with Random Pointers:" << endl;
    printClonedLinkedList(clonedList);

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** $O(2N)$  
  where `N` is the number of nodes in the linked list. The linked list is traversed twice: once for creating copies of each node and a second time to set the next and random pointers for each copied node. The time to access the nodes in the map is $O(1)$ due to hashing.

- **Space Complexity:** $O(N)$ + $O(N)$  
  where `N` is the number of nodes in the linked list. All nodes are stored in the map to maintain mappings ( $O(N)$ ), and the copied linked list takes $O(N)$ space as well.

---

## Optimal Approach

### Algorithm:

The previous approach uses extra space for creating mappings between the original and copied nodes. Instead, we can interleave the copied nodes with the original nodes for quick access without the need for additional space.

1. Traverse the original list and create a copy of each node, inserting it in between the original node and its next node.
2. Traverse this modified list and for each original node that has a random pointer, set the copied node’s random pointer to the corresponding copied node (i.e., `original->next->random = original->random->next`). If the original node’s random pointer is null, set the copied node’s random pointer to null as well.
3. Traverse the modified list again and extract the copied nodes by breaking the links between the original nodes and the copied nodes. Revert the original list to its initial state by fixing the next pointers.
4. Return the head of the deep copy obtained after extracting the copied nodes from the modified list.


### C++ Code:
``` cpp

#include <iostream>
using namespace std;

// Node class to represent elements in the linked list
class Node {
public:
    // Data stored in the node
    int data;           
     // Pointer to the next node
    Node *next;        
    // Pointer to a random node in the list
    Node *random;       

    // Constructors for Node class
    Node() : data(0), next(nullptr), random(nullptr){}; 
    
    Node(int x) : data(x), next(nullptr), random(nullptr) {} 
    
    // Constructor with data, next, and random pointers
    Node(int x, Node *nextNode, Node *randomNode) : data(x), next(nextNode), random(randomNode) {}  
};

// Function to insert a copy of each node in between the original nodes
void insertCopyInBetween(Node* head){
    Node* temp = head;
    while(temp != NULL){
        Node* nextElement = temp->next;
        
        // Create a new node with the same data
        Node* copy = new Node(temp->data);  
        
        // Point the copy's next to the original node's next
        copy->next = nextElement;  
        
        // Point the original node's next to the copy
        temp->next = copy;         

        // Move to the next original node
        temp = nextElement;         
    }
}

// Function to connect random pointers of the copied nodes
void connectRandomPointers(Node* head){
    Node* temp = head;
    while(temp != NULL){
        // Access the copied node
        Node* copyNode = temp->next;    
        
        // If the original node has a random pointer
        if(temp->random){   
            // Point the copied node's random to the corresponding copied random node
            copyNode->random = temp->random->next; 
        }
        else{
            // Set the copied node's random to null if the original random is null
            copyNode->random = NULL;   
        }
        
         // Move to the next original node
        temp = temp->next->next;   
    }
}

// Function to retrieve the deep copy of the linked list
Node* getDeepCopyList(Node* head){
    Node* temp = head;
     // Create a dummy node
    Node* dummyNode = new Node(-1);   
    // Initialize a result pointer
    Node* res = dummyNode;             

    while(temp != NULL){
        // Creating a new List by
        // pointing to copied nodes
        res->next = temp->next;
        res = res->next;

        // Disconnect and revert to the initial state of the original linked list
        temp->next = temp->next->next;
        temp = temp->next;
    }
    
     // Return the deep copy of the list starting from the dummy node
    return dummyNode->next;   
}

// Function to clone the linked list
Node *cloneLL(Node *head){
    // If the original list is empty, return null
    if(!head) return nullptr;   
    
     // Step 1: Insert a copy of the nodes in between
    insertCopyInBetween(head); 
    // Step 2: Connect random pointers of copied nodes
    connectRandomPointers(head);  
    // Step 3: Retrieve the deep copy of the linked list
    return getDeepCopyList(head); 
}

// Function to print the cloned linked list
void printClonedLinkedList(Node *head) {
    while (head != nullptr) {
        cout << "Data: " << head->data;
        if (head->random != nullptr) {
            cout << ", Random: " << head->random->data;
        } else {
            cout << ", Random: nullptr";
        }
        cout << endl;
         // Move to the next node
        head = head->next;  
    }
}

// Main function
int main() {
    // Example linked list: 7 -> 14 -> 21 -> 28
    Node* head = new Node(7);
    head->next = new Node(14);
    head->next->next = new Node(21);
    head->next->next->next = new Node(28);

    // Assigning random pointers
    head->random = head->next->next;
    head->next->random = head;
    head->next->next->random = head->next->next->next;
    head->next->next->next->random = head->next;

    cout << "Original Linked List with Random Pointers:" << endl;
    printClonedLinkedList(head);

    // Clone the linked list
    Node* clonedList = cloneLL(head);

    cout << "\nCloned Linked List with Random Pointers:" << endl;
    printClonedLinkedList(clonedList);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(3N)$  
  where `N` is the number of nodes in the linked list. The algorithm makes three traversals of the linked list: once to create copies and insert them between original nodes, once to set the random pointers of the copied nodes, and once to separate the copied and original nodes.

- **Space Complexity:** $O(N)$  
  where `N` is the number of nodes in the linked list, as the only additional space allocated is to create the copied list without creating any other additional data structures.
                                
                                
