## Sort a Linked List of 0's, 1's, and 2's by Changing Links

**Problem Statement:**  
Given a linked list containing only 0's, 1's, and 2's, sort the linked list by rearranging the links (not by changing the data values).

---

>### Examples:

- **Input:** `1 -> 2 -> 0 -> 1 -> 0 -> 2 -> NULL`  
  **Output:** `0 -> 0 -> 1 -> 1 -> 2 -> 2 -> NULL`

- **Input:** `2 -> 1 -> 2 -> 0 -> 0 -> 1 -> NULL`  
  **Output:** `0 -> 0 -> 1 -> 1 -> 2 -> 2 -> NULL`

---

## Approach

### Algorithm:

Instead of sorting by swapping data values, we need to rearrange the actual links. The key insight is to maintain three separate chains for 0's, 1's, and 2's, then connect them at the end.

1. Traverse the original list once, and for each node:
   - If the value is 0, add it to the "zero's" chain.
   - If the value is 1, add it to the "one's" chain.
   - If the value is 2, add it to the "two's" chain.
2. Finally, connect zero's chain to one's chain and then one's chain to two's chain.
3. Handle edge cases where any chain might be empty.


### C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

// Node class representing each element of the linked list
class Node {
public:
    int data;
    Node* next;
    Node(int val) {
        data = val;
        next = nullptr;
    }
};

// LinkedList class to manage list operations
class LinkedList {
public:
    Node* head;
    LinkedList() { head = nullptr; }
    void insert(int val) {
        Node* newNode = new Node(val);
        if (!head) {
            head = newNode; 
            return;
        }
        Node* temp = head;
        while (temp->next)
            temp = temp->next;
        temp->next = newNode;
    }
    void print() {
        Node* temp = head;
        while (temp) {
            cout << temp->data;
            if (temp->next) cout << " -> ";
            temp = temp->next;
        }
        cout << " -> NULL\n";
    }
};

// Solution class containing logic for sorting the list
class Solution {
public:
    void sortZeroOneTwo(LinkedList& ll) {
        Node* zeroDummy = new Node(-1);
        Node* oneDummy = new Node(-1);
        Node* twoDummy = new Node(-1);
        Node* zeroTail = zeroDummy;
        Node* oneTail = oneDummy;
        Node* twoTail = twoDummy;
        Node* curr = ll.head;
        while (curr) {
            if (curr->data == 0) {
                zeroTail->next = curr;
                zeroTail = zeroTail->next;
            } else if (curr->data == 1) {
                oneTail->next = curr;
                oneTail = oneTail->next;
            } else {
                twoTail->next = curr;
                twoTail = twoTail->next;
            }
            curr = curr->next;
        }
        zeroTail->next = oneDummy->next ? oneDummy->next : twoDummy->next;
        oneTail->next = twoDummy->next;
        twoTail->next = nullptr;
        ll.head = zeroDummy->next;
        delete zeroDummy;
        delete oneDummy;
        delete twoDummy;
    }
};

// Driver code to demonstrate usage
int main() {
    LinkedList ll;
    Solution sol;
    ll.insert(1);
    ll.insert(2);
    ll.insert(0);
    ll.insert(1);
    ll.insert(2);
    ll.insert(0);

    cout << "Original List:\n";
    ll.print();

    sol.sortZeroOneTwo(ll);

    cout << "Sorted List:\n";
    ll.print();

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(n)$  
  We traverse the entire list once.

- **Space Complexity:** $O(1)$  
  Only dummy nodes and pointers are used (constant space).
