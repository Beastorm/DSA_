## Length of Loop in Linked List

**Problem Statement:**  
Given the head of a linked list, determine the length of a loop present in the linked list. If there's no loop present, return `0`.

>### Examples:

- **Input:** 
```  
1 -> 2 -> 3 -> 4 -> 5-
          ^----------|           
```   
 **Output:** `3`  
 **Explanation:** A cycle exists in the linked list starting at node 3 -> 4 -> 5 and then back to 3. There are 3 nodes present in this cycle.

---

- **Input:** `1 -> 2 -> 3 -> 4 -> 9 -> 9`  
  **Output:** `0`  
  **Explanation:** The linked list is linear and does not have a loop, hence return 0.

  ---
  
## Brute Force Approach

### Algorithm:

While traversing the linked list, employ a timer against each node to keep track of the number of nodes you've visited before it. Once a previously visited node is encountered again, the length of the loop can be determined by subtracting the timer values at the two instances of visiting that particular node.

It's important to keep track of nodes and the timer value associated with them. This can be implemented using a hashmap with nodes as the key and the timer as the value.

1. Initialize a temporary pointer to `head`, which will be used to traverse the list. While traversing, keep track of the visited nodes and the timer value associated with the map data structure.
2. Continue traversing until a node that has already been visited is found. The difference between its timer value in the hashmap and the current timer's value will be the length of the loop in the linked list.
3. If the traversal is completed, and we reach the last point of the linked list, which is `null`, it means there was no loop, hence we return 0.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Node class represents a node in a linked list
class Node {
public:
    // Data stored in the node
    int data;

    // Pointer to the next node
    Node* next;

    // Constructor with both data and next node
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Solution class containing the loop length function
class Solution {
public:
    // Function to return the length of the loop using hashing
    int lengthOfLoop(Node* head) {
        // Hashmap to store visited nodes and their timer values
        unordered_map<Node*, int> visitedNodes;

        // Pointer to traverse the linked list
        Node* temp = head;

        // Timer to track visited nodes
        int timer = 0;

        // Traverse the linked list till temp reaches nullptr
        while (temp != NULL) {
            // If revisiting a node, return the difference of timer values
            if (visitedNodes.find(temp) != visitedNodes.end()) {
                // Calculate the length of the loop
                int loopLength = timer - visitedNodes[temp];

                // Return the length of the loop
                return loopLength;
            }

            // Store the current node and its timer value
            visitedNodes[temp] = timer;

            // Move to the next node
            temp = temp->next;

            // Increment the timer
            timer++;
        }

        // If traversal is completed and we reach the end of the list
        // means there is no loop
        return 0;
    }
};

// Main driver function
int main() {
    // Creating a sample linked list with a loop
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    Node* fourth = new Node(4);
    Node* fifth = new Node(5);

    // Linking the nodes
    head->next = second;
    second->next = third;
    third->next = fourth;
    fourth->next = fifth;

    // Creating a loop from fifth to second
    fifth->next = second;

    // Creating a Solution object
    Solution obj;

    // Getting the loop length
    int loopLength = obj.lengthOfLoop(head);

    // Printing the result
    if (loopLength > 0) {
        cout << "Length of the loop: " << loopLength << endl;
    } else {
        cout << "No loop found in the linked list." << endl;
    }

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** $O(N)$  
  We traverse the entire linked list at least once to find the length of the loop.

- **Space Complexity:** $O(N)$  
  We use a map to store the timers for the nodes in the linked list.

  ---

## Optimal Approach

### Algorithm:

The previous method uses additional memory in order to find the length of the loop. To enhance efficiency, the Tortoise and Hare Algorithm is introduced as an optimization.

1. Initialise two pointers, `slow` and `fast`, to the head of the linked list. `slow` will advance one step at a time, while `fast` will advance two steps at a time. These pointers will move simultaneously.
2. Traverse the linked list with the `slow` and `fast` pointers. While traversing, repeatedly move `slow` one step and `fast` two steps at a time.
3. Continue this traversal until either `fast` (or `fast->next`) reaches null or both the pointers, `slow` and `fast`, meet.
4. As the `slow` pointer reaches back at the `fast` pointer, the value of the counter will represent the length of the loop.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Node class represents a node in a linked list
class Node {
public:
    // Data stored in the node
    int data;

    // Pointer to the next node
    Node* next;

    // Constructor with both data and next node
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Solution class containing the loop length function
class Solution {
public:
    // Function to return the length of the loop using Floyd's Algorithm
    int lengthOfLoop(Node* head) {
        // Initialize slow and fast pointers
        Node* slow = head;
        Node* fast = head;

        // Loop until fast and slow meet
        while (fast != NULL && fast->next != NULL) {
            // Move slowly by one step
            slow = slow->next;

            // Move fast by two steps
            fast = fast->next->next;

            // If slow and fast meet, loop detected
            if (slow == fast) {
                // Count the length of the loop
                return countLoopLength(slow);
            }
        }

        // No loop found
        return 0;
    }

    // Function to count loop length
    int countLoopLength(Node* meetingPoint) {
        // Start from the meeting point
        Node* temp = meetingPoint;
        int length = 1;

        // Move until we meet again
        while (temp->next != meetingPoint) {
            temp = temp->next;
            length++;
        }
        return length;
    }
};

// Main driver function
int main() {
    // Creating a sample linked list with a loop
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    Node* fourth = new Node(4);
    Node* fifth = new Node(5);

    // Linking the nodes
    head->next = second;
    second->next = third;
    third->next = fourth;
    fourth->next = fifth;

    // Creating a loop from fifth to second
    fifth->next = second;

    // Creating a Solution object
    Solution obj;

    // Getting the loop length
    int loopLength = obj.lengthOfLoop(head);

    // Printing the result
    if (loopLength > 0) {
        cout << "Length of the loop: " << loopLength << endl;
    } else {
        cout << "No loop found in the linked list." << endl;
    }

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(N)$  
  We traverse the entire linked list at least once to find the length of the loop.

- **Space Complexity:** $O(1)$  
  We use a constant amount of additional space, regardless of the linked list's length, to find the length of the loop.
