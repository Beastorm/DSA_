## Detect a Cycle in a Linked List

**Problem Statement:**  
Given a Linked List, determine whether the linked list contains a cycle or not.

### Examples:

- **Input:** LL: 1 2 3 4 5  
  **Output:** True  
  **Explanation:** The last node with the value of 5 has its 'next' pointer pointing back to a previous node with the value of 3. This has resulted in a loop, hence we return true.

- **Input:** LL: 1 2 3 4 9 9  
  **Output:** False  
  **Explanation:** In this example, the linked list does not have a loop, hence it returns false.

---

## Brute-Force Approach

### Algorithm

A loop in a linked list occurs when there's a node that, when followed, brings you back to it, indicating a closed loop in the list. Hence it's important to keep track of nodes that have already been visited so that loops can be detected. One common way to do this is by using hashing.

1. Traverse the entire linked list using a temporary pointer.
2. While traversing, keep a track of the visited nodes in the map data structure.
3. If a previously visited node is encountered again, that proves that there is a loop in the linked list, hence return true.
4. If the traversal is completed, and we reach the last point of the list, which is null, it means there was no loop, hence we return false.
5. Storing the entire node in the map is essential to distinguish between nodes with identical values but different positions in the list. This ensures accurate loop detection and not just duplicate value checks.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Node class represents a linked list node
class Node {
public:
    // Data stored in the node
    int data;

    // Pointer to the next node
    Node* next;

    // Constructor with data and next
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Solution class contains the loop detection method
class Solution {
public:
    // Function to detect a loop in the linked list
    bool detectLoop(Node* head) {
        // Initialize a pointer at the head
        Node* temp = head;

        // Create a map to keep track of visited nodes
        unordered_map<Node*, int> nodeMap;

        // Traverse the linked list
        while (temp != nullptr) {
            // If node already exists in map, loop detected
            if (nodeMap.find(temp) != nodeMap.end()) {
                return true;
            }
            // Store the current node in the map
            nodeMap[temp] = 1;

            // Move to the next node
            temp = temp->next;
        }

        // If traversal completes, no loop detected
        return false;
    }
};

// Driver function
int main() {
    // Create sample linked list nodes
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    Node* fourth = new Node(4);
    Node* fifth = new Node(5);

    // Link the nodes
    head->next = second;
    second->next = third;
    third->next = fourth;
    fourth->next = fifth;

    // Create a loop for testing
    fifth->next = third;

    // Create a Solution object
    Solution obj;

    // Check if loop exists
    if (obj.detectLoop(head)) {
        cout << "Loop detected in the linked list." << endl;
    } else {
        cout << "No loop detected in the linked list." << endl;
    }

    // Free allocated memory
    delete head;
    delete second;
    delete third;
    delete fourth;
    delete fifth;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*LogN)  
  We traverse the entire linked list once and store and retrieve nodes from the hash map. Map operations have a worst-case time complexity of O(LogN).

- **Space Complexity:** O(N)  
  An additional amount of extra space is used to store nodes in a hash map.

---

## Optimal Approach

### Algorithm:

The earlier approach of using a hash map requires extra memory, which becomes costly when the linked list is very large. To optimize space, we use the Tortoise and Hare Algorithm (Floydâ€™s Cycle Detection). If the list contains a loop, both pointers will eventually enter the cycle. Since the hare is faster, it covers more distance and will eventually overtake the tortoise inside the loop, leading to a meeting point. On the other hand, if the list has no loop, the hare will simply reach the end, and the algorithm terminates without any meeting.

1. To detect a cycle using the Tortoise and Hare method, start by initializing two pointers, `slow` and `fast`, at the head of the linked list.
2. The `slow` pointer moves forward one step at a time, while the `fast` pointer advances two steps at a time.
3. If the `fast` pointer or its `next` becomes null, it means the end of the linked list has been reached. In this case, there is no loop, and the list is linear.
4. If the `slow` and `fast` pointers eventually meet at the same node, it confirms that a cycle exists in the linked list.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Node class represents a linked list node
class Node {
public:
    // Data stored in the node
    int data;

    // Pointer to the next node
    Node* next;

    // Constructor with data and next
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Solution class contains the loop detection method
class Solution {
public:
    // Function to detect a loop in the linked list
    bool detectLoop(Node* head) {
        // Initialize a pointer at the head
        Node* temp = head;

        // Create a map to keep track of visited nodes
        unordered_map<Node*, int> nodeMap;

        // Traverse the linked list
        while (temp != nullptr) {
            // If node already exists in map, loop detected
            if (nodeMap.find(temp) != nodeMap.end()) {
                return true;
            }
            // Store the current node in the map
            nodeMap[temp] = 1;

            // Move to the next node
            temp = temp->next;
        }

        // If traversal completes, no loop detected
        return false;
    }
};

// Driver function
int main() {
    // Create sample linked list nodes
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    Node* fourth = new Node(4);
    Node* fifth = new Node(5);

    // Link the nodes
    head->next = second;
    second->next = third;
    third->next = fourth;
    fourth->next = fifth;

    // Create a loop for testing
    fifth->next = third;

    // Create a Solution object
    Solution obj;

    // Check if loop exists
    if (obj.detectLoop(head)) {
        cout << "Loop detected in the linked list." << endl;
    } else {
        cout << "No loop detected in the linked list." << endl;
    }

    // Free allocated memory
    delete head;
    delete second;
    delete third;
    delete fourth;
    delete fifth;

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(N)  
  We traverse the entire linked list once. The fast pointer either reaches the end of the list or meets the slow pointer in linear time.

- **Space Complexity:** O(1)  
  A constant amount of extra space is used to detect a cycle using Floyd's Cycle Detection Algorithm.
