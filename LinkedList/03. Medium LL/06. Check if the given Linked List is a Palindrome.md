## Check if the given Linked List is a Palindrome

**Problem Statement:**  
Given the head of a singly linked list representing a positive integer number. Each node of the linked list represents a digit of the number, with the 1st node containing the leftmost digit of the number and so on. Check whether the linked list values form a palindrome or not. Return true if it forms a palindrome; otherwise, return false.

A palindrome is a sequence that reads the same forward and backward.

>### Examples:

**Example 1:**  
Input: `head -> 3 -> 7 -> 5 -> 7 -> 3`  
Output: `true`  
Explanation: 37573 is a palindrome.

**Example 2:**  
Input: `head -> 1 -> 1 -> 2 -> 1`  
Output: `false`  
Explanation: 1121 is not a palindrome.

---

## Brute Force Approach

### Algorithm:

1. Traverse the linked list from start to end, and push each node's value into a stack.
2. Once done, start again from the head of the linked list.
3. For each node, pop an element from the stack and compare it with the current node’s value.
4. If any value doesn’t match, return false — it’s not a palindrome.
5. If all values match till the end, return true — the list is a palindrome.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Node class represents a node in a linked list
class Node {
public:
    int data;       // Data stored in the node
    Node* next;     // Pointer to the next node in the list

    // Constructor with both data and next node as parameters
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data as a parameter, sets next to nullptr
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Function to check if the linked list is a palindrome
bool isPalindrome(Node* head) {
    // Create an empty stack to store values
    stack<int> st;

    // Initialize a temporary pointer to the head of the linked list
    Node* temp = head;

    // Traverse the linked list and push values onto the stack
    while (temp != NULL) {
        st.push(temp->data); // Push the data from the current node onto the stack
        temp = temp->next;   // Move to the next node
    }

    // Reset the temporary pointer back to the head of the linked list
    temp = head;

    // Compare values by popping from the stack and checking against linked list nodes
    while (temp != NULL) {
        if (temp->data != st.top()) {
            // If values don't match, it's not a palindrome
            return false;
        }
        st.pop();           // Pop the value from the stack
        temp = temp->next;  // Move to the next node in the linked list
    }

    // If all values match, it's a palindrome
    return true;
}

// Function to print the linked list
void printLinkedList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " "; // Print the current node's data
        temp = temp->next;         // Move to the next node
    }
    cout << endl;
}

// Driver function
int main() {
    // Create a linked list with values 1, 5, 2, 5, and 1 (15251, a palindrome)
    Node* head = new Node(1);
    head->next = new Node(5);
    head->next->next = new Node(2);
    head->next->next->next = new Node(5);
    head->next->next->next->next = new Node(1);

    // Print the original linked list
    cout << "Original Linked List: ";
    printLinkedList(head);

    // Check if the linked list is a palindrome
    if (isPalindrome(head)) {
        cout << "The linked list is a palindrome." << endl;
    } else {
        cout << "The linked list is not a palindrome." << endl;
    }

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(N)$  
  We traverse the entire linked list twice, once to push all elements into the stack, and once to compare them with the original list.
- **Space Complexity:** $O(N)$  
  We use a stack that stores all the elements of the linked list, which takes linear space in the worst case.

  ---

## Optimal Approach

### Algorithm:

1. Return `true` if the list is empty or has only one node, since such lists are palindromes by default.
2. Use two pointers, `slow` and `fast`, to find the middle node, where slow moves one step and fast moves two steps at a time.
3. Reverse the second half of the linked list starting from the node after the middle (`slow->next`), preparing it for comparison.
4. Set two pointers: one at the head of the list and the other at the head of the reversed second half, to compare both halves.
5. Compare both halves node by node; if any mismatch occurs, return false, otherwise continue till the end of either list.
6. Reverse the second half again to restore the original list structure, and return true if all nodes matched successfully.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Node class represents a node in a linked list
class Node {
public:
    int data;       // Data stored in the node
    Node* next;     // Pointer to the next node in the list

    // Constructor with both data and next node as parameters
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data as a parameter, sets next to nullptr
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Function to reverse a linked list using the recursive approach
Node* reverseLinkedList(Node* head) {
    // Check if the list is empty or has only one node
    if (head == NULL || head->next == NULL) {
        return head;  // No change is needed; return the current head
    }

    // Recursive step: Reverse the remaining part of the list and get the new head
    Node* newHead = reverseLinkedList(head->next);

    // Store the next node in 'front' to reverse the link
    Node* front = head->next;

    // Update the 'next' pointer of 'front' to point to the current head
    front->next = head;

    // Set the 'next' pointer of the current head to null to break the original link
    head->next = NULL;

    // Return the new head obtained from the recursion
    return newHead;
}

// Function to check if the linked list is a palindrome
bool isPalindrome(Node* head) {
    // Check if the linked list is empty or has only one node
    if (head == NULL || head->next == NULL) {
        return true;  // It's a palindrome by definition
    }

    // Initialize two pointers, slow and fast, to find the middle of the linked list
    Node* slow = head;
    Node* fast = head;

    // Traverse the linked list to find the middle using slow and fast pointers
    while (fast->next != NULL && fast->next->next != NULL) {
        slow = slow->next;       // Move slow pointer one step at a time
        fast = fast->next->next; // Move fast pointer two steps at a time
    }

    // Reverse the second half of the linked list, starting from the middle
    Node* newHead = reverseLinkedList(slow->next);

    // Pointer to the first half
    Node* first = head;

    // Pointer to the reversed second half
    Node* second = newHead;

    // Compare data values of nodes from both halves
    while (second != NULL) {
        if (first->data != second->data) {
            // If values do not match, the list is not a palindrome
            reverseLinkedList(newHead);  // Reverse the second half back to its original state
            return false;
        }

        first = first->next;  // Move the first pointer
        second = second->next; // Move the second pointer
    }

    // Reverse the second half back to its original state
    reverseLinkedList(newHead);

    // The linked list is a palindrome
    return true;
}

// Function to print the linked list
void printLinkedList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        cout << temp->data << " ";  // Print the current node's data
        temp = temp->next;          // Move to the next node
    }
    cout << endl;
}

// Driver function
int main() {
    // Create a linked list with values 1, 5, 2, 5, and 1 (15251, a palindrome)
    Node* head = new Node(1);
    head->next = new Node(5);
    head->next->next = new Node(2);
    head->next->next->next = new Node(5);
    head->next->next->next->next = new Node(1);

    // Print the original linked list
    cout << "Original Linked List: ";
    printLinkedList(head);

    // Check if the linked list is a palindrome
    if (isPalindrome(head)) {
        cout << "The linked list is a palindrome." << endl;
    } else {
        cout << "The linked list is not a palindrome." << endl;
    }

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(N)$  
  We traverse the list twice, once to reverse half of it and once to compare, each taking $O(N/2)$, which simplifies to $O(N)$.
- **Space Complexity:** $O(1)$  
  No extra space is used apart from a few pointers; operations are done in-place.
