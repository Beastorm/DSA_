## Remove N-th Node from the End of a Linked List

**Problem Statement:**  
Given a linked list and an integer `N`, the task is to delete the Nth node from the end of the linked list and print the updated linked list.

---

>### Examples:

- **Input:** `5->1->2`, `N=2`  
  **Output:** `5->2`  
  **Explanation:** The 2nd node from the end of the linked list is 1. Therefore, we get this result after removing 1 from the linked list.

- **Input:** `1->2->3->4->5`, `N=3`  
  **Output:** `1->2->4->5`  
  **Explanation:** The 3rd node from the end is 3; therefore, we remove 3 from the linked list.

---

## Brute Force Approach

### Algorithm:

The simplest way to delete the `Nth` node from the end is to delete the `(L-N+1)th` node from the start of the linked list, where `L` is the total length of the linked list. Therefore, this problem can be broken down into two sub-problems:
- The first part involves the calculation of the length of the linked list.
- The second part involves the deletion of the `(L-N+1)th` node from the start of the linked list.

**Steps:**
1. If `N` equals `1`, this means we have to delete the tail of the linked list.
2. If `N` equals the length of the linked list, we have to delete the head of the linked list.
3. To calculate the length and delete the node, follow these steps:
   - Initialize a temp pointer that will be used to traverse the list. Create a counter and increment it for every node while traversing.
   - When the pointer reaches null, the counter will store the length of the linked list.
   - To delete the `(L-N+1)th` node of the linked list, create a new temp pointer to the head. Initialize a variable `res` to `L-N`, and start iterating the linked list while decrementing `res` at each node. Once `res` equals `0`, temp will be pointing to the `(L-N)th` node, so stop the traversal.
   - To create a new link, point the `(L-N)th` node to the `(L-N+2)th` node of the linked list, effectively skipping the `(L-N+1)th` node.
   - Finally, free up the memory being occupied by the `(L-N+1)th` node, thus deleting this node.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class representing a node in the linked list
class Node {
public:
    int data;
    Node* next;

    // Constructor for Node with data and next node
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor for Node with only data 
    // (next set to nullptr)
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Class to hold the solution logic
class Solution {
public:
    // Function to print the linked list
    void printLL(Node* head) {
        while (head != NULL) {
            cout << head->data << " ";
            head = head->next;
        }
    }

    // Function to delete the Nth node from the end
    Node* deleteNthNodeFromEnd(Node* head, int N) {
        // If list is empty, return NULL
        if (head == NULL) {
            return NULL;
        }

        int cnt = 0;
        Node* temp = head;

        // Count the number of nodes in the linked list
        while (temp != NULL) {
            cnt++;
            temp = temp->next;
        }

        // If N equals the total number of nodes, delete the head
        if (cnt == N) {
            Node* newHead = head->next;
            // free memory
            delete head; 
            return newHead;
        }

        // Calculate the position from start to delete
        int res = cnt - N;
        temp = head;

        // Traverse to the node just before the one to delete
        while (temp != NULL) {
            res--;
            if (res == 0) {
                break;
            }
            temp = temp->next;
        }

        // Delete the target node
        Node* delNode = temp->next;
        temp->next = temp->next->next;
        delete delNode; // free memory

        return head;
    }
};

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int N = 3;

    // Creating a linked list manually
    Node* head = new Node(arr[0]);
    head->next = new Node(arr[1]);
    head->next->next = new Node(arr[2]);
    head->next->next->next = new Node(arr[3]);
    head->next->next->next->next = new Node(arr[4]);

    Solution sol;
    head = sol.deleteNthNodeFromEnd(head, N);
    sol.printLL(head);
}
```
### Complexity Analysis:

- **Time Complexity:** $O(L)$ + $O(L-N)$  
  We are calculating the length of the linked list and then iterating up to the `(L-N)th` node of the linked list, where `L` is the total length of the list.

- **Space Complexity:** $O(1)$  
  Constant additional space is used.

---
## Optimal Approach

### Algorithm:

The brute force, in the worst case, has a time complexity of $O(2*L)$, where `L` is the length of the linked list. Therefore, it is not the most efficient algorithm, as we are traversing the entire list twice.

To enhance efficiency, we will involve two pointers, a `fast` pointer and a `slow` pointer. The fast-moving pointer will initially be exactly `N` nodes ahead of the slow-moving pointer. After which, both of them will move one step at a time. When the fast pointer reaches the last node, i.e., the `L-th` node, the slow pointer is guaranteed to be at the `(L-N)-th` node, where `L` is the total length of the linked list.

1. Initialize two pointers, `slow` and `fast`, to the head of the linked list. Initially, only `fast` will move till it crosses `N` nodes, after which both of the pointers will move simultaneously.
2. Traverse the linked list till the `fast` pointer reaches the last node, that is, the `Lth` node. At this stage, the `slow` pointer is guaranteed to be at the `(L-N)th` node.
3. Point this `slow` pointer to the `(L-N+2)th` node, effectively skipping the `Nth` node from the end or the `(L-N+1)th` node from the start.
4. Finally, free up the space occupied by this node to delete it.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class representing a node in the linked list
class Node {
public:
    int data;
    Node* next;

    // Constructor for Node with data and next node
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor for Node with only data (next = nullptr)
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Class to hold the solution logic
class Solution {
public:
    // Function to print the linked list
    void printLL(Node* head) {
        while (head != NULL) {
            cout << head->data << " ";
            head = head->next;
        }
    }

    // Function to delete the Nth node from the end 
    // using the optimized two-pointer method
    Node* deleteNthNodeFromEnd(Node* head, int N) {
        // Create a dummy node before head to handle edge cases
        Node* dummy = new Node(0, head);

        // Initialize slow and fast pointers at dummy
        Node* slow = dummy;
        Node* fast = dummy;

        // Move fast pointer N+1 steps ahead to create a gap
        for (int i = 0; i <= N; i++) {
            fast = fast->next;
        }

        // Move both pointers until fast reaches the end
        while (fast != NULL) {
            slow = slow->next;
            fast = fast->next;
        }

        // Slow is now at node before target â†’ delete target node
        slow->next = slow->next->next;

        // Return updated head
        return dummy->next;
    }
};

// Main driver code
int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    int N = 3;

    // Create linked list manually
    Node* head = new Node(arr[0]);
    head->next = new Node(arr[1]);
    head->next->next = new Node(arr[2]);
    head->next->next->next = new Node(arr[3]);
    head->next->next->next->next = new Node(arr[4]);

    // Create Solution object
    Solution sol;

    // Delete the Nth node from the end
    head = sol.deleteNthNodeFromEnd(head, N);

    // Print the modified linked list
    sol.printLL(head);
}
```
### Complexity Analysis:
- **Time Complexity:** $O(N)$  
  Since the fast pointer will traverse the entire linked list, where `N` is the length of the linked list.

- **Space Complexity:** $O(1)$  
  Constant additional space is used to check unique elements.
