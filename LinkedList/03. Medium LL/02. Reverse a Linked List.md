## Reverse a Linked List

**Problem Statement:**  
Given the head of a singly linked list, write a program to reverse the linked list, and return the head pointer to the reversed list.

>### Examples:

- **Input:** LL: `1->3->2->4`  
- **Output:** 3  
- **Explanation:** After reversing the linked list, the new head will point to the tail of the old linked list.

---

## Brute Force Approach

### Algorithm:

A straightforward approach to reversing a singly linked list is to use an additional data structure, such as a stack. As we traverse the list, we push each node’s value onto the stack. Since stacks follow Last-In-First-Out (LIFO) order, popping elements from the stack gives us the values in reverse order. After the stack is filled, we reassign the values to the nodes while traversing the original list again. This effectively reverses the list in terms of values without modifying node links.

1. Create an empty stack to store the node values of the original linked list.
2. Traverse the linked list using a temporary pointer. For each node, push its value onto the stack.
3. Reset the temporary pointer to the head of the list.
4. While the stack is not empty, pop a value and assign it to the current node’s value. Move the pointer to the next node.
5. Once the traversal is complete, return the head of the modified linked list.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Definition for singly-linked list node
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    // Function to reverse a linked list using a stack
    ListNode* reverseList(ListNode* head) {
        // Stack to store values of nodes
        stack<int> st;

        // Temporary pointer to traverse the list
        ListNode* temp = head;

        // Traverse and push all node values to the stack
        while (temp != NULL) {
            st.push(temp->val);
            temp = temp->next;
        }

        // Reset temp back to head
        temp = head;

        // Reassign values from stack in reverse order
        while (temp != NULL) {
            temp->val = st.top();
            st.pop();
            temp = temp->next;
        }

        // Return the modified head
        return head;
    }
};

// Driver code
int main() {
    // Creating linked list 1 -> 2 -> 3 -> NULL
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);

    Solution sol;
    head = sol.reverseList(head);

    // Printing reversed list
    while (head != NULL) {
        cout << head->val << " ";
        head = head->next;
    }

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(N)$  
  We traverse the linked list twice: once to push all node values into the stack, and once to reassign values. Each traversal takes $O(N)$ time, where `N` is the number of nodes.

- **Space Complexity:** $O(N)$  
  We use an extra stack to store all the node values, which requires $O(N)$ additional space.

---

## Optimal Approach

### Algorithm:

The core idea is to change the next pointers of the nodes one by one so that they point backward instead of forward. By maintaining references to the current node, its previous node, and the next node, we can safely rewire the links without losing track of the list. Once all links are reversed, the last node of the original list becomes the new head.

1. Initialize a traversal pointer at the head of the linked list.
2. Also, initialize a pointer for the previous node and set it to NULL.
3. Repeat the following steps until the traversal pointer reaches the end:
   - Save the next node in a temporary pointer.
   - Reverse the `next` pointer of the current node to point to the previous node.
   - Move the previous pointer to the current node.
   - Advance the traversal pointer to the next node (saved earlier).
4. Once the traversal is complete, return the previous node as the new head of the reversed list.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class ListNode {
public:
    int val;
    ListNode* next;

    // Constructor to initialize node value
    ListNode(int val) {
        this->val = val;
        this->next = NULL;
    }
};

class Solution {
public:
    // Function to reverse a linked list iteratively
    ListNode* reverseList(ListNode* head) {
        // Initialize previous pointer to NULL
        ListNode* prev = NULL;

        // Start from the head of the list
        ListNode* temp = head;

        // Traverse the list
        while (temp != NULL) {
            // Save the next node
            ListNode* front = temp->next;

            // Reverse the current node's pointer
            temp->next = prev;

            // Move prev to current node
            prev = temp;

            // Move to the next node
            temp = front;
        }

        // Return new head (last node becomes first)
        return prev;
    }
};

// Driver code
int main() {
    // Creating a linked list: 1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    Solution sol;
    // Reversing the list
    ListNode* newHead = sol.reverseList(head);

    // Printing the reversed list
    while (newHead != NULL) {
        cout << newHead->val << " ";
        newHead = newHead->next;
    }
    cout << endl;

    return 0;
}
```
## Complexity Analysis:

- **Time Complexity:** $O(N)$  
  Because we are traversing each node of the linked list exactly once. Each pointer reversal is done in constant time.
- **Space Complexity:** $O(1)$  
  We are not using any additional data structure or recursion. All modifications are done in-place using pointers.

---
## Recursive Approach

### Algorithm:

Before diving into this approach, make sure your concepts of recursion are solid. Recursion lets us break a problem into smaller subproblems and solve them incrementally. It continues doing this until it hits the base case, the smallest instance of the problem. From there, it starts combining the results of the subproblems to solve the original task.

In the case of reversing a singly linked list, we're reducing the problem from reversing N nodes to reversing N - 1, N - 2, and so on. When we hit the base case (1 node), we start wiring the reversed nodes back together.

For example, if the list has 4 nodes:
- Recursion works down from 4 → 3 → 2 → 1.
- Then it rewires the links backward, starting from node 1.

### Steps:
1. **Base Case:** If the head is null or there’s only one node, it’s already reversed. So, just return the head.
2. **Recursive Step:** Call the same function to reverse the rest of the list starting from `head.next`. This recursive call gives back the new head of the reversed sublist.
3. **Store Reference:** Before breaking any link, store the next node (say `front`) so we don’t lose access to it.
4. **Reverse the Link:** Now, set `front.next = head`. This flips the direction of the link — making the next node point back to the current one.
5. **Break the Old Link:** To avoid cycles, disconnect the original forward link by doing `head.next = null`.
6. **Return the New Head:** Finally, return the `newHead` received from the recursive call — it’s now the head of the reversed list.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Definition for singly-linked list
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    // Recursive function to reverse the linked list
    ListNode* reverseList(ListNode* head) {
        // Base case: if the list is empty or has one node
        if (head == NULL || head->next == NULL)
            return head;

        // Recursively reverse the rest of the list
        ListNode* newHead = reverseList(head->next);

        // Store the next node
        ListNode* front = head->next;

        // Make the next node point back to the current
        front->next = head;

        // Break the current node's forward link
        head->next = NULL;

        // Return the new head of the reversed list
        return newHead;
    }
};

// Driver code
int main() {
    // Creating linked list 1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    Solution sol;
    ListNode* reversed = sol.reverseList(head);

    // Printing reversed list
    while (reversed != NULL) {
        cout << reversed->val << " ";
        reversed = reversed->next;
    }
    cout << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(n)$  
  Each node is visited exactly once during the recursive call, and we do constant-time work for each node (like flipping pointers).

- **Space Complexity:** $O(n)$  
  The recursion stack goes up to n levels deep (one for each node), which uses extra space on the call stack.
