## Add 1 to a Number Represented by a Linked List

**Problem Statement:**  
Given the head of a singly linked list representing a positive integer number. Each node of the linked list represents a digit of the number, with the 1st node containing the leftmost digit of the number and so on. The task is to add one to the value represented by the linked list and return the head of a linked list containing the final value.

The number will contain no leading zeroes except when the value represented is zero itself.

---

> ### Examples:

- **Input:** 4->5->6  
  **Output:** 4->5->7  
  **Explanation:** 456 + 1 = 457

- **Input:** 9->9->9  
  **Output:** 1->0->0->0  
  **Explanation:** 999 + 1 = 1000

---

## Iterative Approach

### Algorithm:

1. Since the least significant digit is at the end of the list, we can’t process it directly using a single traversal. Therefore, to perform addition from the end, we need to reverse the list.
2. Reverse the list and start from the head, and add 1. Carry it forward as needed.
3. If a carry remains after the last node, add a new node with value 1.
4. Reverse the list again to restore the original order and return the head of the modified list.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Node class representing a single digit in the linked list
class Node {
public:
    int data;
    Node* next;

    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// LinkedList class to manage node-level operations
class LinkedList {
public:
    // function to insert digit at the end
    Node* append(Node* head, int value) {
        Node* newNode = new Node(value);
        if (!head) {
            return newNode;
        }
        Node* current = head;
        while (current->next)
            current = current->next;
        current->next = newNode;
        return head;
    }

    // Function to print the list
    void printList(Node* head) {
        Node* current = head;
        while (current) {
            cout << current->data;
            current = current->next;
        }
        cout << endl;
    }
};

// Solution class having the addOne logic 
class Solution {
public:
    // function to reverse the linked list
    Node* reverseList(Node* node) {
        Node* prev = nullptr;
        Node* current = node;

        while (current) {
            Node* nextNode = current->next;
            current->next = prev;
            prev = current;
            current = nextNode;
        }
        return prev;
    }

    // Function to add one to the number represented by the linked list
    Node* addOne(Node* head) {
        // Reverse the list to make the least significant digit accessible
        head = reverseList(head);

        Node* current = head;
        // Initial carry since we want to add 1
        int carry = 1;  

        // Traverse the list and add carry
        while (current && carry) {
            int sum = current->data + carry;
            current->data = sum % 10;
            carry = sum / 10;

            // If there's no next node and we still have a carry, append a new node
            if (!current->next && carry) {
                current->next = new Node(carry);
                carry = 0;  
            }

            current = current->next;
        }

        // Reverse the list back to restore the original order
        head = reverseList(head);
        return head;
    }
};

int main() {
    Node* head = nullptr;
    LinkedList ll;
    Solution sol;

    // Example: Number 129 (1 -> 2 -> 9)
    head = ll.append(head, 1);
    head = ll.append(head, 2);
    head = ll.append(head, 9);

    cout << "Original Number: ";
    ll.printList(head);

    head = sol.addOne(head);

    cout << "After Adding One: ";
    ll.printList(head);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(n)  
  Two reversals plus one pass for addition.

- **Space Complexity:** O(1)  
  An iterative approach, no extra stack or data structure used.


---

## Recursive Approach

### Algorithm:

Since the number is stored in most-significant-digit-first order, it’s difficult to perform addition directly because we need to handle carry from the last digit (least significant digit). Using recursion, we can traverse to the last node first, perform the addition with carry, and propagate the carry backwards.

1. Using a recursive function, traverse to the end of the linked list.
2. Add 1 to the last node and propagate any resulting carry backwards through the recursive calls.
3. At each step, add the carry to the current node's value and update the carry.
4. Once recursion completes, if a carry still remains, create a new node at the beginning of the list with value 1.
5. Return the updated head of the list.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Node class representing a single digit in the linked list
class Node {
public:
    int data;
    Node* next;

    Node(int value) {
        data = value;
        next = nullptr;
    }
};

// LinkedList class having only append and print logic
class LinkedList {
public:
    // Function to insert a digit at the end
    Node* append(Node* head, int value) {
        Node* newNode = new Node(value);
        if (!head) {
            return newNode;
        }
        Node* current = head;
        while (current->next)
            current = current->next;
        current->next = newNode;
        return head;
    }

    // Function to print the list
    void printList(Node* head) {
        Node* current = head;
        while (current) {
            cout << current->data;
            current = current->next;
        }
        cout << endl;
    }
};

// Solution class having the addOne logic
class Solution {
public:
    // Recursive function to add one from the least significant digit (rightmost node)
    int addOneUtil(Node* node) {
        // Base case: when reaching beyond the last node, return carry = 1
        if (!node) return 1;
        
        // Recurse to the end
        int carry = addOneUtil(node->next);  
        int sum = node->data + carry;
        node->data = sum % 10;
        // Return new carry
        return sum / 10;  
    }

    // Function to add one to the number represented by the linked list
    Node* addOne(Node* head) {
        // Perform recursive addition
        int carry = addOneUtil(head);

        // If carry remains after processing the head, create a new head node
        if (carry) {
            Node* newHead = new Node(carry);
            newHead->next = head;
            head = newHead;
        }

        return head;
    }
};

int main() {
    Node* head = nullptr;
    LinkedList ll;
    Solution sol;

    // Example: Number 129 (1 -> 2 -> 9)
    head = ll.append(head, 1);
    head = ll.append(head, 2);
    head = ll.append(head, 9);

    cout << "Original Number: ";
    ll.printList(head);

    head = sol.addOne(head);

    cout << "After Adding One: ";
    ll.printList(head);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(n)  
  One pass for addition using recursion.

- **Space Complexity:** O(n)  
  Auxiliary stack space is used due to recursion.
