## Find pairs with given sum in DLL
**Problem Statement:**  
Given the head of a singly linked list and an integer `sum`, find all pairs of nodes in the linked list whose values add up to the given sum. Return a list of all such pairs.

---

>### Examples:

**Example 1:**  
**Input:** head = `1 -> 2 -> 3 -> 4`, sum = `5`  
**Output:** `[(1, 4), (2, 3)]`  
**Explanation:** `1+4=5` and `2+3=5` are the pairs whose sum is `5`.

**Example 2:**  
**Input:** head = `2 -> 3 -> 5 -> 7`, sum = `10`  
**Output:** `[(3, 7)]`  
**Explanation:** Only `3+7=10`.

---

## Bruteforce

### Algo: 
- Use two pointers to iterate through all possible pairs in the linked list.
- For each node, check all nodes after it to see if their values sum up to the given value.
- Store each valid pair in a result list.

### Steps:

1. Initialize `temp1` to the head of the linked list.
2. While `temp1` is not NULL:
    - Set `temp2` to `temp1->next`.
    - While `temp2` is not NULL and `temp1->val + temp2->val <= sum`:
        - If `temp1->val + temp2->val == sum`, add the pair `(temp1->val, temp2->val)` to the result list.
        - Move `temp2` to `temp2->next`.
    - Move `temp1` to `temp1->next`.
3. Return the result list.


### C++ Code:

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Node structure for singly linked list
struct Node {
    int val;
    Node* next;
    Node(int v) : val(v), next(nullptr) {}
};

// Function to find all pairs with given sum
vector<pair<int, int>> findPairsWithSum(Node* head, int sum) {
    vector<pair<int, int>> result;
    Node* temp1 = head;
    while (temp1 != NULL) {
        Node* temp2 = temp1->next;
        while (temp2 != NULL && temp1->val + temp2->val <= sum) {
            if (temp1->val + temp2->val == sum) {
                result.push_back({temp1->val, temp2->val});
            }
            temp2 = temp2->next;
        }
        temp1 = temp1->next;
    }
    return result;
}

// Helper to print pairs
void printPairs(const vector<pair<int, int>>& pairs) {
    for (auto& p : pairs) {
        cout << "(" << p.first << ", " << p.second << ") ";
    }
    cout << endl;
}

// Driver code
int main() {
    // Create linked list: 1 -> 2 -> 3 -> 4
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);

    int sum = 5;
    vector<pair<int, int>> pairs = findPairsWithSum(head, sum);

    // Output: (1, 4) (2, 3)
    printPairs(pairs);

    // Free memory
    while (head) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(N^2)$  
  where `N` is the number of nodes in the linked list. Each pair is checked once.
- **Space Complexity:** $O(K)$  
  where `K` is the number of pairs found (for storing the result).

---

## Optimized Approach

### Algo:
- Use two pointers: one at the start (`left`) and one at the end (`right`) of the doubly linked list.
- Move the pointers towards each other:
  - If the sum is less than `k`, move `left` forward.
  - If the sum is greater than `k`, move `right` backward.
  - If the sum equals `k`, record the pair and move both pointers.

### Steps:

1. Find the tail of the doubly linked list.
2. Initialize `left` to head and `right` to tail.
3. While `left` is before `right`:
    - If `left->data + right->data == k`, add the pair to the result and move both pointers.
    - If the sum is less than `k`, move `left` forward.
    - If the sum is greater than `k`, move `right` backward.
4. Return the result list.

### C++ Code:

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int v) : data(v), next(nullptr), prev(nullptr) {}
};

// Find the tail of the doubly linked list
Node* findTail(Node* head) {
    Node* tail = head;
    while (tail->next != NULL) tail = tail->next;
    return tail;
}

// Find all pairs with sum k
vector<pair<int, int>> findPairs(Node* head, int k) {
    vector<pair<int, int>> ans;
    if (head == NULL) return ans;
    Node* left = head;
    Node* right = findTail(head);
    while (left->data < right->data) {
        int sum = left->data + right->data;
        if (sum == k) {
            ans.push_back({left->data, right->data});
            left = left->next;
            right = right->prev;
        } else if (sum < k) {
            left = left->next;
        } else {
            right = right->prev;
        }
    }
    return ans;
}

// Driver code
int main() {
    // Create doubly linked list: 1 <-> 2 <-> 3 <-> 4 <-> 5
    Node* head = new Node(1);
    head->next = new Node(2); head->next->prev = head;
    head->next->next = new Node(3); head->next->next->prev = head->next;
    head->next->next->next = new Node(4); head->next->next->next->prev = head->next->next;
    head->next->next->next->next = new Node(5); head->next->next->next->next->prev = head->next->next->next;

    int k = 5;
    vector<pair<int, int>> pairs = findPairs(head, k);

    // Print pairs
    for (auto& p : pairs) {
        cout << "(" << p.first << ", " << p.second << ") ";
    }
    cout << endl;

    // Free memory
    while (head) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(N)$  
  where `N` is the number of nodes in the linked list. Each node is visited at most once by either pointer.
- **Space Complexity:** $O(K)$  
  where `K` is the number of pairs found (for storing the result).
