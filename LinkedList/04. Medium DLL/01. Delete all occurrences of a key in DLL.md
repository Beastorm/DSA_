## Delete all occurrences of a key in the DLL
**Problem Statement:**   
Given the head of a doubly linked list and an integer `k`, delete all occurrences of nodes with value `k` from the list. Return the head of the updated linked list.

---

>### Examples:

**Example 1:**  
**Input:** `1 <-> 2 <-> 3 <-> 2 <-> 4`, k = 2  
**Output:** `1 <-> 3 <-> 4`  
**Explanation:** All nodes with value 2 are removed.

**Example 2:**  
**Input:** `2 <-> 2 <-> 2`, k = 2  
**Output:** (empty list)  
**Explanation:** All nodes are deleted as all have a value of 2.

---

## Approach
### Algo:

- Traverse the doubly linked list.
- For each node, if its value is equal to `k`, remove it from the list.
- If the node to be deleted is the head, update the head pointer.
- Adjust the `prev` and `next` pointers of neighboring nodes to maintain the list structure.
- Free the memory of the deleted node.
- Continue until the end of the list.

### Steps:

1. Initialize a pointer `temp` to the head of the list.
2. While `temp` is not NULL:
    - If `temp->data == k`:
        - If `temp` is the head, update `head` to `temp->next`.
        - Set `nextNode = temp->next` and `prevNode = temp->prev`.
        - If `nextNode` is not NULL, set `nextNode->prev = prevNode`.
        - If `prevNode` is not NULL, set `prevNode->next = nextNode`.
        - Free the memory of `temp`.
        - Move `temp` to `nextNode`.
    - Else, move `temp` to `temp->next`.
3. Return the updated `head`.

---

### C++ Code:

```cpp
#include <iostream>
using namespace std;

// Node structure for a doubly linked list
struct Node {
    int data;
    Node* next;
    Node* prev;
    Node(int val) : data(val), next(NULL), prev(NULL) {}
};

// Insert a node at the end of the list
Node* insertEnd(Node* head, int data) {
    Node* newNode = new Node(data);
    if (!head) return newNode;
    Node* temp = head;
    while (temp->next) temp = temp->next;
    temp->next = newNode;
    newNode->prev = temp;
    return head;
}

// Print all elements in the list
void printList(Node* head) {
    Node* temp = head;
    while (temp) {
        cout << temp->data << " ";
        temp = temp->next;
    }
    cout << endl;
}

// Delete all nodes with value k
Node* deleteAllOccurrences(Node* head, int k) {
    Node* temp = head;
    while (temp != NULL) {
        if (temp->data == k) {
            // Update head if needed
            if (temp == head) head = temp->next;
            Node* nextNode = temp->next;
            Node* prevNode = temp->prev;
            // Fix links
            if (nextNode) nextNode->prev = prevNode;
            if (prevNode) prevNode->next = nextNode;
            delete temp;
            temp = nextNode;
        } else {
            temp = temp->next;
        }
    }
    return head;
}

int main() {
    Node* head = NULL;
    // Build the list: 2 <-> 3 <-> 2 <-> 4 <-> 2
    head = insertEnd(head, 2);
    head = insertEnd(head, 3);
    head = insertEnd(head, 2);
    head = insertEnd(head, 4);
    head = insertEnd(head, 2);

    cout << "Original list: ";
    printList(head);

    int k = 2;
    head = deleteAllOccurrences(head, k);

    cout << "List after deleting all occurrences of " << k << ": ";
    printList(head);

    // Free memory
    while (head) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N)  
  where N is the number of nodes in the linked list. Each node is visited once.
- **Space Complexity:** O(1)  
  As no extra space is used apart from a few pointers.
