## Print all Permutations of a String or Array | Recursion:

**Problem Statement:**  
Given an array `nums` of distinct integers, return all possible permutations. You can return the answer in any order.

---

>### Examples:

### Example 1:

**Input:** `nums = [1, 2, 3]`

**Output:** `[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]`

**Explanation:** All 6 permutations of the array [1, 2, 3].

---

### Example 2:

**Input:** `nums = [0, 1]`

**Output:** `[[0,1], [1,0]]`

**Explanation:** Two permutations are possible.

---

### Example 3:

**Input:** `nums = [1]`

**Output:** `[[1]]`

**Explanation:** Only one permutation is possible.

---

## Approach - I:

### Intuition:

A **permutation** is an arrangement of all elements in different orders. For an array of size `n`, there are `n!` permutations.

**Key Idea:**
- Use **backtracking** to build permutations one element at a time
- At each step, try adding each unused element
- Use a **frequency array** to track which elements have been used
- When the current permutation reaches size `n`, add it to results
- Backtrack by removing the last added element and marking it as unused

**Why frequency array?**
- Prevents using the same element twice in one permutation
- O(1) lookup to check if an element is already used

### Algorithm:

1. Initialize:
   - `ans`: Store all permutations
   - `ds`: Current permutation being built
   - `freq`: Boolean array to mark used elements (0 = unused, 1 = used)

2. Recursive function `recurPermute(ds, nums, ans, freq)`:
   
   **Base case:**
   - If `ds.size() == nums.size()`:
     - Current permutation is complete
     - Add `ds` to `ans`
     - Return

   **Recursive case:**
   - For each index `i` from `0` to `nums.size()-1`:
     - If `freq[i] == 0` (element not used):
       - Mark `freq[i] = 1` (mark as used)
       - Add `nums[i]` to `ds`
       - Recurse to build the rest of the permutation
       - **Backtrack:**
         - Remove `nums[i]` from `ds`
         - Mark `freq[i] = 0` (mark as unused)

3. Call `recurPermute` starting with an empty `ds`.

4. Return `ans` containing all permutations


### Key Points:

- Uses **frequency array** to track used elements
- Each recursion level picks one unused element
- Explores all n choices at level 0, (n-1) at level 1, etc.
- Total recursive calls: n! × n (n! leaves, each needs n operations)
- No sorting required (elements are distinct)
- Backtracking ensures all combinations are explored


### Diagram:
![Permutations - Backtracking with Frequency Array](https://github.com/Beastorm/DSA_/blob/8631af3d3070bd742d1d3e633dc1d82b6ddf6e0d/junk/permutation_.png?raw=true)  
*Backtracking tree representation for generating all permutations of the array [1, 2, 3] using a frequency array to track used elements.*


### C++ Code:
```
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Recursive function to generate permutations
    void recurPermute(
        vector<int> &ds,                  // current permutation (decision sequence)
        vector<int> &nums,                // input numbers
        vector<vector<int>> &ans,         // stores all permutations
        vector<int> &freq                 // frequency array to track used elements
    ) {
        // Base case:
        // If the current permutation size equals the input size,
        //We have formed one complete permutation
        if (ds.size() == nums.size()) {
            ans.push_back(ds);             // store the permutation
            return;                        // stop this recursion branch
        }

        // Try to place each number at the current position
        for (int i = 0; i < nums.size(); i++) {

            // If nums[i] is not used yet
            if (!freq[i]) {

                freq[i] = 1;               // mark nums[i] as used
                ds.push_back(nums[i]);     // choose nums[i]

                // Recurse to fill the next position
                recurPermute(ds, nums, ans, freq);

                // Backtracking step:
                // undo the choice made above
                ds.pop_back();             // remove last added element
                freq[i] = 0;               // mark nums[i] as unused
            }
        }
    }

public:
    vector<vector<int>> permute(vector<int> &nums) {

        vector<vector<int>> ans;           // final answer
        vector<int> ds;                    // current permutation
        vector<int> freq(nums.size(), 0);  // initially, no element is used

        // Start recursion
        recurPermute(ds, nums, ans, freq);

        return ans;                        // return all permutations
    }
};

int main() {
    Solution s;
    vector<int> nums = {1, 2, 3};

    auto res = s.permute(nums);

    for (auto &perm : res) {
        for (int x : perm) cout << x << " ";
        cout << endl;
    }
}

```
### Complexity Analysis

**Time Complexity:** **O(n! × n)**

- **n!** permutations generated
- Each permutation takes **O(n)** time to copy to result
- Total: O(n! × n)

**Space Complexity:** **O(n)**

- **Recursion stack depth:** O(n)
- **Frequency array:** O(n)
- **Current permutation (ds):** O(n)
- **Output space (ans):** O(n! × n) — not counted in auxiliary space

---

## Approach - II (Using Swap mechanism):

### Intuition:

Instead of building permutations element by element using a frequency array, we generate permutations by swapping elements in place.

Core Idea:
- Fix one element at the current position
- Generate all permutations of the remaining elements
- Try fixing each element at the current position by swapping

For [1, 2, 3] at index 0:
- Fix 1 at position 0, permute [2, 3]
- Fix 2 at position 0 (swap 1 and 2), permute [1, 3]
- Fix 3 at position 0 (swap 1 and 3), permute [2, 1]

Why Swap?
- No extra space to track used elements
- The array itself maintains the state
- Elements before the index are fixed
- Elements from the index onwards are candidates

### Algorithm:

Function: recurPermute(index, nums, ans)

**Base Case:**
- If index == nums.size():
  - Current arrangement is a complete permutation
  - Add nums to ans
  - Return

**Recursive Case:**
1. Loop i from index to nums.size() - 1:
   - Swap nums[index] with nums[i] (fix nums[i] at position index)
   - Recurse: recurPermute(index + 1, nums, ans)
   - Backtrack: Swap back nums[index] with nums[i]

**Main Function:**
1. Initialize empty ans
2. Call recurPermute(0, nums, ans)
3. Return ans

### Key Advantages:

- Space Efficient: No extra arrays needed
- In-place: Modifies the array during recursion
- Cleaner Code: Fewer variables to manage
- Optimal: No unnecessary data structure overhead

### Why Backtracking is Critical?

Without swap back, the array remains modified, and the next iterations work on the wrong state.

Example:
index=0, nums=[1,2,3]

i=0: swap(0,0) → [1,2,3], recurse, swap back → [1,2,3]
i=1: swap(0,1) → [2,1,3], recurse, swap back → [1,2,3]
i=2: swap(0,2) → [3,2,1], recurse, swap back → [1,2,3]

Each iteration must start from the original state.

### Diagram:
![Permutations - Swap Mechanism](https://github.com/Beastorm/DSA_/blob/e3b82784ca6007c027725bfecc39c5fd60bb22ed/junk/permutation_swap.png?raw=true)  
*Permutation generation using the in-place swap method — fixing each index by swapping and exploring all possible configurations recursively.*

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    void recurPermute(int index, vector<int> &nums, vector<vector<int>> &ans) {
        // Base case: reached end of array, one permutation is complete
        if (index == nums.size()) {
            ans.push_back(nums);
            return;
        }

        // Try swapping the current index with every index from the current to the end
        for (int i = index; i < nums.size(); i++) {
            // Swap current element with element at index i
            swap(nums[index], nums[i]);
            
            // Recurse for next index
            recurPermute(index + 1, nums, ans);
            
            // Backtrack: swap back to restore the original array
            swap(nums[index], nums[i]);
        }
    }

public:
    vector<vector<int>> permute(vector<int> &nums) {
        vector<vector<int>> ans;
        recurPermute(0, nums, ans);
        return ans;
    }
};

// Driver code
int main() {
    Solution sol;
    vector<int> nums = {1, 2, 3};
    vector<vector<int>> result = sol.permute(nums);
    
    cout << "All Permutations:" << endl;
    for (auto perm : result) {
        cout << "[";
        for (int i = 0; i < perm.size(); i++) {
            cout << perm[i];
            if (i != perm.size() - 1) cout << ",";
        }
        cout << "]" << endl;
    }
    
    return 0;
}
```

### Complexity Analysis:

**Time Complexity:** O(n! × n)
- n! permutations to generate
- O(n) to copy each permutation to the result
- Total recursive calls exploring the tree: O(n × n!)

**Space Complexity:** O(n)
- Recursion stack depth: O(n)
- No extra data structures needed
- In-place swapping: O(1) auxiliary space
- Output space O(n! × n) not counted
