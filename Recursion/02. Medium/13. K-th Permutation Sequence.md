## K-th Permutation Sequence

**Problem Statement:**
Given `n` and `k`, return the `k-th` permutation sequence of numbers from `1` to `n`.

The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations. By listing and labeling all permutations in order, we can get the sequence at position `k`.

---

>### Examples:

### Example 1:

**Input:** `n = 3`, `k = 3`

**Output:** `"213"`

**Explanation:**  
All permutations in order:
1. "123"
2. "132"
3. "213" ← k=3
4. "231"
5. "312"
6. "321"

---

### Example 2:

**Input:** `n = 4`, `k = 9`

**Output:** `"2314"`

**Explanation:**  
The 9th permutation of [1,2,3,4] is "2314".

---

### Example 3:

**Input:** `n = 3`, `k = 1`

**Output:** `"123"`

**Explanation:**  
The first permutation is "123".

---

### Constraints:

- `1 <= n <= 9`
- `1 <= k <= n!`

---

## Approach - Brute Force

### Intuition:

Generate all possible permutations of [1, 2, ..., n], sort them in lexicographic order, and pick the k-th one.

For n=3:
Generated permutations → Sort → Pick k-th
```
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]
After sorting: 1.[1,2,3], 2.[1,3,2], 3.[2,1,3] (k=3), 4.[2,3,1], 5.[3,1,2], 6.[3,2,1]
```
This approach is straightforward but inefficient - it computes all n! permutations even though we only need one.

### Algorithm:

1. Create initial array nums = [1, 2, 3, ..., n]

2. Generate all permutations using backtracking:
   - For each position index from 0 to n-1
   - Try fixing each remaining element at the current position
   - Swap nums[index] with nums[i] for i from index to n-1
   - Recursively generate permutations for remaining positions
   - Backtrack by swapping back
   - When the index reaches n, store the current permutation

3. Sort all permutations lexicographically

4. Pick the k-th permutation (index k-1 since 0-indexed)

5. Convert the permutation vector to a string and return
 Technical interviews (shows lack of optimization)


### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    void generatePermutations(int index, vector<int>& nums, vector<vector<int>>& all) {
        if (index == nums.size()) {
            all.push_back(nums);  // Store one full permutation
            return;
        }

        for (int i = index; i < nums.size(); i++) {
            swap(nums[index], nums[i]); // Fix element at current index
            generatePermutations(index + 1, nums, all);
            swap(nums[index], nums[i]); // Backtrack
        }
    }

public:
    string getPermutation(int n, int k) {
        // Step 1: Create initial array [1, 2, ..., n]
        vector<int> nums;
        for (int i = 1; i <= n; ++i) {
            nums.push_back(i);
        }

        // Step 2: Generate all permutations
        vector<vector<int>> allPermutations;
        generatePermutations(0, nums, allPermutations);

        // Step 3: Sort lexicographically
        sort(allPermutations.begin(), allPermutations.end());

        // Step 4: Pick the (k-1)th permutation (0-indexed)
        vector<int>& kth = allPermutations[k - 1];

        // Step 5: Convert vector<int> to string
        string result;
        for (int num : kth) {
            result += to_string(num);
        }

        return result;
    }
};

// Driver Code
int main() {
    Solution sol;

    int n, k;
    cin >> n >> k;

    string result = sol.getPermutation(n, k);

    cout << "The " << k << "-th permutation of [1.." << n << "] is: " << result << endl;

    return 0;
}
```
### Complexity Analysis:

Time Complexity: O(n! × n × log(n!))
- Generate all permutations: O(n! × n)
- Sort n! permutations: O(n! × log(n!) × n)
- Pick k-th: O(1)
- Convert to string: O(n)

Space Complexity: O(n! × n)
- Store all n! permutations: O(n! × n)
- Recursion stack: O(n)

### Practical Impact:

| n | Permutations | Time | Space | Practical? |
|---|-------------|------|-------|------------|
| 3 | 6 | Instant | 24 bytes | Yes |
| 4 | 24 | Instant | 96 bytes | Yes |
| 5 | 120 | 1ms | 600 bytes | Yes |
| 6 | 720 | 10ms | 3.6 KB | Acceptable |
| 7 | 5,040 | 100ms | 35 KB | Slow |
| 8 | 40,320 | 1-2s | 322 KB | Very slow |
| 9 | 362,880 | 30s+ | 3.3 MB | Unacceptable |

### When to Use:

Good for:
- Small inputs (n less than or equal to 6)
- Learning and understanding permutations
- Verification of optimal solutions

Not good for:
- Large inputs (n greater than 6)
- Production code

---

## Optimal Approach

### Intuition:

Instead of generating all n! permutations, we can directly compute the k-th permutation using the factorial number system.

Key observation: Permutations follow a mathematical pattern based on factorials.

For n=4, permutations starting with each digit:
- Starting with 1: positions 1-6 (3! = 6 permutations)
- Starting with 2: positions 7-12 (3! = 6 permutations)
- Starting with 3: positions 13-18 (3! = 6 permutations)
- Starting with 4: positions 19-24 (3! = 6 permutations)

Pattern: First digit changes every (n-1)! permutations

To find the 9th permutation:
- 9 divided by 6 = 1 (with remainder 3)
- Index 1 in [1,2,3,4] is 2
- First digit is 2

Continue this process for each position using the remainder and reduced factorial.

This allows us to build the k-th permutation digit by digit without generating all permutations.

### Algorithm:

1. Compute (n-1)! and store it in fact
   - Also create a numbers array [1, 2, 3, ..., n]

2. Convert k to 0-based index: k = k - 1

3. While the numbers array is not empty:
   - Find which block k falls into: index = k / fact
   - Pick the number at that index: ans += numbers[index]
   - Remove the used number from the numbers array
   - Update k to position within current block: k = k % fact
   - Update factorial for next iteration: fact = fact/numbers.size()

4. Return the built permutation string



### C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    string getPermutation(int n, int k) {
        int fact = 1;
        vector<int> numbers;

        // Compute (n-1)! and store numbers 1 to n
        for (int i = 1; i < n; i++) {
            fact = fact * i;
            numbers.push_back(i);
        }
        numbers.push_back(n);

        string ans = "";

        // Convert k to 0-based index
        k = k - 1;

        while (true) {
            // Pick the element at index k / fact
            ans += to_string(numbers[k / fact]);

            // Remove used number
            numbers.erase(numbers.begin() + k / fact);

            // If no numbers left, break
            if (numbers.size() == 0)
                break;

            // Reduce k for next block
            k = k % fact;

            // Update factorial for remaining digits
            fact = fact / numbers.size();
        }

        return ans;
    }
};

int main() {
    Solution sol;

    // Test case 1
    cout << "n = 3, k = 3" << endl;
    cout << "Output: " << sol.getPermutation(3, 3) << endl;
    cout << "Expected: 213" << endl << endl;

    // Test case 2
    cout << "n = 4, k = 9" << endl;
    cout << "Output: " << sol.getPermutation(4, 9) << endl;
    cout << "Expected: 2314" << endl << endl;

    // Test case 3
    cout << "n = 3, k = 1" << endl;
    cout << "Output: " << sol.getPermutation(3, 1) << endl;
    cout << "Expected: 123" << endl << endl;

    // Test case 4
    cout << "n = 4, k = 24" << endl;
    cout << "Output: " << sol.getPermutation(4, 24) << endl;
    cout << "Expected: 4321" << endl << endl;

    return 0;
}
```

### Complexity Analysis:

**Time Complexity:** O(n^2)
- Initial loop to compute factorial and fill numbers: O(n)
- Main while loop runs n times
- Each iteration: O(1) for division/modulo, O(n) for erase
- Total: O(n × n) = O(n^2)

**Space Complexity:** O(n)
- numbers array: O(n)
- ans string: O(n)
- No recursion or extra storage
