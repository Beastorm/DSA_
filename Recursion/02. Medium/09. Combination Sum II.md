## Combination Sum II - Find All Unique Combinations

**Problem Statement:**
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.

**Key constraint:** Each number in the candidates may only be used once in the combination.

---

>### Examples:

### Example 1:
**Input:** candidates = [10,1,2,7,6,1,5], target = 8    
**Output:** 
```
[
  [1,1,6],
  [1,2,5],
  [1,7],
  [2,6]
]
```
**Explanation:** These are the unique combinations whose sum is equal to the target.

---

### Example 2:
**Input:** candidates = [2,5,2,1,2], target = 5    
**Output:**  ``` [[1,2,2], [5]]```    
**Explanation:** These are the unique combinations whose sum is equal to the target.

---

### Example 3: Multiple Duplicates
**Input:** candidates = [10, 1, 2, 7, 6, 1, 5], target = 8    

**Without Sorting and Duplicate Handling:**    
*Unsorted array:* [10, 1, 2, 7, 6, 1, 5]    
*Duplicate combinations generated:*       
```
- [1, 1, 6] from indices [1, 5, 4]
- [1, 1, 6] from indices [5, 1, 4]
- [1, 7] from indices [1, 3]
- [1, 7] from indices [5, 3]
- [1, 2, 5] from indices [1, 2, 6]
- [1, 2, 5] from indices [5, 2, 6]
- [2, 6] from indices [2, 4]
```
*Result:* ``` [[1,1,6], [1,1,6], [1,7], [1,7], [1,2,5], [1,2,5], [2,6]]```   
*Status:* DUPLICATES! Wrong answer    

**With Sorting and Duplicate Handling:**     

*After sorting:* ```[1, 1, 2, 5, 6, 7, 10]```     

*At each level:*   
- Pick 1 (index 0) and explore deeper
- Skip 1 (index 1) because i > index and candidates[1] == candidates[0]
- Pick 2 (index 2) and explore deeper
- Pick 5, 6, 7 similarly

*Result:* [[1,1,6], [1,2,5], [1,7], [2,6]]    

*Status:* Correct, no duplicates    

---

### Example 4: Three Identical Elements

**Input:** candidates = [2, 5, 2, 1, 2], target = 5    

**Without Sorting and Duplicate Handling:**    

*Unsorted array:* [2, 5, 2, 1, 2]    

*Duplicate combinations generated:*   
```
- [1, 2, 2] from indices [3, 0, 2]
- [1, 2, 2] from indices [3, 0, 4]
- [1, 2, 2] from indices [3, 2, 0]
- [1, 2, 2] from indices [3, 2, 4]
- [1, 2, 2] from indices [3, 4, 0]
- [1, 2, 2] from indices [3, 4, 2]
- [5] from index [1]
```
*Result:* ```[[1,2,2], [1,2,2], [1,2,2], [1,2,2], [1,2,2], [1,2,2], [5]]```     

*Status:* 6 duplicates of [1,2,2]! Wrong answer    

**With Sorting and Duplicate Handling:**    

*After sorting:* [1, 2, 2, 2, 5]     

*Recursion process:*     
- Level 0: Pick 1, Pick 2 (first), Skip 2 (second/third), Pick 5
- Level 1 (after 1): Pick 2 (first), Pick 2 (second - different level allowed), Skip 2 (third)
- Result: [1,2,2] generated exactly once

*Result:* ```[[1,2,2], [5]]```       

*Status:* Correct, no duplicates    

---

## Approach

### Algorithm:

1. Sort the array before starting recursion to:
   - Ensure combinations are in sorted order
   - Group duplicates together for easier skipping
   - Enable early termination when elements exceed the target

2. Begin recursion from index 0 and explore each element for inclusion in the current combination

3. If the current element is suitable (less than or equal to the target):
   - Add it to the combination
   - Move to the next index (not the same index, since each element can be used only once)

4. Skip over duplicate elements to avoid generating the same combination again:
   - After processing an element at index i, skip all subsequent elements with the same value

5. Backtrack by removing the last added element from the combination after the recursive call

6. Terminate early if the current element exceeds the target:
   - Since the array is sorted, all further elements will be larger
   - No need to explore further

### Key Differences from Combination Sum I:

| Aspect | Combination Sum I | Combination Sum II |
|--------|-------------------|-------------------|
| Element reuse | Same element can be reused unlimited times | Each element can be used only once |
| Duplicates in input | Array has distinct elements | Array may contain duplicates |
| Duplicate handling | Not needed | Must skip duplicate values |
| Recursion call | Stay at same index when picking | Move to next index when picking |
| Sorting required | Optional | Required (to handle duplicates) |

### Algorithm Steps:

1. Sort the candidates array

2. Define recursive function(index, target, current_combination):
   
   a. Base case: if target == 0
      - Add current_combination to results
      - Return
   
   b. For i from index to end of array:
      - If i > index AND candidates[i] == candidates[i-1]:
        - Skip (avoid duplicates)
      
      - If candidates[i] > target:
        - Break (early termination, array is sorted)
      
      - Add candidates[i] to current_combination
      - Recurse with (i + 1, target - candidates[i], current_combination)
      - Remove candidates[i] from current_combination (backtrack)

3. Call the recursive function starting from index 0

### Diagram:
![Combination Sum II - Backtracking Tree](https://github.com/Beastorm/DSA_/blob/ffdf15a50216988290ddeb11caeb3dccb40b4a38/junk/combination_sum-II.png?raw=true)  


### C++ Code:

``` cpp

#include<bits/stdc++.h>
using namespace std;

// Function to find all unique combinations of numbers that sum up to the target
void findUniqueCombinationsRecursive(int currentIndex, int remainingTarget, 
                                      vector<int>& candidateNumbers, 
                                      vector<vector<int>>& allUniqueCombinations, 
                                      vector<int>& currentCombination) {
    // Base case: If the remaining target becomes 0, we found a valid combination
    if (remainingTarget == 0) {
        allUniqueCombinations.push_back(currentCombination);
        return;
    }

    // Loop through the elements starting from currentIndex
    for (int nextIndex = currentIndex; nextIndex < candidateNumbers.size(); nextIndex++) {
        // Skip duplicates to avoid repeating combinations
        if (nextIndex > currentIndex && candidateNumbers[nextIndex] == candidateNumbers[nextIndex - 1]) {
            continue;
        }

        // If the current element exceeds the remaining target, break (array is sorted)
        if (candidateNumbers[nextIndex] > remainingTarget) {
            break;
        }

        // Include the current element in the combination
        currentCombination.push_back(candidateNumbers[nextIndex]);

        // Recur with updated target and next index (nextIndex + 1 to avoid reusing same element)
        findUniqueCombinationsRecursive(nextIndex + 1, 
                                         remainingTarget - candidateNumbers[nextIndex], 
                                         candidateNumbers, 
                                         allUniqueCombinations, 
                                         currentCombination);

        // Backtrack by removing the last added element
        currentCombination.pop_back();
    }
}

// Function to calculate all unique combinations that sum up to the target
vector<vector<int>> findCombinationSumUnique(vector<int>& candidateNumbers, int targetSum) {
    // Sort the candidates to handle duplicates and enable early termination
    sort(candidateNumbers.begin(), candidateNumbers.end());
    
    vector<vector<int>> allUniqueCombinations;
    vector<int> currentCombination;
    
    findUniqueCombinationsRecursive(0, targetSum, candidateNumbers, allUniqueCombinations, currentCombination);
    
    return allUniqueCombinations;
}

int main() {
    // Example input: candidate numbers with duplicates
    vector<int> candidateNumbers = {10, 1, 2, 7, 6, 1, 5};
    int targetSum = 8;

    // Get all unique combinations that sum up to targetSum
    vector<vector<int>> validCombinations = findCombinationSumUnique(candidateNumbers, targetSum);

    // Output the combinations
    cout << "[ ";
    for (const auto& combination : validCombinations) {
        cout << "[ ";
        for (int number : combination) {
            cout << number << " ";
        }
        cout << "]";
    }
    cout << " ]" << endl;

    return 0;
}

```

### Complexity Analysis:

- **Time Complexity:** O(2^n * k)
  - In worst case, explore all subsets: O(2^n)
  - Each valid combination takes O(k) to copy (k = avg combination length)

- **Space Complexity:** O(k * x)
  - x = number of valid combinations
  - k = average length of combinations
  - Recursion stack: O(n) in worst case
