## Combination Sum II - Find All Unique Combinations

**Problem Statement:**
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.

**Key constraint:** Each number in the candidates may only be used once in the combination.

---

>### Examples:

### Example 1:
**Input:** candidates = [10,1,2,7,6,1,5], target = 8    
**Output:** 
```
[
  [1,1,6],
  [1,2,5],
  [1,7],
  [2,6]
]
```
**Explanation:** These are the unique combinations whose sum is equal to the target.

---

### Example 2:
**Input:** candidates = [2,5,2,1,2], target = 5    
**Output:**  ``` [[1,2,2], [5]]```    
**Explanation:** These are the unique combinations whose sum is equal to the target.

---

### Example 3: Multiple Duplicates
**Input:** candidates = [10, 1, 2, 7, 6, 1, 5], target = 8    

**Without Sorting and Duplicate Handling:**    
*Unsorted array:* [10, 1, 2, 7, 6, 1, 5]    
*Duplicate combinations generated:*       
```
- [1, 1, 6] from indices [1, 5, 4]
- [1, 1, 6] from indices [5, 1, 4]
- [1, 7] from indices [1, 3]
- [1, 7] from indices [5, 3]
- [1, 2, 5] from indices [1, 2, 6]
- [1, 2, 5] from indices [5, 2, 6]
- [2, 6] from indices [2, 4]
```
*Result:* ``` [[1,1,6], [1,1,6], [1,7], [1,7], [1,2,5], [1,2,5], [2,6]]```   
*Status:* DUPLICATES! Wrong answer    

**With Sorting and Duplicate Handling:**     

*After sorting:* ```[1, 1, 2, 5, 6, 7, 10]```     

*At each level:*   
- Pick 1 (index 0) and explore deeper
- Skip 1 (index 1) because i > index and candidates[1] == candidates[0]
- Pick 2 (index 2) and explore deeper
- Pick 5, 6, 7 similarly

*Result:* [[1,1,6], [1,2,5], [1,7], [2,6]]    

*Status:* Correct, no duplicates    

---

### Example 4: Three Identical Elements

**Input candidates** = [2, 5, 2, 1, 2], target = 5    

**Without Sorting and Duplicate Handling:**    

*Unsorted array:* [2, 5, 2, 1, 2]    

*Duplicate combinations generated:*   
```
- [1, 2, 2] from indices [3, 0, 2]
- [1, 2, 2] from indices [3, 0, 4]
- [1, 2, 2] from indices [3, 2, 0]
- [1, 2, 2] from indices [3, 2, 4]
- [1, 2, 2] from indices [3, 4, 0]
- [1, 2, 2] from indices [3, 4, 2]
- [5] from index [1]
```
*Result:* ```[[1,2,2], [1,2,2], [1,2,2], [1,2,2], [1,2,2], [1,2,2], [5]]```     

*Status:* 6 duplicates of [1,2,2]! Wrong answer    

**With Sorting and Duplicate Handling:**    

*After sorting:* [1, 2, 2, 2, 5]     

*Recursion process:*     
- Level 0: Pick 1, Pick 2 (first), Skip 2 (second/third), Pick 5
- Level 1 (after 1): Pick 2 (first), Pick 2 (second - different level allowed), Skip 2 (third)
- Result: [1,2,2] generated exactly once

*Result:* ```[[1,2,2], [5]]```       

*Status:* Correct, no duplicates    

---

## Approach

### Algorithm:

1. Sort the array before starting recursion to:
   - Ensure combinations are in sorted order
   - Group duplicates together for easier skipping
   - Enable early termination when elements exceed the target

2. Begin recursion from index 0 and explore each element for inclusion in the current combination

3. If the current element is suitable (less than or equal to the target):
   - Add it to the combination
   - Move to the next index (not the same index, since each element can be used only once)

4. Skip over duplicate elements to avoid generating the same combination again:
   - After processing an element at index i, skip all subsequent elements with the same value

5. Backtrack by removing the last added element from the combination after the recursive call

6. Terminate early if the current element exceeds the target:
   - Since the array is sorted, all further elements will be larger
   - No need to explore further

### Key Differences from Combination Sum I:

| Aspect | Combination Sum I | Combination Sum II |
|--------|-------------------|-------------------|
| Element reuse | Same element can be reused unlimited times | Each element can be used only once |
| Duplicates in input | Array has distinct elements | Array may contain duplicates |
| Duplicate handling | Not needed | Must skip duplicate values |
| Recursion call | Stay at same index when picking | Move to next index when picking |
| Sorting required | Optional | Required (to handle duplicates) |

### Algorithm Steps:

1. Sort the candidates array

2. Define recursive function(index, target, current_combination):
   
   a. Base case: if target == 0
      - Add current_combination to results
      - Return
   
   b. For i from index to end of array:
      - If i > index AND candidates[i] == candidates[i-1]:
        - Skip (avoid duplicates)
      
      - If candidates[i] > target:
        - Break (early termination, array is sorted)
      
      - Add candidates[i] to current_combination
      - Recurse with (i + 1, target - candidates[i], current_combination)
      - Remove candidates[i] from current_combination (backtrack)

3. Call the recursive function starting from index 0

### Diagram:
![Combination Sum II - Backtracking Tree](https://github.com/Beastorm/DSA_/blob/ffdf15a50216988290ddeb11caeb3dccb40b4a38/junk/combination_sum-II.png?raw=true)  


### C++ Code:

``` cpp
#include<bits/stdc++.h>
using namespace std;

// Function to find all combinations of numbers that sum up to the target
void findCombination(int ind, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& ds) {
    // Base case: If the target becomes 0, we found a valid combination
    if (target == 0) {
        ans.push_back(ds);  // Add the current combination to the result
        return;
    }

    // Loop through the elements starting from index ind
    for (int i = ind; i < arr.size(); i++) {
        // Skip duplicates to avoid repeating combinations
        if (i > ind && arr[i] == arr[i - 1]) continue;

        // If the current element is greater than the remaining target, break the loop
        if (arr[i] > target) break;

        // Include the current element in the combination
        ds.push_back(arr[i]);

        // Recur with the updated target and next index (i + 1 to avoid repetition)
        findCombination(i + 1, target - arr[i], arr, ans, ds);

        // Backtrack by removing the last added element
        ds.pop_back();
    }
}

// Function to calculate all unique combinations that sum up to the target
vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
    sort(candidates.begin(), candidates.end());  // Sort the candidates to handle duplicates
    
    vector<vector<int>> ans;  // To store the final answer
    
    vector<int> ds;  // To store the current combination
    
    findCombination(0, target, candidates, ans, ds);  // Call the helper function
    
    return ans;  // Return all valid combinations
}

int main() {
    // Example input
    vector<int> v{10, 1, 2, 7, 6, 1, 5};

    // Get all combinations that sum up to 8
    vector<vector<int>> comb = combinationSum2(v, 8);

    // Output the combinations
    cout << "[ ";
    for (int i = 0; i < comb.size(); i++) {
        cout << "[ ";
        for (int j = 0; j < comb[i].size(); j++) {
            cout << comb[i][j] << " ";
        }
        cout << "]";
    }
    cout << " ]";

    return 0;
}

```

### Complexity Analysis:

- **Time Complexity:** O(2^n * k)
  - In worst case, explore all subsets: O(2^n)
  - Each valid combination takes O(k) to copy (k = avg combination length)

- **Space Complexity:** O(k * x)
  - x = number of valid combinations
  - k = average length of combinations
  - Recursion stack: O(n) in worst case
