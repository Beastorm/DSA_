## Combination Sum - I

**Problem Statement:**  

Given an array of distinct integers and a target, return the list of all unique combinations where the chosen numbers sum to the target. You may return the combinations in any order.

- The same number may be chosen from the array an unlimited number of times
- Two combinations are unique if the frequency of at least one chosen number is different
- It is guaranteed that the number of unique combinations is less than 150

---

>### Examples:

### Example 1:

**Input:** `array = [2,3,6,7]`, `target = 7`

**Output:** `[[2,2,3], [7]]`

**Explanation:**
- 2 and 3 are candidates, and 2 + 2 + 3 = 7 (Note: 2 can be used multiple times)
- 7 is a candidate, and 7 = 7
- These are the only two combinations

---

### Example 2:

**Input:** `array = [2]`, `target = 1`

**Output:** `[]`

**Explanation:** No combination is possible

---

## Approach

### Intuition:

For problems involving printing combinations or subsequences, **recursion** should be the first approach that comes to mind.

**How to think recursively?**

When the problem involves picking elements from an array to form a combination, use the **" pick and non-pick " approach**.


### Algorithm:

We use a **recursive backtracking** approach to find all combinations that sum up to the target.

**Recursive function parameters:**
- `index`: Current position in the array
- `target`: Remaining sum we need to achieve
- `ds`: Data structure to store the current combination

**At every step, we have two choices:**

1. **Pick** the element at the current index:
   - Reduce the target by `arr[index]`
   - Add `arr[index]` to `ds`
   - Stay on the same index (since we can reuse the same element)

2. **Not pick** the element:
   - Move to the next index
   - Target remains unchanged
   - Element is not added to `ds`

**Backtracking:**
- While backtracking, remove the last inserted element to explore new paths
- This process is repeated while `index < array.size()`

**Base case:**
- When `target == 0`, we have found a valid combination
- When `index >= array.size()` or `target < 0`, stop recursion


### Diagram:
![Combination Sum I - Backtracking Tree](https://github.com/Beastorm/DSA_/blob/2e16e86f2bd58c1f2ea048311e6656e86d8d331e/junk/combination_sum-I.png?raw=true)  

### C++ Code:

``` cpp
#include<bits/stdc++.h>
using namespace std;

class CombinationSumFinder {
public:
    // Function to find all combinations of numbers that sum up to the target
    void findCombinationsRecursive(int currentIndex, int remainingTarget, 
                                    vector<int>& candidates, 
                                    vector<vector<int>>& allCombinations, 
                                    vector<int>& currentCombination) {
        // Base case: if we have considered all elements in the array
        if (currentIndex == candidates.size()) {
            // If the remaining target is zero, we have found a valid combination
            if (remainingTarget == 0) {
                allCombinations.push_back(currentCombination);
            }
            return;
        }

        // Recursive case: pick the element if it's less than or equal to the remaining target
        if (candidates[currentIndex] <= remainingTarget) {

            // Add the current element to the combination
            currentCombination.push_back(candidates[currentIndex]);

            // Continue with the same index to allow repeated elements
            findCombinationsRecursive(currentIndex, 
                                       remainingTarget - candidates[currentIndex], 
                                       candidates, 
                                       allCombinations, 
                                       currentCombination);

            // Backtrack by removing the last added element
            currentCombination.pop_back();
        }

        // Skip the current element and move to the next index
        findCombinationsRecursive(currentIndex + 1, 
                                   remainingTarget, 
                                   candidates, 
                                   allCombinations, 
                                   currentCombination);
    }

    // Main function to get all combinations
    vector<vector<int>> findAllCombinations(vector<int>& candidates, int targetSum) {
        vector<vector<int>> allCombinations;
        vector<int> currentCombination;

        findCombinationsRecursive(0, targetSum, candidates, allCombinations, currentCombination);

        return allCombinations;
    }
};

int main() {
    CombinationSumFinder finder;

    vector<int> candidateNumbers = {2, 3, 6, 7};
    int targetSum = 7;

    vector<vector<int>> validCombinations = finder.findAllCombinations(candidateNumbers, targetSum);

    cout << "Combinations are: " << endl;
    for (const auto& combination : validCombinations) {
        for (int number : combination) {
            cout << number << " ";
        }
        cout << endl;
    }

    return 0;
}
```

###  Complexity Analysis:

- **Time Complexity:** `O(2^t * k)`

   - We explore all possible combinations that can sum up to `target = t`.
   - At each step, we make two choices: **pick** or **not pick** → leading to an exponential number of calls.
   - Worst-case: Up to `2^t` recursive calls.
   - For each valid combination, we copy it to the result → takes `O(k)` time on average, where `k` is the average size of one combination.

- **Space Complexity:** `O(k * x)`
   
   - `x` = total number of valid combinations.
   - `k` = average length of each combination.
   - We store all combinations in memory, leading to `O(k * x)` space usage.
   - Additional recursive call stack space can go up to `O(t)` (target level depth).
