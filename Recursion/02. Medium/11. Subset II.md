## Subset II - Print All Unique Subsets

**Problem Statement:**  
Given an integer array `nums` that may contain duplicate entries, return the power set (all possible subsets). The solution set must **not contain duplicate subsets**. Return the answer in any order.

---

>### Examples:

### Example 1:

**Input:** `array[] = [1, 2, 2]`

**Output:** `[[], [1], [1,2], [1,2,2], [2], [2,2]]`

**Explanation:**  
We can have subsets ranging from length 0 to 3. The subset `[1,2]` could appear twice during generation, but is printed only once as we require only unique subsets.

---

### Example 2:

**Input:** `array[] = [1]`

**Output:** `[[], [1]]`

**Explanation:**  
Only two unique subsets are available.

---

## Brute Force Approach

### Algorithm:

To find all unique subsets from an array like `[1, 2, 2]`, the most direct way is to first generate every possible combination of elements (subsets). We can do this with a **"pick" or "don't pick"** choice for each element.

This process, however, will create duplicates, like generating `[1, 2]` twice. To solve this, we store all the generated subsets in a **Set**, which automatically discards any duplicates. After generating all possibilities, we copy the unique subsets from the Set to a list for the final answer.


### Steps:

1. Define a **recursive function** to generate subsets
2. **Base case:** When all elements of the input array have been considered:
   - The currently formed subset is complete
   - Insert this subset into a **Set** to automatically handle uniqueness
3. For each element in the array, make **two recursive calls**:
   - One where the element is **included** in the subset
   - Another where it is **not included**
4. The main function will:
   - Initialize a Set to store unique results
   - Start the recursion from the first element
   - Convert the Set of unique subsets into a list and return it

### Diagram:
![Subset II - Unique Subsets Using Set](https://github.com/Beastorm/DSA_/blob/0cb1c5ff11b4f67fa482ed0106e579d9b949e4bb/junk/subset_II.png?raw=true)  
*Brute-force generation of all subsets with duplicate handling using a set to ensure unique subsets are kept.*

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Recursive helper to generate all subsets
    void findSubsets(int ind, vector<int>& nums, vector<int>& ds, set<vector<int>>& result) {
        // Base case: if we've considered all elements, add the current subset to the result set
        if (ind == nums.size()) {
            result.insert(ds);
            return;
        }

        // Choice 1: Include the element at the current index
        ds.push_back(nums[ind]);

        findSubsets(ind + 1, nums, ds, result);

        // Backtrack to explore the other choice
        ds.pop_back();

        // Choice 2: Do not include the element at the current index
        findSubsets(ind + 1, nums, ds, result);
    }

    // Main function to find all unique subsets
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        set<vector<int>> result;

        vector<int> ds;

        // Sort the array to handle duplicates consistently
        sort(nums.begin(), nums.end());
        
        findSubsets(0, nums, ds, result);

        // Convert the set of unique subsets to a vector for the final answer
        vector<vector<int>> ans(result.begin(), result.end());


        return ans;
    }
};

// Driver code to test the solution
int main() {
    Solution sol;
    vector<int> nums = {1, 2, 2};
    vector<vector<int>> ans = sol.subsetsWithDup(nums);
    
    // Print the result
    cout << "[ ";
    for (const auto& subset : ans) {
        cout << "[ ";
        for (int num : subset) {
            cout << num << " ";
        }
        cout << "] ";
    }
    cout << "]" << endl;

    return 0;
}
```

### Complexity Analysis:

**Time Complexity:** O(2^N × N)
- O(2^N) subsets generated
- O(N) to copy each subset
- Set operations add O(N) for comparison

**Space Complexity:** O(2^N × N)
- O(2^N) subsets stored
- Each subset can have up to N elements
- Recursion stack: O(N)

---

## Subset II - Optimal Approach

### Algorithm:

Instead of generating all subsets and then removing duplicates, we can **avoid creating duplicates in the first place**. This is done by:

1. **Sorting the input array** first so that all duplicate numbers are adjacent
2. While generating subsets through backtracking, if we encounter a number that is the **same as the previous one** and it's **not the first** in the current recursive call, we **skip it**

This pruning step ensures we only generate unique subsets without extra storage for duplicate removal.

**Why sorting is essential:**  
Without sorting, duplicates would be scattered and hard to skip correctly. This method is efficient and avoids unnecessary subset generation, making it better in both runtime and memory usage compared to the brute force approach.

---

### Steps:

1. **Sort the input array** so that duplicates are adjacent

2. Initialize:
   - A list to store the current subset
   - A list of lists to store all unique subsets

3. Use a **recursive backtracking function** that:
   - Adds the current subset to the list of results
   - Iterates from the current index to the end of the array
   - **Skip duplicates:** If the current element is the same as the previous one and not at the starting index of this recursion, skip it
   - Include the current element in the subset and recurse for the next index
   - Backtrack by removing the last added element

4. Return the list of all unique subsets


### Key Difference from Brute Force

| Aspect | Brute Force | Optimal |
|--------|-------------|---------|
| **Duplicate handling** | Generate all, use Set to filter | Skip duplicates during generation |
| **Space for duplicates** | Set stores all attempts | No extra space needed |
| **Efficiency** | O(2^N × N × log(2^N)) | O(2^N × N) |
| **When to skip** | After generation | During generation |


### Diagram:
![Subset II - Optimal Backtracking](https://github.com/Beastorm/DSA_/blob/b16ca70917ccd789c67fa5db3d021bbc24a2b9a0/junk/subset-II_optimal.png?raw=true)  
*Optimized backtracking tree for generating unique subsets from a sorted array, avoiding duplicates by pruning during recursion.*

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to generate all unique subsets
    void backtrack(int start, vector<int>& nums, vector<int>& current, vector<vector<int>>& result) {
        // Add the current subset to the result
        result.push_back(current);

        // Iterate over the array from 'start' index
        for (int i = start; i < nums.size(); i++) {
            // Skip duplicates: if current number is the same as previous and not at the start index,
            if (i > start && nums[i] == nums[i - 1]) continue;

            // Include nums[i] in current subset
            current.push_back(nums[i]);

            // Recurse for next index
            backtrack(i + 1, nums, current, result);

            // Backtrack: remove the last added element
            current.pop_back();
        }
    }

    // Main function to get unique subsets
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        // Sort the array to handle duplicates
        sort(nums.begin(), nums.end());

        vector<vector<int>> result;
        vector<int> current;

        // Start backtracking from index 0
        backtrack(0, nums, current, result);

        return result;
    }
};

// Driver code
int main() {
    Solution obj;
    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) cin >> nums[i];

    vector<vector<int>> ans = obj.subsetsWithDup(nums);
    for (auto subset : ans) {
        cout << "[";
        for (int i = 0; i < subset.size(); i++) {
            cout << subset[i];
            if (i != subset.size() - 1) cout << ",";
        }
        cout << "] ";
    }
    cout << endl;
    return 0;
}
```

### Complexity Analysis:

**Time Complexity:** O(2^N × N)
- Generate unique subsets: O(2^N)
- Copy each subset: O(N)

**Space Complexity:** O(N)
- Recursion stack depth: O(N)
- Current subset storage: O(N)
- Output space not counted

---
