## Subset Sum - Sum of All Subsets

**Problem Statement:**  
Given an array, print all the subset sums (sum of elements in all possible subsets) in **increasing order**.

---

>### Examples:

### Example 1:

**Input:**  N = 3  arr[] = {5, 2, 1}
**Output:** 0, 1, 2, 3, 5, 6, 7, 8

**Explanation:**  
Subsets =  [ ], [1], [2], [2,1], [5], [5,1], [5,2], [5,2,1]  
Subset sums =  0, 1, 2, 3, 5, 6, 7, 8

---

### Example 2:

**Input:**  N = 3  arr[] = {3, 1, 2}
**Output:**  0, 1, 2, 3, 3, 4, 5, 6

**Explanation:**  Subsets = [ ], [1], [2], [2,1], [3], [3,1], [3,2], [3,2,1]  
Subset sums =  0, 1, 2, 3, 3, 4, 5, 6

---

## Bitmasking Approach

### Algorithm:

1. Initialize an empty list to store subset sums.
2. Iterate `mask` from `0` to `2^N - 1`:
   - Each mask represents a subset.
3. For each mask:
   - Initialize `sum = 0`.
   - For each bit `i` from `0` to `N - 1`:
     - If the `i-th` bit is set in `mask`, include `arr[i]` in `sum`.
4. Add `sum` to the list.
5. After processing all masks, **sort** the list.
6. Output the sorted list of subset sums.

### Diagram:
![Subset Sum using Bitmasking](https://github.com/Beastorm/DSA_/blob/974f23fca9edcb5a5699a9814dd8d8a0deae9944/junk/subset_sum_masking.png?raw=true) 

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find all subset sums using bitmasking
    vector<int> subsetSums(vector<int>& arr) {
        int n = arr.size();
        vector<int> sums;

        // Iterate through all possible bitmasks from 0 to 2^n - 1
        for (int mask = 0; mask < (1 << n); mask++) {
            int sum = 0; // store sum of current subset
            for (int i = 0; i < n; i++) {
                // If ith bit is set, include arr[i] in sum
                if (mask & (1 << i)) {
                    sum += arr[i];
                }
            }
            sums.push_back(sum);
        }

        // Sort sums to get increasing order
        sort(sums.begin(), sums.end());
        return sums;
    }
};

// Driver code
int main() {
    Solution sol;
    vector<int> arr = {5, 2, 1};
    vector<int> result = sol.subsetSums(arr);

    // Print the subset sums
    for (int sum : result) {
        cout << sum << " ";
    }
    cout << endl;

    return 0;
}
```
### Time Complexity:

- **O(2^N × N)** — iterating over all subsets and their elements.
- **O(2^N log(2^N))** — for sorting the final subset sums.

---

## Subset Sum - Recursive Approach

### Algorithm:

We can solve this more cleanly using **recursion** without generating all bitmasks.

**Key Idea:**
- Start from index 0
- Maintain a running sum
- At each index, make two recursive calls:
  - **Include** the current element (add to sum)
  - **Exclude** the current element (sum unchanged)
- When we reach the end of the array, store the current sum

This avoids explicitly storing subsets, reduces unnecessary operations, and still generates all sums in **O(2^N)** time. Sorting at the end gives the required increasing order.

### Steps:

1. Initialize an empty list to store sums
2. Create a recursive function taking **index** and **current sum** as parameters
3. **Base case:** If index equals N:
   - Push the current sum into the list
   - Return
4. **Recursive case:**
   - Recursively call the function **including** the current element (sum + arr[index])
   - Recursively call the function **excluding** the current element (sum remains the same)
5. Call the function starting from **index = 0** and **sum = 0**
6. Sort the result list and print it

### Diagram:
![Subset Sum using Recursion](https://github.com/Beastorm/DSA_/blob/2feb45c9b518778ce1445d6f02b4af2abd31af69/junk/subset_sum_recursive.png?raw=true) 


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Helper function to generate subset sums recursively
    void findSums(int index, int currentSum, vector<int>& arr, vector<int>& sums) {
        // Base case: if we have considered all elements
        if (index == arr.size()) {
            sums.push_back(currentSum);
            return;
        }

        // Include current element
        findSums(index + 1, currentSum + arr[index], arr, sums);

        // Exclude current element
        findSums(index + 1, currentSum, arr, sums);
    }

    // Main function
    vector<int> subsetSums(vector<int>& arr) {
        vector<int> sums;
        findSums(0, 0, arr, sums);
        sort(sums.begin(), sums.end()); // Sort in increasing order
        return sums;
    }
};

// Driver code
int main() {
    Solution sol;
    vector<int> arr = {5, 2, 1};
    vector<int> result = sol.subsetSums(arr);

    for (int sum : result) {
        cout << sum << " ";
    }
    cout << endl;

    return 0;
}

```

---

### Complexity Analysis:
- **Time Complexity:** O(2^N × N + 2^N log 2^N)
   - O(2^N) recursive calls
   - O(2^N log 2^N) for sorting

- **Space Complexity:** O(2^N + N)
   - O(2^N) for storing subset sums
   - O(N) for recursion stack depth
