## Letter Combinations of a Phone Number

**Problem Statement:**  
Given a string consisting of digits from 2 to 9 (inclusive), return all possible letter combinations that the number can represent.
The mapping of digits to letters (just like on a telephone keypad):
- 2: abc
- 3: def
- 4: ghi
- 5: jkl
- 6: mno
- 7: pqrs
- 8: tuv
- 9: wxyz

---

>### Examples:

### Example 1:

**Input:** digits = "34"

**Output:** ``` ["dg", "dh", "di", "eg", "eh", "ei", "fg", "fh", "fi"] ```

**Explanation:**
- The digit 3 is mapped to "def"
- The digit 4 is mapped to "ghi"
- All possible combinations by replacing the digits with characters are shown in the output

---

### Example 2:

**Input:** digits = "3"   

**Output:** ``` ["d", "e", "f"]```

**Explanation:**  
- The digit 3 is mapped to "def"

---

### Example 3:

**Input:** digits = ""

**Output:** []

**Explanation:**  
- Empty input returns empty output

---

## Approach

### Intuition:

Each digit from 2 to 9 maps to 3 or 4 letters (like on a phone keypad).
For example, digit 2 maps to abc, 3 to def, etc.

We can use backtracking to generate all possible letter combinations:
- At each position (digit), we have multiple letter choices
- We build the string one letter at a time
- When the built string has the same length as the input digits, we add it to the result

Example for digits = "23":
- Start with an empty string
- First digit 2 maps to abc: try a, then b, then c
- For each choice, move to the next digit 3, which maps to def
- Try all combinations: ad, ae, af, bd, be, bf, cd, ce, cf

### Algorithm:

1. Map digits to letters:
   - 2 to abc, 3 to def, 4 to ghi
   - 5 to jkl, 6 to mno
   - 7 to pqrs, 8 to tuv, 9 to wxyz

2. Handle edge case: if input is empty, return empty result

3. Define recursive function backtrack(index, currentCombination):
   - Base case: if index equals digits.length(), add currentCombination to result
   - Recursive case:
     - Get the current digit and its mapped letters
     - For each letter:
       - Append letter to current combination
       - Recurse for next index
       - Remove letter (backtrack)

4. Start recursion with index = 0 and empty string

5. Return the result list

### Diagram:
![Letter Combinations of a Phone Number](https://github.com/Beastorm/DSA_/blob/b57fedd76aa21ffaa000f28ac607b94a3196c1f3/junk/phone_digit_.png?raw=true)  
*Backtracking tree for generating all letter combinations from digits on a phone keypad (example: digits = "23").*

![Letter Combinations - digits "234"](https://github.com/Beastorm/DSA_/blob/37fe2bffe310a92352c177c616f274febe73516a/junk/phone_digit2.png?raw=true)  
*Backtracking tree for generating all 27 letter combinations from digits "234" on a phone keypad (partial visualization with collapsed branches).*

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Mapping of digits to letters
    unordered_map<char, string> phoneMap = {
        {'2', "abc"},
        {'3', "def"},
        {'4', "ghi"},
        {'5', "jkl"},
        {'6', "mno"},
        {'7', "pqrs"},
        {'8', "tuv"},
        {'9', "wxyz"}
    };
    
    // Recursive backtracking function
    void backtrack(int index, string& digits, string& current, vector<string>& result) {
        // Base case: if we've processed all digits,
        if (index == digits.size()) {
            result.push_back(current);
            return;
        }
        
        // Get the letters mapped to the current digit
        char digit = digits[index];
        string letters = phoneMap[digit];
        
        // Try each letter mapped to this digit
        for (char letter : letters) {
            current.push_back(letter);              // Add letter to current combination
            backtrack(index + 1, digits, current, result);  // Recurse for next digit
            current.pop_back();                     // Backtrack: remove last letter
        }
    }

public:
    vector<string> letterCombinations(string digits) {
        vector<string> result;
        
        // Edge case: empty input
        if (digits.empty()) {
            return result;
        }
        
        string current = "";
        backtrack(0, digits, current, result);
        
        return result;
    }
};

// Driver code
int main() {
    Solution sol;
    
    // Test case 1
    string digits1 = "34";
    vector<string> result1 = sol.letterCombinations(digits1);
    cout << "Input: \"" << digits1 << "\"" << endl;
    cout << "Output: [";
    for (int i = 0; i < result1.size(); i++) {
        cout << "\"" << result1[i] << "\"";
        if (i != result1.size() - 1) cout << ", ";
    }
    cout << "]" << endl << endl;
    
    // Test case 2
    string digits2 = "3";
    vector<string> result2 = sol.letterCombinations(digits2);
    cout << "Input: \"" << digits2 << "\"" << endl;
    cout << "Output: [";
    for (int i = 0; i < result2.size(); i++) {
        cout << "\"" << result2[i] << "\"";
        if (i != result2.size() - 1) cout << ", ";
    }
    cout << "]" << endl << endl;
    
    // Test case 3
    string digits3 = "";
    vector<string> result3 = sol.letterCombinations(digits3);
    cout << "Input: \"" << digits3 << "\"" << endl;
    cout << "Output: [";
    for (int i = 0; i < result3.size(); i++) {
        cout << "\"" << result3[i] << "\"";
        if (i != result3.size() - 1) cout << ", ";
    }
    cout << "]" << endl << endl;
    
    // Test case 4
    string digits4 = "23";
    vector<string> result4 = sol.letterCombinations(digits4);
    cout << "Input: \"" << digits4 << "\"" << endl;
    cout << "Output: [";
    for (int i = 0; i < result4.size(); i++) {
        cout << "\"" << result4[i] << "\"";
        if (i != result4.size() - 1) cout << ", ";
    }
    cout << "]" << endl << endl;
    
    // Test case 5
    string digits5 = "2";
    vector<string> result5 = sol.letterCombinations(digits5);
    cout << "Input: \"" << digits5 << "\"" << endl;
    cout << "Output: [";
    for (int i = 0; i < result5.size(); i++) {
        cout << "\"" << result5[i] << "\"";
        if (i != result5.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    return 0;
}
```
### Complexity Analysis:

**Time Complexity:** $O(4^n × n)$
   - Each digit maps to up to 4 letters (worst case: digits 7 and 9)
   - Total combinations: $4^n$ in the worst case
   - Building each combination takes $O(n)$ time
   - Total: $4^n$ combinations × n time per combination

**Space Complexity:** $O(n)$
   - Recursion stack depth: $O(n)$
   - Current combination string: $O(n)$
   - Output storage: $O(4^n × n)$ not counted in auxiliary space
