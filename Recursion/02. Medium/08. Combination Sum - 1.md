## Combination Sum - 1

**Problem Statement:**  

Given an array of distinct integers and a target, return the list of all unique combinations where the chosen numbers sum to the target. You may return the combinations in any order.

- The same number may be chosen from the array an unlimited number of times
- Two combinations are unique if the frequency of at least one chosen number is different
- It is guaranteed that the number of unique combinations is less than 150

---

>### Examples:

### Example 1:

**Input:** `array = [2,3,6,7]`, `target = 7`

**Output:** `[[2,2,3], [7]]`

**Explanation:**
- 2 and 3 are candidates, and 2 + 2 + 3 = 7 (Note: 2 can be used multiple times)
- 7 is a candidate, and 7 = 7
- These are the only two combinations

---

### Example 2:

**Input:** `array = [2]`, `target = 1`

**Output:** `[]`

**Explanation:** No combination is possible

---

## Approach

### Intuition:

For problems involving printing combinations or subsequences, **recursion** should be the first approach that comes to mind.

**How to think recursively?**

When the problem involves picking elements from an array to form a combination, use the **" pick and non-pick " approach**.

---

### Algorithm:

We use a **recursive backtracking** approach to find all combinations that sum up to the target.

**Recursive function parameters:**
- `index`: Current position in the array
- `target`: Remaining sum we need to achieve
- `ds`: Data structure to store the current combination

**At every step, we have two choices:**

1. **Pick** the element at the current index:
   - Reduce the target by `arr[index]`
   - Add `arr[index]` to `ds`
   - Stay on the same index (since we can reuse the same element)

2. **Not pick** the element:
   - Move to the next index
   - Target remains unchanged
   - Element is not added to `ds`

**Backtracking:**
- While backtracking, remove the last inserted element to explore new paths
- This process is repeated while `index < array.size()`

**Base case:**
- When `target == 0`, we have found a valid combination
- When `index >= array.size()` or `target < 0`, stop recursion


### Diagram:
![Combination Sum I - Backtracking Tree](https://github.com/Beastorm/DSA_/blob/2e16e86f2bd58c1f2ea048311e6656e86d8d331e/junk/combination_sum-I.png?raw=true)  

### C++ Code:

``` cpp
#include<bits/stdc++.h>
using namespace std;

class Solution {
  public:
    // Function to find all combinations of numbers that sum up to the target
    void findCombination(int ind, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& ds) {
        // Base case: if we have considered all elements in the array
        if (ind == arr.size()) {
            // If the target is zero, we have found a valid combination
            if (target == 0) {
                ans.push_back(ds);  // Add the current combination to the result
            }
            return;
        }

        // Recursive case: pick the element if it's less than or equal to the target
        if (arr[ind] <= target) {
            ds.push_back(arr[ind]);  // Add the current element to the combination
            findCombination(ind, target - arr[ind], arr, ans, ds);  // Continue with the same index to allow repeated elements
            ds.pop_back();  // Backtrack by removing the last added element
        }

        // Skip the current element and move to the next index
        findCombination(ind + 1, target, arr, ans, ds);
    }

  public:
    // Main function to get all combinations
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;  // To store the result
        vector<int> ds;  // To store a current combination
        findCombination(0, target, candidates, ans, ds);  // Start the recursive search
        return ans;  // Return all valid combinations
    }
};

int main() {
    Solution obj;
    vector<int> v {2, 3, 6, 7};  // Candidate numbers
    int target = 7;  // Target sum

    // Get all combinations
    vector<vector<int>> ans = obj.combinationSum(v, target);

    // Output the combinations
    cout << "Combinations are: " << endl;
    for (int i = 0; i < ans.size(); i++) {
        for (int j = 0; j < ans[i].size(); j++) {
            cout << ans[i][j] << " ";  // Print each element of the combination
        }
        cout << endl;  // Print a newline after each combination
    }

    return 0;
}
```

###  Complexity Analysis:

**Time Complexity:** `O(2^t * k)`

- We explore all possible combinations that can sum up to `target = t`.
- At each step, we make two choices: **pick** or **not pick** → leading to an exponential number of calls.
- Worst-case: Up to `2^t` recursive calls.
- For each valid combination, we copy it to the result → takes `O(k)` time on average, where `k` is the average size of one combination.

**Space Complexity:** `O(k * x)`

- `x` = total number of valid combinations.
- `k` = average length of each combination.
- We store all combinations in memory, leading to `O(k * x)` space usage.
- Additional recursive call stack space can go up to `O(t)` (target level depth).
