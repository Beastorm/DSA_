## Print N-bit Binary Numbers Having More 1’s Than 0’s for Any Prefix

**Problem Statement:**   
Given a positive integer `N`, print all `N-bit` binary numbers such that in every prefix of the number, the count of `1’s` is never less than the count of `0’s`.

**Rules for Valid Binary Numbers:**   
- In every prefix of the binary number, the number of 1’s must be **greater than or equal to** the number of 0’s.
- The total length of the binary number must be exactly N.

---

>### Examples:

### Example 1: N = 2

**All possible 2-bit binary numbers:**
- 00 ✖️ (invalid: prefix "0" has more 0’s than 1’s)
- 01 ✖️ (invalid: prefix "0" has more 0’s than 1’s)
- 10 ✔️ (valid: prefixes "1", "10" → 1’s ≥ 0’s)
- 11 ✔️ (valid: prefixes "1", "11" → 1’s ≥ 0’s)

**Valid outputs:**  
- 10
- 11

---

### Example 2: N = 3

**All possible 3-bit binary numbers:**
- 000 ✖️ (invalid: prefix "0" has more 0’s than 1’s)
- 001 ✖️ (invalid: prefix "0" has more 0’s than 1’s)
- 010 ✖️ (invalid: prefix "0" has more 0’s than 1’s)
- 011 ✖️ (invalid: prefix "0" has more 0’s than 1’s)
- 100 ✔️ (valid: prefixes "1", "10", "100" → 1’s ≥ 0’s at each step)
- 101 ✔️ (valid: prefixes "1", "10", "101" → 1’s ≥ 0’s at each step)
- 110 ✔️ (valid: prefixes "1", "11", "110" → 1’s ≥ 0’s at each step)
- 111 ✔️ (valid: prefixes "1", "11", "111" → 1’s ≥ 0’s at each step)

**Valid outputs:**  
- 100
- 101
- 110
- 111

---

### Example 3: N = 4

**All possible 4-bit binary numbers:**
- 1111 ✔️ (all prefixes: 1’s ≥ 0’s)
- 1110 ✔️ (prefixes: "1", "11", "111", "1110" → 1’s ≥ 0’s)
- 1101 ✔️ (prefixes: "1", "11", "110", "1101" → 1’s ≥ 0’s)
- 1100 ✔️ (prefixes: "1", "11", "110", "1100" → 1’s ≥ 0’s)
- 1011 ✔️ (prefixes: "1", "10", "101", "1011" → 1’s ≥ 0’s)
- 1010 ✔️ (prefixes: "1", "10", "101", "1010" → 1’s ≥ 0’s)
- 1001 ✔️ (prefixes: "1", "10", "100", "1001" → 1’s ≥ 0’s)
- 1000 ✔️ (prefixes: "1", "10", "100", "1000" → 1’s ≥ 0’s)
- (All others are invalid as some prefix will have more 0’s than 1’s)

**Valid outputs:**  
- 1111
- 1110
- 1101
- 1100
- 1011
- 1010
- 1001
- 1000

### Why are some numbers invalid?

- If at any point in the number, the count of 0’s exceeds the count of 1’s in the prefix, the number is invalid.

**In short:**  
- Only print binary numbers where, for every prefix, the number of 1’s is never less than the number of 0’s.

---

## Approach

### Intuitions:

- At every step, you want to ensure that in any prefix of the binary number, the number of 1’s is never less than the number of 0’s.
- You can **always** add a '1' because it increases the count of 1’s and keeps the prefix valid.
- You can **only** add a '0' if there are already more 1’s than 0’s in the current prefix. This ensures that after adding '0', the prefix still has at least as many 1’s as 0’s.
- By following these rules recursively, you generate only those binary numbers where every prefix is valid.
- This approach prunes out invalid numbers early, so you never generate or print a number that violates the condition.

### Algo Steps:
1. **Initialize:**  
   - Start with counts of ones = 0, zeros = 0, an empty output string, and n (number of bits to generate).

2. **Recursive Function:**  
   - If n == 0 (no more bits to add), print the output string and return.
   - Always add '1':
     - Increment the count of ones.
     - Decrement n by 1.
     - Append '1' to the output string and recurse.
   - Add '0' only if ones > zeros:
     - Increment the count of zeros.
     - Decrement n by 1.
     - Append '0' to the output string and recurse.

3. **Repeat:**  
   - Continue recursion until all valid N-bit binary numbers are generated.

4. **End:**  
   - All printed numbers will have more 1’s than 0’s in every prefix.

### Diagram:
![Prefix Having More 1s Than 0s](https://raw.githubusercontent.com/Beastorm/DSA_/0f824721bdb9b0b67a7632f42caf9720fc666c61/junk/prefix_having_more_1s_eqaul_or_greater_than_zeros.png)

### C++ Code:
``` cpp
#include <iostream>
using namespace std;

// Recursive function to generate valid binary numbers
void solve(int one, int zero, int n, string op) {
    // Base case: if no more bits to add, print the result
    if (n == 0) {
        cout << op << " ";
        return;
    }
    // Always add '1'.
    solve(one + 1, zero, n - 1, op + "1");

    // Add '0' only if the number of 1's so far is greater than the number of 0's
    if (one > zero) {
        solve(one, zero + 1, n - 1, op + "0");
    }
}

int main() {
    int N;
    cin >> N;
    string op = "";
    int one = 0, zero = 0;
    solve(one, zero, N, op);
    cout << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  O(2^n), where n is the number of bits.  
  - In the worst case, each bit can be either '1' or '0', but the prefix rule prunes many branches, so the actual number of valid strings is less than 2^n.
  - Still, the number of recursive calls is O(2^n) in the worst case.

- **Space Complexity:**  
  O(n), due to the recursion stack and the space used to build the output string at each step.

