## Letter Case Permutation | Recursion

**Problem Statement:**  
Given a string `S`, we can transform every letter individually to be lowercase or uppercase to create another string.  
Return a list of all possible `strings` we could create.

---

>### Examples:

**Input:** S = "a1b2"  
**Output:** ["a1b2", "a1B2", "A1b2", "A1B2"]

**Input:** S = "3z4"  
**Output:** ["3z4", "3Z4"]

**Input:** S = "12345"  
**Output:** ["12345"]

---

## Approach

### Algo:

1. For each character in the string:
    - If it is a letter, branch into two recursive calls:
        - One with the character in lowercase.
        - One with the character in uppercase.
    - If it is not a letter, just continue with the same character.
2. When the input string is empty, add the current output to the result list.


### C++ Code:

```cpp
#include <iostream>
#include <vector>
using namespace std;

void solve(string ip, string op, vector<string>& res) {
    if (ip.length() == 0) {
        res.push_back(op);
        return;
    }
    char ch = ip[0];
    ip.erase(ip.begin());
    if (isalpha(ch)) {
        solve(ip, op + (char)tolower(ch), res);
        solve(ip, op + (char)toupper(ch), res);
    } else {
        solve(ip, op + ch, res);
    }
}

int main() {
    string S;
    cin >> S;
    vector<string> res;
    solve(S, "", res);
    for (const auto& s : res) {
        cout << s << endl;
    }
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  O(2^n), where n is the number of letters in the input string.

- **Space Complexity:**  
  O(n), due to the recursion stack and the space used to build the output string at each step.
  

### Why does this work?

- At each step, you branch into two paths for each letter: lowercase and uppercase.
- This explores all possible case combinations while keeping the sequence.
- Non-letter characters are added as is.

---

**In short:**

- Use recursion to explore all case changes for each character.
- Add the result to the list when the input is empty.
