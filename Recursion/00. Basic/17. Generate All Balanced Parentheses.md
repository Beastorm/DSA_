## Generate All Balanced Parentheses

**Problem Statement:**  
Given `n` pairs of parentheses, write a function to generate all combinations of well-formed (balanced) parentheses of length `2*n`.

**Rules for Balanced Parentheses:**  
- Every opening parenthesis `'('` must have a corresponding closing parenthesis `')'`.
- At any point in the string, the number of closing parentheses should **never** exceed the number of opening parentheses.
- The total number of opening and closing parentheses must both be exactly `n`.

---

>### Examples:

### Example 1:
**Input:** n = 1    
**Output:**  
- `()` ✔️ (balanced)

### Example 2:
**Input:** n = 2    
**Output:**  
- `(())` ✔️ (balanced)
- `()()` ✔️ (balanced)
- `())(` ✖️ (not balanced)
- `(()`  ✖️ (not balanced)
- `())`  ✖️ (not balanced)

### Example 3:
**Input:** n = 3    
**Output:**  
- `((()))` ✔️ (balanced)
- `(()())` ✔️ (balanced)
- `(())()` ✔️ (balanced)
- `()(())` ✔️ (balanced)
- `()()()` ✔️ (balanced)
- `())(()` ✖️ (not balanced)
- `((())` ✖️ (not balanced)
- `())())` ✖️ (not balanced)

### Example 4:
**Input:** n = 4   
**Output:**  
- `(((())))` ✔️
- `((()()))` ✔️
- `((())())` ✔️
- `((()))()` ✔️
- `(()(()))` ✔️
- `(()()())` ✔️
- `(()())()` ✔️
- `(())(())` ✔️
- `(())()()` ✔️
- `()((()))` ✔️
- `()(()())` ✔️
- `()(())()` ✔️
- `()()(())` ✔️
- `()()()()` ✔️

---

### Which is Balanced and Which is Not?

- **Balanced:**  
  - `()`, `(())`, `()()`, `((()))`, `(()())`, `(())()`, `()(())`, `()()()`, etc.
- **Not Balanced:**  
  - `())(`, `(()`, `())`, `())(()`, `((())`, `())())`, etc.

A string is **balanced** if:
- The number of opening and closing parentheses is equal.
- At no point in the string do closing parentheses outnumber opening parentheses.

---

## Approach

### Algorithm:

1. **Initialize:**   
   - Set the number of open and closed parentheses to `n`.
   - Start with an empty output string.

2. **Recursive Function:**   
   - If both open and close counts are zero, add the current output string to the result (base case).
   - If open > 0:
     - Add `'('` to the output string.
     - Recurse with open decreased by 1.
   - If close > open:
     - Add `')'` to the output string.
     - Recurse with close decreased by 1.

3. **Repeat:**    
   - Continue the recursion until all valid combinations are generated.

4. **Return:**   
   - Collect and return all valid combinations.


### Diagram:
![Generate Valid Parenthesis](https://raw.githubusercontent.com/Beastorm/DSA_/1bd1e6ee4438cca7d16c074be3bb114d00827c1b/junk/generate_valid_parenthesis.png)

### C++ Code:

``` cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to generate all balanced parentheses
void solve(int open, int close, string op, vector<string>& v) {

    // Base case: if no open and closed parentheses left, add to result
    if (open == 0 && close == 0) {
        v.push_back(op);
        return;
    }

    // If we can still add an open parenthesis, do so
    if (open > 0) {
        string op1 = op;
        op1.push_back('(');
        solve(open - 1, close, op1, v);
    }

    // If we can add a close parenthesis (only if close > open)
    if (close > open) {
        string op2 = op;
        op2.push_back(')');
        solve(open, close - 1, op2, v);
    }
}

vector<string> generateParenthesis(int n) {
    vector<string> v;
    int open = n, close = n;
    string op = "";
    solve(open, close, op, v);
    return v;
}

int main() {
    int n;
    cin >> n;
    vector<string> result = generateParenthesis(n);
    for (const auto& s : result) {
        cout << s << endl;
    }
    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:**  
  O(2^n * n), where n is the number of pairs of parentheses.
  - The number of valid combinations is given by the nth Catalan number, which is approximately O(4^n / (n * sqrt(n))).
  - Each valid combination is a string of length 2n, so generating and storing all combinations takes O(2^n * n) time in practice.

- **Why O(4^n / √n)?**
    This comes from the **Catalan Number** formula.
    The number of valid parenthesis combinations for `n` pairs is exactly the **nth Catalan Number**:

- **In Simple Terms:**
  - You are choosing `n` positions for `(` out of `2n` total positions.
  - That logic leads to `4^n`.
  - The division by `n` and `sqrt(n)` comes from filtering out the invalid combinations (like `)(`).

So, while it looks like `2^(2n) = 4^n`, the valid ones are a specific fraction of that, leading to the precise **O(4^n / √n)**.

---

- **Space Complexity:**  
  O(n) for the recursion stack (maximum depth is 2n),  
  plus O(2^n * n) for storing all valid combinations in the result vector.

---

### How it works:

- Start with `n` open and `n` close parentheses to use.
- At each step, you can add `'('` if you have any left, or `')'` if there are more closes than opens left.
- When both open and close are zero, you have a valid combination.

---

### In short:
- Use recursion and backtracking to build all valid combinations.
- Only add parentheses when it keeps the string balanced.
