## Hypothesis-Induction-Base Condition (IBH Method)

### IBH Method: A Way to Think About Recursive Problems

- **I (Induction/Hypothesis):**  
  Assume your function works correctly for a smaller input (this is your hypothesis).
- **B (Base Condition):**  
  Define the simplest case where the answer is obvious, and the recursion should stop.
- **H (How to build/Induction step):**  
  Use the assumption (hypothesis) to build the solution for the current input.

---

### Why is Making Input Smaller Popular/Important?

- Making the input smaller at each step ensures that recursion will eventually reach the base case and stop.
- This prevents infinite recursion and helps break down complex problems into manageable pieces.
- **Example:**  
  In factorial, each call reduces `n` by 1, so you eventually reach `n == 0`.

### Example: Print 1 to N

- **Base Condition:** If `n == 0`, stop (do nothing).
- **Hypothesis:** Assume you can print numbers from 1 to `n-1`.
- **Induction Step:** Print numbers from 1 to `n-1`, then print `n`.

``` cpp
void print1toN(int n) {
    if (n == 0) return;         // Base condition
    print1toN(n-1);             // Hypothesis/Induction
    cout << n << " ";           // Work after recursion
}
```
**How does it work?**

For `print1toN(3)`, the calls are:  
`print1toN(2)` → `print1toN(1)` → `print1toN(0)`  
Then prints: `1 2 3`

---

## Approaches to Solve Recursive Problems

### 1. Simple Problems – IBH

Use the IBH method for straightforward problems.

**Examples:**

- **Factorial:**
  - Base: `n == 0` → return 1
  - Hypothesis: `factorial(n-1)` works
  - Induction: `factorial(n) = n * factorial(n-1)`

- **Sum of Array:**
  - Base: array is empty → return 0
  - Hypothesis: sum of smaller array works
  - Induction: `sum(arr, n) = arr[0] + sum(arr+1, n-1)`

---

### 2. Medium Problems – Recursive Problems (Choices Based)

Problems where you have to make choices at each step.

**Examples:**

- **Subsets of a set:**
  - At each step, choose to include or exclude the current element.
  - Base: if `index == n`, print current subset.
  - Induction: call for include and exclude.

- **String Permutations:**
  - At each step, pick a character to fix and permute the rest.

---

### 3. Hard Problems – Choice Diagram

For complex problems, draw a choice diagram (recursive tree) to visualize all possible decisions and paths.

**Examples:**

- **N-Queens Problem:**
  - At each row, try placing a queen in every column and recursively solve for the next row.
  - The choice diagram helps visualize all possible board configurations.

- **Subset Sum Problem:**
  - At each step, choose to include or exclude the current number, and check if you can reach the target sum.

---

## Summary Table

| Problem Type | Approach        | Example                    |
|--------------|----------------|----------------------------|
| Simple       | IBH            | Factorial, Print 1 to N    |
| Medium       | Choices-based  | Subsets, Permutations      |
| Hard         | Choice Diagram | N-Queens, Subset Sum       |

---


- Use IBH for simple recursive problems.
- For problems with choices, use recursion to explore all options.
- For hard problems, draw a choice diagram to understand all possible paths.
