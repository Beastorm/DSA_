## Kth Symbol in Grammar

**Problem Statement:**   
On the first row, we write a `0`.  
In every subsequent row, we look at the previous row and:
- Replace each occurrence of `0` with `01`
- Replace each occurrence of `1` with `10`

Given row `N` and index `K`, return the K-th indexed symbol in row N.  
(Note: K is 1-indexed.)

---

>### Example:

- **Row 1:** 0  
- **Row 2:** 0 → 01  
- **Row 3:** 01 → 0110  
- **Row 4:** 0110 → 01101001  
- and so on...

---

## Approach

### Intuition:

This problem generates a grammar sequence recursively:
- Row 1: `0`
- Row 2: `01`
- Row 3: `0110`
- Row 4: `01101001`
- Row n: previous row + complement of previous row

Each row is formed by concatenating the previous row with its complement (0↔1).

Key insight: The sequence has a symmetric/mirrored structure. The second half is the complement of the first half.



### Algorithm:

1. **Base case:** If `n == 1`, return `0` (first row has only one element: 0)

2. **Find midpoint:** `mid = 2^(n-1) / 2 = 2^(n-2)`
   - Row n has `2^(n-1)` elements
   - First half has `2^(n-2)` elements

3. **Recursive cases:**
   - If `k <= mid`: 
     - k is in the first half
     - Answer is the same as position k in row (n-1)
     - Return `solve(n-1, k)`
   
   - If `k > mid`:
     - k is in the second half (complement part)
     - Answer is the complement of position (k-mid) in row (n-1)
     - Return `!solve(n-1, k-mid)`


### Diagram:
![Kth Grammar Symbol Problem](https://github.com/Beastorm/DSA_/blob/b15fe835e7b9b18a6993e6bc8bda40c5365c1512/junk/kth_grammer.png?raw=true)  
*Recursive solution for Kth Grammar problem - uses binary tree structure to find the kth element by checking if the position is in the first half (same as previous row) or second half (complement of previous row).*

### C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int solve(int n, int k) {
    // Base case
    if (n == 1)
        return 0;

    int mid = pow(2, n - 1) / 2;

    if (k <= mid) {
        return solve(n - 1, k);
    } else {
        return !solve(n - 1, k - mid);
    }
}

int main() {
    int n, k;
    cin >> n >> k;
    cout << solve(n, k) << endl;
    return 0;
}

```
### Complexity Analysis:
**Time Complexity:** O(n)
- Recursion depth = n
- Each level does O(1) work
- Total: O(n)

**Space Complexity:** O(n)
- Recursion stack depth = n

---

### Summary:

- **Pattern:** Binary tree structure with complement symmetry
- **Key idea:** Reduce problem size by half each time
- **No need to generate entire sequence** - find position directly
- **Efficient:** O(n) instead of O(2^n) for generating full sequence
