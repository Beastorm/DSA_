## Count Good Numbers

**Problem Statement:**  
A digit string is considered good if:
- Digits at even indices (0-based) are even digits (0, 2, 4, 6, 8)
- Digits at odd indices are prime digits (2, 3, 5, 7)

Given an integer `n`, return the total number of good digit strings of length `n`.  
As the result may be large, return it modulo \(10^9 + 7\).

A digit string is a string consisting only of the digits '0' through '9'. It may contain leading zeros.

---

### Examples:

**Example 1:**  
**Input:** `n = 1`  
**Output:** `5`  
**Explanation:**    
```
Only one index (0) â†’ must be even.  
Valid strings: "0", "2", "4", "6", "8"
```
**Example 2:**  
**Input:** `n = 2`  
**Output:** `20`  
**Explanation:**  
```
Index 0: 5 options (even digits)  
Index 1: 4 options (prime digits)  
Total: 5 * 4 = 20
```
---

## Approach

### Algorithm:

1. For each index in the digit string:
    - If the index is even, the valid digits are: 0, 2, 4, 6, 8 (5 options).
    - If the index is odd, the valid digits are: 2, 3, 5, 7 (4 options).
2. Recursively compute the number of valid strings based on the index.
3. For each valid digit, move to the next index and continue the recursion.

``` cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;

// Recursive function to count good numbers
int countGoodNumbers(int index, int n) {
    // Base case: if we've reached the end of the string
    if (index == n) {
        // Return 1 as we've formed a valid string
        return 1; 
    }

    int result = 0;
    // Even index: Use even digits
    if (index % 2 == 0) {  
        // Even digits: 0, 2, 4, 6, 8
        for (int digit : {0, 2, 4, 6, 8}) {
            result = (result + countGoodNumbers(index + 1, n)) % MOD;
        }
    } 
    // Odd index: Use prime digits
    else {  
        // Prime digits: 2, 3, 5, 7
        for (int digit : {2, 3, 5, 7}) {
            result = (result + countGoodNumbers(index + 1, n)) % MOD;
        }
    }
    return result;
}

int main() {
    int n = 1;
    cout << countGoodNumbers(0, n) << endl;
    return 0;
}
```
### Complexity Analysis

- **Time Complexity (TC):** `O(2^n)`   
  At each index, we have 5 choices for even indices and 4 choices for odd indices, leading to an exponential number of recursive calls as the string length increases.

- **Space Complexity (SC):** `O(n)`   
  This is due to the recursion depth, as each function call adds a new frame to the call stack. The maximum depth is `n` (the length of the string).
4. Return the result modulo \(10^9 + 7\) once all digits are chosen.
