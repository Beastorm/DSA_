## Implement Pow(x, n) | X raised to the power N

**Problem Statement:**   
Implement the power function `pow(x, n)`, which calculates `x` raised to `n` (i.e., `x^n`).

---

>### Examples:

**Example 1:**  
**Input:**  `x = 2.0000, n = 10`  
**Output:**  `1024.0000`  
**Explanation:** The answer is calculated as $2^10$, which equals 1024.

**Example 2:**  
**Input:** `x = 2.0000, n = -2`  
**Output:** `0.2500`  
**Explanation:** The answer is calculated as 2^-2, which is equal to 1/4 = 0.25.

---

## Brute Force

### Algo:
1. **Initialize** the result variable `ans` to 1.  
   (Any number raised to the power of 0 is 1.)

2. **Check if the exponent `n` is negative:**  
   - If true, invert `x` by setting `x = 1/x` and make `n` positive by setting `n = -n`.  
   (This handles negative exponents.)

3. **Iterate** from 0 to `n` (converted to an integer):  
   - In each iteration, multiply `ans` by `x`.  
   (This computes `x` raised to the power of `n`.)

4. **Return** the result stored in `ans`, which now contains the value of `x^n`.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    double myPow(double x, int n) {
        // Base case: any number to the power of 0 is 1
        if (n == 0 || x == 1.0) return 1; 
        
        long long temp = n; // to avoid integer overflow
        
        // Handle negative exponents
        if (n < 0) { 
            x = 1 / x;
            temp = -1*1LL*n;
        }

        double ans = 1;

        for (long long i = 0; i < temp; i++) {
            // Multiply ans by x for n times
            ans *= x; 
        }
        return ans;
    }
};

int main() {
    Solution sol;
    // Output: 1024.0000
    printf("%.4f\n", sol.myPow(2.0000, 10));
    // Output: 0.2500 
    printf("%.4f\n", sol.myPow(2.0000, -2)); 
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(n)`, where `n` is the absolute value of the exponent.  
  This is because we multiply the base `x`, `n` times in the loop.

- **Space Complexity:**  
  `O(1)`, as we are using only a constant amount of extra space for variables (like `ans`, `x`, and `n`), regardless of the input size.


---

## Optimal Approach

### Algorithm:

1. **Define a helper function** that handles the recursive calculation of the power.

2. **Base Case 1:**  
   If the exponent `n` is 0, return 1 (any number raised to the power of 0 is 1).

3. **Base Case 2:**  
   If the exponent `n` is 1, return the base `x` (any number raised to the power of 1 is itself).

4. **If the exponent `n` is even:**  
   - Recursively calculate the power by squaring the base and halving the exponent:  
     `power(x, n) = power(x * x, n / 2)`

5. **If the exponent `n` is odd:**  
   - Recursively calculate the power by multiplying the base by the result of the power function for `n - 1`:  
     `power(x, n) = x * power(x, n - 1)`

6. **Handle negative exponents:**  
   - If the exponent is negative, calculate the power for the positive exponent and take the reciprocal of the result.

7. **Combine these steps** in a main function that checks if the exponent is negative and calls the helper function accordingly.   


<img src="https://static.takeuforward.org/content/-ridNVfWg" width="520">

### C++ Code:
``` cpp
#include<bits/stdc++.h>
using namespace std;

// Class definition for the solution
class Solution {
private:
    // Function to calculate power of 'x' raised to 'n'
    double power(double x, long n) {
        // Base case: anything raised to 0 is 1
        if (n == 0) return 1.0;

        // Base case: anything raised to 1 is itself
        if (n == 1) return x;

        // If 'n' is even
        if (n % 2 == 0) {
            // Recursive call: x * x, n / 2
            return power(x * x, n / 2);
        }
        // If 'n' is odd, Recursive call: x * power(x, n-1)
        return x * power(x, n - 1);
    }

public:
    // Function to calculate x raised to n
    double myPow(double x, int n) {
        // Store the value of n in a separate variable
        int num = n;

        // If n is negative
        if (num < 0) {
            // Calculate the power of -n and take the reciprocal
            return (1.0 / power(x, -1 * num));
        }
        // If n is non-negative
        return power(x, num);
    }
};

int main() {
    Solution sol;
    double x = 2.0;
    int n = 10;

    // Calculate x raised to n
    double result = sol.myPow(x, n);

    // Print the result
    std::cout << x << "^" << n << " = " << result << std::endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(log n)`, where `n` is the absolute value of the exponent.  
  This is because the problem size is halved in each recursive call when `n` is even.

- **Space Complexity:**  
  `O(log n)`, due to the recursive call stack.  
  In the worst case, the recursion depth can reach up to `log(n)` when `n` is even.
