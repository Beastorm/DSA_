# Recursive Implementation of atoi()

## Problem Statement

Implement the function `myAtoi(s)` which converts the given string `s` to a 32-bit signed integer (similar to the C/C++ `atoi` function).

---

## Steps to Implement

1. **Ignore Leading Whitespace:**  
   Skip any leading whitespace characters `' '` until the first non-whitespace character is found.

2. **Check for Sign:**  
   - If the next character is `'-'`, the number should be negative.  
   - If itâ€™s `'+'`, the number should be positive.  
   - If neither is found, assume the number is positive.

3. **Read and Convert Digits:**  
   - Read the digits and convert them into a number.  
   - Stop reading once a non-digit character is encountered or the end of the string is reached.  
   - Ignore leading zeros during conversion.

4. **Clamp to 32-bit Signed Integer Range:**  
   - The result should be clamped within the range: `[-2147483648, 2147483647]`.  
   - If the computed number is less than `-2147483648`, return `-2147483648`.  
   - If the computed number is greater than `2147483647`, return `2147483647`.

5. **Return the Result:**  
   Return the computed number after applying all the above steps.

---

>### Examples:

**Example 1:**  
**Input:** `s = " -12345"`  
**Output:** `-12345`  
**Explanation:**    
Ignore leading whitespaces.  
The sign '-' is encountered, indicating the number is negative.  
Digits 12345 are read and converted to -12345.

---

**Example 2:**  
**Input:**  `s = "4193 with words"`  
**Output:** `4193`  
**Explanation:**  
Read the digits 4193 and stop when encountering the first non-digit character (w).

---

## Approach

### Algorithm:

- Define a helper function that takes the string `s`, current index `i`, current result `num`, and `sign`.
- Recursively skip leading whitespaces until a non-whitespace character is found.
- Handle the sign if present (positive or negative).
- Recursively process each digit:
  - Continue until the end of the string or a non-digit character is encountered.
  - For each digit, update the result.
  - Clamp the result to `INT_MIN` or `INT_MAX` to handle overflow conditions.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

const int INT_MIN_VAL = -2147483648;
const int INT_MAX_VAL = 2147483647;

// Recursive helper
int helper(const string &s, int i, long long num, int sign) {
    // If we are out of bounds or at a non-digit, return
    if (i >= s.size() || !isdigit(s[i]))
        return (int)(sign * num);

    // Update num with current digit
    num = num * 10 + (s[i] - '0');

    // Clamp if overflow
    if (sign * num <= INT_MIN_VAL) return INT_MIN_VAL;
    if (sign * num >= INT_MAX_VAL) return INT_MAX_VAL;

    // Recurse for next character
    return helper(s, i + 1, num, sign);
}

int myAtoi(string s, int i = 0) {
    // Skip leading whitespaces
    while (i < s.size() && s[i] == ' ') i++;

    // Handle sign
    int sign = 1;
    if (i < s.size() && (s[i] == '+' || s[i] == '-')) {
        sign = (s[i] == '-') ? -1 : 1;
        i++;
    }

    // Call recursive helper
    return helper(s, i, 0, sign);
}

int main() {
    string s = "  -12345";
    cout << myAtoi(s) << endl;  // Output: -12345
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(n)` &mdash; Each character in the string is processed once.

- **Space Complexity:**  
  `O(n)` &mdash; The recursion stack can grow up to `n` calls in the worst case (where `n` is the length of the string).

---

### Dry run:

```
myAtoi("123")
   |
   +-- myAtoi("23")
           |
           +-- myAtoi("3")
                   |
                   +-- myAtoi("")

 ```                  

- myAtoi("123"): Reads '1', recurses on "23"
- myAtoi("23"):  Reads '2', recurses on "3"
- myAtoi("3"):   Reads '3', recurses on ""
- myAtoi(""):    Base case, returns 0

Returns build up as:
myAtoi("3")   = 3
myAtoi("23")  = 2 * 10 + 3 = 23
myAtoi("123") = 1 * 100 + 23 = 123
