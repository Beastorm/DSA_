## Parameterized vs Functional Recursion

**Two ways to design recursive functions:**   

1. Parameterized Recursion - Carry result as a parameter
2. Functional Recursion - Return result from each call

---

## Parameterized Recursion:

**Definition:** Pass the result or accumulator as a parameter through recursive calls.

### Sum of first N numbers

**Code:** 
``` cpp
void sumParameterized(int i, int sum) {
    if (i < 1) {
        cout << "Sum: " << sum << endl;
        return;
    }
    sumParameterized(i - 1, sum + i);
}
```

**Usage:** sumParameterized(5, 0);

**Output:** Sum: 15

**Execution Trace:**
```
sumParameterized(5, 0)
sumParameterized(4, 5)
sumParameterized(3, 9)
sumParameterized(2, 12)
sumParameterized(1, 14)
sumParameterized(0, 15)
Base case: Print 15
```
**Characteristics:**
- Result passed as a parameter   
- Builds result going down   
- No return value needed (void function)   
- Tail recursion (can be optimized)   

---

## Functional Recursion

**Definition:** Return the result from each recursive call and combine them.

### Sum of first N numbers

**Code:**
``` cpp
int sumFunctional(int n) {
    if (n == 0) {
        return 0;
    }
    return n + sumFunctional(n - 1);
}
```
**Usage:** int result = sumFunctional(5);

**Output:** Sum: 15

**Execution Trace:**
```
sumFunctional(5)
= 5 + sumFunctional(4)
= 5 + (4 + sumFunctional(3))
= 5 + (4 + (3 + sumFunctional(2)))
= 5 + (4 + (3 + (2 + sumFunctional(1))))
= 5 + (4 + (3 + (2 + (1 + sumFunctional(0)))))
= 5 + (4 + (3 + (2 + (1 + 0))))
= 5 + (4 + (3 + (2 + 1)))
= 5 + (4 + (3 + 3))
= 5 + (4 + 6)
= 5 + 10
= 15
```
**Characteristics:**    
- Result returned from each call
- Builds the result coming back up
- Returns a value
- Head recursion (cannot be tail-optimized)

---

### Side-by-Side Comparison

**Parameterized:** Pass result as parameter

``` cpp
void sumParam(int i, int sum) {
    if (i < 1) {
        cout << sum << endl;
        return;
    }
    sumParam(i - 1, sum + i);
}
```

**Functional**: Return result

``` cpp
int sumFunc(int n) {
    if (n == 0) return 0;
    return n + sumFunc(n - 1);
}
```

_Output for both:_ 15

---

## More Examples:

### Example 1: Factorial

**Parameterized:**  
``` cpp
void factorialParam(int i, int result) {
    if (i < 1) {
        cout << result << endl;
        return;
    }
    factorialParam(i - 1, result * i);
}
```
**Usage:** factorialParam(5, 1)

**Functional:**  
``` cpp
int factorialFunc(int n) {
    if (n <= 1) return 1;
    return n * factorialFunc(n - 1);
}
```
**Usage:** cout << factorialFunc(5)

---

### Example 2: Array Sum

**Parameterized:**  
``` cpp
void arraySumParam(int arr[], int n, int sum) {
    if (n == 0) {
        cout << sum << endl;
        return;
    }
    arraySumParam(arr, n - 1, sum + arr[n - 1]);
}
```
**Usage:** arraySumParam(arr, 5, 0)

**Functional:**  
``` cpp
int arraySumFunc(int arr[], int n) {
    if (n == 0) return 0;
    return arr[n - 1] + arraySumFunc(arr, n - 1);
}
```
**Usage:** cout << arraySumFunc(arr, 5)

---

### Comparison Table:

| Aspect | Parameterized | Functional |
|--------|--------------|-----------|
| Result storage | Parameter (accumulator) | Return value |
| Return type | Usually void | Returns result type |
| When result built | Going down (forward) | Coming back up (backward) |
| Recursion type | Tail recursion | Head recursion |
| Optimization | Can be tail-call optimized | Cannot be optimized |
| Readability | Less intuitive | More intuitive |
| Usage | When void is acceptable | When return value needed |

---

### When to Use Which?

**Use Parameterized When:**   

- You want tail recursion (optimization potential)
- Building result incrementally makes sense
- No need to return a value

**Use Functional When:**    

- Natural mathematical definition (n! = n Ã— (n-1)!)
- Need to return the result
- More readable/intuitive code
- Combining results from subproblems

---

### Key Takeaways:

**Parameterized Recursion:**    

- Accumulate the result in the parameter
- Tail recursion can be optimized
- Good for iteration-like problems

**Functional Recursion:**    

- Returns and combines results
- Head recursion is natural for math problems
- More intuitive but less optimizable

Both solve the same problems; choose based on readability and optimization needs.
