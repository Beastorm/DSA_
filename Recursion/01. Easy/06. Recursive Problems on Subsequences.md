## Recursion on Subsequences

### What is a Subsequence?

A **subsequence** is a sequence derived from another sequence by selecting elements in the same order (not necessarily contiguous).

**Example:** For array [3, 1, 2]

**All subsequences:**
```
- [] (empty)
- [3]
- [1]
- [2]
- [3, 1]
- [3, 2]
- [1, 2]
- [3, 1, 2]
```
**Total:** 2^n subsequences (for n elements)

---

### Pattern: Pick / Not Pick

For each element, we have **two choices:**
1. **Pick** the element (include in current subsequence)
2. **Not pick** the element (exclude from current subsequence)

This creates a **binary decision tree**.

---

## Problem 1: Print All Subsequences

### Diagram:
![Recursion on Subsequences - Pick/Not Pick Pattern](https://github.com/Beastorm/DSA_/blob/38ae6a429adbd054a8255b6055c18f07f3cf0b7f/junk/print_sub_sequence.png?raw=true)  
*Binary recursion tree showing pick/not-pick pattern for generating all subsequences of array [3, 1, 2] - demonstrates backtracking and generates all 2^n subsequences.*

### C++ Code:

```cpp
#include <iostream>
#include <vector>
using namespace std;

void printSubsequences(int index, vector<int>& arr, vector<int>& current) {
    // Base case: processed all elements
    if (index == arr.size()) {
        // Print current subsequence
        cout << "[";
        for (int i = 0; i < current.size(); i++) {
            cout << current[i];
            if (i != current.size() - 1) cout << ", ";
        }
        cout << "]" << endl;
        return;
    }
    
    // Pick the element at index
    current.push_back(arr[index]);
    printSubsequences(index + 1, arr, current);
    
    // Backtrack: remove the element (not pick)
    current.pop_back();
    printSubsequences(index + 1, arr, current);
}

int main() {
    vector<int> arr = {3, 1, 2};
    vector<int> current;
    
    cout << "All subsequences of [3, 1, 2]:" << endl;
    printSubsequences(0, arr, current);
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(2^n × n)

- **Why?**
    - Total subsequences = 2^n (each element: pick or not pick)
    - Printing each subsequence = O(n) (worst case: n elements to print)
    - Total = 2^n subsequences × O(n) per print = **O(2^n × n)**

- **Recursion tree:**
    - Depth = n
    - Total nodes ≈ 2^n
    - Each leaf prints a subsequence
    
---

**Space Complexity:** O(n)

- **Why?**
    - Recursion stack depth = n
    - Current subsequence storage = n
    - Total = **O(n)**

- **Note:** No extra data structures used.

---

## Problem 2: Print Subsequences with Sum K

### Diagram:
![Print Subsequences with Sum K](https://github.com/Beastorm/DSA_/blob/71aef125439c8ddfcbc5803665578b913f7f9481/junk/subsequence_with_sum_k.png?raw=true)  
*Binary recursion tree for finding all subsequences with sum equal to K - explores all 2^n possibilities and prints only those matching the target sum (array = [1, 2, 1], K = 2).*

### C++ Code:
``` cpp
#include <iostream>
#include <vector>
using namespace std;

void printSubsequencesWithSum(int index, vector<int>& arr, vector<int>& current, int sum, int k) {
    // Base case
    if (index == arr.size()) {
        if (sum == k) {
            cout << "[";
            for (int i = 0; i < current.size(); i++) {
                cout << current[i];
                if (i != current.size() - 1) cout << ", ";
            }
            cout << "]" << endl;
        }
        return;
    }
    
    // Pick
    current.push_back(arr[index]);
    printSubsequencesWithSum(index + 1, arr, current, sum + arr[index], k);
    
    // Not pick (backtrack)
    current.pop_back();
    printSubsequencesWithSum(index + 1, arr, current, sum, k);
}

int main() {
    vector<int> arr = {1, 2, 1};
    vector<int> current;
    int k = 2;
    
    cout << "Subsequences with sum = " << k << ":" << endl;
    printSubsequencesWithSum(0, arr, current, 0, k);
    
    return 0;
}
```
### Complexity Analysis:

**Time Complexity:** O(2^n)

- **Why?**

    - Still explores all 2^n subsequences
    - Each subsequence is checked if the sum equals k
    - Printing only happens for matching subsequences (subset of 2^n)
    - Worst case: all subsequences match → O(2^n × n) for printing
    - Average/Best case: fewer matches → closer to O(2^n)

- **Overall:** O(2^n) for exploring + O(m × n) for printing m matching subsequences

---

**Space Complexity:** O(n)

- **Why?**
    - Recursion stack depth = n
    - Current subsequence storage = n
    - Sum variable = O(1)
    - Total = O(n)

---

## Problem 3: Count Subsequences with Sum K

### Diagram:
![Count Subsequences with Sum K](https://github.com/Beastorm/DSA_/blob/65ae1e50dff1eaef627bdc725d2067c59b3fb088/junk/subsequence_count_sum_k.png?raw=true)  
*Recursion tree for counting subsequences with sum equal to K - leaf nodes return 1 or 0, counts propagate up through pick/not-pick decisions (array = [1, 2, 1], K = 2, result = 2).*

### C++ Code:

``` cpp
#include <iostream>
#include <vector>
using namespace std;

int countSubsequencesWithSum(int index, vector<int>& arr, int sum, int k) {
    // Base case
    if (index == arr.size()) {
        return (sum == k) ? 1 : 0;
    }
    
    // Pick: add to sum
    int pick = countSubsequencesWithSum(index + 1, arr, sum + arr[index], k);
    
    // Not pick: don't add
    int notPick = countSubsequencesWithSum(index + 1, arr, sum, k);
    
    return pick + notPick;
}

int main() {
    vector<int> arr = {1, 2, 1};
    int k = 2;
    
    int count = countSubsequencesWithSum(0, arr, 0, k);
    cout << "Count of subsequences with sum = " << k << ": " << count << endl;
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(2^n)

- **Why?**
    - Explores all 2^n subsequences
    - Each leaf returns 1 or 0 (O(1) operation)
    - No printing overhead
    - Total recursive calls = 2^n

- **Overall:** O(2^n)

---

- **Space Complexity:** O(n)

- **Why?**
    - Recursion stack depth = n
    - Sum variable = O(1)
    - No current array storage needed
    - Total = O(n)

---

## Problem 4: Print Only One Subsequence with Sum K

### Diagram:
![Print Only ONE Subsequence with Sum K](https://github.com/Beastorm/DSA_/blob/1e8843ecb28f243a820100d5555a0dded64c6fe2/junk/subseq_exit_found_sum_k.png?raw=true)  
*Early termination in subsequence search - finds first matching subsequence with sum K and immediately stops exploration, pruning remaining branches (array = [1, 2, 1], K = 2, prints [1, 1] and exits).*

### C++ Code:
``` cpp
#include <iostream>
#include <vector>
using namespace std;

bool printOneSubsequence(int index, vector<int>& arr, vector<int>& current, int sum, int k) {
    // Base case
    if (index == arr.size()) {
        if (sum == k) {
            cout << "[";
            for (int i = 0; i < current.size(); i++) {
                cout << current[i];
                if (i != current.size() - 1) cout << ", ";
            }
            cout << "]" << endl;
            return true;  // Found one, stop searching
        }
        return false;
    }
    
    // Pick
    current.push_back(arr[index]);
    if (printOneSubsequence(index + 1, arr, current, sum + arr[index], k)) {
        return true;  // Found, propagate back
    }
    
    // Backtrack
    current.pop_back();
    
    // Not pick
    if (printOneSubsequence(index + 1, arr, current, sum, k)) {
        return true;
    }
    
    return false;
}

int main() {
    vector<int> arr = {1, 2, 1};
    vector<int> current;
    int k = 2;
    
    cout << "One subsequence with sum = " << k << ":" << endl;
    if (!printOneSubsequence(0, arr, current, 0, k)) {
        cout << "No subsequence found" << endl;
    }
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(2^n)

- **Why?**
    - **Worst case:** O(2^n) - no matching subsequence exists, explore entire tree
    - **Best case:** O(n) - first path finds a match immediately
    - **Average case:** Between O(n) and O(2^n)
    - **Early termination:** Stops as soon as one subsequence is found
    - **Key difference:** Returns true to propagate back and stop exploration

---

- **Space Complexity:** O(n)

- **Why?**
    - Recursion stack depth = n
    - Current subsequence storage = n
    - Sum variable = O(1)
    - Total = O(n)

