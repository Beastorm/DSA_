## Recursion

## What is Recursion?

**Recursion** is a programming technique where a function calls itself to solve a problem by breaking it down into smaller, similar subproblems.

**Key Idea:** Solve a big problem by solving smaller versions of the same problem.

---

### Core Components of Recursion

#### 1. Base Case (Stopping Condition)
- The simplest case that can be solved directly without recursion
- Prevents infinite loops
- *Without base case = infinite recursion = stack overflow!*

#### 2. Recursive Case
- The function calls itself with a modified (usually smaller) input
- Moves towards the base case

#### 3. Return and Combine
- Results from smaller problems are combined to solve the bigger problem

---

## Count from 1 to N - Head vs Tail Recursion

### Approach 1: Head Recursion

### C++ Code:
```cpp
void countUpHead(int n) {
    // Base case
    if (n == 0) {
        return;
    }
    
    // Recursive call FIRST
    countUpHead(n - 1);
    
    // Print AFTER recursive call (on the way back)
    cout << n << " ";
}

int main(){
   countUpHead(5);
   // Output: 1 2 3 4 5
}
```
### Diagram:
![Head Recursion Tree](https://github.com/Beastorm/DSA_/blob/fb4a2dee8333841f4c8373e6871f3609e9ff8f5c/junk/head.png?raw=true)  
*Head recursion visualization for counting from 1 to N - recursive calls go down, printing happens on the way back up.*

### Stack Visualization:
**Phase 1:** Going Down (No printing yet)

```
countUpHead(5)
  â†“ Call countUpHead(4)
    â†“ Call countUpHead(3)
      â†“ Call countUpHead(2)
        â†“ Call countUpHead(1)
          â†“ Call countUpHead(0)
            â†“ Base case reached, return

Stack at deepest point:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ countUpHead(0)  â”‚ â† Base case, return
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpHead(1)  â”‚ â† Waiting
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpHead(2)  â”‚ â† Waiting
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpHead(3)  â”‚ â† Waiting
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpHead(4)  â”‚ â† Waiting
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpHead(5)  â”‚ â† Waiting
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```
**Phase 2:** Coming Back Up (Printing happens)

```
countUpHead(0) returns
  â†“
countUpHead(1) resumes â†’ Print 1
  â†“
countUpHead(2) resumes â†’ Print 2
  â†“
countUpHead(3) resumes â†’ Print 3
  â†“
countUpHead(4) resumes â†’ Print 4
  â†“
countUpHead(5) resumes â†’ Print 5
  â†“
Done

Output: 1 2 3 4 5

```
### Characteristics
**Type**: Head Recursion     
**Print timing:** After recursive call (on return path)   
**Stack usage:** Full depth (n levels)   
**Work done:** On the way back up   

---

## Approach 2: Tail Recursion

### C++ Code:
``` cpp
void countUpTail(int current, int n) {
    // Base case
    if (current > n) {
        return;
    }
    
    // Print BEFORE recursive call
    cout << current << " ";
    
    // Recursive call is the LAST operation (tail recursion)
    countUpTail(current + 1, n);
}
int main(){
    countUpTail(1, n);  // Start from 1
    // Output: 1 2 3 4 5
}

```
### Diagram:
![Tail Recursion Tree](https://github.com/Beastorm/DSA_/blob/fb4a2dee8333841f4c8373e6871f3609e9ff8f5c/junk/tail.png?raw=true)  
*Tail recursion visualization for counting from 1 to N - printing happens on the way down, returns are just unwinding the stack.*


### Stack Visualization:
Printing happens while going down:

``` 
Call countUpTail(1, 5)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ countUpTail(1,5)â”‚ â† Print 1, then call (2,5)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Output: 1

Call countUpTail(2, 5)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ countUpTail(2,5)â”‚ â† Print 2, then call (3,5)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(1,5)â”‚ â† Waiting
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Output: 1 2

Call countUpTail(3, 5)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ countUpTail(3,5)â”‚ â† Print 3, then call (4,5)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(2,5)â”‚ â† Waiting
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(1,5)â”‚ â† Waiting
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Output: 1 2 3

Call countUpTail(4, 5)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ countUpTail(4,5)â”‚ â† Print 4, then call (5,5)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(3,5)â”‚ â† Waiting
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(2,5)â”‚ â† Waiting
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(1,5)â”‚ â† Waiting
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Output: 1 2 3 4

Call countUpTail(5, 5)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ countUpTail(5,5)â”‚ â† Print 5, then call (6,5)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(4,5)â”‚ â† Waiting
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(3,5)â”‚ â† Waiting
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(2,5)â”‚ â† Waiting
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(1,5)â”‚ â† Waiting
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Output: 1 2 3 4 5

Call countUpTail(6, 5)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ countUpTail(6,5)â”‚ â† current > n, BASE CASE, return
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(5,5)â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(4,5)â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(3,5)â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(2,5)â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ countUpTail(1,5)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Then all functions return (nothing left to do)

```
### Characteristics:
Type: Tail Recursion
Print timing: Before recursive call (on the way down)
Stack usage: Full depth (n levels) in practice
Work done: On the way down
Optimization potential: Can be optimized through iteration by the compiler

---

## Stack Space & Stack Overflow 

### âœ… Stack Space

- Memory used to store function calls (call stack)
- Each recursive call adds a new **stack frame**
- Stack frame stores:
  - Parameters
  - Local variables
  - Return address
- **Space Complexity in recursion:** O(n) (n = depth)

**Example:**
Calling `countUp(5)` recursively â†’ 5 stack frames used

---

### âŒ Stack Overflow

- Happens when **too many recursive calls** exceed memory limit
- Common causes:
  - Missing base case
  - Deep recursion (e.g., `countDown(1e6)`)

**Symptoms:**
- Program crashes
- â€œSegmentation Faultâ€ or â€œStackOverflowErrorâ€

#### ğŸ” How to Prevent:
1. **Always define a base case*
2. *Use iteration* for deep recursion (loops use O(1) space)  
3. *Tail recursion* (if compiler supports optimization)

---

### ğŸ§  Summary:

| Term            | Meaning                          |
|-----------------|----------------------------------|
| Stack Space     | Memory used by function calls    |
| Stack Overflow  | Error: stack memory exceeded     |
| Recursion Depth | Affects stack usage              |
| Fix             | Use base case or convert to loop |




