## What is Multiple Recursion?
Multiple recursion occurs when a function makes more than one recursive call.
Common problems like Fibonacci, tree traversals, merge sort, etc.

### Example:  Fibonacci Number

Find the nth Fibonacci number where:
- fib(0) = 0
- fib(1) = 1
- fib(n) = fib(n-1) + fib(n-2)

**Sequence:** 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

### Diagram:
![Fibonacci Multiple Recursion Tree](https://github.com/Beastorm/DSA_/blob/97656da66bd6f81ee90e5247e3769e0739bb133c/junk/fibbonacci.png?raw=true)  
*Multiple recursion tree for calculating Fibonacci numbers - shows how fib(5) makes recursive calls and demonstrates redundant calculations (highlighted in red).*

### C++ Code:

```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    // Base cases
    if (n == 0) return 0;
    if (n == 1) return 1;
    
    // Multiple recursion: two recursive calls
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    cout << "Fibonacci numbers:" << endl;
    for (int i = 0; i <= 10; i++) {
        cout << "fib(" << i << ") = " << fibonacci(i) << endl;
    }
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(2^n)$
    - **Why exponential?**
        - Each call makes 2 recursive calls
        - Creates a binary tree of calls
        - Total calls â‰ˆ 2^n
    
    - **Example:** fib(5) makes **15 function calls**
    
    - **Growth:**
        - fib(10): ~1,000 calls
        - fib(20): ~1,000,000 calls
        - fib(30): ~1,000,000,000 calls
    
    - **Extremely slow for large n!**

- **Space Complexity:** $O(n)$
    - **Why linear?**
        - Space = maximum recursion depth
        - Depth = height of tree = n
        - Stack holds at most n frames simultaneously
    
    - **Example:** fib(5) has max depth of 5


### Problem: Redundant Calculations:

**For fib(5):**   
- fib(3): calculated 2 times
- fib(2): calculated 3 times
- fib(1): calculated 5 times
- fib(0): calculated 3 times

---

### Optimized Approaches:

| Approach | Time | Space |
|----------|------|-------|
| Naive Recursion | O(2^n) | O(n) |
| Memoization | O(n) | O(n) |
| Iteration | O(n) | O(1) |

---

### Summary:

- **Time:** Exponential O(2^n) - very inefficient
- **Space:** Linear O(n) - recursion depth
- **Solution:** Use memoization or iteration instead
- Good for learning, bad for production
