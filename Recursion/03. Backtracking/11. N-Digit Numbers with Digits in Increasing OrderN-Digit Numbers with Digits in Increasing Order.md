## N-Digit Numbers with Digits in Increasing Order

**Problem Statement:**    
Given an integer `N`, print all the `N-digit` numbers in increasing order, such that their digits are in strictly increasing order (from left to right).

**Key Constraints:**    
_Digits used:_ 1 to 9 (0 cannot be the first digit, and including 0 breaks the strict increasing order from any digit)
_Strictly increasing:_ Each digit must be greater than the previous
_N-digit number:_ Must have exactly N digits

---
>### Examples:

### Example 1:
**Input:** N = 1   
**Output:** 0 1 2 3 4 5 6 7 8 9     
**Explanation:** Single-digit numbers are considered to be in strictly increasing order.    

### Example 2:
**Input:** N = 2    
**Output:** 12 13 14 15 16 17 18 19 23 24 25 26 27 28 29 34 35 36 37 38 39 45 46 47 48 49 56 57 58 59 67 68 69 78 79 89     
**Explanation:** Must have exactly 2 digits, and each digit is greater than the previous.   

---

## Approach

### Intuition:

- The problem asks for all N-digit numbers where each digit is strictly greater than the previous one (digits are in increasing order).
- This is a classic backtracking problem: at each step, you choose the next digit to be greater than the last digit used.
- For N = 1, all single-digit numbers (including 0) are valid.
- For N > 1, you start with 1 (to avoid leading zeros) and recursively build up the number by adding valid digits.
- When the number reaches N digits, you add it to the result.


### Algorithm Steps:

1. **Start with an empty number (`vector<int> v`) and `n = N`.**
2. **Recursive Function:**
   - If `n == 0`, convert the vector to a number and add it to the result.
   - Determine the next possible digit:
     - If the vector is empty and `N == 1`, start from 0.
     - If the vector is empty and `N > 1`, start from 1.
     - Otherwise, start from the last digit + 1.
   - For each digit `i` from `start` to 9:
     - Add `i` to the current number.
     - Recurse with one less digit to fill.
     - Backtrack by removing the last digit.
3. **Repeat until all combinations are generated.**


### Backtracking Template for This Problem

- **State:** Current number (as a string or vector), current length, last digit used.
- **Choices:** Next digit can be any digit greater than the last used digit (from last+1 to 9).
- **Base Case:** If the current number has N digits, print it.
- **Backtrack:** Remove the last digit and try the next possible digit.

### In short:

- Use recursion to build numbers digit by digit.
- At each step, only add digits greater than the previous one.
- Print the number when it reaches N digits.


### Diagram:
![N Digit Numbers Recursive Tree](https://raw.githubusercontent.com/Beastorm/DSA_/9edad9b67244b86d30439bcec35b77206ee1c1c4/junk/nth_digit.png)


### C++ Code:

``` cpp
#include <iostream>
#include <vector>
using namespace std;

void generateIncreasingNumbers(int remainingDigits, vector<int>& currentDigits, vector<int>& resultNumbers) {
    // Base case: All digits have been chosen
    if (remainingDigits == 0) {
        int formedNumber = 0;
        for (int digit : currentDigits) {
            formedNumber = formedNumber * 10 + digit;
        }
        resultNumbers.push_back(formedNumber);
        return;
    }
    
    // Determine the starting digit for this position
    int startDigit = 1;
    
    if (currentDigits.empty()) {
    
        // For single-digit numbers, allow 0; otherwise start from 1
        startDigit = (remainingDigits == 1) ? 0 : 1;
        
    } else {
        // Next digit must be greater than the last chosen digit
        startDigit = currentDigits.back() + 1;
    }
    
    // Try all valid digits from startDigit to 9
    for (int nextDigit = startDigit; nextDigit <= 9; ++nextDigit) {

        // Choose a digit
        currentDigits.push_back(nextDigit);  
        
        // Recurse
        generateIncreasingNumbers(remainingDigits - 1, currentDigits, resultNumbers);  
        
        currentDigits.pop_back(); // Backtrack
    }
}

vector<int> findAllIncreasingNumbers(int totalDigits) {
    vector<int> resultNumbers;
    vector<int> currentDigits;
    
    generateIncreasingNumbers(totalDigits, currentDigits, resultNumbers);
    
    return resultNumbers;
}

int main() {
    int numberOfDigits;
    cin >> numberOfDigits;
    
    vector<int> increasingNumbers = findAllIncreasingNumbers(numberOfDigits);
    
    for (int number : increasingNumbers) {
        cout << number << " ";
    }
    cout << endl;
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  $O(C(10, N))$, where $C(10, N)$ is the number of ways to choose N digits from 10 in increasing order (i.e., "10 choose N").
  - For each valid N-digit number, the function does $O(N)$ work (building the number).
  - The total number of such numbers is $C(10, N)$.

- **Space Complexity:**  
  $O(N)$ for the recursion stack (maximum depth is N).
  - $O(C(10, N))$ for storing all results if you keep them in a vector.
