## Time Complexity of a Recursive Tree

### Key Idea:

- The time complexity of a recursive solution can often be derived by analyzing its **recursive tree**.
- **Total Time = (Number of nodes in the tree) × (Work done at each node)**

### Steps to Analyze:

1. **Draw the recursive tree:**  
   - Each node represents a function call.
   - Children represent further recursive calls.

2. **Count the number of nodes:**  
   - This is the total number of function calls made during the recursion.

3. **Calculate the work per node:**  
   - This is the amount of computation (excluding recursive calls) done in each function call.

4. **Multiply:**  
   - Total time complexity = (Number of nodes) × (Work per node)

---

### Examples: 

**1. Fibonacci**  
_code:_
  ```cpp
  int fib(int n) {
      if (n <= 1) return n;
      return fib(n-1) + fib(n-2);
  }
  ```
- Recursive Tree: Binary Tree (Each call splits into 2 calls).
- Number of nodes: Grows exponentially ($\approx 2^n$).
- Work per node: O(1)
- Total Time Complexity: O(2^n)

---

**2. Binary Tree Traversal (Preorder, Inorder, Postorder)**  
_Code:_
``` cpp
void traverse(TreeNode* root) {
    if (!root) return;
    traverse(root->left);
    traverse(root->right);
}
```
- Recursive Tree: Each node is visited once.
- Number of nodes: n (number of tree nodes)
- Work per node: O(1)
- Total Time Complexity: O(n)

---

**3. Subset Generation**  
_Code:_
``` cpp
void generate(int i, vector<int>& subset) {
    if (i == n) { print(subset); return; }
    generate(i+1, subset);         // Exclude current
    subset.push_back(arr[i]);
    generate(i+1, subset);         // Include current
    subset.pop_back();
}
```
- Recursive Tree: Each level branches into 2 (include/exclude).
- Number of nodes: 2^n
- Work per node: O(n) (for printing subset)
- Total Time Complexity: O(n * 2^n)

---

**4. Merge Sort**  
_Code:_

``` cpp
void mergeSort(int arr[], int l, int r) {
    if (l >= r) return;
    int m = (l + r) / 2;
    mergeSort(arr, l, m);
    mergeSort(arr, m+1, r);
    merge(arr, l, m, r);
}
```
- Recursive Tree: Each level splits the array in half.
- Number of levels: log n
- Work per level: O(n)
- Total Time Complexity: O(n log n)

---

**5. Tower of Hanoi**   
_Code:_  

``` cpp
void hanoi(int n, char A, char B, char C) {
    if (n == 0) return;
    hanoi(n-1, A, C, B);
    // move disk
    hanoi(n-1, B, A, C);
}
```
- Recursive Tree: Each call makes 2 recursive calls.
- Number of nodes: 2^n
- Work per node: O(1)
- Total Time Complexity: O(2^n)











