## Rat in a Maze Problem

**Problem Statement:**  

Given an `N x N` maze (matrix) filled with `0s` (blocked) and `1s` (open), a rat starts at the top-left cell `(0,0)` and needs to reach the bottom-right cell `(N-1, N-1)`. The rat can move in four directions (`up`, `down`, `left`, `right`) but cannot visit a cell more than once in a path. Print all possible paths from start to finish as strings of directions (e.g., `DRDR` for `Down`, `Right`, `Down`, `Right`).

---

### Example:

**Input:** N = 4
```
maze = 
      [
       [1, 0, 0, 0], 
       [1, 1, 0, 1],
       [0, 1, 0, 0],
       [1, 1, 1, 1]
      ]
```
**Output:** DDRDRR, DRDDRR

_Notes:_
- Use recursion and backtracking to explore all valid paths.
- Mark cells as visited to avoid cycles.
- Add the path to the result when the destination is reached.

---

## Approach
### Intuition:

- The problem is to find all possible paths for a rat to move from the top-left to the bottom-right of a maze, moving only through open cells (1s) and not revisiting any cell in a path.
- At each step, the rat can move in four directions (down, left, right, up), but only if the move is within bounds, not blocked, and not already visited.
- Backtracking is used: mark the cell as visited, explore all possible moves, and unmark (backtrack) after exploring.


### Backtracking Template for This Problem:

- **State:** Current cell (i, j), current path string, visited matrix.
- **Choices:** Move in any valid direction (D, L, R, U).
- **Base Case:** Reached destination cell (N-1, N-1).
- **Backtrack:** Unmark the cell as visited after exploring all options from it.


### Algorithm Steps:

1. **Start at (0, 0)** if it is open.
2. **Recursive Function:**
   - If the current cell is the destination, add the current path to the result and return.
   - For each possible move (D, L, R, U):
     - Calculate the new cell coordinates.
     - If the move is valid (within bounds, open, not visited):
       - Mark the current cell as visited.
       - Add the direction to the path.
       - Recurse to the new cell.
       - Unmark the cell (backtrack).
       - Remove the last direction from the path.
3. **Repeat** until all paths are explored.


**Diagram:**  
shows all four possible moves: Up (U), Left (L), Right (R), Down (D).   

![Rat in a Maze Recursive Tree](https://raw.githubusercontent.com/Beastorm/DSA_/f8b3fca782afc5c0f4e12b54440c3381cf121655/junk/rat_maze.png)


### C++ Code:
``` cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Struct to represent a movement direction in the maze
struct Direction {
    char directionSymbol;  // Direction name: 'D', 'L', 'R', 'U'
    int rowChange;         // Change in row (x-coordinate)
    int colChange;         // Change in column (y-coordinate)
};

// Check if the destination (bottom-right corner) is reached
bool isDestinationReached(int currentRow, int currentCol, int mazeSize) {
    return currentRow == mazeSize - 1 && currentCol == mazeSize - 1;
}

// Check if the move to a cell is valid
bool isCellValid(int targetRow, int targetCol, int mazeSize, vector<vector<int>>& maze) {
    return targetRow >= 0 && targetRow < mazeSize && 
           targetCol >= 0 && targetCol < mazeSize && 
           maze[targetRow][targetCol] == 1;
}

// Backtracking function to find all paths from source to destination
void findAllPathsRecursive(int currentRow, int currentCol, const int mazeSize, 
                           vector<string>& allPaths, string& currentPath, 
                           vector<vector<int>>& maze, const vector<Direction>& possibleDirections) {
    // Base case: Destination reached
    if (isDestinationReached(currentRow, currentCol, mazeSize)) {
        allPaths.push_back(currentPath);
        return;
    }
    
    // Try all possible directions
    for (const auto& direction : possibleDirections) {
        int nextRow = currentRow + direction.rowChange;
        int nextCol = currentCol + direction.colChange;
        
        if (isCellValid(nextRow, nextCol, mazeSize, maze)) {
            maze[currentRow][currentCol] = 0;              // Mark current cell as visited
            currentPath.push_back(direction.directionSymbol);  // Add direction to path
            
            // Recurse to the next cell
            findAllPathsRecursive(nextRow, nextCol, mazeSize, allPaths, currentPath, maze, possibleDirections);
            
            maze[currentRow][currentCol] = 1;              // Unmark cell (backtrack)
            currentPath.pop_back();                        // Remove direction from path (backtrack)
        }
    }
}

class MazeSolver {
public:
    vector<string> findAllPaths(vector<vector<int>>& maze, int mazeSize) {
        vector<string> allPaths;
        string currentPath = "";
        
        // Define all four possible directions: Down, Left, Right, Up (lexicographical order)
        vector<Direction> possibleDirections = {
            {'D', 1, 0},   // Down
            {'L', 0, -1},  // Left
            {'R', 0, 1},   // Right
            {'U', -1, 0}   // Up
        };
        
        // Start pathfinding only if the starting cell is accessible
        if (maze[0][0] == 1) {
            findAllPathsRecursive(0, 0, mazeSize, allPaths, currentPath, maze, possibleDirections);
        }
        
        return allPaths;
    }
};

int main() {
    int mazeSize = 4;
    vector<vector<int>> maze = {
        {1, 0, 0, 0},
        {1, 1, 0, 1},
        {0, 1, 0, 0},
        {1, 1, 1, 1}
    };
    
    MazeSolver solver;
    vector<string> validPaths = solver.findAllPaths(maze, mazeSize);
    
    cout << "All possible paths from top-left to bottom-right:" << endl;
    for (const string& path : validPaths) {
        cout << path << endl;
    }
    
    return 0;
}

```

### Complexity Analysis:

- **Time Complexity:** $O(4^(n*n))$, where n is the size of the maze.
  - In the worst case, each cell can branch into 4 directions, and there are n*n cells.
  - However, pruning (not revisiting cells) reduces the actual number of paths.

- **Space Complexity:** $O(n*n)$ for the recursion stack and visited matrix.
  - O(L) for storing all valid paths, where L is the total number of valid paths.
