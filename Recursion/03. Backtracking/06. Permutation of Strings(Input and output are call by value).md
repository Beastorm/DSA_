## Permutation of Strings

**Problem Statement:**
Given a string S, print all **unique permutations** of the given string in **lexicographically sorted order**.

---

### Example 1:

**Input:** ABC

**Output:** ABC ACB BAC BCA CAB CBA

**Explanation:**  
Given string ABC has 6 permutations:  
ABC, ACB, BAC, BCA, CAB, CBA

---

### Example 2:

**Input:** ABSG

**Output:**  
ABGS ABSG AGBS AGSB ASBG ASGB BAGS BASG BGAS BGSA BSAG BSGA GABS GASB GBAS GBSA GSAB GSBA SABG SAGB SBAG SBGA SGAB SGBA

---

## Approach

### Intuition:

- The goal is to generate all unique permutations of a string in lexicographical order.
- At each step, you choose one character from the remaining string and append it to the current output.
- To avoid duplicates (especially when the string has repeated characters), you use a set to ensure each character is only chosen once at each position.
- By recursively building the output and removing the chosen character from the input, you explore all possible arrangements.
- Sorting the input string and the final result ensures the output is in lexicographical order.


![Permutation of String](https://raw.githubusercontent.com/Beastorm/DSA_/c80448be39d77c4e58ab0b81af2865daacae4a84/junk/permutation_of_String.png)

### Algorithm for Unique Permutations in Lexicographical Order:

1. **Sort the Input String**
   - Sort the string `S` to ensure permutations are generated in lexicographical order.

2. **Define a Recursive Function**
   - The function takes the current input string (`ip`), the current output string (`op`), and a result vector (`v`).

3. **Base Case**
   - If the input string is empty (`ip.size() == 0`), add the output string (`op`) to the result vector and return.

4. **Recursive Case**
   - Use a set to keep track of characters already used at the current recursion level (to avoid duplicates).
   - For each character in the input string:
     - If the character has not been used at this level:
       - Mark the character as used by inserting it into the set.
       - Form a new input string by removing the current character.
       - Form a new output string by appending the current character to `op`.
       - Recurse with the new input and output strings.

5. **After Recursion**
   - Sort the result vector to ensure the final output is in lexicographical order.

6. **Print or Return the Result**
   - Output all unique permutations.


**In short:**  
- At each step, pick a unique character, build the permutation recursively, and use a set to avoid duplicates at each level.
- Sorting ensures the output is in the required order.


### C++ Code:(Input and output are call by value)

``` cpp
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

// Helper function to generate all unique permutations
void Permute(string ip, string op, vector<string>& v) {
    // Base case: if input is empty, store the output permutation
    if (ip.size() == 0) {
        v.push_back(op);
        return;
    }
    // Use a set to avoid duplicate characters at the current position
    set<char> mp;
    for (int i = 0; i < ip.size(); i++) {
        if (mp.find(ip[i]) == mp.end()) { // If character not used at this level
            mp.insert(ip[i]);
            
            // Form new input by removing the i-th character
            string newIP = ip.substr(0, i) + ip.substr(i + 1);
            
            // Form new output by adding the chosen character
            string newOP = op + ip[i];
            
            // Recurse
            Permute(newIP, newOP, v);
        }
    }
}

// Function to find all unique permutations in sorted order
vector<string> findPermutations(string S) {
    vector<string> v;
    
    sort(S.begin(), S.end()); // Sort to ensure lexicographical order
    
    Permute(S, "", v);
    
    sort(v.begin(), v.end()); // Sort the result for lex order
    
    return v;
}

int main() {
    string S;
    cin >> S;
    vector<string> result = findPermutations(S);
    
    for (const auto& s : result) {
        cout << s << " ";
    }
    cout << endl;
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  O(n! * n), where n is the length of the string.
  - There are up to n! unique permutations for a string of length n.
  - Each permutation takes O(n) time to build and store.
  - The use of a set at each recursion level adds some overhead, but does not change the overall factorial growth.

- **Space Complexity:**  
  O(n! * n) for storing all unique permutations (each of length n).
  - O(n) for the recursion stack (maximum depth is n).
  - O(n) for the set used at each recursion level.


