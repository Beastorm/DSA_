## Largest number in K swaps

**Problem Statement:**   
Given a number `K` and a string `str` of digits denoting a positive integer, build the largest number possible by performing swap operations on the digits of `str` at most `K` times.

---

### Example:
**Input:** `K = 4`, `str = "1234567"`    
**Output:** 7654321      
**Explanation:**   
Three swaps can make the
Input 1234567 to 7654321, swapping 1
with 7, 2 with 6, and finally 3 with 5

---
## Approach

### Intuition:

- The goal is to make the largest number possible by performing at most K swaps.
- At each position in the string, you want to bring the largest possible digit (from the right) to the current position.
- By always swapping with the maximum digit available, you maximize the number at each step.
- You use recursion to try all possible swaps with the maximum digit, and backtrack to explore all options.
- The result is updated whenever a larger number is formed.


### Algorithm Steps:

1. **Initialize:**  
   - Start with the original string and set the result as the original string.

2. **Recursive Function:**  
   - If no swaps are left or you have reached the end of the string, return.
   - Find the maximum digit from the current position to the end.
   - If the maximum digit is not greater than the current digit, move to the next position.
   - For every occurrence of the maximum digit to the right:
     - Swap it with the current position.
     - If the new string is greater than the result, update the result.
     - Recurse with one less swap and move to the next position.
     - Backtrack (undo the swap).

3. **Return:**  
   - After all recursive calls, the result will hold the largest number possible.


### Diagram:
![K-Swap Tree](https://github.com/Beastorm/DSA_/blob/6b0b5d3b64cf19d2fefe60909b79d6e46c9e8f35/junk/kswap.png?raw=true)  
*Visual representation of state transitions in a k-swap problem, illustrating how different swaps lead to different permutations.*

### C++ Code:

``` cpp
#include <iostream>
#include <string>
using namespace std;

// Helper function to update the result if the current string is greater
void solve(string& s, int k, string& res, int start) {
    // Base case: no swaps left or reached end of string
    if (k == 0 || start == s.size() - 1)
        return;

    char maxChar = s[start];
    // Find the maximum digit from start to end
    for (int i = start + 1; i < s.size(); i++) {
        if (s[i] > maxChar)
            maxChar = s[i];
    }

    // If maxChar is not greater, no need to swap
    if (maxChar == s[start]) {
        solve(s, k, res, start + 1);
        return;
    }

    // Try all swaps with maxChar
    for (int i = start + 1; i < s.size(); i++) {
        if (s[i] == maxChar) {
            swap(s[start], s[i]);

            // Update result if current string is greater
            if (s.compare(res) > 0)
                res = s;

            solve(s, k - 1, res, start + 1);

            swap(s[start], s[i]); // Backtrack
        }
    }
}

int main() {
    int k;
    string s;
    cin >> k >> s;
    string res = s;
    solve(s, k, res, 0);
    cout << res << endl;
    return 0;
}

```

### Complexity Analysis:

- **Time Complexity:**  
  O((n!) * n), where n is the length of the string.
  - In the worst case, you may try all possible swaps at each position (though the use of the maximum digit prunes many branches).
  - Each swap and comparison takes O(n) time.

- **Space Complexity:**  
  O(n), due to the recursion stack and the space used to store the result string.
