## Lecture 10: Kth Symbol in Grammar

### Problem Statement:

On the first row, we write a `0`.  
In every subsequent row, we look at the previous row and:
- Replace each occurrence of `0` with `01`
- Replace each occurrence of `1` with `10`

Given row `N` and index `K`, return the K-th indexed symbol in row N.  
(Note: K is 1-indexed.)

---

### Example:

- **Row 1:** 0  
- **Row 2:** 0 → 01  
- **Row 3:** 01 → 0110  
- **Row 4:** 0110 → 01101001  
- and so on...

---

## Approach

### Recursive Insight

- The K-th symbol in row N depends on its "parent" in the previous row.
- Each symbol in row N-1 generates two symbols in row N:
  - If the parent is `0`, it generates `0` (left child) and `1` (right child).
  - If the parent is `1`, it generates `1` (left child) and `0` (right child).
- The first half of the row comes from the left child, the second half from the right child.

### Recursive Algorithm

1. **Base Case:**  
   If N == 1, return 0 (the only symbol in the first row).

2. **Recursive Step:**  
   - Find the parent position: `parentK = (K + 1) / 2`
   - Recursively find the parent's value in row N-1.
   - If K is odd (left child), the symbol is the same as the parent.
   - If K is even (right child), the symbol is the complement (flip) of the parent.

---

## C++ Code:

```cpp
#include <iostream>
using namespace std;

// Recursive function to find the K-th symbol in the N-th row
int kthGrammar(int N, int K) {
    if (N == 1) return 0; // Base case: first row is always 0
    
    int parent = kthGrammar(N - 1, (K + 1) / 2);
    if (K % 2 == 1) return parent;      // Odd K: left child, same as parent
    else return 1 - parent;             // Even K: right child, flip parent
}

int main() {
    int N = 4, K = 5;
    cout << "The " << K << "-th symbol in row " << N << " is: " << kthGrammar(N, K) << endl;
    
    // You can test with other values as well
    cout << "The 1st symbol in row 1 is: " << kthGrammar(1, 1) << endl;
    cout << "The 2nd symbol in row 2 is: " << kthGrammar(2, 2) << endl;
    cout << "The 3rd symbol in row 3 is: " << kthGrammar(3, 3) << endl;
    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:**  
  `O(N)`, where `N` is the row number.  
  The recursion goes up one row at each step, so there are at most `N` recursive calls.

- **Space Complexity:**  
  `O(N)`, due to the recursion stack.  
  The maximum depth of recursion is equal to the row number `N`.

### How does this work?

- Each symbol is determined by its parent in the previous row and whether it is a left or right child.
- The recursion reduces the problem size by moving up one row each time, until the base case is reached.

---

**In short:**
- Use recursion to find the parent symbol,
- Decide the current symbol based on whether K is odd (left) or even (right).

