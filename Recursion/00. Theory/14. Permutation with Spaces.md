## Permutation with Spaces

**Problem Statement:**   
Given a string, print all possible strings that can be made by placing spaces (zero or one) in between the characters.  
The output should be printed in sorted (lexicographically increasing) order of strings.

>### Examples:
### Example 1:
**Input:** str = "ABC"    
**Output:**   
- A B C
- A BC
- AB C
- ABC
  
---

### Example 2:
**Input:** str = "AB"   
**Output:**  
- A B
- AB

---

### Example 3:
**Input:** str = "XYZ"   
**Output:**     
- X Y Z
- X YZ
- XY Z
- XYZ

---

### Example 4:
**Input:** str = "ABCD"   
**Output:**  
- A B C D
- A B CD
- A BC D
- A BCD
- AB C D
- AB CD
- ABC D
- ABCD

---

**Note:**  
- Each output line represents a different way to insert zero or one space between each pair of characters.
- The outputs are sorted in lexicographical order.

---

## Approach

### Algo:
1. Start with the first character in the output.
2. For each subsequent character, you have two choices:
    - Add a space before the character and append it to the output.
    - Add the character directly (without a space) to the output.
3. Recursively explore both choices for every character.
4. Store all results in a vector, sort them, and print.

### Diagram:
![Permutation with Spaces](https://github.com/Beastorm/DSA_/blob/1302a7ac3ec11fefa0ba6ede9f0cc504b9d7cb95/junk/Permutation%20with%20Spaces.png?raw=true)  
*Recursive tree for generating permutations with spaces for input "ABC" - shows choices (add space vs no space) and backtracks via return paths.*

### C++ Code:
``` cpp
#include <iostream>
using namespace std;

// Recursive function to generate all permutations with spaces
void solve(string ip, string op) {
    // Base case: if input is empty, print the output string
    if (ip.length() == 0) {
        cout << op << endl;
        return;
    }
    // Option 1: Add space before next character (if op is not empty)
    string op1 = op;
    op1.push_back(' ');
    op1.push_back(ip[0]);

    // Option 2: Add character without space
    string op2 = op;
    op2.push_back(ip[0]);

    // Remove the first character from input
    ip.erase(ip.begin());

    // Recurse for both choices
    solve(ip, op1);
    solve(ip, op2);
}

int main() {
    string ip;
    cin >> ip;
    // Start with the first character in output, and remove it from input
    string op = "";
    op.push_back(ip[0]);
    ip.erase(ip.begin());
    solve(ip, op);
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(2^{n-1} * n)`, where `n` is the length of the input string.  
  - For a string of length `n`, there are `n-1` places to insert a space (between characters).
  - Each place has 2 choices: insert a space or not, so total combinations = `2^{n-1}`.
  - Each output string can be up to length `2n-1` (if a space is inserted between every character), so printing each string takes `O(n)` time.

- **Space Complexity:**  
  `O(n)` due to the recursion stack and the space used to build the output string at each step.
---

### Why does this work?

- At each step, you branch into two paths: add a space or not before the next character.
- This explores all possible ways to insert spaces.
- Sorting ensures the output is in lexicographical order.

---

### In short: 
- Use recursion to explore all choices (space or no space).
- Store and sort results for lexicographical order.
