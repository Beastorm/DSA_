## Lecture 2: Recursion is Everywhere

### Recursion Problems:

---

### 1. Using the Input-Output Method

- **Idea:**  
  Define the function by specifying what input it takes and what output it should return.  
  The recursion works by reducing the input size at each step.

- **Example 1: Factorial**
  - **Function:** `factorial(n)`
  - **Input:** Integer `n`
  - **Output:** Product of all numbers from 1 to `n`
  - **Recursive Step:**  
    `factorial(n) = n * factorial(n-1)`
  - **Base Case:**  
    `factorial(0) = 1`
  - **How it works:**  
    To compute `factorial(4)`, you call `factorial(3)`, then `factorial(2)`, and so on, until you reach the base case.

- **Example 2: Sum of Array**
  - **Function:** `sum(arr, n)`
  - **Input:** Array `arr` and its size `n`
  - **Output:** Sum of all elements in the array
  - **Recursive Step:**  
    `sum(arr, n) = arr[0] + sum(arr+1, n-1)`
  - **Base Case:**  
    If `n == 0`, return 0.

---

### 2. Using the Extended Input-Output Method

- **Idea:**  
  Sometimes, you need to keep track of extra information (like a partial answer or state) as you recurse.  
  The function may take additional parameters to carry this information.

- **Example 1: Generating All Subsets**
  - **Function:** `generateSubsets(arr, index, currentSubset)`
  - **Input:** Array `arr`, current index, and the current subset (partial output)
  - **Output:** Print or collect all possible subsets
  - **Recursive Step:**  
    At each index, you have two choices:  
    1. Include the current element in the subset  
    2. Exclude the current element  
    Call the function recursively for both choices, updating `currentSubset` accordingly.
  - **Base Case:**  
    If `index == arr.size()`, print or store `currentSubset`.

  - **Example Trace for arr = [1, 2]:**
    ```
    generateSubsets([1,2], 0, [])
    ├── include 1 → generateSubsets([1,2], 1, [1])
    │   ├── include 2 → generateSubsets([1,2], 2, [1,2]) → print [1,2]
    │   └── exclude 2 → generateSubsets([1,2], 2, [1])   → print [1]
    └── exclude 1 → generateSubsets([1,2], 1, [])
        ├── include 2 → generateSubsets([1,2], 2, [2])   → print [2]
        └── exclude 2 → generateSubsets([1,2], 2, [])    → print []
    ```

- **Example 2: String Permutations**
  - **Function:** `permute(str, l, r)`
  - **Input:** String `str`, left index `l`, right index `r`
  - **Output:** Print all permutations of the string
  - **Recursive Step:**  
    For each index from `l` to `r`, swap the current index with `l`, and recursively permute the rest of the string.
  - **Base Case:**  
    If `l == r`, print the string.

---

**In summary:**  
- Recursion can be used in many problems.
- You can solve problems by defining clear input and output for your recursive function.
- For more complex problems, you might need to extend the input/output to carry extra information through the recursion.
