## Generate All Balanced Parentheses

**Problem Statement:**  
Given `n` pairs of parentheses, write a function to generate all combinations of well-formed (balanced) parentheses of length `2*n`.

**Rules for Balanced Parentheses:**  
- Every opening parenthesis `'('` must have a corresponding closing parenthesis `')'`.
- At any point in the string, the number of closing parentheses should **never** exceed the number of opening parentheses.
- The total number of opening and closing parentheses must both be exactly `n`.

---

>### Examples:

### Example 1:
**Input:**  
n = 1  
**Output:**  
- `()` ✔️ (balanced)

### Example 2:
**Input:**  
n = 2  
**Output:**  
- `(())` ✔️ (balanced)
- `()()` ✔️ (balanced)
- `())(` ✖️ (not balanced)
- `(()`  ✖️ (not balanced)
- `())`  ✖️ (not balanced)

### Example 3:
**Input:**  
n = 3  
**Output:**  
- `((()))` ✔️ (balanced)
- `(()())` ✔️ (balanced)
- `(())()` ✔️ (balanced)
- `()(())` ✔️ (balanced)
- `()()()` ✔️ (balanced)
- `())(()` ✖️ (not balanced)
- `((())` ✖️ (not balanced)
- `())())` ✖️ (not balanced)

### Example 4:
**Input:**  
n = 4  
**Output:**  
- `(((())))` ✔️
- `((()()))` ✔️
- `((())())` ✔️
- `((()))()` ✔️
- `(()(()))` ✔️
- `(()()())` ✔️
- `(()())()` ✔️
- `(())(())` ✔️
- `(())()()` ✔️
- `()((()))` ✔️
- `()(()())` ✔️
- `()(())()` ✔️
- `()()(())` ✔️
- `()()()()` ✔️

---

### Which is Balanced and Which is Not?

- **Balanced:**  
  - `()`, `(())`, `()()`, `((()))`, `(()())`, `(())()`, `()(())`, `()()()`, etc.
- **Not Balanced:**  
  - `())(`, `(()`, `())`, `())(()`, `((())`, `())())`, etc.

A string is **balanced** if:
- The number of opening and closing parentheses is equal.
- At no point in the string do closing parentheses outnumber opening parentheses.

---

## Approach

1. Use recursion and backtracking to build the string step by step.
2. Keep track of the number of open and closed parentheses used so far.
3. At each step:
    - If the number of open parentheses is less than `n`, you can add an open parenthesis `'('`.
    - If the number of close parentheses is less than the number of open parentheses, you can add a close parenthesis `')'`.
4. When the current string has length `2*n`, add it to the result.  

![Generate Valid Parenthesis](https://raw.githubusercontent.com/Beastorm/DSA_/1bd1e6ee4438cca7d16c074be3bb114d00827c1b/junk/generate_valid_parenthesis.png)

### C++ Code:

``` cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to generate all balanced parentheses
void solve(int open, int close, string op, vector<string>& v) {
    // Base case: if no open and closed parentheses left, add to result
    if (open == 0 && close == 0) {
        v.push_back(op);
        return;
    }
    // If we can still add an open parenthesis, do so
    if (open > 0) {
        string op1 = op;
        op1.push_back('(');
        solve(open - 1, close, op1, v);
    }
    // If we can add a close parenthesis (only if close > open)
    if (close > open) {
        string op2 = op;
        op2.push_back(')');
        solve(open, close - 1, op2, v);
    }
}

vector<string> generateParenthesis(int n) {
    vector<string> v;
    int open = n, close = n;
    string op = "";
    solve(open, close, op, v);
    return v;
}

int main() {
    int n;
    cin >> n;
    vector<string> result = generateParenthesis(n);
    for (const auto& s : result) {
        cout << s << endl;
    }
    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:**  
  O(2^n * n), where n is the number of pairs of parentheses.
  - The number of valid combinations is given by the nth Catalan number, which is approximately O(4^n / (n * sqrt(n))).
  - Each valid combination is a string of length 2n, so generating and storing all combinations takes O(2^n * n) time in practice.

- **Space Complexity:**  
  O(n) for the recursion stack (maximum depth is 2n),  
  plus O(2^n * n) for storing all valid combinations in the result vector.


### How it works:

- Start with `n` open and `n` close parentheses to use.
- At each step, you can add `'('` if you have any left, or `')'` if there are more closes than opens left.
- When both open and close are zero, you have a valid combination.

---

**In short:**  
- Use recursion and backtracking to build all valid combinations.
- Only add parentheses when it keeps the string balanced.
