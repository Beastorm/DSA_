## Tower of Hanoi | Recursion

**Problem Statement:**   
The Tower of Hanoi is a famous puzzle with `three` rods and `N` disks.  
The objective is to move the entire stack from rod `1` to rod `3`, following these **rules**:
- _Only one disk can be moved at a time._
- _Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty rod._
- _No disk may be placed on top of a smaller disk._

Given the number of disks `N`, print all the steps to move the disks from rod `1` to rod `3`, and also find the `total number of moves`.

---

## Approach

### Recursive Insight:

- Move `N-1` disks from source rod to auxiliary rod.
- Move the largest disk (`Nth` disk) from the source rod to the destination rod.
- Move the `N-1` disks from auxiliary rod to destination rod.

### Recursive Algorithm:

1. **Base Case:**  
   If `N == 1`, move the disk directly from source to destination.

2. **Recursive Step:**  
   - Move `N-1` disks from source to auxiliary.
   - Move the Nth disk from source to destination.
   - Move `N-1` disks from auxiliary to destination.



### C++ Code:

```cpp
#include <iostream>
using namespace std;

void towerOfHanoi(int n, int source, int dest, int aux, int& moves) {
    if (n == 1) {
        cout << "Move disk 1 from rod " << source << " to rod " << dest << endl;
        moves++;
        return;
    }
    towerOfHanoi(n - 1, source, aux, dest, moves); // Step:1 move n-1 discs from source to aux
    cout << "Move disk " << n << " from rod " << source << " to rod " << dest << endl;  // Step:2 move the bottom one i.e. n from source to dest.
    moves++;
    towerOfHanoi(n - 1, aux, dest, source, moves); // Step:3 move n-1 discs from aux to dest 
}

int main() {
    int n = 3;
    int moves = 0;
    towerOfHanoi(n, 1, 3, 2, moves);
    cout << "Total moves: " << moves << endl;
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:**  
  `O(2^N)`, as the number of moves required is `2^N - 1`.

- **Space Complexity:**  
  `O(N)`, due to the recursion stack.

### Why does this work?

- The recursion breaks the problem into smaller subproblems (moving N-1 disks).
- Each step follows the rules of the puzzle.
- The base case ensures the smallest disk is moved directly.

---

### In short:

- Use recursion to move smaller stacks,
- Always move the largest disk last,
- Repeat until all disks are moved.



