## Recursion Concepts:

### 1. Make input smaller? But why?
   - In recursion, we solve a problem by breaking it into smaller parts.
   - Making the input smaller each time helps the recursion eventually stop.
   - _**Examples:**_  
     - **Factorial:**  
       `factorial(5)` calls `factorial(4)`, then `factorial(3)`, ..., until `factorial(0)`.
     - **Sum of array:**  
       To sum `[1, 2, 3, 4]`, call `sum([2, 3, 4])`, then `sum([3, 4])`, ..., until the array is empty.

---

### 2. Recursion â†’ Decision space: 
   - When you have choices, then you have to make decisions.
   - Recursion is useful when you have to choose between different options.
   - At each step, you decide which option to take.
   - ***Examples:***  
     - **Subsets:**  
       For set `{a, b}`, at each step, choose to include or exclude each element.
     - **String permutations:**  
       For "abc", at each step, pick a character to fix at the current position and permute the rest.

---

### 3. Recursive tree to represent decisions made out of choices:
   - A recursive tree shows all the choices you can make at each step.
   - Each branch is a different decision.
   
   - ***Examples:***  
     - **Subsets of "ab":**
     ![Subsets of String "ab"](https://github.com/Beastorm/DSA_/blob/6caf0a672115685b2630cd0bf45d9a65feb6f885/junk/subset_ab.png?raw=true)  
*Binary recursion tree showing pick/not-pick pattern for generating all subsets of string "ab" - demonstrates backtracking with return arrows and produces all 2^2 = 4 subsets.*

     - **Binary strings of length 2:**
![Binary Strings of Length 2](https://github.com/Beastorm/DSA_/blob/2ab3557438f0906822ccc616f668b558fea4f0dc/junk/binary_string.png?raw=true)  
*Binary recursion tree for generating all binary strings of length 2 - at each position choose '0' or '1', produces all 2^2 = 4 combinations: "00", "01", "10", "11".*

---

### 4. We can create a recursion using the input-output method:
   - Think about what the function gets as input and what it should return as output.
   - Use this to define your recursive steps.
   - ***Examples:***  
     - **Fibonacci:**  
       Input: `n`  
       Output: `fib(n)`  
       Recursive step: `fib(n) = fib(n-1) + fib(n-2)`
     - **Reverse a string:**  
       Input: `"abc"`  
       Output: `"cba"`  
       Recursive step: `reverse("abc") = reverse("bc") + "a"`

---

### In short:
- Make the problem smaller each time.  
- Use recursion when you have choices to make.  
- Draw a tree to see all possible decisions.  
- Define your recursion by thinking about input and output.
