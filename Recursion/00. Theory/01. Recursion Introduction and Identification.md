## Recursion Concepts:

### 1. Make input smaller? But why?
   - In recursion, we solve a problem by breaking it into smaller parts.
   - Making the input smaller each time helps the recursion eventually stop.
   - *Examples:*  
     - **Factorial:**  
       `factorial(5)` calls `factorial(4)`, then `factorial(3)`, ..., until `factorial(0)`.
     - **Sum of array:**  
       To sum `[1, 2, 3, 4]`, call `sum([2, 3, 4])`, then `sum([3, 4])`, ..., until the array is empty.

---

### 2. Recursion → decision space: When you have choices, then you have to make decisions
   - Recursion is useful when you have to choose between different options.
   - At each step, you decide which option to take.
   - *Examples:*  
     - **Subsets:**  
       For set `{a, b}`, at each step, choose to include or exclude each element.
     - **String permutations:**  
       For "abc", at each step, pick a character to fix at the current position and permute the rest.

---

### 3. Recursive tree to represent decisions made out of choices
   - A recursive tree shows all the choices you can make at each step.
   - Each branch is a different decision.
   
   - *Examples:*  
     - **Subsets of "ab":**
       ```
       Start
       ├── include 'a'
       │   ├── include 'b'   → "ab"
       │   └── exclude 'b'   → "a"
       └── exclude 'a'
           ├── include 'b'   → "b"
           └── exclude 'b'   → ""
       ```
     - **Binary strings of length 2:**
       ```
       Start
       ├── choose '0'
       │   ├── choose '0'   → "00"
       │   └── choose '1'   → "01"
       └── choose '1'
           ├── choose '0'   → "10"
           └── choose '1'   → "11"
       ```

---

### 4. We can create a recursion using the input-output method 
   - Think about what the function gets as input and what it should return as output.
   - Use this to define your recursive steps.
   - *Examples:*  
     - **Fibonacci:**  
       Input: `n`  
       Output: `fib(n)`  
       Recursive step: `fib(n) = fib(n-1) + fib(n-2)`
     - **Reverse a string:**  
       Input: `"abc"`  
       Output: `"cba"`  
       Recursive step: `reverse("abc") = reverse("bc") + "a"`

---

### In short:
- Make the problem smaller each time.  
- Use recursion when you have choices to make.  
- Draw a tree to see all possible decisions.  
- Define your recursion by thinking about input and output.
