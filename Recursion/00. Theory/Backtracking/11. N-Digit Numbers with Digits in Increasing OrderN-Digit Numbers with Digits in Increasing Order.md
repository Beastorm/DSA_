## N-Digit Numbers with Digits in Increasing Order

**Problem Statement:**    
Given an integer `N`, print all the `N-digit` numbers in increasing order, such that their digits are in strictly increasing order (from left to right).

**Key Constraints:**    
_Digits used:_ 1 to 9 (0 cannot be the first digit, and including 0 breaks the strict increasing order from any digit)
_Strictly increasing:_ Each digit must be greater than the previous
_N-digit number:_ Must have exactly N digits

---
>### Examples:

### Example 1:
**Input:** N = 1   
**Output:** 0 1 2 3 4 5 6 7 8 9     
**Explanation:** Single-digit numbers are considered to be in strictly increasing order.    

### Example 2:
**Input:** N = 2    
**Output:** 12 13 14 15 16 17 18 19 23 24 25 26 27 28 29 34 35 36 37 38 39 45 46 47 48 49 56 57 58 59 67 68 69 78 79 89     
**Explanation:** Must have exactly 2 digits, and each digit is greater than the previous.   

---

## Approach

### Intuition:

- The problem asks for all N-digit numbers where each digit is strictly greater than the previous one (digits are in increasing order).
- This is a classic backtracking problem: at each step, you choose the next digit to be greater than the last digit used.
- For N = 1, all single-digit numbers (including 0) are valid.
- For N > 1, you start with 1 (to avoid leading zeros) and recursively build up the number by adding valid digits.
- When the number reaches N digits, you add it to the result.


### Algorithm Steps:

1. **Start with an empty number (`vector<int> v`) and `n = N`.**
2. **Recursive Function:**
   - If `n == 0`, convert the vector to a number and add it to the result.
   - Determine the next possible digit:
     - If the vector is empty and `N == 1`, start from 0.
     - If the vector is empty and `N > 1`, start from 1.
     - Otherwise, start from the last digit + 1.
   - For each digit `i` from `start` to 9:
     - Add `i` to the current number.
     - Recurse with one less digit to fill.
     - Backtrack by removing the last digit.
3. **Repeat until all combinations are generated.**


### Backtracking Template for This Problem

- **State:** Current number (as a string or vector), current length, last digit used.
- **Choices:** Next digit can be any digit greater than the last used digit (from last+1 to 9).
- **Base Case:** If the current number has N digits, print it.
- **Backtrack:** Remove the last digit and try the next possible digit.

### In short:

- Use recursion to build numbers digit by digit.
- At each step, only add digits greater than the previous one.
- Print the number when it reaches N digits.


### Diagram:
![N Digit Numbers Recursive Tree](https://raw.githubusercontent.com/Beastorm/DSA_/9edad9b67244b86d30439bcec35b77206ee1c1c4/junk/nth_digit.png)


### C++ Code:
``` cpp
#include <iostream>
#include <vector>
using namespace std;

void solve(int n, vector<int>& v, vector<int>& res) {
    if (n == 0) {
        int ans = 0;
        for (int d : v) {
            ans = ans * 10 + d;
        }
        res.push_back(ans);
        return;
    }
    int start = 1;
    if (v.empty()) {
        start = (n == 1) ? 0 : 1; // For N=1, allow 0 as the first digit
    } else {
        start = v.back() + 1;
    }
    for (int i = start; i <= 9; ++i) {
        v.push_back(i);
        solve(n - 1, v, res);
        v.pop_back();
    }
}

vector<int> increasingNumbers(int N) {
    vector<int> res;
    vector<int> v;
    solve(N, v, res);
    return res;
}

int main() {
    int N;
    cin >> N;
    vector<int> numbers = increasingNumbers(N);
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  O(C(10, N)), where C(10, N) is the number of ways to choose N digits from 10 in increasing order (i.e., "10 choose N").
  - For each valid N-digit number, the function does O(N) work (building the number).
  - The total number of such numbers is C(10, N).

- **Space Complexity:**  
  O(N) for the recursion stack (maximum depth is N).
  - O(C(10, N)) for storing all results if you keep them in a vector.
