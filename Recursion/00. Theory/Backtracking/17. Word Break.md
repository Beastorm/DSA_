## Word Break Problem

**Problem Statement:**  
Given a string `s` and a dictionary of words `wordDict`, determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.

**Note:** The same word in the dictionary may be reused multiple times in the segmentation.

---

>### Examples:

### Example 1:
**Input:** s = "leetcode", wordDict = ["leet", "code"]
**Output:** true
**Explanation:** "leetcode" can be segmented as "leet code"

### Example 2:
**Input:** s = "applepenapple", wordDict = ["apple", "pen"]
**Output:** true
**Explanation:** "applepenapple" can be segmented as "apple pen apple"

### Example 3:
**Input:** s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
**Output:** false
**Explanation:** No valid segmentation exists

---

## Approach

### Intuition:
We need to check if a string can be **completely broken down** into words from a dictionary.
**Key Idea:**  
At each position, try to match any word from the dictionary. If a word matches, recursively check if the **remaining string** can also be broken down.
**Think of it like:**  
"Can I split the string starting here? If yes, can the rest also be split?"

### Algorithm Steps:
1. Start from **index 0**
2. Try all substrings from `index` to `end`
3. If the substring exists in the dictionary:
   - Recursively check the remaining string from `i+1`
   - If remaining returns `true` → we found a solution ✓
4. If no valid path found → return `false`
5. **Base case:** If `index == length` → return `true` (entire string segmented)

### Diagram:
![Word Break - Backtracking Visualization](https://github.com/Beastorm/DSA_/blob/3f12cc32ed4d3a15df7e105aa46c004225ded34d/junk/word_break.png?raw=true)


### C++ Code:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
#include <string>

using namespace std;

class Solution {
public:
    unordered_set<string> dict;
    
    bool backtrack(string& s, int index) {
        // Base case: reached end of string
        if (index == s.length()) {
            return true;
        }
        
        // Try all possible words starting from the current index
        for (int i = index; i < s.length(); i++) {
            // Extract substring from index to i
            string word = s.substr(index, i - index + 1);
            
            // If word exists in dictionary
            if (dict.count(word)) {
                // Recursively check remaining string
                if (backtrack(s, i + 1)) {
                    return true;
                }
            }
        }
        
        // No valid segmentation found
        return false;
    }
    
    bool wordBreak(string s, vector<string>& wordDict) {
        // Convert vector to set for O(1) lookup
        dict = unordered_set<string>(wordDict.begin(), wordDict.end());
        return backtrack(s, 0);
    }
};

int main() {
    Solution sol;
    
    // Test case 1
    string s1 = "leetcode";
    vector<string> dict1 = {"leet", "code"};
    cout << "\"" << s1 << "\" -> " << (sol.wordBreak(s1, dict1) ? "true" : "false") << endl;
    
    // Test case 2
    string s2 = "applepenapple";
    vector<string> dict2 = {"apple", "pen"};
    cout << "\"" << s2 << "\" -> " << (sol.wordBreak(s2, dict2) ? "true" : "false") << endl;
    
    // Test case 3
    string s3 = "catsandog";
    vector<string> dict3 = {"cats", "dog", "sand", "and", "cat"};
    cout << "\"" << s3 << "\" -> " << (sol.wordBreak(s3, dict3) ? "true" : "false") << endl;
    
    return 0;
}
```
### Complexity Analysis:

**Time Complexity:** O(2^n) – without memoization  
- At each position, we try all possible substrings  
- Leads to exponential branching

**Space Complexity:** O(n)  
- Recursion stack depth = string length

**With Memoization:**  
- **Time:** O(n²) – each index computed once  
- **Space:** O(n) – memo map + recursion stack
