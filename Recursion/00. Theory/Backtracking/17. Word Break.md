## Word Break Problem

**Problem Statement:**  
Given a string `s` and a dictionary of words `wordDict`, determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.

**Note:** The same word in the dictionary may be reused multiple times in the segmentation.

---

>### Examples:

### Example 1:
**Input:** s = "leetcode", wordDict = ["leet", "code"]   
**Output:** true   
**Explanation:** "leetcode" can be segmented as "leet code"   

### Example 2:
**Input:** s = "applepenapple", wordDict = ["apple", "pen"]   
**Output:** true   
**Explanation:** "applepenapple" can be segmented as "apple pen apple"    

### Example 3:
**Input:** s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]    
**Output:** false   
**Explanation:** No valid segmentation exists   

---

## Approach

### Intuition:
We need to check if a string can be **completely broken down** into words from a dictionary.
**Key Idea:**  
At each position, try to match any word from the dictionary. If a word matches, recursively check if the **remaining string** can also be broken down.
**Think of it like:**  
"Can I split the string starting here? If yes, can the rest also be split?"

### Algorithm Steps:
1. Start from **index 0**
2. Try all substrings from `index` to `end`
3. If the substring exists in the dictionary:
   - Recursively check the remaining string from `i+1`
   - If remaining returns `true` → we found a solution ✓
4. If no valid path found → return `false`
5. **Base case:** If `index == length` → return `true` (entire string segmented)

### Diagram:
![Word Break - Backtracking Visualization](https://github.com/Beastorm/DSA_/blob/3f12cc32ed4d3a15df7e105aa46c004225ded34d/junk/word_break.png?raw=true)


### C++ Code:

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
#include <string>

using namespace std;

class WordBreakSolver {
public:
    unordered_set<string> wordDictionary;
    
    bool canSegmentFromIndex(string& inputString, int currentIndex) {
        // Base case: reached end of string - successful segmentation
        if (currentIndex == inputString.length()) {
            return true;
        }
        
        // Try all possible words starting from the current index
        for (int endIndex = currentIndex; endIndex < inputString.length(); endIndex++) {
            // Extract substring from currentIndex to endIndex
            string currentWord = inputString.substr(currentIndex, endIndex - currentIndex + 1);
            
            // If word exists in dictionary
            if (wordDictionary.count(currentWord)) {
                // Recursively check if the remaining string can be segmented
                if (canSegmentFromIndex(inputString, endIndex + 1)) {
                    return true;
                }
            }
        }
        
        // No valid segmentation found from this index
        return false;
    }
    
    bool canBreakIntoWords(string inputString, vector<string>& validWords) {
        // Convert vector to set for O(1) lookup
        wordDictionary = unordered_set<string>(validWords.begin(), validWords.end());
        return canSegmentFromIndex(inputString, 0);
    }
};

int main() {
    WordBreakSolver solver;
    
    // Test case 1
    string testString1 = "leetcode";
    vector<string> dictionary1 = {"leet", "code"};
    cout << "\"" << testString1 << "\" -> " 
         << (solver.canBreakIntoWords(testString1, dictionary1) ? "true" : "false") << endl;
    
    // Test case 2
    string testString2 = "applepenapple";
    vector<string> dictionary2 = {"apple", "pen"};
    cout << "\"" << testString2 << "\" -> " 
         << (solver.canBreakIntoWords(testString2, dictionary2) ? "true" : "false") << endl;
    
    // Test case 3
    string testString3 = "catsandog";
    vector<string> dictionary3 = {"cats", "dog", "sand", "and", "cat"};
    cout << "\"" << testString3 << "\" -> " 
         << (solver.canBreakIntoWords(testString3, dictionary3) ? "true" : "false") << endl;
    
    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** O(2^n) – without memoization  
   - At each position, we try all possible substrings  
   - Leads to exponential branching

- **Space Complexity:** O(n)  
   - Recursion stack depth = string length

- **With Memoization:**  
   - **Time:** O(n²) – each index computed once  
   - **Space:** O(n) – memo map + recursion stack
