## Lecture 2: Basics of Backtracking

### Basics of Backtracking and How It Differs from Other Recursion Variants

- **Backtracking** is a special form of recursion used to solve problems where you need to explore all possible options and "backtrack" (undo choices) when a path does not lead to a solution.
- Unlike simple recursion, backtracking often involves making a choice, exploring further, and then undoing that choice to try other possibilities.

---

### All These Come Under Recursion

- **Dynamic Programming (DP):** Uses recursion with memoization to solve optimization problems efficiently by storing results of subproblems.
- **Backtracking (BT):** Uses recursion to explore all possible solutions, undoing choices as needed.
- **Divide and Conquer:** Breaks the problem into smaller subproblems, solves them recursively, and combines their results.

---

### Key Differences

- **Backtracking = Controlled Recursion + Pass by Reference**
  - "Controlled recursion" means you only explore valid options (prune invalid paths early).
  - "Pass by reference" allows you to modify the current state and undo changes (backtrack) as you return from recursion.

- **Dynamic Programming (DP):**
  - Focuses on finding the optimal solution.
  - Uses memoization or tabulation to avoid recomputation.

- **Backtracking (BT):**
  - The answer is often found at the root of the recursion tree (as a combination of choices).
  - Used for generating all combinations, permutations, or valid configurations.

- **Simple Recursion:**
  - The answer is typically found at the leaf nodes of the recursion tree (after making all choices and decisions).

---

### Summary Table

| Approach            | Main Use                | Where is the Answer?         | Example Problem                |
|---------------------|-------------------------|------------------------------|--------------------------------|
| Dynamic Programming | Optimization problems   | At the root (optimal value)  | Minimum coin change, LIS       |
| Backtracking        | Combinatorial problems  | At the root (combinations)   | N-Queens, Sudoku, Subsets      |
| Simple Recursion    | Explore all choices     | At the leaf nodes            | Factorial, Fibonacci, Tree DFS |


---

### Comparison BT with and without pass by reference:

| With Pass by Reference (`string& a`)                                  | Without Pass by Reference (`string a`)                         |
|-----------------------------------------------------------------------|----------------------------------------------------------------|
| ```cpp                                                               | ```cpp                                                         |
| void permute(string& a, int l, int r) {                              | void permute(string a, int l, int r) {                         |
|     if (l == r)                                                      |     if (l == r)                                                |
|         cout << a << endl;                                           |         cout << a << endl;                                     |
|     else {                                                           |     else {                                                     |
|         for (int i = l; i <= r; i++) {                               |         for (int i = l; i <= r; i++) {                         |
|             swap(a[l], a[i]);           // Swapping done             |             swap(a[l], a[i]);           // Swapping done       |
|             permute(a, l + 1, r);       // Recursion called          |             permute(a, l + 1, r);       // Recursion called    |
|             swap(a[l], a[i]);           // Backtrack                 |             swap(a[l], a[i]);           // Backtrack           |
|         }                                                            |         }                                                      |
|     }                                                                |     }                                                          |
| }                                                                    | }                                                              |
| // main() is the same                                                | // main() is the same                                          |
| ```                                                                  | ```                                                            |



| Aspect                | Pass by Reference (`string& a`) | Pass by Value (`string a`)      |
|-----------------------|:-------------------------------:|:-------------------------------:|
| Memory Usage          | Lower (no copy at each call)    | Higher (copy at each call)      |
| Backtracking Needed   | Yes (must undo swap)            | No (copy is local to call)      |
| Side Effects          | Changes affect original string   | Changes are local to function   |
| Performance           | Faster for large strings        | Slower for large strings        |


---

### Example Diagrams

### 1. Simple Recursion (Factorial)

factorial(3)
- factorial(2)
  - factorial(1)
    - factorial(0)

(Answer is built up from the leaves.)

---

### 2. Backtracking (Subsets of "ab")

Start  
├─ include 'a'  
│  ├─ include 'b'   → "ab"  
│  └─ exclude 'b'   → "a"  
└─ exclude 'a'  
   ├─ include 'b'   → "b"  
   └─ exclude 'b'   → ""  

(All valid combinations are collected at the root.)

---

### 3. Dynamic Programming (Fibonacci with Memoization)

- Each subproblem is solved once and stored, so repeated calls use the stored value.

---

**In short:**  
- Backtracking is recursion with control and the ability to undo choices.
- DP is about optimal solutions, backtracking is about all valid combinations, and simple recursion is about exploring all possible choices.

