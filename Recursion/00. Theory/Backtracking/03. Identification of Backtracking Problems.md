## Identification of Backtracking Problems

### How to Identify Backtracking Problems

Backtracking is a powerful technique, but it is not always the right tool. Here’s how to recognize when a problem is a good fit for backtracking:

---

### Key Properties to Look For

- **Choices + Decisions:**  
  The problem involves making a sequence of choices, and at each step, you must decide which option to pick.

- **All Combinations:**  
  You are asked to generate or count all possible combinations, arrangements, or configurations (e.g., subsets, permutations, valid board states).

- **Controlled Recursion:**  
  You need to explore all possibilities, but you can prune (stop) paths early if they violate constraints.

- **Number of Choices:**  
  At each step, you have a finite set of options to choose from (e.g., which number to place, which direction to move).

- **Size of Constraints:**  
  The problem has constraints that are small enough to allow exploring all possibilities (e.g., n ≤ 10 or 15).

- **Don’t Be Greedy:**  
  Greedy algorithms make the best choice at each step and never backtrack. If you need to try all options and possibly undo choices, backtracking is likely needed.

---

### Typical Backtracking Problem Types

- Generating all subsets, permutations, or combinations.
- Solving puzzles (Sudoku, N-Queens, Crossword).
- Pathfinding with constraints (Rat in a Maze, Word Search).
- Partitioning or coloring problems (Graph Coloring, Subset Sum).

---

### In short:

- If a problem asks for **all possible ways** to do something, or to **find any/one valid way** under constraints, and you can try options one by one, **think backtracking**.
- If you can prune invalid paths early, backtracking is even more effective.
