## Lecture 12: Rat in a Maze Problem

**Problem Statement:**  

Given an N x N maze (matrix) filled with 0s (blocked) and 1s (open), a rat starts at the top-left cell (0,0) and needs to reach the bottom-right cell (N-1,N-1). The rat can move in four directions (up, down, left, right) but cannot visit a cell more than once in a path. Print all possible paths from start to finish as strings of directions (e.g., "DRDR" for Down, Right, Down, Right).

---

### Example:

**Input:**N = 4
```
maze = [
[1, 0, 0, 0],
[1, 1, 0, 1],
[0, 1, 0, 0],
[1, 1, 1, 1]
]
```
**Output:** DDRDRR, DRDDRR

_Notes:_
- Use recursion and backtracking to explore all valid paths.
- Mark cells as visited to avoid cycles.
- Add the path to the result when the destination is reached.
---

## Approach
### Intuition:

- The problem is to find all possible paths for a rat to move from the top-left to the bottom-right of a maze, moving only through open cells (1s) and not revisiting any cell in a path.
- At each step, the rat can move in four directions (down, left, right, up), but only if the move is within bounds, not blocked, and not already visited.
- Backtracking is used: mark the cell as visited, explore all possible moves, and unmark (backtrack) after exploring.

### Algorithm Steps:

1. **Start at (0, 0)** if it is open.
2. **Recursive Function:**
   - If the current cell is the destination, add the current path to the result and return.
   - For each possible move (D, L, R, U):
     - Calculate the new cell coordinates.
     - If the move is valid (within bounds, open, not visited):
       - Mark the current cell as visited.
       - Add the direction to the path.
       - Recurse to the new cell.
       - Unmark the cell (backtrack).
       - Remove the last direction from the path.
3. **Repeat** until all paths are explored.


**Diagram:**  
shows all four possible moves: Up (U), Left (L), Right (R), Down (D).   

![Rat in a Maze Recursive Tree](https://raw.githubusercontent.com/Beastorm/DSA_/f8b3fca782afc5c0f4e12b54440c3381cf121655/junk/rat_maze.png)


### Backtracking Template for This Problem

- **State:** Current cell (i, j), current path string, visited matrix.
- **Choices:** Move in any valid direction (D, L, R, U).
- **Base Case:** Reached destination cell (N-1, N-1).
- **Backtrack:** Unmark the cell as visited after exploring all options from it.



### C++ Code:
``` cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Struct to represent a move (direction)
struct Choice {
    char dname; // Direction name: 'D', 'L', 'R', 'U'
    int dx, dy; // Change in x and y
};

// Check if the destination is reached
bool isSolved(int x, int y, int n) {
    return x == n - 1 && y == n - 1;
}

// Check if the move is valid
bool isValid(int x, int y, int n, vector<vector<int>>& arr) {
    return x >= 0 && x < n && y >= 0 && y < n && arr[x][y] == 1;
}

// Backtracking function to find all paths
void solve(int x, int y, const int n, vector<string>& res, string& path, vector<vector<int>>& arr, const vector<Choice>& choices) {
    if (isSolved(x, y, n)) {
        res.push_back(path);
        return;
    }
    for (const auto& choice : choices) {
        int newX = x + choice.dx;
        int newY = y + choice.dy;
        if (isValid(newX, newY, n, arr)) {
            arr[x][y] = 0; // Mark as visited
            path.push_back(choice.dname);
            solve(newX, newY, n, res, path, arr, choices);
            arr[x][y] = 1; // Unmark (backtrack)
            path.pop_back();
        }
    }
}

class Solution {
public:
    vector<string> findPath(vector<vector<int>>& arr, int n) {
        vector<string> res;
        string path = "";
        // D, L, R, U
        vector<Choice> choices = {{'D', 1, 0}, {'L', 0, -1}, {'R', 0, 1}, {'U', -1, 0}};
        if (arr[0][0] == 1)
            solve(0, 0, n, res, path, arr, choices);
        return res;
    }
};

int main() {
    int n = 4;
    vector<vector<int>> arr = {
        {1, 0, 0, 0},
        {1, 1, 0, 1},
        {0, 1, 0, 0},
        {1, 1, 1, 1}
    };
    Solution sol;
    vector<string> paths = sol.findPath(arr, n);
    cout << "All possible paths:" << endl;
    for (const string& p : paths) {
        cout << p << endl;
    }
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:**  
  O(4^(n*n)), where n is the size of the maze.
  - In the worst case, each cell can branch into 4 directions, and there are n*n cells.
  - However, pruning (not revisiting cells) reduces the actual number of paths.

- **Space Complexity:**  
  O(n*n) for the recursion stack and visited matrix.
  - O(L) for storing all valid paths, where L is the total number of valid paths.
