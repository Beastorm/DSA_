## Lecture 11: N-Digit Numbers with Digits in Increasing Order

**Problem Statement:**    
Given an integer `N`, print all the N-digit numbers in increasing order, such that their digits are in strictly increasing order (from left to right).

---

>### Example 1:

**Input:** N = 1
**Output:** 0 1 2 3 4 5 6 7 8 9

**Explanation:**  
Single-digit numbers are considered to be in strictly increasing order.

---

## Approach

### Intuition

- The task is to generate all N-digit numbers where each digit is strictly greater than the previous one (i.e., digits are in increasing order).
- This is a classic backtracking problem: at each step, you choose the next digit to be greater than the last digit used.
- You start with an empty number and recursively build up the number by adding valid digits.
- When the number reaches N digits, you add it to the result.

### Algorithm Steps

1. **Start with an empty number (`current_num = 0`) and `digitsLeft = N`.**
2. **Recursive Function:**
   - If `digitsLeft == 0`, add `current_num` to the result and return.
   - Determine the next possible digit: it must be greater than the last digit used (`start_digit = (current_num % 10) + 1`).
   - For each digit `d` from `start_digit` to 9:
     - Add `d` to the current number.
     - Recurse with one less digit to fill.
     - Backtrack by removing the last digit.
3. **Repeat until all combinations are generated.**


### Backtracking Template for This Problem

- **State:** Current number (as a string or vector), current length, last digit used.
- **Choices:** Next digit can be any digit greater than the last used digit (from last+1 to 9).
- **Base Case:** If the current number has N digits, print it.
- **Backtrack:** Remove the last digit and try the next possible digit.

### In short

- Use recursion to build numbers digit by digit.
- At each step, only add digits greater than the previous one.
- Print the number when it reaches N digits.

![N Digit Numbers with Increasing Digits](https://raw.githubusercontent.com/Beastorm/DSA_/3c01b6143c44630c51872a75b46c848447801e87/junk/n_digit.png)


### C++ Code:
``` cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution {
private:
    // Helper function for backtracking
    void findIncreasingHelper(vector<int>& result, int current_num, int digitsLeft) {
        // Base case: if no more digits to add, store the number
        if (digitsLeft == 0) {
            result.push_back(current_num);
            return;
        }

        // Next digit must be greater than the last digit used
        int start_digit = (current_num % 10) + 1;

        for (int d = start_digit; d <= 9; ++d) {
            // Choose: add digit d to the current number
            current_num = current_num * 10 + d;

            // Explore: recurse with one less digit to fill
            findIncreasingHelper(result, current_num, digitsLeft - 1);

            // Un-choose (Backtrack): remove the last digit
            current_num = (current_num - d) / 10;
        }
    }

public:
    vector<int> increasingNumbers(int N) {
        vector<int> result;
        if (N <= 0 || N > 9) return result;
        findIncreasingHelper(result, 0, N);
        return result;
    }
};

int main() {
    Solution sol;
    int N = 3;
    vector<int> numbers = sol.increasingNumbers(N);

    cout << "N-digit numbers with increasing digits for N = " << N << ":" << endl;
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl; // Expected output for N=3: 123, 124, ..., 789

    N = 2;
    numbers = sol.increasingNumbers(N);
    cout << "\nN-digit numbers with increasing digits for N = " << N << ":" << endl;
    for (int num : numbers) {
        cout << num << " ";
    }
    cout << endl; // Expected output for N=2: 12, 13, ..., 89

    return 0;
}
```

### Complexity Analysis

- **Time Complexity:**  
  O(C(10, N)), where C(10, N) is the number of ways to choose N digits from 10 in increasing order (i.e., "10 choose N").
  - For each valid N-digit number, the function does O(N) work (building the number).
  - The total number of such numbers is C(10, N).

- **Space Complexity:**  
  O(N) for the recursion stack (maximum depth is N).
  - O(C(10, N)) for storing all results if you keep them in a vector.
