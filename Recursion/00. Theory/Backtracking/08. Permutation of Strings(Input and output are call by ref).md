## Permutation of Strings | Backtracking Solution

**Problem Statement:**  
Given a string S, print all **unique permutations** of the given string in **lexicographically sorted order**.

---

>### Examples:

### Example 1:

**Input:** ABC

**Output:** ABC ACB BAC BCA CAB CBA

**Explanation:**  
Given string ABC has 6 permutations:  
ABC, ACB, BAC, BCA, CAB, CBA

---

## Example 2:

**Input:** ABSG

**Output:**  
ABGS ABSG AGBS AGSB ASBG ASGB BAGS BASG BGAS BGSA BSAG BSGA GABS GASB GBAS GBSA GSAB GSBA SABG SAGB SBAG SBGA SGAB SGBA

**Explanation:**  
Given string ABSG has 24 permutations.

---

## Approach-(Call by Ref)

### Algo:
1. **Sort the string** to ensure lexicographical order.
2. Use **backtracking** to generate all unique permutations:
    - At each step, swap the current character with every character that comes after it (including itself).
    - Use a set at each recursion level to avoid duplicate swaps (for unique permutations).
    - After each swap, recurse for the next position.
    - Backtrack (undo the swap) after recursion.
3. Print each permutation when the end of the string is reached.

### Backtracking Template for Permutations:

- **State:** Current string and current index.
- **Choices:** Swap current index with every index â‰¥ current, skipping duplicates.
- **Base Case:** If the current index is at the end, print the string.
- **Backtrack:** Undo the swap.

---

### In short:

- Sort the string first.
- Use backtracking and a set to generate all unique permutations.
- Print each permutation when a complete arrangement is formed.

### Diagram:
![Unique Permutations with Swap](https://github.com/Beastorm/DSA_/blob/e37e3a5676591751876de7fae763b1c4d858a8c1/junk/permute_swap.png?raw=true)  
*Recursion tree for generating unique permutations of "AAB" using the swap method. A local `set` at each level tracks used characters to prevent duplicate swaps, efficiently pruning redundant branches.*

### C++ Code:
``` cpp
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

// Recursive function to generate unique permutations
void generatePermutationsRecursive(string& inputString, int currentIndex, vector<string>& permutationsList) {
    // Base case: If we reached the last character, store the permutation
    if (currentIndex == inputString.size() - 1) {
        permutationsList.push_back(inputString);
        return;
    }

    // Set to track characters used at this position to avoid duplicates
    set<char> usedCharacters;

    for (int swapIndex = currentIndex; swapIndex < inputString.size(); swapIndex++) {
        char currentChar = inputString[swapIndex];
        
        // If this character hasn't been swapped into current position yet
        if (usedCharacters.find(currentChar) == usedCharacters.end()) {
            usedCharacters.insert(currentChar);                 // Mark as used
            swap(inputString[currentIndex], inputString[swapIndex]);   // Swap current char into position
            
            generatePermutationsRecursive(inputString, currentIndex + 1, permutationsList); // Recurse for next position
            
            swap(inputString[currentIndex], inputString[swapIndex]);   // Backtrack to restore original string
        }
    }
}

// Wrapper function to find all unique permutations
vector<string> findUniquePermutations(string originalString) {
    vector<string> allPermutations;
    
    // Sort input to process duplicates together
    sort(originalString.begin(), originalString.end());
    
    generatePermutationsRecursive(originalString, 0, allPermutations);
    
    // Sort final result for lexicographical output order
    sort(allPermutations.begin(), allPermutations.end());
    
    return allPermutations;
}

int main() {
    string userInput;
    cin >> userInput;
    
    vector<string> permutationResults = findUniquePermutations(userInput);
    
    for (const auto& permutation : permutationResults) {
        cout << permutation << " ";
    }
    cout << endl;
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:**  
  O(n! * n), where n is the length of the string.
  - There are up to n! unique permutations for a string of length n.
  - Each permutation takes O(n) time to build and store.
  - The use of a set at each recursion level adds some overhead, but does not change the overall factorial growth.

- **Space Complexity:**  
  O(n! * n) for storing all unique permutations (each of length n).
  - O(n) for the recursion stack (maximum depth is n).
  - O(n) for the set used at each recursion level.
