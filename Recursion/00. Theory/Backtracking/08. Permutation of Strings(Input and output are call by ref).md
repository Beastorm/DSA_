## Permutation of Strings | Backtracking Solution

**Problem Statement:**  
Given a string S, print all **unique permutations** of the given string in **lexicographically sorted order**.

---

>### Examples:

### Example 1:

**Input:** ABC

**Output:** ABC ACB BAC BCA CAB CBA

**Explanation:**  
Given string ABC has 6 permutations:  
ABC, ACB, BAC, BCA, CAB, CBA

---

## Example 2:

**Input:** ABSG

**Output:**  
ABGS ABSG AGBS AGSB ASBG ASGB BAGS BASG BGAS BGSA BSAG BSGA GABS GASB GBAS GBSA GSAB GSBA SABG SAGB SBAG SBGA SGAB SGBA

**Explanation:**  
Given string ABSG has 24 permutations.

---

## Approach-(Call by Ref)

### Algo:
1. **Sort the string** to ensure lexicographical order.
2. Use **backtracking** to generate all unique permutations:
    - At each step, swap the current character with every character that comes after it (including itself).
    - Use a set at each recursion level to avoid duplicate swaps (for unique permutations).
    - After each swap, recurse for the next position.
    - Backtrack (undo the swap) after recursion.
3. Print each permutation when the end of the string is reached.

### Backtracking Template for Permutations:

- **State:** Current string and current index.
- **Choices:** Swap current index with every index â‰¥ current, skipping duplicates.
- **Base Case:** If the current index is at the end, print the string.
- **Backtrack:** Undo the swap.

---

### In short:

- Sort the string first.
- Use backtracking and a set to generate all unique permutations.
- Print each permutation when a complete arrangement is formed.



### C++ Code:
``` cpp
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

// Helper function to generate all unique permutations
void solve(string& s, int start, vector<string>& v) {
    // Base case: if start is at the end, store the permutation
    if (start == s.size() - 1) {
        v.push_back(s);
        return;
    }
    set<char> mp; // To avoid duplicate swaps at this level
    for (int i = start; i < s.size(); i++) {
        if (mp.find(s[i]) == mp.end()) { // If character not used at this level
            mp.insert(s[i]);
            swap(s[start], s[i]);           // Make the choice
            solve(s, start + 1, v);         // Recurse
            swap(s[start], s[i]);           // Backtrack
        }
    }
}

vector<string> findPermutations(string S) {
    vector<string> v;
    sort(S.begin(), S.end()); // Sort to ensure lexicographical order
    solve(S, 0, v);
    sort(v.begin(), v.end()); // Sort the result for lex order
    return v;
}

int main() {
    string S;
    cin >> S;
    vector<string> result = findPermutations(S);
    for (const auto& s : result) {
        cout << s << " ";
    }
    cout << endl;
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:**  
  O(n! * n), where n is the length of the string.
  - There are up to n! unique permutations for a string of length n.
  - Each permutation takes O(n) time to build and store.
  - The use of a set at each recursion level adds some overhead, but does not change the overall factorial growth.

- **Space Complexity:**  
  O(n! * n) for storing all unique permutations (each of length n).
  - O(n) for the recursion stack (maximum depth is n).
  - O(n) for the set used at each recursion level.
