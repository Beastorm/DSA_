## N-Queens

**Problem Statement:**  
Given an integer `N`, place `N` queens on an `N×N` chessboard so that no two queens threaten each other.  
A queen can attack any other queen in the same row, column, or diagonal.  
Print all possible distinct solutions to the `N-Queens` puzzle.  
Each solution should be represented as a list of strings, where `Q` represents a queen and `.` represents a space.

---

>### Examples:

### Example 1:

**Input:** N = 4     
**Output:**    
- _Solution 1:_
```
. Q . .
. . . Q
Q . . .
. . Q .
```
- _Solution 2:_
```
. . Q .
Q . . .
. . . Q
. Q . .
```

**Explanation:** There are 2 solutions for N=4. Each row has exactly one queen, and no two queens attack each other.

---

### Example 2:

**Input:** N = 1

**Output:**  
```
Q

```
**Explanation:** There is only one way to place a queen on a 1×1 board.

---

### Example 3:

**Input:** N = 3

**Output:** (no solution)

**Explanation:** It is not possible to place 3 queens on a 3×3 board so that no two queens threaten each other.

---

## Approach

### Intuition:

- The `N-Queens` problem asks you to place `N` queens on an `N×N` chessboard so that no two queens threaten each other (no two in the same row, column, or diagonal).
- The solution uses backtracking: place a queen in a row, try all columns, and for each valid placement, move to the next row.
- If a placement leads to a conflict, backtrack and try the next column.
- When all `N` queens are placed, a valid solution is found.


### Algorithm Steps:

1. **Start with an empty board.**
2. **Recursive Function (row):**
   - If `row == N`, add the current board to the result (all queens placed).
   - For each column in the current row:
     - Check if placing a queen at (row, col) is safe (no other queen in the same column or diagonals).
     - If safe:
       - Place the queen at (row, col).
       - Recurse to the next row.
       - Remove the queen (backtrack) and try the next column.
3. **Repeat** until all possible placements are explored.

### Diagram:

![N Queens Recursive Tree](https://raw.githubusercontent.com/Beastorm/DSA_/2b27814c349e4747907308aa6a7bfefe80c3a159/junk/n_queens.png)


![N Queens Board Example](https://raw.githubusercontent.com/Beastorm/DSA_/1adc5694c6196e58af73e4fe48078207a296e019/junk/Screenshot%20from%202026-01-19%2006-08-30.png)

### C++ Code:

``` cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Helper function to check if it's safe to place a queen at (row, col)
bool isSafe(int row, int col, vector<string>& board, int n) {
    // Check column
    for (int i = 0; i < row; i++)
        if (board[i][col] == 'Q') return false;
    // Check upper left diagonal
    for (int i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--)
        if (board[i][j] == 'Q') return false;
    // Check upper right diagonal
    for (int i = row-1, j = col+1; i >= 0 && j < n; i--, j++)
        if (board[i][j] == 'Q') return false;
    return true;
}

// Backtracking function to solve N-Queens
void solve(int row, vector<string>& board, vector<vector<string>>& res, int n) {
    if (row == n) {
        res.push_back(board);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (isSafe(row, col, board, n)) {
            board[row][col] = 'Q';      // Choose
            solve(row + 1, board, res, n); // Explore
            board[row][col] = '.';      // Un-choose (backtrack)
        }
    }
}

vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> res;
    vector<string> board(n, string(n, '.'));
    solve(0, board, res, n);
    return res;
}

int main() {
    int n;
    cin >> n;
    vector<vector<string>> solutions = solveNQueens(n);
    cout << "Number of solutions: " << solutions.size() << endl;
    for (const auto& board : solutions) {
        for (const string& row : board) {
            cout << row << endl;
        }
        cout << endl;
    }
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:**  
  O(N!), where N is the size of the board.
  - For each row, you try up to N columns, but the number of valid choices decreases as queens are placed.
  - The total number of recursive calls is bounded by N! (factorial growth).

- **Space Complexity:**  
  O(N^2) for storing the board and O(N) for the recursion stack.
  - O(K * N^2) if you store all K solutions (each is an N×N board).


---

## Optimized Approach (Column and Diags in O(1))

### Intuition:

- The N-Queens problem asks you to place N queens on an N×N chessboard so that no two queens threaten each other (no two in the same row, column, or diagonal).
- The optimized approach uses three boolean arrays to track which columns and diagonals are already occupied, allowing you to check and update these constraints in O(1) time.
- At each row, you try to place a queen in every column. If it’s safe, you mark the column and diagonals, recurse to the next row, and backtrack after exploring.
- When all N queens are placed, you have found a valid solution.


### Algorithm Steps:

1. **Initialize:**  
   - Create an empty board and three boolean arrays: `cols`, `diag1`, and `diag2` to track columns and diagonals.

2. **Recursive Function (row):**
   - If `row == N`, add the current board to the result (all queens placed).
   - For each column in the current row:
     - Check if placing a queen at (row, col) is safe using the boolean arrays.
     - If safe:
       - Place the queen at (row, col).
       - Mark the column and diagonals as occupied.
       - Recurse to the next row.
       - Unmark the column and diagonals (backtrack) and remove the queen.

3. **Repeat** until all possible placements are explored.



### C++ Code:
``` cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Check if it's safe to place a queen at (row, col)
bool isSafe(int row, int col, int n, const vector<bool>& cols, const vector<bool>& diag1, const vector<bool>& diag2) {
    // Check column and both diagonals in O(1)
    return !cols[col] && !diag1[row + col] && !diag2[row - col + n - 1];
}

// Mark or unmark the column and diagonals as occupied
void mark(int row, int col, int n, vector<bool>& cols, vector<bool>& diag1, vector<bool>& diag2, bool value) {
    cols[col] = value;
    diag1[row + col] = value;
    diag2[row - col + n - 1] = value;
}

// Backtracking function to solve N-Queens
void solve(int row, int n, vector<string>& board, vector<vector<string>>& res,
           vector<bool>& cols, vector<bool>& diag1, vector<bool>& diag2) {
    if (row == n) {
        // All queens placed, store the solution
        res.push_back(board);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (isSafe(row, col, n, cols, diag1, diag2)) {
            // Place queen
            board[row][col] = 'Q';
            mark(row, col, n, cols, diag1, diag2, true);
            // Recurse to next row
            solve(row + 1, n, board, res, cols, diag1, diag2);
            // Backtrack: remove queen and unmark
            mark(row, col, n, cols, diag1, diag2, false);
            board[row][col] = '.';
        }
    }
}

// Main function to solve N-Queens
vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> res;
    vector<string> board(n, string(n, '.'));
    vector<bool> cols(n, false), diag1(2 * n - 1, false), diag2(2 * n - 1, false);
    solve(0, n, board, res, cols, diag1, diag2);
    return res;
}

int main() {
    int n;
    cin >> n;
    vector<vector<string>> solutions = solveNQueens(n);
    cout << "Number of solutions: " << solutions.size() << endl;
    for (const auto& board : solutions) {
        for (const string& row : board) {
            cout << row << endl;
        }
        cout << endl;
    }
    return 0;
}
```


### Complexity Analysis:

- **Time Complexity:**  
  O(N!), where N is the size of the board.
  - For each row, you try up to N columns, but the number of valid choices decreases as queens are placed.
  - The use of boolean arrays makes each check and update O(1).

- **Space Complexity:**  
  O(N^2) for storing the board and O(N) for the recursion stack and boolean arrays.
  - O(K * N^2) if you store all K solutions (each is an N×N board).
