## Backtracking Generalization

### Pseudocode Template:

``` text
void solve(state V) {
    if (isSolved(V) == true) {
        print/save V
    return
    }

    // huge number of choices, sometimes variable no of choices
    for (c in all choices) {
        if (isValid(c) == true) {
            change c in V
            solve(V)
        Revert changes in V
        }
    }
    return
}
```

---

### Explanation of Each Section

- **void solve(state V):**  
  This is your main backtracking function. `V` represents the current state (could be a board, a string, a path, etc.).

- **if (isSolved(V) == true):**  
  This is the **base case**. If the current state is a solution (e.g., all queens placed, all numbers filled, etc.), process it (print or save) and return.

- **for (c in all choices):**  
  Loop through all possible choices you can make at this step (e.g., which number to place, which direction to move, which element to pick).

- **if (isValid(c) == true):**  
  Check if making this choice keeps the state valid (does not violate any constraints).

- **change c in V:**  
  Make the choice—update the state to reflect this choice.

- **solve(V):**  
  Recurse with the updated state to explore further choices.

- **revert changes in V:**  
  **Backtrack**—undo the choice so you can try the next option in the loop.

- **return:**  
  End the function after all choices have been explored.

---

### In short

- **Backtracking = Try all choices + Prune invalid paths + Undo choices**
- This template helps you structure any backtracking solution systematically.

