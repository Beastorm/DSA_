## Word Search 
**Problem Statement:**   
Given an `m x n` grid of characters board and a string `word`, return `true` if the word exists in the grid. 
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

---

>### Examples:

### Example 1:

**Input:** board = [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]], word = "ABCCED"

**Output:** true

**Explanation:** We can easily find the given word in the matrix.

### Example 2:

**Input:** board = [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]], word = "ABCB"

**Output:** false

**Explanation:** There is no such word in the given matrix.

---

## Approach

### Intuition:

The word must be formed by sequentially adjacent cells in the grid. This is a classic backtracking problem:

- Find starting points: Any cell matching the first character
- Explore paths: From each starting point, try all 4 directions recursively
- Track visited cells: Mark cells to avoid reusing them in the same path
- Backtrack: If a path fails, unmark cells and try different directions
- Success: When we match all characters in sequence

Think of it as exploring a maze where each step must match the next letter in the word.

### Algorithm:

1. For each cell (i, j) in the board:
   - If board[i][j] == word[0], start DFS from (i, j)

2. DFS(x, y, index):
   - Base case: if index == word.length(), return true
   - If out of bounds OR cell != word[index] OR already visited, return false
   - Mark current cell as visited (board[x][y] = '#')
   - For each of 4 directions:
     - If DFS(new_x, new_y, index+1) returns true, restore cell and return true
   - Restore cell (backtrack)
   - Return false

3. Return true if any starting point succeeds, else false


### Key Points:

- Pattern: Backtracking + DFS
- Visited tracking: Mark cells with '#'
- Optimization: Only start DFS if the first character matches
- Direction handling: Use direction arrays for clean code
- Early termination: Return immediately when a word is found

### Edge Cases:

- Word length = 1 (single character)
- Word longer than the total cells
- Empty board or empty word
- Word requires revisiting the same cell (should return false)
- Multiple valid paths (return on first found)


### Diagram:
![Word Search - Backtracking Visualization](https://github.com/Beastorm/DSA_/blob/main/junk/word_search.png?raw=true)

### C++ Code:

``` cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    int m, n;
    // Using pairs for directions: Down, Up, Right, Left
    vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    
    bool dfs(vector<vector<char>>& board, string& word, int x, int y, int index) {
        // Base case: Successfully matched entire word
        if (index == word.length()) {
            return true;
        }
        
        // Boundary checks + character match check + visited check
        if (x < 0 || x >= m || y < 0 || y >= n || 
            board[x][y] != word[index] || board[x][y] == '#') {
            return false;
        }
        
        // Mark current cell as visited
        char temp = board[x][y];
        board[x][y] = '#';
        
        // Loop through all 4 directions
        for (auto [dx, dy] : directions) {
            if (dfs(board, word, x + dx, y + dy, index + 1)) {
                board[x][y] = temp;  // Restore before returning true
                return true;
            }
        }
        
        // Backtrack: restore the cell value
        board[x][y] = temp;
        return false;
    }
    
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size();
        n = board[0].size();
        
        // Edge case: empty word
        if (word.empty()) return true;
        
        // Try starting DFS from every cell
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // Optimization: only start if the first character matches
                if (board[i][j] == word[0] && dfs(board, word, i, j, 0)) {
                    return true;
                }
            }
        }
        
        return false;
    }
};

int main() {
    Solution sol;
    
    cout << "=== Word Search - LeetCode Problem ===" << endl << endl;
    
    // Test case 1: Word exists
    cout << "Test Case 1:" << endl;
    vector<vector<char>> board1 = {
        {'A', 'B', 'C', 'E'},
        {'S', 'F', 'C', 'S'},
        {'A', 'D', 'E', 'E'}
    };
    string word1 = "ABCCED";
    
    cout << "Board:" << endl;
    for (auto& row : board1) {
        for (char c : row) {
            cout << c << " ";
        }
        cout << endl;
    }
    cout << "Word: \"" << word1 << "\"" << endl;
    cout << "Result: " << (sol.exist(board1, word1) ? "true" : "false") << endl;
    cout << "Expected: true" << endl << endl;
    
    // Test case 2: Word exists (simple path)
    cout << "Test Case 2:" << endl;
    vector<vector<char>> board2 = {
        {'A', 'B', 'C', 'E'},
        {'S', 'F', 'C', 'S'},
        {'A', 'D', 'E', 'E'}
    };
    string word2 = "SEE";
    
    cout << "Board:" << endl;
    for (auto& row : board2) {
        for (char c : row) {
            cout << c << " ";
        }
        cout << endl;
    }
    cout << "Word: \"" << word2 << "\"" << endl;
    cout << "Result: " << (sol.exist(board2, word2) ? "true" : "false") << endl;
    cout << "Expected: true" << endl << endl;
    
    // Test case 3: Word doesn't exist (would need to reuse a cell)
    cout << "Test Case 3:" << endl;
    vector<vector<char>> board3 = {
        {'A', 'B', 'C', 'E'},
        {'S', 'F', 'C', 'S'},
        {'A', 'D', 'E', 'E'}
    };
    string word3 = "ABCB";
    
    cout << "Board:" << endl;
    for (auto& row : board3) {
        for (char c : row) {
            cout << c << " ";
        }
        cout << endl;
    }
    cout << "Word: \"" << word3 << "\"" << endl;
    cout << "Result: " << (sol.exist(board3, word3) ? "true" : "false") << endl;
    cout << "Expected: false (would need to reuse 'B')" << endl << endl;
    
    // Test case 4: Single character
    cout << "Test Case 4:" << endl;
    vector<vector<char>> board4 = {
        {'A', 'B'},
        {'C', 'D'}
    };
    string word4 = "A";
    
    cout << "Board:" << endl;
    for (auto& row : board4) {
        for (char c : row) {
            cout << c << " ";
        }
        cout << endl;
    }
    cout << "Word: \"" << word4 << "\"" << endl;
    cout << "Result: " << (sol.exist(board4, word4) ? "true" : "false") << endl;
    cout << "Expected: true" << endl << endl;
    
    // Test case 5: Long winding path
    cout << "Test Case 5:" << endl;
    vector<vector<char>> board5 = {
        {'A', 'B', 'C', 'E'},
        {'S', 'F', 'E', 'S'},
        {'A', 'D', 'E', 'E'}
    };
    string word5 = "ABCESEEEFS";
    
    cout << "Board:" << endl;
    for (auto& row : board5) {
        for (char c : row) {
            cout << c << " ";
        }
        cout << endl;
    }
    cout << "Word: \"" << word5 << "\"" << endl;
    cout << "Result: " << (sol.exist(board5, word5) ? "true" : "false") << endl;
    cout << "Expected: true" << endl << endl;
    
    // Test case 6: Word doesn't exist at all
    cout << "Test Case 6:" << endl;
    vector<vector<char>> board6 = {
        {'A', 'B'},
        {'C', 'D'}
    };
    string word6 = "XYZ";
    
    cout << "Board:" << endl;
    for (auto& row : board6) {
        for (char c : row) {
            cout << c << " ";
        }
        cout << endl;
    }
    cout << "Word: \"" << word6 << "\"" << endl;
    cout << "Result: " << (sol.exist(board6, word6) ? "true" : "false") << endl;
    cout << "Expected: false" << endl << endl;
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity: O(m × n × 4^L)**
   - m × n: Try starting from each cell
   - 4^L: At each step, explore up to 4 directions
   - L: Length of the word (recursion depth)

- **Space Complexity: O(L)**

- Recursion stack depth: Maximum L (word length)
- No extra data structures: We modify the board in-place
