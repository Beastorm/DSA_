## Sudoku Solver

**Problem Statement:**   
Given a partially filled `9x9` Sudoku board, fill the board so that every row, every column, and every 3x3 subgrid contains the digits `1` to `9` exactly once. Empty cells are represented by the character `.` 

---

>### Examples:

### Example 1:

**Input:**  
A partially filled Sudoku board:

```
5 3 . . 7 . . . .
6 . . 1 9 5 . . .
. 9 8 . . . . 6 .
8 . . . 6 . . . 3
4 . . 8 . 3 . . 1
7 . . . 2 . . . 6
. 6 . . . . 2 8 .
. . . 4 1 9 . . 5
. . . . 8 . . 7 9
```

**Output:**  
A completed Sudoku board (one possible solution):
```
5 3 4 6 7 8 9 1 2
6 7 2 1 9 5 3 4 8
1 9 8 3 4 2 5 6 7
8 5 9 7 6 1 4 2 3
4 2 6 8 5 3 7 9 1
7 1 3 9 2 4 8 5 6
9 6 1 5 3 7 2 8 4
2 8 7 4 1 9 6 3 5
3 4 5 2 8 6 1 7 9
```
---

### Example 2

**Input:**  
A nearly completed Sudoku board:
```
. 2 3 4
3 4 . 2
4 . 2 3
2 3 4 .
````

**Output:**  
A completed 4x4 Sudoku board:
```
1 2 3 4
3 4 1 2
4 1 2 3
2 3 4 1
```
---

**Explanation:**  
- Each row, column, and subgrid contains all digits exactly once.
- The solver fills in the empty cells to complete the board.

---

## Approach
### Intuition:

- Sudoku is a constraint satisfaction problem: you must fill each empty cell with a digit from 1 to 9 so that every row, column, and 3x3 subgrid contains each digit exactly once.
- The backtracking approach tries all possible digits for each empty cell, checking if the placement is valid.
- If a digit fits, it is placed, and the algorithm recurses to the next empty cell.
- If a dead end is reached (no valid digit for a cell), the algorithm backtracks and tries a different digit for the previous cell.
- This process continues until the board is filled or all possibilities are exhausted.


### Algorithm Steps:

1. **Find the first empty cell (row, col).**
2. **For each digit from 1 to 9:**
   - Check if placing the digit in the current cell is valid (not already in the same row, column, or 3x3 subgrid).
   - If valid:
     - Place the digit in the cell.
     - Recursively solve the rest of the board.
     - If solved, return true.
     - If not, remove the digit (backtrack) and try the next digit.
3. **If all cells are filled, return true (solved).**
4. **If no digit can be placed in an empty cell, return false (backtrack).**


### Diagram:
**Option-1:**   
![Sudoku Solver Recursive Tree](https://raw.githubusercontent.com/Beastorm/DSA_/6f45a63985e33cb12fb92acab97d06fa111fa597/junk/suduko_1.png)   

**Option-2:**   
![Sudoku Solver Example 2](https://raw.githubusercontent.com/Beastorm/DSA_/6f45a63985e33cb12fb92acab97d06fa111fa597/junk/suduko_2.png)   

### C++ Code:
``` cpp
class Solution {
public:
    // check if placing `num` at board[i][j] is valid
    bool check(int num, vector<vector<char>>& board, int i, int j) {
        char c = '0' + num;

        // check same row
        for (int col = 0; col < 9; col++) {
            if (board[i][col] == c)
                return false;
        }

        // check same column
        for (int row = 0; row < 9; row++) {
            if (board[row][j] == c)
                return false;
        }

        // check same 3x3 box
        int startRow = (i / 3) * 3;
        int startCol = (j / 3) * 3;

        for (int r = 0; r < 3; r++) {
            for (int c2 = 0; c2 < 3; c2++) {
                if (board[startRow + r][startCol + c2] == c)
                    return false;
            }
        }

        return true;
    }

    // backtracking function
    bool find(int i, int j, vector<vector<char>>& board) {
        // base condition: finished all rows
        if (i == 9)
            return true;

        // move to next row
        if (j == 9)
            return find(i + 1, 0, board);

        // skip filled cells
        if (board[i][j] != '.')
            return find(i, j + 1, board);

        // try numbers 1 to 9
        for (int num = 1; num <= 9; num++) {
            if (check(num, board, i, j)) {
                board[i][j] = '0' + num;

                if (find(i, j + 1, board))
                    return true;

                // backtrack
                board[i][j] = '.';
            }
        }

        return false;
    }

    void solveSudoku(vector<vector<char>>& board) {
        find(0, 0, board);
    }
};

// -------- DRIVER CODE --------
int main() {
    vector<vector<char>> board = {
        {'5','3','.','.','7','.','.','.','.'},
        {'6','.','.','1','9','5','.','.','.'},
        {'.','9','8','.','.','.','.','6','.'},
        {'8','.','.','.','6','.','.','.','3'},
        {'4','.','.','8','.','3','.','.','1'},
        {'7','.','.','.','2','.','.','.','6'},
        {'.','6','.','.','.','.','2','8','.'},
        {'.','.','.','4','1','9','.','.','5'},
        {'.','.','.','.','8','.','.','7','9'}
    };

    cout << "Sudoku before solving:\n";
    for (auto &row : board) {
        for (char c : row) cout << c << " ";
        cout << endl;
    }

    Solution obj;
    obj.solveSudoku(board);

    cout << "\nSudoku after solving:\n";
    for (auto &row : board) {
        for (char c : row) cout << c << " ";
        cout << endl;
    }

    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:**
   **O(9^(n×n))**, where n is the size of the board (n=9 for standard Sudoku).
   
   - Each empty cell can have up to **9 choices**
   - There are up to **81 cells** (n×n)
   - In practice, the number of possibilities is **much less** due to constraints and pruning

- **Space Complexity:**
   **O(n²)** for the recursion stack and the board.
   
   - The recursion stack can go as deep as the **number of empty cells**
   - Board storage requires **n×n = 81** cells
   - Auxiliary variables use **constant space**
