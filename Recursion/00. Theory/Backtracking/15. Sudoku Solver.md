# Lecture 21: Sudoku Solver

**Problem Statement:**   

Given a partially filled 9x9 Sudoku board, fill the board so that every row, every column, and every 3x3 subgrid contains the digits `1` to `9` exactly once.  
Empty cells are represented by the character `.`.

---

>### Examples:

### Example 1:

**Input:**  
A partially filled Sudoku board:

```
5 3 . . 7 . . . .
6 . . 1 9 5 . . .
. 9 8 . . . . 6 .
8 . . . 6 . . . 3
4 . . 8 . 3 . . 1
7 . . . 2 . . . 6
. 6 . . . . 2 8 .
. . . 4 1 9 . . 5
. . . . 8 . . 7 9
```

**Output:**  
A completed Sudoku board (one possible solution):
```
5 3 4 6 7 8 9 1 2
6 7 2 1 9 5 3 4 8
1 9 8 3 4 2 5 6 7
8 5 9 7 6 1 4 2 3
4 2 6 8 5 3 7 9 1
7 1 3 9 2 4 8 5 6
9 6 1 5 3 7 2 8 4
2 8 7 4 1 9 6 3 5
3 4 5 2 8 6 1 7 9
```
---

### Example 2

**Input:**  
A nearly completed Sudoku board:
```
. 2 3 4
3 4 . 2
4 . 2 3
2 3 4 .
````

**Output:**  
A completed 4x4 Sudoku board:
```
1 2 3 4
3 4 1 2
4 1 2 3
2 3 4 1
```
---

**Explanation:**  
- Each row, column, and subgrid contains all digits exactly once.
- The solver fills in the empty cells to complete the board.

---

## Approach
### Intuition:

- Sudoku is a constraint satisfaction problem: you must fill each empty cell with a digit from 1 to 9 so that every row, column, and 3x3 subgrid contains each digit exactly once.
- The backtracking approach tries all possible digits for each empty cell, checking if the placement is valid.
- If a digit fits, it is placed, and the algorithm recurses to the next empty cell.
- If a dead end is reached (no valid digit for a cell), the algorithm backtracks and tries a different digit for the previous cell.
- This process continues until the board is filled or all possibilities are exhausted.


### Algorithm Steps:

1. **Find the first empty cell (row, col).**
2. **For each digit from 1 to 9:**
   - Check if placing the digit in the current cell is valid (not already in the same row, column, or 3x3 subgrid).
   - If valid:
     - Place the digit in the cell.
     - Recursively solve the rest of the board.
     - If solved, return true.
     - If not, remove the digit (backtrack) and try the next digit.
3. **If all cells are filled, return true (solved).**
4. **If no digit can be placed in an empty cell, return false (backtrack).**


### Diagram:
**Option-1:**   
![Sudoku Solver Recursive Tree](https://raw.githubusercontent.com/Beastorm/DSA_/6f45a63985e33cb12fb92acab97d06fa111fa597/junk/suduko_1.png)   

**Option-2:**   
![Sudoku Solver Example 2](https://raw.githubusercontent.com/Beastorm/DSA_/6f45a63985e33cb12fb92acab97d06fa111fa597/junk/suduko_2.png)   

### C++ Code:
``` cpp
#include <iostream>
#include <vector>
using namespace std;

// Check if it's safe to place num at board[row][col]
bool isSafe(vector<vector<char>>& board, int row, int col, char num) {
    for (int i = 0; i < 9; i++) {
        // Check row and column
        if (board[row][i] == num || board[i][col] == num)
            return false;
        // Check 3x3 subgrid
        int subRow = 3 * (row / 3) + i / 3;
        int subCol = 3 * (col / 3) + i % 3;
        if (board[subRow][subCol] == num)
            return false;
    }
    return true;
}

// Backtracking function to solve Sudoku
bool solveSudoku(vector<vector<char>>& board) {
    for (int row = 0; row < 9; row++) {
        for (int col = 0; col < 9; col++) {
            if (board[row][col] == '.') {
                // Try all digits 1-9
                for (char num = '1'; num <= '9'; num++) {
                    if (isSafe(board, row, col, num)) {
                        board[row][col] = num; // Place digit
                        if (solveSudoku(board))
                            return true; // If solved, return true
                        board[row][col] = '.'; // Backtrack
                    }
                }
                return false; // No valid digit found, backtrack
            }
        }
    }
    return true; // All cells filled, solved
}

int main() {
    vector<vector<char>> board = {
        {'5','3','.','.','7','.','.','.','.'},
        {'6','.','.','1','9','5','.','.','.'},
        {'.','9','8','.','.','.','.','6','.'},
        {'8','.','.','.','6','.','.','.','3'},
        {'4','.','.','8','.','3','.','.','1'},
        {'7','.','.','.','2','.','.','.','6'},
        {'.','6','.','.','.','.','2','8','.'},
        {'.','.','.','4','1','9','.','.','5'},
        {'.','.','.','.','8','.','.','7','9'}
    };

    if (solveSudoku(board)) {
        cout << "Sudoku solved:" << endl;
        for (const auto& row : board) {
            for (char c : row)
                cout << c << " ";
            cout << endl;
        }
    } else {
        cout << "No solution exists." << endl;
    }
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  O(9^(n*n)), where n is the size of the board (n=9 for standard Sudoku).
  - Each empty cell can have up to 9 choices, and there are up to 81 cells.
  - In practice, the number of possibilities is much less due to constraints and pruning.

- **Space Complexity:**  
  O(n^2) for the recursion stack and the board.
  - The recursion stack can go as deep as the number of empty cells.
