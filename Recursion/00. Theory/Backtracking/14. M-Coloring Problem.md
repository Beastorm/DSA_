## M-Coloring Problem

**Problem Statement:**   
Given an undirected graph and an integer M, determine if the graph can be colored with at most M colors such that no two adjacent vertices have the same color.  
If possible, could you print one such coloring? If not, please print that it is not possible.

---
>### Examples:

### Example 1:

**Input:**  
Graph (adjacency matrix):  
```
0 1 1 0
1 0 1 1
1 1 0 1
0 1 1 0

M = 3
```
**Output:**  
Coloring is possible. One solution:  
```
- Vertex 0 -> Color 1  
- Vertex 1 -> Color 2  
- Vertex 2 -> Color 3  
- Vertex 3 -> Color 1  
```
**Explanation:**  
No two adjacent vertices have the same color, and only 3 colors are used.

---

### Example 2:

**Input:**  
Graph (adjacency matrix):  
```
0 1 1 1
1 0 1 0
1 1 0 1
1 0 1 0

M = 2
```
**Output:**  
Coloring is not possible with 2 colors.

**Explanation:**  
There is no way to color the graph with only 2 colors such that no two adjacent vertices share the same color.

---

### Example 3:

**Input:**  
Graph (adjacency matrix): 
```
0 1 0
1 0 1
0 1 0

M = 2
```
**Output:**  
Coloring is possible. One solution:  
- Vertex 0 -> Color 1  
- Vertex 1 -> Color 2  
- Vertex 2 -> Color 1  

**Explanation:**  
This is a simple path graph, and 2 colors are sufficient.


---

## Approach

### Intuition:

- The M-Coloring problem asks if you can color the vertices of a graph using at most M colors such that no two adjacent vertices share the same color.
- The approach is to try all possible color assignments for each vertex using backtracking.
- For each vertex, you try every color from 1 to M, check if itâ€™s safe (no adjacent vertex has the same color), and move to the next vertex.
- If you reach a vertex where no color can be assigned, you backtrack and try a different color for the previous vertex.
- If all vertices are colored successfully, you have found a valid coloring.


### Algorithm Steps:

1. **Start with the first vertex (vertex 0).**
2. **Recursive Function (vertex v):**
   - If all vertices are colored (`v == n`), return true (solution found).
   - For each color from 1 to M:
     - Check if the color can be assigned to vertex v (no adjacent vertex has the same color).
     - If valid:
       - Assign the color to vertex v.
       - Recurse to color the next vertex (`v + 1`).
       - If recursion returns true, return true.
       - Otherwise, remove the color (backtrack).
   - If no color can be assigned, return false.
3. **Repeat** until all vertices are colored or no valid coloring is possible.

### Diagram:
![M Coloring Recursive Tree](https://raw.githubusercontent.com/Beastorm/DSA_/f66d0a67b84cbff138727e141a98c9617ec6727d/junk/M_COLOR.png)

**Option-1:**  
![M Coloring Example 2](https://raw.githubusercontent.com/Beastorm/DSA_/f0d50b11cfeb508be022e44055e6598d2b82c9ca/junk/m_color_2.png)

**Option-2:**  
![M Coloring Backtracking Example](https://raw.githubusercontent.com/Beastorm/DSA_/f66d0a67b84cbff138727e141a98c9617ec6727d/junk/m_coloring_BT.png)



### C++ Code:

``` cpp
#include <iostream>
#include <vector>
using namespace std;

// Function to check if it's safe to color vertex v with color c
bool isSafe(int v, int c, const vector<vector<int>>& graph, const vector<int>& color, int n) {
    // Check all adjacent vertices
    for (int i = 0; i < n; i++) {

        // If there is an edge and the adjacent vertex has the same color, it's not safe
        if (graph[v][i] && color[i] == c)
            return false;
    }
    return true;
}

// Backtracking function to try coloring the graph
bool solve(int v, int n, int m, const vector<vector<int>>& graph, vector<int>& color) {
    // Base case: If all vertices are colored, return true
    if (v == n) {
        return true;
    }

    // Try all colors for the current vertex
    for (int c = 1; c <= m; c++) {

        // Check if assigning color c to vertex v is safe
        if (isSafe(v, c, graph, color, n)) {
            color[v] = c; // Assign color

            // Recurse to color the next vertex
            if (solve(v + 1, n, m, graph, color))
                return true; // If coloring is possible, return true

            color[v] = 0; // Backtrack: Remove color assignment
        }
    }
    // If no color can be assigned, return false
    return false;
}

// Wrapper function to start the coloring process
bool graphColoring(const vector<vector<int>>& graph, int m, int n, vector<int>& color) {
    return solve(0, n, m, graph, color);
}

int main() {
    // Example graph (adjacency matrix)
    // 0---1
    // |  /|
    // 2---3

    int n = 4; // Number of vertices

    int m = 3; // Number of colors

    vector<vector<int>> graph = {
        {0, 1, 1, 0},
        {1, 0, 1, 1},
        {1, 1, 0, 1},
        {0, 1, 1, 0}
    };
    vector<int> color(n, 0); // Color assignment for each vertex

    if (graphColoring(graph, m, n, color)) {

        cout << "Coloring is possible. One solution:" << endl;
        for (int i = 0; i < n; i++)
            cout << "Vertex " << i << " -> Color " << color[i] << endl;

    } else {
        cout << "Coloring is not possible with " << m << " colors." << endl;
    }
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:**  
  O(M^N), where N is the number of vertices and M is the number of colors.
  - For each vertex, you try up to M colors, and there are N vertices.
  - In the worst case, all combinations are tried.

- **Space Complexity:**  
  O(N), for the recursion stack and the color assignment array.
