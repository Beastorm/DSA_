## Palindrome Partitioning

**Problem:**  
Given a string `s`, partition it such that every substring in the partition is a palindrome. Return all possible palindrome partitions.

---

>### Examples: 

### Example 1: `s = "aab"`

**Input:** `"aab"`

**Output:** `[["a","a","b"], ["aa","b"]]`

**Explanation:**
- `"a"` is a palindrome, `"a"` is a palindrome, `"b"` is a palindrome → `["a","a","b"]` ✓
- `"aa"` is a palindrome, `"b"` is a palindrome → `["aa","b"]` ✓

---

### Example 2: `s = "a"`

**Input:** `"a"`

**Output:** `[["a"]]`

**Explanation:**
- Only one character, which is always a palindrome.

---

## Approach:
### Intuition: 

The goal is to split a string into all possible combinations where every substring is a **palindrome**.

We use **backtracking**:
- Start from index 0
- At each step, try all substrings `s[index...i]`
- If the substring is a **palindrome**:
  - Add it to the current path
  - Recurse for the rest of the string
  - Backtrack to try other options

This explores all valid partitions.

Example for `"aab"`:
- `"a" → "a" → "b"` ⇒ `["a", "a", "b"]`
- `"aa" → "b"` ⇒ `["aa", "b"]`

Only paths with palindromes are added to the result.

### Algorithm Steps:

1. Use backtracking to explore all possible partitions.
2. Start from index 0, try all substrings starting from the current index.
3. Check if the current substring is a palindrome.
4. If palindrome, add to current partition and recurse for the remaining string.
5. Backtrack by removing the last added substring.
6. When the index reaches the end of the string, add the current partition to the result.

### Diagram:

**Option-1:**  
![Palindrome Partition Recursion Tree](https://github.com/Beastorm/DSA_/raw/3228f7f5207671fa195012c50552f22212722f10/junk/palindrome_partitions.png)

**Option-2:**  
![Palindrome Partition Diagram](https://github.com/Beastorm/DSA_/raw/3228f7f5207671fa195012c50552f22212722f10/junk/palindrome_partition_2.png)

### C++ Code:
```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

class PalindromePartitioner {
public:
    vector<vector<string>> allPartitions;

    // Helper function to check if a substring is a palindrome
    bool isSubstringPalindrome(string& inputString, int startIndex, int endIndex) {
        while (startIndex < endIndex) {
            if (inputString[startIndex] != inputString[endIndex]) {
                return false;
            }
            startIndex++;
            endIndex--;
        }
        return true;
    }

    // Backtracking function to generate all valid palindrome partitions
    void findPartitionsRecursive(string& inputString, int currentIndex, vector<string>& currentPartition) {
        // Base case: Reached end of string, add current partition to results
        if (currentIndex == inputString.length()) {
            allPartitions.push_back(currentPartition);
            return;
        }

        // Try all substrings starting from the current index
        for (int endIndex = currentIndex; endIndex < inputString.length(); endIndex++) {
            if (isSubstringPalindrome(inputString, currentIndex, endIndex)) {

                // Substring inputString[currentIndex...endIndex] is a palindrome
                string palindromeSubstring = inputString.substr(currentIndex, endIndex - currentIndex + 1);

                // Choose
                currentPartition.push_back(palindromeSubstring);           

                // Explore
                findPartitionsRecursive(inputString, endIndex + 1, currentPartition);  

                // Un-choose (backtrack)
                currentPartition.pop_back();                               
            }
        }
    }

    // Public function to find all palindrome partitions
    vector<vector<string>> findAllPalindromePartitions(string inputString) {
        vector<string> currentPartition;
        
        allPartitions.clear();  // Ensure results are fresh
        
        findPartitionsRecursive(inputString, 0, currentPartition);

        
        return allPartitions;
    }
};

// Main driver function
int main() {
    PalindromePartitioner partitioner;
    string userInput = "aab";
    
    vector<vector<string>> validPartitions = partitioner.findAllPalindromePartitions(userInput);

    cout << "All Palindrome Partitions of \"" << userInput << "\":" << endl;
    
    for (const auto& partition : validPartitions) {
        cout << "[ ";
        for (const string& substringPart : partition) {
            cout << "\"" << substringPart << "\" ";
        }
        cout << "]" << endl;
    }

    return 0;
}
```
### Complexity Analysis:

#### Time Complexity: **O(n × 2ⁿ)**  
- **2ⁿ**: Total number of ways to partition the string (each character can be a split point or not).  
- **n**: Cost to check palindrome and create substrings.  
- **Total**: O(n × 2ⁿ)

#### Space Complexity: **O(n)** (excluding output)  
- **O(n)** recursion stack (max depth = string length).  
- **O(n)** for current path (partition being built).  
- **Result storage** takes O(n × 2ⁿ), not counted in auxiliary space.
