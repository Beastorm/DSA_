## Palindrome Partitioning

**Problem:**  
Given a string `s`, partition it such that every substring in the partition is a palindrome. Return all possible palindrome partitions.

---

>### Examples: 

### Example 1: `s = "aab"`

**Input:** `"aab"`

**Output:** `[["a","a","b"], ["aa","b"]]`

**Explanation:**
- `"a"` is a palindrome, `"a"` is a palindrome, `"b"` is a palindrome → `["a","a","b"]` ✓
- `"aa"` is a palindrome, `"b"` is a palindrome → `["aa","b"]` ✓

---

### Example 2: `s = "a"`

**Input:** `"a"`

**Output:** `[["a"]]`

**Explanation:**
- Only one character, which is always a palindrome.

---

## Approach:
### Intuition: 

The goal is to split a string into all possible combinations where every substring is a **palindrome**.

We use **backtracking**:
- Start from index 0
- At each step, try all substrings `s[index...i]`
- If the substring is a **palindrome**:
  - Add it to the current path
  - Recurse for the rest of the string
  - Backtrack to try other options

This explores all valid partitions.

Example for `"aab"`:
- `"a" → "a" → "b"` ⇒ `["a", "a", "b"]`
- `"aa" → "b"` ⇒ `["aa", "b"]`

Only paths with palindromes are added to the result.

### Algorithm Steps:

1. Use backtracking to explore all possible partitions.
2. Start from index 0, try all substrings starting from the current index.
3. Check if the current substring is a palindrome.
4. If palindrome, add to current partition and recurse for the remaining string.
5. Backtrack by removing the last added substring.
6. When the index reaches the end of the string, add the current partition to the result.

### Diagram:

**Option-1:**  
![Palindrome Partition Recursion Tree](https://github.com/Beastorm/DSA_/raw/3228f7f5207671fa195012c50552f22212722f10/junk/palindrome_partitions.png)

**Option-2:**  
![Palindrome Partition Diagram](https://github.com/Beastorm/DSA_/raw/3228f7f5207671fa195012c50552f22212722f10/junk/palindrome_partition_2.png)

### C++ Code:
```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

class Solution {
public:
    vector<vector<string>> result;

    // Helper function to check if a substring is a palindrome
    bool isPalindrome(string& s, int start, int end) {
        while (start < end) {
            if (s[start] != s[end]) {
                return false;
            }
            start++;
            end--;
        }
        return true;
    }

    // Backtracking function to generate partitions
    void backtrack(string& s, int index, vector<string>& current) {
        if (index == s.length()) {
            // Reached end of string, add current partition to result
            result.push_back(current);
            return;
        }

        // Try all substrings starting from the current index
        for (int i = index; i < s.length(); i++) {
            if (isPalindrome(s, index, i)) {

                // Substring s[index...i] is a palindrome
                current.push_back(s.substr(index, i - index + 1));  // Choose

                backtrack(s, i + 1, current);                        // Explore

                current.pop_back();                                  // Un-choose (backtrack)
            }
        }
    }

    // Public function to be called with input string
    vector<vector<string>> partition(string s) {
        vector<string> current;
        result.clear();  // Ensure result is fresh
        backtrack(s, 0, current);
        return result;
    }
};

// Main driver function (for testing)
int main() {
    Solution sol;
    string input = "aab";
    vector<vector<string>> partitions = sol.partition(input);

    cout << "All Palindrome Partitions of \"" << input << "\":" << endl;
    for (const auto& partition : partitions) {
        cout << "[ ";
        for (const string& str : partition) {
            cout << "\"" << str << "\" ";
        }
        cout << "]" << endl;
    }

    return 0;
}
```
### Complexity Analysis:

#### Time Complexity: **O(n × 2ⁿ)**  
- **2ⁿ**: Total number of ways to partition the string (each character can be a split point or not).  
- **n**: Cost to check palindrome and create substrings.  
- **Total**: O(n × 2ⁿ)

#### Space Complexity: **O(n)** (excluding output)  
- **O(n)** recursion stack (max depth = string length).  
- **O(n)** for current path (partition being built).  
- **Result storage** takes O(n × 2ⁿ), not counted in auxiliary space.
