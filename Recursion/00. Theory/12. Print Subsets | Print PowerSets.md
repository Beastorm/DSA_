## Print Subsets | Print PowerSets

### Examples:

### Example 1: Array

**Input:**  
`arr = [1, 2]`.

**Output:**  
```
- {}
- {1}
- {2}
- {1, 2}
```
---

### Example 2: String

**Input:**  
`s = "ab"`

**Output:**  
```
- ""
- "a"
- "b"
- "ab"
```
---

### Example 3: Array

**Input:**  
`arr = [1, 2, 3]`.

**Output:**  
```
- {}
- {1}
- {2}
- {3}
- {1, 2}
- {1, 3}
- {2, 3}
- {1, 2, 3}
```
---

### Mathematical Formula

For a set (or string/array) of size `n`, the total number of possible subsets (the powerset) is:

**Number of subsets = 2ⁿ**

- Each element has two choices: **include** or **exclude**.
- So, for `n` elements, total subsets = 2 × 2 × ... × 2 (n times) = 2ⁿ.

**Example:**  
If `n = 3` (e.g., `[1, 2, 3]`),  
Number of subsets = 2³ = 8.

---

## Approach

### Recursive Insight:

- At each step, you have two choices for the current element:
  1. Include it in the current subset.
  2. Exclude it from the current subset.
- Recursively explore both choices for every element.

### Recursive Algorithm:

1. **Base Case:**  
   If you have considered all elements (reached the end of the array or string), print the current subset.

2. **Recursive Step:**  
   - Include the current element and recurse for the rest.
   - Exclude the current element and recurse for the rest.

```
                 +------------------+
                 |   i/p: "ab"      |
                 |   o/p: ""        |
                 +------------------+
                   /              \
                aX/                \ a
                 /                  \
+------------------+            +------------------+
|   i/p: "b"       |            |   i/p: "b"       |
|   o/p: " "       |            |   o/p: "a"       |
+------------------+            +------------------+
     /        \                      /        \
bX  /          \b                bx /          \ b
   /            \                  /            \
+--------+   +--------+       +--------+   +---------+
| i/p:"" |   | i/p:"" |       | i/p:"" |   | i/p:""  |
| o/p:" "|   | o/p:"b"|       | o/p:"a"|   | o/p:"ab"|
+--------+   +--------+       +--------+   +---------+


```

---

### C++ Code:

```cpp
#include <iostream>
using namespace std;

void solve(string ip, string op) {
    if (ip.length() == 0) {
        cout << op << endl;
        return;
    }
    // op1: include the first character
    string op1 = op;
    op1.push_back(ip[0]);
    
    // op2: exclude the first character
    string op2 = op;
    
    // Remove the first character from input
    ip.erase(ip.begin() + 0);
    
    // Recurse for both choices
    solve(ip, op1);
    solve(ip, op2);
}

int main() {
    string ip;
    cin >> ip;
    string op = "";
    solve(ip, op);
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  O(2^n), where n is the number of elements, since each element has two choices.

- **Space Complexity:**  
  O(n), due to the recursion stack and the space used to store the current subset.

### Why does this work?

- At each step, you branch into two paths: include or exclude the current element.
- This explores all possible combinations (subsets) of the array or string.

---

### In short:

- Use recursion to explore all choices (include/exclude each element).
- Print the subset when you reach the end.

---

