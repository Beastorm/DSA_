## Print Unique Subsets and Variations

### Key Concepts:

- **Powerset** and **all subsets** are the same:  
  They refer to the set of all possible subsets of a given set or string, including the empty set.

- **Subsequence** is different:  
  A subsequence is a sequence that can be derived from another sequence by deleting some or no elements, without changing the order of the remaining elements.


**Venn Diagram:**
  ```
           +-----------------------------+
           |                             |
           |   Powerset (All Subsets)    |
           |   +---------------------+   |
           |   |                     |   |
           |   |     Subsequences    |   |
           |   |   (order preserved) |   |
           |   |   +-------------+   |   |
           |   |   |             |   |   |
           |   |   |  Substrings |   |   |
           |   |   | (contiguous)|   |   |
           |   |   +-------------+   |   |
           |   |                     |   |
           |   +---------------------+   |
           |                             |
           +-----------------------------+

  ```

### Counting Formulas:

#### 1. Powerset (All Subsets)
- **Formula:**  
  Number of subsets = 2ⁿ  
  (where n is the number of elements in the set or string)

#### 2. Subsequences
- **Formula:**  
  Number of subsequences = 2ⁿ  
  (Every subset can be represented as a subsequence by preserving order, including the empty subsequence)

#### 3. Substrings
- **Formula:**  
  Number of substrings = n × (n + 1) / 2  (where n is the length of the string)

  - Each substring is a contiguous sequence of characters.
  - For a string of length n, there are n choices for the starting index and for each start, up to n choices for the ending index, but only those where end ≥ start.

#### 4. Example: 
**Example for n = 3 ("abc"):**
- Number of subsets (powerset): 2³ = 8
- Number of subsequences: 2³ = 8
- Number of substrings: 3 × (3 + 1) / 2 = 6

---

>### Examples:

### Example 1: Array: `[1, 2, 2]`

### 1. All Subsets:   
*If we treat indices as distinct:*   
`{}`, `{1}`, `{2}`, `{2}`, `{1, 2}`, `{1, 2}`, `{2, 2}`, `{1, 2, 2}`

### 2. Unique Subsets:    
*Removing duplicate subsets from the list above:*    
`{}`, `{1}`, `{2}`, `{1, 2}`, `{2, 2}`, `{1, 2, 2}`

### 3. All Subsequences:     
`{}`, `{1}`, `{2}`, `{2}`, `{1, 2}`, `{1, 2}`, `{2, 2}`, `{1, 2, 2}`    

### 4. Unique Subsequences:   
*Removing duplicate Subsequences from the list above:*    
`{}`, `{1}`, `{2}`, `{1, 2}`, `{2, 2}`, `{1, 2, 2}`

---

### Variations:

- **Print all unique subsets:**  
  Use a set or sort the array and skip duplicates during recursion.

- **Print all unique subsequences:**  
  Use a set to avoid printing duplicate subsequences.

---

### Summary:

| Term         | Definition                                                                 | Example for "ab"         |
|--------------|----------------------------------------------------------------------------|--------------------------|
| Powerset     | All possible subsets (including empty set)                                 | `""`, `"a"`, `"b"`, `"ab"` |
| All subsets  | Same as powerset                                                           | `""`, `"a"`, `"b"`, `"ab"` |
| Subsequence  | Sequence from original by deleting some elements, order preserved          | `""`, `"a"`, `"b"`, `"ab"` |


### In short:
- Powerset and all subsets are the same.
- Subsequences are similar but are about order and not necessarily contiguous elements.
- For unique results with duplicates, use a set or skip duplicates in recursion.   


### Choice diagram:
``` text 
                            +------------------+
                            |  i/p: "aab"      |
                            |  o/p: ""         |
                            +------------------+
                                  /      \
                              aX /        \ a
                               /            \
            +------------------+        +------------------+
            |  i/p: "ab"       |        |  i/p: "ab"       |
            |  o/p: ""         |        |  o/p: "a"        |
            +------------------+        +------------------+
                     /     \                      /     \
                aX  /       \ a               aX /       \ a
                   /         \                 /           \
   +------------------+  +------------------+  +------------------+  +------------------+
   |  i/p: "b"        |  |  i/p: "b"        |  |  i/p: "b"        |  |  i/p: "b"        |
   |  o/p: ""         |  |  o/p: "a"        |  |  o/p: "a"        |  |  o/p: "aa"       |
   +------------------+  +------------------+  +------------------+  +------------------+
            /    \               /    \               /    \               /    \
        bX /      \ b        bX /      \ b        bX /      \ b        bX /      \ b
          /        \           /        \           /        \           /        \
+---------+  +---------+ +---------+  +---------+ +---------+  +---------+ +---------+  +----------+
| i/p:""  |  | i/p:""  | | i/p:""  |  | i/p:""  | | i/p:""  |  | i/p:""  | | i/p:""  |  | i/p:""   |
| o/p:""  |  | o/p:"b" | | o/p:"a" |  | o/p:"ab"| | o/p:"a" |  | o/p:"ab"| | o/p:"aa"|  | o/p:"aab"|
+---------+  +---------+ +---------+  +---------+ +---------+  +---------+ +---------+  +----------+

```
---

### C++ Code(for string):

``` cpp
#include <iostream>
#include <set>
using namespace std;

// Recursive function to generate all unique subsequences
void solve(string ip, string op, set<string>& st) {
    if (ip.length() == 0) {
        if (!op.empty()) // Only insert non-empty subsequences
            st.insert(op);
        return;
    }
    // Include the first character
    string op1 = op;
    op1.push_back(ip[0]);
    // Exclude the first character
    string op2 = op;
    // Remove the first character from input
    ip.erase(ip.begin());
    // Recurse for both choices
    solve(ip, op1, st);
    solve(ip, op2, st);
}

int main() {
    string ip;
    cin >> ip;
    string op = "";
    set<string> st;
    solve(ip, op, st);
    for (const auto& s : st) {
        cout << s << endl;
    }
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(2^n * n)`, where `n` is the length of the input string.  
  - There are `2^n` possible subsequences.
  - Each subsequence can be up to length `n` (for insertion and set operations).

- **Space Complexity:**  
  `O(2^n * n)`,  
  - The set can store up to `2^n` unique subsequences, each of length up to `n`.
  - The recursion stack uses up to `O(n)` space.

### How it works:

- For each character, you branch into two paths: include or exclude it in the current subsequence.
- When the input string is empty, you insert the current output string into a set (to ensure uniqueness and skip empty subsequences).
- At the end, print all unique non-empty subsequences.

---

## To get subsets or subsequences in lexicographical order, you need to:

1. **Store all generated subsequences/subsets in a container** (like a vector).
2. **Sort the container before printing.**
3. If you want to avoid duplicates (for unique subsequences), use a `set` (which is always sorted in C++), or use a `vector` and call `sort()` and `unique()`.

### Note:
- Use a vector to collect all results, then sort.
- For unique results, use a set or sort + unique.


### C++ Code(for string):

``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void solve(string ip, string op, vector<string>& res) {
    if (ip.length() == 0) {
        res.push_back(op);
        return;
    }
    // Include the first character
    string op1 = op + ip[0];
    // Exclude the first character
    string op2 = op;
    // Remove the first character from input
    ip.erase(ip.begin());
    // Recurse for both choices
    solve(ip, op1, res);
    solve(ip, op2, res);
}

int main() {
    string ip;
    cin >> ip;
    vector<string> res;
    solve(ip, "", res);

    // Remove duplicates for unique subsequences
    sort(res.begin(), res.end());
    res.erase(unique(res.begin(), res.end()), res.end());

    for (const auto& s : res) {
        cout << (s.empty() ? "\"\"" : s) << endl;
    }
    return 0;
}
```

### How does it work?

- All subsequences are generated and stored in a vector.
- The vector is sorted to ensure lexicographical order.
- `unique()` and `erase()` remove duplicates (for unique subsequences).
- If you want all (not unique) subsequences in lex order, just skip the `unique()` line.

**For subsets of an array:**
- Sort the array before generating subsets to ensure the output is in lexicographical order.

### Summary:
- Store all results in a vector.
- Sort the vector before printing.
- Remove duplicates if you want unique results.


---

### Clarification:

- **Powerset (All Subsets):**  
  All possible combinations of elements.  
  (Order does not matter for sets, but for strings, order is preserved in the output.)

- **Subsequences:**  
  All possible sequences you can get by deleting zero or more characters, without changing the order of the remaining characters.  
  For a string, the set of all subsequences is the same as the powerset.

- **Substrings:**  
  Only contiguous sequences.

---

| Task                | Code Above | Needs Set? | Needs Different Code? |
|---------------------|:----------:|:----------:|:--------------------:|
| All subsequences    |    Yes     |    No      |         No           |
| Powerset            |    Yes     |    No      |         No           |
| Unique subsequences |    No      |   Yes      |         No           |
| Substrings          |    No      |    No      |        Yes           |
