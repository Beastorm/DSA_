## Josephus Problem 

**Problem Statement:**

- There are **n people** standing in a **circle**
- They are numbered **1 to n** (clockwise)
- Counting starts from **person 1**
- Every time:
  - Skip (k − 1) people
  - Kill the kᵗʰ person
- The killed person is removed from the circle
- Counting continues from the next person
- This repeats until only one person remains
- That remaining position is called the safe position

**Key Idea:**

The circle keeps shrinking, but the counting rule stays the same.

---

>### Examples:

### Example 1:
**Input:** n = 1, k = any number
**Output:** [1]  
Only one person remains.
Safe position = 1

---

### Example 2:
**Input:** n = 2, k = 2
Meaning: skip 1, kill 2

Initial circle:
```
1 -> 2 -> (back to 1)
```
Steps:
- Skip 1
- Kill 2

Remaining:
```
1
```

Safe position = 1

---

### Example 3:

### n = 5, k = 2

Meaning: skip 1, kill 2

Initial:
```
1 -> 2 -> 3 -> 4 -> 5
```

Step-by-step execution:

1. Kill 2
   ```
   1 -> 3 -> 4 -> 5
   ```

2. Kill 4
   ```
   1 -> 3 -> 5
   ```

3. Kill 1
   ```
   3 -> 5
   ```

4. Kill 5
   ```
   3
   ```

Safe position = 3

---

### Example 4

### n = 7, k = 3

Meaning: skip 2, kill 3

Initial:
```
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7
```

Execution order:
```
Killed: 3 -> 6 -> 2 -> 7 -> 5 -> 1
```

Remaining:
```
4
```

Safe position = 4

---

#### Mathematical Formula:

```
J(1, k) = 0
J(n, k) = (J(n-1, k) + k) % n
```

Final answer:
```
Safe position = J(n, k) + 1
```

#### One-Line Memory Trick:

Josephus problem = kill every kᵗʰ person in a circle until only one survives


---

## Approach

### Intuition:

- The problem is a simulation of a circle where every k-th person is eliminated.
- By always removing the k-th person (using modulo for wrap-around), you reduce the problem size by one each time.
- The recursion naturally simulates the process, always working with a smaller circle.
- The base case is when only one person is left, which is the survivor.

### Algorithm Steps:

1. **Initialize:**
   - Create a vector `v` containing elements from 1 to n.
   - Set the starting index to 0.

2. **Recursive Function:**
   - If only one element is left in the vector, that is the answer. Return it.
   - Calculate the next index to remove: `(current_index + k) % v.size()`.
   - Remove the element at this index from the vector.
   - Recurse with the updated vector and the new index.

3. **Repeat:**
   - Continue the process until only one element remains.

**In short:**  
- The recursive approach mimics the elimination process, shrinking the circle step by step until only one remains.

### C++ Code:

``` cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function to find the last remaining element
void solve(vector<int>& v, int k, int index, int& ans) {
    // Base case: only one element left
    if (v.size() == 1) {
        ans = v[0];
        return;
    }
    // Find the next index to remove
    index = (index + k) % v.size();

    // Remove the element at the calculated index
    v.erase(v.begin() + index);

    // Recurse for the reduced vector
    solve(v, k, index, ans);
}

int main() {
    int n, k;
    cin >> n >> k;
    k--; // Since we are using 0-based indexing
    vector<int> v;
    // Fill the vector with 1 to n
    for (int i = 1; i <= n; i++) {
        v.push_back(i);
    }
    int ans = 0;
    solve(v, k, 0, ans);
    cout << "The last remaining element is: " << ans << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  O(n^2), where n is the number of elements.
  - Each recursive call removes one element from the vector, which takes O(n) time due to shifting elements.
  - There are n recursive calls (one for each removal), so total time is O(n^2).

- **Space Complexity:**  
  O(n), due to the space used by the vector to store the elements and the recursion stack (which can go up to n calls deep).
