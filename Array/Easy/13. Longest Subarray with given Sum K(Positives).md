# Longest Subarray with given Sum K (Positives)

**Problem Statement:**  
Given an array `nums` of size `n` and an integer `k`, find the length of the longest sub-array that sums to `k`. If no such sub-array exists, return `0`.

### Examples

**Example 1:**  
**Input:**  
`nums = [10, 5, 2, 7, 1, 9]`, `k = 15`  
**Output:**  
`4`  
**Explanation:**  
The longest sub-array with a sum equal to 15 is `[5, 2, 7, 1]`, which has a length of 4. This sub-array starts at index 1 and ends at index 4, and the sum of its elements (5 + 2 + 7 + 1) equals 15. Therefore, the length of this sub-array is 4.

**Example 2:**  
**Input:**  
`nums = [-3, 2, 1]`, `k = 6`  
**Output:**  
`0`  
**Explanation:**  
There is no sub-array in the array that sums to 6. Therefore, the output is 0.

---

## Brute Force Approach

### Algorithm

1. Run a loop with index `i` to select every possible starting index of the subarray. These starting indices range from `0` to `n-1` where `n` is the size of the array.
2. Inside this loop, run another loop with index `j` to select the ending index of the subarray. For each subarray starting at index `i`, the ending index `j` can range from `i` to `n-1`.
3. For each subarray starting from index `i` and ending at index `j` (i.e., `arr[i...j]`), run an additional loop to calculate the sum of all the elements in that subarray.
4. If the sum equals `k`, compute its length as `(j - i + 1)` and update the maximum length found so far.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution
{
public:
    int longestSubarray(vector<int> &nums, int k)
    {
        int n = nums.size(); 
        int maxLength = 0;

        // starting index
        for (int startIndex = 0; startIndex < n; startIndex++) { 
            // ending index
            for (int endIndex = startIndex; endIndex < n; endIndex++) { 
                /* add all the elements of 
                   subarray = nums[startIndex...endIndex]  */
                int currentSum = 0;
                for (int i = startIndex; i <= endIndex; i++) {
                    currentSum += nums[i];
                }

                if (currentSum == k)
                    maxLength = max(maxLength, endIndex - startIndex + 1);
            }
        }
        return maxLength;
    }
};

int main()
{
    vector<int> a = { -1, 1, 1 };
    int k = 1;

    // Create an instance of the Solution class
    Solution solution;
    // Function call to get the result
    int len = solution.longestSubarray(a, k);
    
    cout << "The length of the longest subarray is: " << len << "\n";
    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(n^3)$  
  Where $n$ is the size of the array. This is because we have three nested loops: one for the starting index, one for the ending index, and one for calculating the sum of the subarray.

* **Space Complexity:** $O(1)$  
  As we are using a constant amount of space for variables and not using any additional data structures that grow with input size.

---

### Optimal Approach: Two Pointers / Sliding Window (for non-negative numbers)

**Algorithm**

1. Two pointers, `left` and `right`, are used to maintain the current window of elements in the array. These pointers represent the start and end of the current subarray.
2. A variable `sum` is used to keep track of the sum of the elements in the current window between `left` and `right`.
3. The `right` pointer expands the window by including new elements, increasing the `sum`.
4. If the `sum` of the window exceeds `k`, the `left` pointer shrinks the window by removing elements from the start until the sum is less than or equal to `k`.
5. If the `sum` of the current window equals `k`, the maximum length of such a subarray is updated.
6. The process continues until the `right` pointer traverses the entire array.
7. Finally, the maximum length of the subarray with sum `k` is returned as the result.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution{
public:
    // Function to find the length of longest subarray having sum k
    int longestSubarray(vector<int> &nums, int k){
        int n = nums.size();
        
        // To store the maximum length of the subarray
        int maxLen = 0;
        
        // Pointers to mark the start and end of window
        int left = 0, right = 0;
        
        // To store the sum of elements in the window
        int sum = nums[0];
        
        // Traverse all the elements
        while(right < n) {
            
            // If the sum exceeds K, shrink the window
            while(left <= right && sum > k) {
                sum -= nums[left];
                left++;
            }
            
            // store the maximum length
            if(sum == k) {
                maxLen = max(maxLen, right - left + 1);
            }
            
            right++;
            if(right < n) sum += nums[right];
        }
        
        return maxLen;
    }
};

int main() {
    vector<int> nums = {10, 5, 2, 7, 1, 9};
    int k = 15;
    
    // Creating an object of Solution class
    Solution sol;

    /* Function call to find the length of longest subarray having sum k */
    int ans = sol.longestSubarray(nums, k);

    cout << "The length of longest subarray having sum k is: " << ans;

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N)$, where $N$ is the size of the array.  
  The algorithm traverses the array once with two pointers, making it linear in time complexity.

* **Space Complexity:** $O(1)$, as it uses a constant amount of space.
