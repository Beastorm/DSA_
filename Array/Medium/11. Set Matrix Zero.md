# Set Matrix Zero

**Problem Statement:**  
Given a matrix, if an element in the matrix is `0` then you have to set its entire **row** and **column** to `0` and then return the matrix.

---

## Examples

**Example 1:**

**Input:**  
`matrix = [[1,1,1],[1,0,1],[1,1,1]]`  

**Output:**  
`[[1,0,1],[0,0,0],[1,0,1]]`  

**Explanation:**  
Since `matrix[1][1] = 0` (0-based index), the 2nd row and 2nd column are set to 0.

---

**Example 2:**

**Input:**  
`matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]`  

**Output:**  
`[[0,0,0,0],[0,4,5,0],[0,3,1,0]]`  

**Explanation:**  
`matrix[0][0] = 0` and `matrix[0][3] = 0`.  
So 1st row, 1st column, and 4th column are set to 0.

---

## Brute Force Approach

### Algorithm

Think of the matrix as a chessboard. If you see a zero somewhere, you need to wipe out its whole row and column to zero.

The problem:  
If you set them to zero **immediately**, those new zeros will trigger extra unwanted zeroing when you continue scanning.

To avoid this, we:

1. Use a **marker value** (like `-1`, or any value guaranteed not to occur in the input) to **mark** positions that should be zero later.
2. Do a second pass to convert all markers to `0`.

**Steps:**

1. Traverse the entire matrix.
2. If an element is `0`:
   - Mark all elements in its **row** (except existing zeros) as `-1`.
   - Mark all elements in its **column** (except existing zeros) as `-1`.
3. After full traversal, run a second pass and replace all `-1` with `0`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to set entire row and column to 0 if an element in the matrix is 0
    void setZeroes(vector<vector<int>>& matrix) {
        // Get number of rows
        int m = matrix.size();
        // Get number of columns
        int n = matrix[0].size();

        // Traverse each cell of the matrix
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // If current cell is zero
                if (matrix[i][j] == 0) {
                    // Mark all elements in this row as -1 (except existing zeros)
                    for (int col = 0; col < n; col++) {
                        if (matrix[i][col] != 0)
                            matrix[i][col] = -1;
                    }
                    // Mark all elements in this column as -1 (except existing zeros)
                    for (int row = 0; row < m; row++) {
                        if (matrix[row][j] != 0)
                            matrix[row][j] = -1;
                    }
                }
            }
        }

        // Second pass: replace all -1 markers with 0
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == -1)
                    matrix[i][j] = 0;
            }
        }
    }
};

int main() {
    // Example matrix
    vector<vector<int>> matrix = {{1,1,1},{1,0,1},{1,1,1}};
    
    // Create Solution object
    Solution sol;
    // Call function to modify matrix
    sol.setZeroes(matrix);
    
    // Print final matrix
    for (auto row : matrix) {
        for (auto val : row) {
            cout << val << " ";
        }
        cout << endl;
    }
    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(m \times n \times (m + n))$  
  We iterate through every cell ($m \times n$), and for each zero, we potentially mark its entire row ( $O(n)$ ) and column ( $O(m)$ ),  
  leading to $O(m \times n \times (m + n))$ overall.

* **Space Complexity:** $O(1)$  
  We are not using any extra data structures; we only modify the matrix in place, apart from a few constant-size variables.

---

## Better Approach: Using Extra Row and Column Arrays

**Algorithm**
 
Instead of marking directly in the matrix, we keep two extra arrays:

- One to track which **rows** need to be zeroed.
- One to track which **columns** need to be zeroed.

When you find a zero, mark its row index in the `row` array and its column index in the `col` array. After the first scan, you go back and zero out all marked rows and columns. This avoids accidental over-zeroing during the first pass.

**Steps:**

1. Let `m` be the number of rows and `n` be the number of columns.
2. Create:
   - `row` array of size `m` initialized to `0`.
   - `col` array of size `n` initialized to `0`.
3. **First pass:** Traverse the matrix:
   - Whenever you find `matrix[i][j] == 0`:
     - Mark `row[i] = 1`
     - Mark `col[j] = 1`
4. **Second pass:** Traverse the matrix again:
   - If `row[i] == 1` **or** `col[j] == 1`, set `matrix[i][j] = 0`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to set entire row and column to 0 if an element in the matrix is 0
    void setZeroes(vector<vector<int>>& matrix) {
        // Get number of rows
        int m = matrix.size();
        // Get number of columns
        int n = matrix[0].size();

        // Create row marker array
        vector<int> row(m, 0);
        // Create column marker array
        vector<int> col(n, 0);

        // First pass: mark rows and columns that need to be zeroed
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // If element is zero, mark its row and column
                if (matrix[i][j] == 0) {
                    row[i] = 1;
                    col[j] = 1;
                }
            }
        }

        // Second pass: set cells to zero based on markers
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // If the row or column is marked, set cell to zero
                if (row[i] == 1 || col[j] == 1) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
};

int main() {
    // Create the matrix
    vector<vector<int>> matrix = {{1,1,1},{1,0,1},{1,1,1}};
    
    // Create Solution object
    Solution obj;
    // Call function
    obj.setZeroes(matrix);
    
    // Print the updated matrix
    for (auto row : matrix) {
        for (auto val : row) {
            cout << val << " ";
        }
        cout << endl;
    }
    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(m \times n)$  
  We make two passes over the matrix:  
  - First pass to identify rows and columns to be zeroed ($O(m \times n)$).  
  - Second pass to update the matrix using the markers ($O(m \times n)$).  
  Total time is proportional to the number of cells in the matrix, so overall $O(m \times n)$.

* **Space Complexity:** $O(m + n)$  
  We store two extra arrays: one of size $m$ for rows and one of size $n$ for columns.  
  No other extra space is used besides these arrays.

---

## Optimal Approach: In-place Marking Using First Row and Column (O(1) Extra Space)

**Algorithm**

Instead of using separate arrays, we use the **first row** and **first column** of the matrix itself to store whether a row or column needs to be zeroed.  
We also use two flags:

- `firstRowZero`: was the first row supposed to be all zero?
- `firstColZero`: was the first column supposed to be all zero?

Steps:

1. **Check first row:**  
   Scan the first row; if any cell is 0, set `firstRowZero = true`.

2. **Check first column:**  
   Scan the first column; if any cell is 0, set `firstColZero = true`.

3. **Mark rows and columns using first row/column:**  
   For each cell `(i, j)` with `i > 0` and `j > 0`:
   - If `matrix[i][j] == 0`, mark:
     - `matrix[i][0] = 0`  (this row needs to be zeroed)
     - `matrix[0][j] = 0`  (this column needs to be zeroed)

4. **Zero out cells based on markers:**  
   For each cell `(i, j)` with `i > 0` and `j > 0`:
   - If `matrix[i][0] == 0` or `matrix[0][j] == 0`, set `matrix[i][j] = 0`.

5. **Handle the first row and first column separately** using `firstRowZero` and `firstColZero`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to set entire row and column to 0 if an element in the matrix is 0 (Optimal O(1) space)
    void setZeroes(vector<vector<int>>& matrix) {
        // Get dimensions of matrix
        int m = matrix.size();
        int n = matrix[0].size();

        // Flag to track if first row should be zeroed
        bool firstRowZero = false;
        // Flag to track if first column should be zeroed
        bool firstColZero = false;

        // Check if first row has any zero
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                firstRowZero = true;
                break;
            }
        }

        // Check if first column has any zero
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                firstColZero = true;
                break;
            }
        }

        // Mark rows and columns in first row/column
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        // Set matrix cells to zero based on markers
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

        // Handle first row
        if (firstRowZero) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }

        // Handle first column
        if (firstColZero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
};

int main() {
    Solution obj;
    vector<vector<int>> matrix = {{0,1,2,0},{3,4,5,2},{1,3,1,5}};
    obj.setZeroes(matrix);
    for (auto row : matrix) {
        for (auto val : row) {
            cout << val << " ";
        }
        cout << endl;
    }
    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(m \times n)$  
  We iterate over the entire matrix a constant number of times (first pass for markers, second pass for zeroing, final pass for first row/column), where $m$ = number of rows and $n$ = number of columns.

* **Space Complexity:** $O(1)$  
  No extra space is used apart from a few boolean flags; all marker information is stored within the first row and column of the matrix itself.
