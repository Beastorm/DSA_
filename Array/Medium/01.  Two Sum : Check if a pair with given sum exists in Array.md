# Two Sum : Check if a pair with given sum exists in Array

**Problem Statement:**  
Given an array of integers `arr[]` and an integer `target`.

- **1st variant:** Return `YES` if there exist two numbers such that their sum is equal to the target. Otherwise, return `NO`.
- **2nd variant:** Return **indices** of the two numbers such that their sum is equal to the target. Otherwise, return `{-1, -1}`.

---

## Examples

**Input:** `N = 5, arr[] = {2, 6, 5, 8, 11}, target = 14`  
**Output:** `YES`  
**Explanation:** `arr[1] + arr[3] = 14`.  
So, the answer is `YES` for the first variant.  
For the second variant, the output will be: `[1, 3]`.

---

**Input:** `N = 5, arr[] = {2, 6, 5, 8, 11}, target = 15`  
**Output:** `NO`  
**Explanation:** There exist no such two numbers whose sum is equal to the target.

---

## Brute Force Approach

### Algorithm

For each element of the given array, we will try to search for another element such that its sum is equal to the target. If such two numbers exist, we will return the indices or `YES` accordingly.

1. Use a loop (say `i`) to select indices of the array one by one.
2. For every index `i`, traverse through the remaining array using another loop (say `j`) to find the other number such that the sum is equal to the target (i.e. `arr[i] + arr[j] == target`).
3. **Observation:**  
   If the inner loop starts from index `0`, we will check the same pair of numbers multiple times.  
   For example:
   - In iteration 1, for `i = 0`, we check pair `arr[0]` and `arr[1]`.
   - In iteration 2, for `i = 1`, we again check `arr[1]` and `arr[0]`.  
   To avoid this, start the inner loop from `i + 1`.

---

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to check if any two numbers sum up to target (variant 1)
    string twoSumExists(vector<int>& arr, int target) {
        int n = arr.size();
        // Outer loop picks one element at a time
        for (int i = 0; i < n; i++) {
            // Inner loop searches for another element that complements arr[i]
            for (int j = i + 1; j < n; j++) {
                // If sum equals target, return "YES"
                if (arr[i] + arr[j] == target) {
                    return "YES";
                }
            }
        }
        // No pair found that sums to target
        return "NO";
    }

    // Function to return indices of two numbers that sum to target (variant 2)
    vector<int> twoSumIndices(vector<int>& arr, int target) {
        int n = arr.size();
        // Outer loop picks one element at a time
        for (int i = 0; i < n; i++) {
            // Inner loop searches for another element that complements arr[i]
            for (int j = i + 1; j < n; j++) {
                // If sum equals target, return the pair of indices
                if (arr[i] + arr[j] == target) {
                    return {i, j};
                }
            }
        }
        // No such pair found
        return {-1, -1};
    }
};

int main() {
    Solution sol;

    vector<int> arr = {2, 6, 5, 8, 11};
    int target = 14;

    // Variant 1
    cout << sol.twoSumExists(arr, target) << "\n";

    // Variant 2
    vector<int> res = sol.twoSumIndices(arr, target);
    cout << "[" << res[0] << ", " << res[1] << "]\n";

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N^2)$  
  Because we use two nested loops to check every possible pair of elements in the array, where $N$ is the size of the array.

* **Space Complexity:** $O(1)$  
  As we use a constant amount of extra space regardless of input size.

---

### Better Approach: Using HashMap (unordered_map)

**Algorithm**

Basically, in the previous approach we selected one element and then searched for the other one using a loop.  
Here, instead of using a loop for the second element, we use a **HashMap** to check if the other element `target - arr[i]` exists.  
Thus we can trim down the time complexity.

- For the **first variant**, we just need to know whether such a pair exists.
- For the **second variant**, we store the element **along with its index** in the HashMap, so we can return the indices directly.

**Steps:**

1. Select elements of the array one by one using a loop (say `i`).
2. For each `arr[i]`, compute the needed complementary value: `target - arr[i]`.
3. Check if this complementary value exists in the HashMap:
   - If it exists:
     - For **variant 1**, return `"YES"`.
     - For **variant 2**, return `{ mp[target - arr[i]], i }`.
   - If it does **not** exist:
     - Store the current element and its index in the HashMap: `mp[arr[i]] = i`.
4. If the loop finishes and no pair found:
   - For **variant 1**, return `"NO"`.
   - For **variant 2**, return `{-1, -1}`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Variant 1: Check if two numbers sum to target using hashing
    string twoSumExists(vector<int>& arr, int target) {
        unordered_map<int, int> mp;  // Map to store element -> index
        int n = arr.size();
        // Iterate over all elements
        for (int i = 0; i < n; i++) {
            int complement = target - arr[i];  // Needed value to reach target sum
            // Check if complement is already in map
            if (mp.find(complement) != mp.end()) {
                return "YES";  // Pair found
            }
            // Store current element with its index for future reference
            mp[arr[i]] = i;
        }
        // No pair found
        return "NO";
    }

    // Variant 2: Return indices of two numbers that sum to target using hashing
    vector<int> twoSumIndices(vector<int>& arr, int target) {
        unordered_map<int, int> mp;  // Map to store element -> index
        int n = arr.size();
        for (int i = 0; i < n; i++) {
            int complement = target - arr[i];
            // If complement found, return indices
            if (mp.find(complement) != mp.end()) {
                return {mp[complement], i};
            }
            // Store current element and index
            mp[arr[i]] = i;
        }
        return {-1, -1};  // No pair found
    }
};

int main() {
    Solution sol;
    vector<int> arr = {2, 6, 5, 8, 11};
    int target = 14;

    cout << sol.twoSumExists(arr, target) << "\n";
    vector<int> res = sol.twoSumIndices(arr, target);
    cout << "[" << res[0] << ", " << res[1] << "]\n";

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N)$  
  Because we traverse the array only once, and each lookup or insertion in the hash map takes $O(1)$ on average, where $N$ is the size of the array.

* **Space Complexity:** $O(N)$  
  Since in the worst case we may store all elements of the array in the hash map.

  
---

### Optimal Approach: Two Pointers on Sorted Array

**Algorithm**

In this approach, we will first sort the array and will try to choose the numbers in a greedy way.

We will keep a `left` pointer at the first index and a `right` pointer at the last index. Now until `left < right`, we will check the sum of `arr[left]` and `arr[right]`.

- If `sum < target`, we need bigger numbers → increment `left`.
- If `sum > target`, we need smaller numbers → decrement `right`.
- If `sum == target`:
  - For variant 1: return `"YES"`.
  - For variant 2: return the indices of the two numbers.

If `left` crosses `right`, no pair exists and we return `"NO"` or `{-1, -1}`.

**Steps:**

1. Sort the given array (for variant 2, keep track of original indices).
2. Take two pointers:
   - `left` at the first index,
   - `right` at the last index.
3. While `left < right`:
   - If `arr[left] + arr[right] > target`, decrement `right`.
   - If `arr[left] + arr[right] < target`, increment `left`.
   - If `arr[left] + arr[right] == target`, return the result.
4. If no such pair is found, return `"NO"` or `{-1, -1}`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Variant 1: Check if two numbers sum to target using two-pointer approach
    string twoSumExists(vector<int> arr, int target) {
        int n = arr.size();
        // Create a vector of pairs to remember original indices after sorting
        vector<pair<int, int>> numsWithIndex;
        for (int i = 0; i < n; i++) {
            numsWithIndex.push_back({arr[i], i});
        }
        // Sort based on the element values
        sort(numsWithIndex.begin(), numsWithIndex.end());

        int left = 0, right = n - 1;
        // Loop until pointers cross
        while (left < right) {
            int sum = numsWithIndex[left].first + numsWithIndex[right].first;
            if (sum == target) {
                return "YES";  // Pair found
            } else if (sum < target) {
                left++;  // Need bigger sum, move left pointer right
            } else {
                right--; // Need smaller sum, move right pointer left
            }
        }
        return "NO";  // No pair found
    }

    // Variant 2: Return original indices of two numbers that sum to target
    vector<int> twoSumIndices(vector<int> arr, int target) {
        int n = arr.size();
        vector<pair<int, int>> numsWithIndex;
        for (int i = 0; i < n; i++) {
            numsWithIndex.push_back({arr[i], i});
        }
        sort(numsWithIndex.begin(), numsWithIndex.end());

        int left = 0, right = n - 1;
        while (left < right) {
            int sum = numsWithIndex[left].first + numsWithIndex[right].first;
            if (sum == target) {
                // Return original indices
                return {numsWithIndex[left].second, numsWithIndex[right].second};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        return {-1, -1};  // No pair found
    }
};

int main() {
    Solution sol;
    vector<int> arr = {2, 6, 5, 8, 11};
    int target = 14;

    cout << sol.twoSumExists(arr, target) << "\n";
    vector<int> res = sol.twoSumIndices(arr, target);
    cout << "[" << res[0] << ", " << res[1] << "]\n";

    return 0;
}
```

### Complexity Analysis

* **Time Complexity:** $O(N \log N)$  
  Due to sorting the array initially, where $N$ is the number of elements.  
  The two-pointer traversal afterward runs in $O(N)$.

* **Space Complexity:** $O(N)$  
  Because we store the array elements along with their original indices in a separate vector for sorting, to maintain original positions.
