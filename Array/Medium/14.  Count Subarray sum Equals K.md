# Count Subarray Sum Equals K

**Problem Statement:**  
Given an array of integers and an integer `k`, return the total number of subarrays whose sum equals `k`.  
A subarray is a contiguous non-empty sequence of elements within an array.

---

## Examples

**Example 1:**

**Input:**  
`N = 4, array[] = {3, 1, 2, 4}, k = 6`

**Output:**  
`2`

**Explanation:**  
The subarrays that sum up to 6 are:  
- `[3, 1, 2]`
- `[2, 4]`

---

**Example 2:**

**Input:**  
`N = 3, array[] = {1, 2, 3}, k = 3`

**Output:**  
`2`

**Explanation:**  
The subarrays that sum up to 3 are:  
- `[1, 2]`
- `[3]`

---

## Brute Force Approach

### Algorithm

We will check the sum of **every possible subarray** and count how many of them are equal to `k`.

To get every possible subarray sum, we will be using **three nested loops**:

1. The first loop (`i`) will iterate over every possible **starting index** of the subarray.  
   Possible `i` range: `0` to `n-1` (where `n` is the size of the array).
2. The second loop (`j`) will iterate over every possible **ending index** for the subarray starting at `i`.  
   Possible `j` range: `i` to `n-1`.
3. For each subarray `arr[i...j]`, the third loop (`m`) will compute the **sum** of elements from index `i` to `j`.
4. If this sum equals `k`, we increment our `count`.

> Note: This approach explicitly enumerates all possible subarrays and recomputes the sum for each using an inner loop.

---

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find count of subarrays with sum equal to k
    int subarraySum(vector<int>& arr, int k) {
        // Size of the array
        int n = arr.size();

        // Initialize count of subarrays
        int count = 0;

        // Traverse all possible start indices
        for (int i = 0; i < n; i++) {
            // Traverse all possible end indices from start
            for (int j = i; j < n; j++) {
                // Initialize sum for current subarray
                int sum = 0;

                // Calculate sum of subarray from i to j
                for (int m = i; m <= j; m++) {
                    sum += arr[m];
                }

                // If sum equals k, increment count
                if (sum == k) {
                    count++;
                }
            }
        }

        // Return total count of subarrays
        return count;
    }
};

int main() {
    // Input array
    vector<int> arr = {3, 1, 2, 4};

    // Target sum
    int k = 6;

    // Create Solution object
    Solution sol;

    // Call function and store result
    int result = sol.subarraySum(arr, k);

    // Print the count of subarrays
    cout << "The number of subarrays is: " << result << "\n";

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N^3)$  
  Where $N$ is the size of the array. We are using three nested loops here. Though all are not running for exactly $N$ times, the overall time complexity is approximately $O(N^3)$.

* **Space Complexity:** $O(1)$  
  As we are not using any extra space besides a few variables.

---

## Better Approach: Two Loops with Running Sum

**Algorithm**

If we carefully observe, we can notice that to get the sum of the current subarray we just need to add the current element `arr[j]` to the sum of the **previous** subarray `arr[i…j-1]`.

Let:

- Previous subarray = `arr[i…j-1]`
- Current subarray  = `arr[i…j]`

Then:

\[
\text{sum of } arr[i…j] = (\text{sum of } arr[i…j-1]) + arr[j]
\]

So we can **remove the third loop** and, while moving the `j` pointer, we can maintain a running sum.

Steps:

1. Run a loop `i` from `0` to `n-1` to choose every possible **starting index** of the subarray.
2. For each `i`, initialize `sum = 0`.
3. Run another loop `j` from `i` to `n-1`:
   - Add the current element to the running sum: `sum += arr[j]`
   - If `sum == k`, increment the `count` of valid subarrays.
4. After finishing both loops, return `count`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find count of subarrays with sum equal to k
    int subarraySum(vector<int>& arr, int k) {
        // Size of the array
        int n = arr.size();

        // Initialize count of subarrays
        int count = 0;

        // Traverse all possible start indices
        for (int i = 0; i < n; i++) {
            // Initialize sum for current subarray
            int sum = 0;

            // Traverse all possible end indices from start
            for (int j = i; j < n; j++) {
                // Add current element to sum
                sum += arr[j];

                // If sum equals k, increment count
                if (sum == k) {
                    count++;
                }
            }
        }

        // Return total count of subarrays
        return count;
    }
};

int main() {
    // Input array
    vector<int> arr = {3, 1, 2, 4};

    // Target sum
    int k = 6;

    // Create Solution object
    Solution sol;

    // Call function and store result
    int result = sol.subarraySum(arr, k);

    // Print the count of subarrays
    cout << "The number of subarrays is: " << result << "\n";

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(n^2)$  
  We use two nested loops to check all possible subarrays, where $n$ is the size of the array.

* **Space Complexity:** $O(1)$  
  Only a few extra variables are used, so the extra space is constant regardless of input size.

---

## Optimal Approach: Prefix Sum + HashMap

**Algorithm / Intuition**

We use the concept of **prefix sum** to efficiently count subarrays whose sum is `k`.

- Let the prefix sum up to index `i` be `x` (i.e., sum of `arr[0..i]`).
- We want a subarray ending at `i` whose sum is `k`.
- Suppose there is some index `j` (where `0 ≤ j ≤ i`) such that the sum of `arr[j..i] = k`.

Then:

\[
\text{sum}(arr[j..i]) = \text{prefixSum}(i) - \text{prefixSum}(j-1) = k
\]

Rearranging:

\[
\text{prefixSum}(j-1) = \text{prefixSum}(i) - k
\]

So for each `prefixSum = x` at index `i`, we just need to know how many times we've seen prefix sums equal to `x - k` **before**. Each such occurrence corresponds to a subarray ending at `i` whose sum is `k`.

Instead of searching all subarrays, we:

- Maintain a hashmap (`prefixSumCount`) where:
  - **key** = prefix sum value
  - **value** = how many times this prefix sum has occurred so far
- For each index `i`, with current prefix sum `prefixSum`:
  - The number of subarrays ending at `i` with sum `k` is exactly `prefixSumCount[prefixSum - k]`.

We accumulate this count for all `i`.

**Why initialize `prefixSumCount[0] = 1`?**

Consider example: `arr = [3, -3, 1, 1, 1]`, `k = 3`.

- At index `0`, prefix sum = `3`.
- We want subarray sums of `k = 3`, so we look for `prefixSum - k = 3 - 3 = 0`.
- If `prefixSumCount[0]` was not initialized to `1`, we would get `0` occurrences and miss the subarray `[3]` (from index `0` itself).
- Setting `prefixSumCount[0] = 1` accounts for subarrays that **start at index 0**.

**Steps:**

1. Declare an `unordered_map<int,int> prefixSumCount` to store prefix sums and their frequencies.
2. Set `prefixSumCount[0] = 1` (base case).
3. Initialize:
   - `prefixSum = 0`
   - `count = 0`
4. Loop `i` from `0` to `n-1`:
   - Add current element to prefix sum: `prefixSum += arr[i]`
   - Compute `remove = prefixSum - k`
   - If `remove` exists in the map, add its frequency to `count`
   - Increment `prefixSumCount[prefixSum]`
5. Return `count`.

---

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find count of subarrays with sum equal to k using prefix sums and hashmap
    int subarraySum(vector<int>& arr, int k) {
        // Size of the array
        int n = arr.size();

        // Map to store frequency of prefix sums
        unordered_map<int, int> prefixSumCount;

        // Initialize prefix sum and count of subarrays
        int prefixSum = 0;
        int count = 0;

        // Base case: prefix sum 0 has occurred once
        prefixSumCount[0] = 1;

        // Traverse through the array
        for (int i = 0; i < n; i++) {
            // Add current element to prefix sum
            prefixSum += arr[i];

            // Calculate the prefix sum that needs to be removed
            int remove = prefixSum - k;

            // If this prefix sum has been seen before,
            // add its count to the result
            if (prefixSumCount.find(remove) != prefixSumCount.end()) {
                count += prefixSumCount[remove];
            }

            // Update the frequency of the current prefix sum
            prefixSumCount[prefixSum]++;
        }

        // Return the total count of subarrays
        return count;
    }
};

int main() {
    // Input array
    vector<int> arr = {3, 1, 2, 4};

    // Target sum
    int k = 6;

    // Create Solution object
    Solution sol;

    // Call function and store result
    int result = sol.subarraySum(arr, k);

    // Print the count of subarrays
    cout << "The number of subarrays is: " << result << "\n";

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(n)$  
  We traverse the array once, where $n$ is the size of the array. Each prefix sum update and hashmap lookup/insert is $O(1)$ on average.

* **Space Complexity:** $O(n)$  
  In the worst case, all prefix sums are distinct and stored in the hashmap, so the space used by the map grows linearly with the input size.
