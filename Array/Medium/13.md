# Spiral Traversal of Matrix

**Problem Statement:**  
Given a matrix, print the given matrix in spiral order.

---

## Examples

**Example 1:**

**Input:**  
`Matrix = { { 1, 2, 3, 4 },{ 5, 6, 7, 8 },{ 9, 10, 11, 12 },{ 13, 14, 15, 16 } }`  

**Output:**  
`1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10`  

**Explanation:**  
The output is the elements of the matrix printed in spiral form.

---

**Example 2:**

**Input:**  
`Matrix = { { 1, 2, 3 }, { 4, 5, 6 },{ 7, 8, 9 } }`  

**Output:**  
`1 2 3 6 9 8 7 4 5`  

**Explanation:**  
The output is the elements of the matrix printed in spiral form.

---

## Approach

### Algorithm (Boundary-based Spiral Traversal)

We maintain four boundaries to simulate the spiral traversal:

- `top` → index of the current top row.
- `bottom` → index of the current bottom row.
- `left` → index of the current left column.
- `right` → index of the current right column.

We then traverse in four directions in this order:

1. **Left to Right** across the top row.
2. **Top to Bottom** down the right column.
3. **Right to Left** across the bottom row (if `top <= bottom`).
4. **Bottom to Top** up the left column (if `left <= right`).

After each directional traversal, we move the corresponding boundary inward:

- After traversing the top row, increment `top`.
- After traversing the right column, decrement `right`.
- After traversing the bottom row, decrement `bottom`.
- After traversing the left column, increment `left`.

We repeat this process while `top <= bottom` and `left <= right`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to return matrix in spiral order
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        // Vector to store final spiral order result
        vector<int> result;

        // Get number of rows and columns
        int top = 0;
        int bottom = matrix.size() - 1;
        int left = 0;
        int right = matrix[0].size() - 1;

        // Traverse the matrix in spiral order
        while(top <= bottom && left <= right) {

            // Traverse from left to right across the top row
            for(int i = left; i <= right; i++) {
                result.push_back(matrix[top][i]);
            }
            top++; // Move top boundary down

            // Traverse from top to bottom on the right column
            for(int i = top; i <= bottom; i++) {
                result.push_back(matrix[i][right]);
            }
            right--; // Move right boundary left

            // Check if there are rows remaining
            if(top <= bottom) {
                // Traverse from right to left on the bottom row
                for(int i = right; i >= left; i--) {
                    result.push_back(matrix[bottom][i]);
                }
                bottom--; // Move bottom boundary up
            }

            // Check if there are columns remaining
            if(left <= right) {
                // Traverse from bottom to top on the left column
                for(int i = bottom; i >= top; i--) {
                    result.push_back(matrix[i][left]);
                }
                left++; // Move left boundary right
            }
        }

        // Return the final spiral order
        return result;
    }
};

// Driver code
int main() {
    Solution obj;

    vector<vector<int>> matrix = {
        { 1, 2, 3, 4 },
        { 5, 6, 7, 8 },
        { 9, 10, 11, 12 },
        { 13, 14, 15, 16 }
    };

    vector<int> result = obj.spiralOrder(matrix);

    for(int val : result) {
        cout << val << " ";
    }

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(m \times n)$  
  Because we visit each element of the matrix exactly once, where $m$ is the number of rows and $n$ is the number of columns.

* **Space Complexity:** $O(1)$  
  We use only a few integer variables to keep track of boundaries (`top`, `bottom`, `left`, `right`).  
  The `result` vector is part of the required output, so it is not counted as extra space.
