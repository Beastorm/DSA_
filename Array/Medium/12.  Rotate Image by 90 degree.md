# Rotate Image by 90 degree

**Problem Statement:**  
Given an `N x N` 2D integer matrix, rotate the matrix by **90 degrees clockwise**.  
The rotation must be done in place (for the optimal approach), but here we first show a brute force approach using extra space.

---

## Example

**Input:**  
`matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]`

**Output:**  
`matrix = [[7, 4, 1], [8, 5, 2], [9, 6, 3]]`

---

## Brute Force Approach

### Algorithm

In a 90-degree clockwise rotation, each element in the matrix moves from its original position to a new position based on a specific pattern:

- The **first column** becomes the **first row** (in reverse order).
- The **second column** becomes the **second row**, and so on.

We can simulate this movement by using a **new matrix**.

For each element at position `(i, j)` in the original matrix, we calculate its new position in the rotated matrix as:

\[
(i, j) \rightarrow (j, n - i - 1)
\]

Where `n` is the size of the matrix.

**Steps:**

1. Initialize a new matrix `rotated` of the same size `n x n`.
2. Loop through every element of the original matrix using two nested loops.
3. For each element at position `(i, j)`, place it in `rotated[j][n - i - 1]`.
4. After completing the placement for all elements, return the `rotated` matrix (or copy it back to the original if needed).

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to rotate the matrix 90 degrees clockwise using extra space
    vector<vector<int>> rotateClockwise(vector<vector<int>>& matrix) {
        // Get the size of the square matrix
        int n = matrix.size();

        // Create a new matrix of same size to store rotated result
        vector<vector<int>> rotated(n, vector<int>(n));

        // Traverse each element of original matrix
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                // Place the element at its new rotated position
                rotated[j][n - i - 1] = matrix[i][j];
            }
        }

        // Return the rotated matrix
        return rotated;
    }
};

// Driver code
int main() {
    vector<vector<int>> mat = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    Solution obj;
    vector<vector<int>> rotated = obj.rotateClockwise(mat);

    // Print the rotated matrix
    for (auto row : rotated) {
        for (int val : row) cout << val << " ";
        cout << endl;
    }

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N^2)$  
  Each element of the matrix is visited exactly once and placed into a new matrix, so the time taken is proportional to the total number of elements.

* **Space Complexity:** $O(N^2)$  
  We use an additional matrix of the same size to store the rotated result, leading to $O(N^2)$ extra space.

---

### Optimal Approach: In-place Rotation using Transpose + Reverse

**Algorithm**

To rotate a matrix 90 degrees clockwise **in-place** (without using extra space), we use two key operations:

1. **Transpose the matrix**  
   Swap elements across the main diagonal (i.e., convert rows to columns).  
   Element at position `(i, j)` moves to `(j, i)`.

2. **Reverse each row**  
   After transposing, reverse every row of the matrix.  
   This finalizes the 90-degree clockwise rotation.

**Why this works:**

- Transposing the matrix reflects it over its top-left to bottom-right diagonal.
- Reversing each row then rearranges the columns into their correct rotated positions.

**Steps:**

1. Get the size `n` of the square matrix (`n x n`).
2. **Transpose phase:**
   - For each `i` from `0` to `n-1`:
     - For each `j` from `i+1` to `n-1`:
       - Swap `matrix[i][j]` with `matrix[j][i]`.
3. **Reverse phase:**
   - For each row `i` from `0` to `n-1`:
     - Reverse `matrix[i]`.
4. The matrix is now rotated 90 degrees clockwise in-place.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to rotate matrix 90 degrees clockwise in-place
    void rotateClockwise(vector<vector<int>>& matrix) {
        int n = matrix.size();

        // Step 1: Transpose the matrix
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                // Swap element at (i, j) with (j, i) to transpose
                swap(matrix[i][j], matrix[j][i]);
            }
        }

        // Step 2: Reverse each row
        for (int i = 0; i < n; ++i) {
            // Reverse the current row to complete clockwise rotation
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};

// Driver code
int main() {
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    Solution obj;
    obj.rotateClockwise(matrix);

    // Print rotated matrix
    for (auto row : matrix) {
        for (int val : row) {
            cout << val << " ";
        }
        cout << endl;
    }

    return 0;
}
```

### Complexity Analysis

* **Time Complexity:** $O(N^2)$  
  We traverse every element once during transposition and again during reversal of each row, resulting in a total of $O(N^2)$ time.

* **Space Complexity:** $O(1)$  
  All operations are done in-place using only temporary variables. No extra matrix is used.
