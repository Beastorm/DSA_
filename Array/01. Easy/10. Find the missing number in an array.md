# Find the missing number in an array

**Problem Statement:**  
Given an integer `N` and an array of size `N-1` containing `N-1` numbers between 1 to `N`. Find the number(between 1 to `N`), that is not present in the given array.

### Examples

**Example 1:**  
**Input Format:** `N = 5, array[] = {1, 2, 4, 5}`  
**Result:** `3`  
**Explanation:** In the given array, number 3 is missing. So, 3 is the answer.

**Example 2:**  
**Input Format:** `N = 3, array[] = {1, 3}`  
**Result:** `2`  
**Explanation:** In the given array, number 2 is missing. So, 2 is the answer.

---

### Algorithm: Brute Force Approach

For each number between 1 to `N`, we will try to find it in the given array using linear search. If we donâ€™t find any of them, we will return the number.

1.  We will run a loop from 1 to `N`.
2.  For each integer, we will try to find it in the given array using linear search.
3.  For that, we will run another loop to iterate over the array and consider a `flag` variable to indicate if the element exists in the array.
    *   `Flag = 1` means the element is present.
    *   `Flag = 0` means the element is missing.
4.  Initially, the flag value will be set to 0. While iterating the array, if we find the element, we will set the flag to 1 and break out from the loop.
5.  Now, for any number `i`, if we cannot find it, the flag will remain 0 even after iterating the whole array, and we will return the number.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the missing number in the array
    int missingNumber(vector<int>& a, int N) {
        // Loop through numbers from 1 to N
        for (int i = 1; i <= N; i++) {
            int flag = 0; // To check if i exists in the array

            // Linear search to check if i is in the array
            for (int j = 0; j < N - 1; j++) {
                if (a[j] == i) {
                    flag = 1; // i is found
                    break;
                }
            }

            // If i was not found, it is the missing number
            if (flag == 0) return i;
        }

        // Control should never reach here
        return -1;
    }
};

int main() {
    int N = 5;
    vector<int> a = {1, 2, 4, 5};

    Solution obj;
    int ans = obj.missingNumber(a, N);
    cout << "The missing number is: " << ans << endl;

    return 0;
}
```
### Complexity Analysis

*   **Time Complexity:** $O(N \times N)$
    Since nested for loops are used.

*   **Space Complexity:** $O(1)$
    No extra space used.

---

### Optimized Approach 1: Summation Method

**Algorithm**

**Intuition:**
We know that the summation of the first $N$ numbers is $\frac{N \times (N+1)}{2}$. We can say this is $S1$. Now, in the given array, every number between 1 to $N$ except one number is present. So, if we add the numbers of the array (say $S2$), the difference between $S1$ and $S2$ will be the missing number. Because, while adding all the numbers of the array, we did not add that particular number that is missing.

**Approach:**
1.  We will first calculate the summation of first $N$ natural numbers (i.e. 1 to $N$) using the specified formula.
2.  Then we will add all the array elements using a loop.
3.  Finally, we will consider the difference between the summation of the first $N$ natural numbers and the sum of the array elements.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the missing number using the sum formula
    int missingNumber(vector<int>& a, int N) {
        // Sum of first N natural numbers using formula: N*(N+1)/2
        int sum = (N * (N + 1)) / 2;

        // Sum of elements present in the array
        int s2 = 0;
        for (int i = 0; i < N - 1; i++) {
            s2 += a[i];
        }

        // The missing number is the difference between the expected and actual sum
        return sum - s2;
    }
};

int main() {
    int N = 5;
    vector<int> a = {1, 2, 4, 5};

    Solution obj;
    int ans = obj.missingNumber(a, N);
    cout << "The missing number is: " << ans << endl;

    return 0;
}
```
### Complexity Analysis

*   **Time Complexity:** $O(N)$
    A single loop is used to iterate through the array to calculate the sum.

*   **Space Complexity:** $O(1)$
    We are only using a constant amount of extra space (variables `sum`, `s2`, and `i`) regardless of the input size.

---

### Optimized Approach 2: XOR Method

**Algorithm**

**Intuition:**
Two important properties of XOR are the following:
1.  XOR of two same numbers is always 0, i.e., $a \oplus a = 0$.
2.  XOR of a number with 0 will result in the number itself, i.e., $0 \oplus a = a$.

**Approach:**
1.  We will first run a loop, from 0 to `size-2` (as the length of the array = `size-1`).
2.  Inside the loop, the `xor2` variable will calculate the XOR of array elements, i.e., `xor2 = xor2 ^ a[i]`.
3.  And the `xor1` variable will calculate the XOR of 1 to `N-1` i.e. `xor1 = xor1 ^ (i+1)`.
4.  After the loop ends, we will XOR `xor1` and `N` to get the total XOR of 1 to `N`.
5.  Finally, the answer will be the XOR of `xor1` and `xor2`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the missing number using the XOR approach
    int missingNumber(vector<int>& a, int N) {
        int xor1 = 0, xor2 = 0;

        // XOR all the array elements and numbers from 1 to N-1
        for (int i = 0; i < N - 1; i++) {
            xor2 = xor2 ^ a[i];      // XOR of array elements
            xor1 = xor1 ^ (i + 1);   // XOR of numbers from 1 to N-1
        }

        xor1 = xor1 ^ N; // Include N in the XOR

        // XOR of xor1 and xor2 gives the missing number
        return xor1 ^ xor2;
    }
};

int main() {
    int N = 5;
    vector<int> a = {1, 2, 4, 5};

    Solution obj;
    int ans = obj.missingNumber(a, N);
    cout << "The missing number is: " << ans << endl;

    return 0;
}
```

### Complexity Analysis

*   **Time Complexity:** $O(N)$
    For loop is used.

*   **Space Complexity:** $O(1)$
    No extra space used.
