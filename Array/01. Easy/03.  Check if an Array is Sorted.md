# Check if an Array is Sorted

**Problem Statement:**  
Given an array of size `n`, write a program to check if the given array is sorted in (ascending/increasing / non-decreasing) order or not.  
If the array is sorted, then return `True`, else return `False`.

>### Examples:

### Example 1:  
**Input:** `N = 5, array[] = {1, 2, 3, 4, 5}`  
**Output:** `True`  
**Explanation:** The given array is sorted, i.e., every element in the array is smaller than or equal to its next value. So the answer is `True`.

---

### Example 2:
**Input:** `N = 5, array[] = {5, 4, 6, 7, 8}`  
**Output:** `False`  
**Explanation:** The given array is not sorted, i.e., every element in the array is not smaller than or equal to its next value.  
Here, element `5` is not smaller than or equal to its future elements.

---

## Brute Force Approach

### Algorithm:

1. Start with the element at index `0` and compare it with all of its future elements in the array.
2. If the picked element is smaller than or equal to all of its future values, move to the next index/element.
3. If any picked element is greater than one of its future elements, return `False`.
4. If the size of the array is `0` or `1` (i.e., `N = 0` or `N = 1`) or the entire array is traversed successfully, return `True`.


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Function to check if the array is sorted
bool isSorted(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            // If any element is smaller than the previous one, return false
            if (arr[j] < arr[i]) 
                return false;
        }
    }

    return true; // Return true if no unsorted elements are found
}

int main() {
    int arr[] = {1, 2, 3, 4, 5}, n = 5;
    bool ans = isSorted(arr, n);
    
    // Output result
    if (ans) cout << "True" << endl;
    else cout << "False" << endl;
    
    return 0;
}
```

### Complexity Analysis:

* **Time Complexity:** $O(N^2)$  
  As it uses two nested loops to compare every pair of elements in the array.

* **Space Complexity:** $O(1)$  
  As no extra space is used apart from a few variables.

---

### Optimal Approach

### Algorithm:

- For a sorted array, every previous element is smaller than or equal to its current element.  
- So, if for all `i` from `1` to `n-1`, `arr[i-1] <= arr[i]` holds, then the array is sorted.
- We will:
  1. Traverse the array from index `1` to `n-1`.
  2. For each index `i`, check if `arr[i] < arr[i-1]`.
     - If this condition is true for any `i`, the array is not sorted â†’ return `False`.
  3. If the whole array is traversed without violation (or if `N = 0` or `N = 1`), return `True`.


### C++ Code:
```cpp
#include<bits/stdc++.h>
using namespace std;

// Function to check if the array is sorted
bool isSorted(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        // If any element is smaller than the previous one, return false
        if (arr[i] < arr[i - 1])
            return false;
    }

    // Return true if the array is sorted
    return true;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5}, n = 5;
    printf("%s", isSorted(arr, n) ? "True" : "False");  // Output result
}
```
### Complexity Analysis:

* **Time Complexity:** $O(N)$  
  As it checks each adjacent pair once in a single pass through the array.

* **Space Complexity:** $O(1)$  
  As it uses constant extra space regardless of input size.
