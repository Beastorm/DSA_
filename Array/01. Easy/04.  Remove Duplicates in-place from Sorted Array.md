## Remove Duplicates in-place from Sorted Array

**Problem Statement:**  
Given an integer array sorted in non-decreasing order, remove the duplicates in place such that each unique element appears only once. The relative order of the elements should be kept the same.

If there are `k` elements after removing the duplicates, then the first `k` elements of the array should hold the final result. It does not matter what you leave beyond the first `k` elements.

>### Examples:


### Example 1:
**Input:** `arr = [1,1,2,2,2,3,3]`  
**Output:** `[1,2,3,_,_,_,_]`  
**Explanation:** Total number of unique elements is 3, i.e. `[1,2,3]`. Therefore, return `3` after assigning `[1,2,3]` in the beginning of the array.

---

### Example 2:
**Input:** `arr = [1,1,1,2,2,3,3,3,3,4,4]`  
**Output:** `[1,2,3,4,_,_,_,_,_,_,_]`  
**Explanation:** Total number of unique elements is 4, i.e. `[1,2,3,4]`. Therefore, return `4` after assigning `[1,2,3,4]` in the beginning of the array.

---

## Brute Force Approach

### Algorithm:

Since we need to store only unique elements, we can use a **set-like** data structure:

1. Insert all elements of the array into a set/hash set – duplicates will be automatically ignored.
2. The number of unique elements in the array is equal to the size of the set.
3. Traverse the set and fill the first `k` indices of the array with the unique elements.


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class containing the removeDuplicates method
class Solution {
public:
    // Removes duplicates using unordered_set and returns count of unique elements
    int removeDuplicates(vector<int>& nums) {
        // Unordered set to store elements we have already seen
        unordered_set<int> seen;

        // Index where the next unique element will be written
        int index = 0;

        // Loop over each element in the array
        for (int num : nums) {
            // If num is not in seen, it's unique
            if (seen.find(num) == seen.end()) {
                // Add this num to the set of seen numbers
                seen.insert(num);

                // Overwrite nums[index] with this unique num
                nums[index] = num;

                // Move index forward
                index++;
            }
        }
        // Return count of unique elements
        return index;
    }
};

int main() {
    vector<int> nums = {0,0,1,1,1,2,2,3,3,4};

    Solution sol;
    int k = sol.removeDuplicates(nums);

    cout << "k = " << k << "\nArray after removing duplicates: ";
    for (int i = 0; i < k; i++) {
        cout << nums[i] << " ";
    }
    cout << endl;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(N)$  
  We traverse the entire array and insert elements into the set.

* **Space Complexity:** $O(N)$  
  Additional space is used to store elements in the set.

---

### Optimal Approach: Two Pointers (In-place)

### Algorithm:

Instead of using a set to store the unique elements, we can implement a **two-pointer strategy** to optimize space. Since the array is sorted, all duplicate values will be adjacent to each other.

1. Begin at the first position, which will always be part of the final unique list.
2. Use two pointers:
   - `i` for the position of the last kept unique element.
   - `j` to scan through the array from left to right.
3. For each `nums[j]`:
   - If `nums[j]` is the same as `nums[i]`, skip it because it’s a duplicate.
   - If it’s different, increment `i` and set `nums[i] = nums[j]` to place the new unique element.
4. After the loop ends, the first `i + 1` elements of `nums` will be the unique elements in original order.
5. Return `i + 1` as the count of unique elements.


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Class to hold the solution logic
class Solution {
public:
    // Function to remove duplicates from a sorted array in-place
    int removeDuplicates(vector<int>& nums) {
        // If the array is empty, return 0 directly
        if (nums.empty()) return 0;

        // Pointer for the position of the last unique element
        int i = 0;

        // Traverse the array starting from the second element
        for (int j = 1; j < nums.size(); j++) {
            // If the current element is different from the last unique element
            if (nums[j] != nums[i]) {
                // Move pointer for unique element forward
                i++;
                // Place the new unique element at the next position
                nums[i] = nums[j];
            }
        }

        // i is the index of the last unique element, count = i + 1
        return i + 1;
    }
};

int main() {
    vector<int> nums = {0,0,1,1,1,2,2,3,3,4};

    Solution sol;
    int k = sol.removeDuplicates(nums);

    cout << "Unique count = " << k << "\n";
    cout << "Array after removing duplicates: ";
    for (int x = 0; x < k; x++) {
        cout << nums[x] << " ";
    }
    cout << endl;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(N)$  
  We traverse the entire original array only once.

* **Space Complexity:** $O(1)$  
  Constant additional space is used to track unique elements.
