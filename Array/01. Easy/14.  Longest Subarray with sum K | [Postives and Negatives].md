# Longest Subarray with sum K | [Positives and Negatives]

**Problem Statement:**  
Given an array and a sum `k`, we need to print the length of the longest subarray that sums to `k`.

### Examples

**Example 1:**  
**Input Format:** `N = 3, k = 5, array[] = {2, 3, 5}`  
**Result:** `2`  
**Explanation:** The longest subarray with sum 5 is `{2, 3}`. And its length is 2.

**Example 2:**  
**Input Format:** `N = 3, k = 1, array[] = {-1, 1, 1}`  
**Result:** `3`  
**Explanation:** The longest subarray with sum 1 is `{-1, 1, 1}`. And its length is 3.

---

## Brute Force

### Algorithm

**Intuition**  
We will check the sum of every possible subarray and consider the one with the sum `k` and the maximum length among them. To get every possible subarray sum, we will be using three nested loops. The first loops (say `i` and `j`) will iterate over every possible starting index and ending index of a subarray. Basically, in each iteration, the subarray range will be from index `i` to index `j`. Using another loop, we will get the sum of the elements of the subarray `[i…..j]`. Among all the subarrays with sum `k`, we will consider the one with the maximum length.

**Approach**

1. First, go through each position in the list as the starting point of a group of numbers.
2. For each starting point, go through every possible ending point that comes after or at the same position.
3. For each group formed by the starting and ending positions, add up all the numbers in that group.
4. If the total matches the target value, check how many numbers are in the group and keep track of the largest size found.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Class to handle subarray-related operations
class SubarraySolver {
public:
    // Method to find the length of the longest subarray with sum equal to k
    int getLongestSubarray(vector<int>& a, int k) {
        int n = a.size(); // Get the size of the input array
        int len = 0;      // Variable to store the maximum length found

        // Loop to choose the starting index of the subarray
        for (int i = 0; i < n; i++) {
            // Loop to choose the ending index of the subarray
            for (int j = i; j < n; j++) {
                int sum = 0; // Store sum of current subarray

                // Loop to calculate the sum of the subarray from i to j
                for (int idx = i; idx <= j; idx++) {
                    sum += a[idx];
                }

                // If subarray sum matches target, update maximum length
                if (sum == k) {
                    len = max(len, j - i + 1);
                }
            }
        }
        return len; // Return the longest length found
    }
};

int main() {
    vector<int> a = { -1, 1, 1 };
    int k = 1;

    SubarraySolver solver;
    int len = solver.getLongestSubarray(a, k);

    cout << "The length of the longest subarray is: " << len << "\n";
    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N^3)$ (approximately), where $N$ is the size of the array.

* **Space Complexity:** $O(1)$  
  As we are not using any extra space.

---

### Better Approach

**Algorithm**

1. First, go through each position in the list to choose a starting point for a group of numbers.
2. For each starting point, go through every position after it to select the current number and extend the group.
3. As you move through the list, keep adding each number to the total of the current group.
4. If the total becomes equal to the desired value, check how many numbers are in the group and keep track of the largest group that meets the condition.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Class to encapsulate the subarray logic
class SubarraySolver {
public:
    // Method to find the longest subarray with sum equal to k
    int getLongestSubarray(vector<int>& a, int k) {
        int n = a.size(); // Total number of elements
        int len = 0;      // Variable to store the max length found

        // Outer loop: pick every possible starting index
        for (int i = 0; i < n; i++) {
            int s = 0; // Reset sum for each new starting index

            // Inner loop: extend the subarray from the current start
            for (int j = i; j < n; j++) {
                s += a[j]; // Add current element to the ongoing sum

                // If the current sum equals the target, update the max length
                if (s == k) {
                    len = max(len, j - i + 1);
                }
            }
        }
        return len; // Return the maximum length found
    }
};

int main() {
    vector<int> a = { -1, 1, 1 };
    int k = 1;
    SubarraySolver solver;
    int len = solver.getLongestSubarray(a, k);

    cout << "The length of the longest subarray is: " << len << "\n";
    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N^2)$ (approximately), where $N$ is the size of the array.

* **Space Complexity:** $O(1)$  
  As we are not using any extra space.

---

### Optimal Approach: Prefix Sum + Hash Map

**Algorithm**

First, we use the concept of prefix sum and a map to efficiently track subarrays with sum `k`.

1. Declare a map to store prefix sums and their earliest indices.
2. Run a loop `i` from index `0` to `n-1` (where `n` is the size of the array).
3. For each index `i`:
   - Add the current element `a[i]` to the running prefix sum `sum`.
   - If `sum == k`, then the subarray from `0` to `i` is a candidate; its length is `i + 1`. Update the maximum length.
   - Compute `rem = sum - k`.  
     If `rem` exists in the map, it means there is a subarray ending at `i` with sum `k`. Its length is `i - preSumMap[rem]`. Update the maximum length.
   - If `sum` is not already in the map, store `sum` with index `i`.  
     We only store the first occurrence to maximize the subarray length.

In this approach, we are using the concept of the prefix sum to solve this problem. Here, the prefix sum of a subarray ending at index `i` simply means the sum of all the elements from index `0` to `i`.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Class to encapsulate subarray logic
class SubarraySolver {
public:
    // Function to get the length of the longest subarray with sum equal to k
    int getLongestSubarray(vector<int>& a, int k) {
        int n = a.size();
        map<int, int> preSumMap; // prefixSum -> earliest index
        int sum = 0;
        int maxLen = 0;

        for (int i = 0; i < n; i++) {
            sum += a[i]; // compute running prefix sum

            // Case 1: If the entire sum from 0 to i is equal to k
            if (sum == k) {
                maxLen = max(maxLen, i + 1);
            }

            // Case 2: If (sum - k) is seen before, a valid subarray exists
            int rem = sum - k;
            if (preSumMap.find(rem) != preSumMap.end()) {
                int len = i - preSumMap[rem];
                maxLen = max(maxLen, len);
            }

            // Only store the first occurrence of each prefix sum
            if (preSumMap.find(sum) == preSumMap.end()) {
                preSumMap[sum] = i;
            }
        }

        return maxLen;
    }
};

int main() {
    vector<int> a = { -1, 1, 1 };
    int k = 1;

    SubarraySolver solver;
    int len = solver.getLongestSubarray(a, k);

    cout << "The length of the longest subarray is: " << len << "\n";
    return 0;
}
```

### Complexity Analysis

* **Time Complexity:** $O(N)$ or $O(N \log N)$ depending on which map data structure we are using, where $N$ is the size of the array.  
  - Using `unordered_map` → average $O(N)$  
  - Using `map` (balanced BST) → $O(N \log N)$

* **Space Complexity:** $O(N)$  
  As we are using a map to store prefix sums and their indices.

