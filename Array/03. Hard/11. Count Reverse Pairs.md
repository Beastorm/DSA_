## üìù Count Reverse Pairs

**Problem Statement:**  
Given an array of numbers, you need to return the count of reverse pairs.  
Reverse Pairs are those pairs where `i < j` and `arr[i] > 2*arr[j]`.  

### üí° Examples

**Example 1:**
**Input:**  
 `N = 5, array[] = {1,3,2,3,1}`  
**Output:**  
 `2`  
**Explanation:**  
 The pairs are (3, 1) and (3, 1), as from both the pairs, the condition `arr[i] > 2*arr[j]` is satisfied.  

**Example 2:**  
**Input:**  
 `N = 4, array[] = {3,2,1,4}`  
**Output:**  
 `1`  
**Explanation:**  
 There is only 1 pair `(3, 1)` that satisfies the condition `arr[i] > 2*arr[j]`.  

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Inversions detect ANY out-of-order pair                ‚îÇ
‚îÇ  Reverse Pairs detect SIGNIFICANT anomalies             ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  Use Case: Finding drastic drops/changes in data        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
---

## üê¢ Brute Force Approach

### Algorithm / Intuition
The naive approach is pretty straightforward. We will use nested loops to generate all possible pairs. We know index `i` must be smaller than index `j`. So, we will fix `i` at one index at a time through a loop, and with another loop, we will check (the condition `a[i] > 2*a[j]`) the elements from index `i+1` to `N-1` if they can form a pair with `a[i]`.

**Steps:**
1.  First, we will run a loop (say `i`) from 0 to `N-1` to select the `a[i]`.
2.  As index `j` should be greater than index `i`, inside loop `i`, we will run another loop, i.e., `j` from `i+1` to `N-1`, and select the element `a[j]`.
3.  Inside this second loop, we will check if `a[i] > 2*a[j]`, i.e., if `a[i]` and `a[j]` can be a pair. If they satisfy the condition, we will increase the count by 1.
4.  Finally, we will return the count, i.e., the number of such pairs.

```cpp
#include <bits/stdc++.h>
using namespace std;

int countPairs(vector<int>&a, int n) {

    // Count the number of pairs:
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (a[i] > 2 * a[j]) cnt++;
        }
    }
    return cnt;
}

int team(vector <int> & skill, int n) {
    return countPairs(skill, n);
}

int main()
{
    vector<int> a = {4, 1, 2, 3, 1};
    int n = 5;
    int cnt = team(a, n);
    cout << "The number of reverse pairs is: "
         << cnt << endl;
    return 0;
}
```
### üìä Complexity Analysis
- **Time Complexity:** O(N^2). We are using nested loops here, and those two loops roughly run for N times.
- **Space Complexity:** O(1), as we are not using any extra space to solve this problem.

---

## üß† Optimal Approach

### Algorithm / Intuition
In order to solve this problem, we will use the merge sort algorithm as we used in the problem count inversion with a slight modification of the merge() function. But in this case, the same logic will not work. In order to understand this, we need to deep dive into the merge() function.

**Why does the same logic of count inversion not work?**

The merge function works by comparing two elements from two halves, i.e., `arr[left]` and `arr[right]`. Now, the condition in question was `arr[i] > arr[j]`. That is why we merged the logic. While comparing the elements, we counted the number of pairs.
But in this case, the condition is `arr[i] > 2*arr[j]`. And, we cannot change the condition of comparing the elements in the merge() function. If we change the condition, the merge() function will fail to merge the elements. So, we need to check this condition and count the number of pairs separately.

**Approach:**

The steps are basically the same as they are in the case of the merge sort algorithm. The change will be just in the `mergeSort()` function:

1.  To count the number of pairs, we will keep a count variable, `cnt`, initialized to 0 beforehand inside the `mergeSort()`.
2.  We will add the numbers returned by the previous `mergeSort()` calls.
3.  Before the merge step, we will count the number of pairs using a function named `countPairs()`.
4.  We need to remember that the left half starts from `low` and ends at `mid`, and the right half starts from `mid+1` and ends at `high`.

The steps of the `countPairs()` function will be as follows:
1.  We will declare a variable, `cnt`, initialized with 0.
2.  We will run a loop from `low` to `mid`, to select an element at a time from the left half.
3.  Inside that loop, we will use another loop to check how many elements from the right half can make a pair.
4.  Lastly, we will add the total number of elements, i.e., `(right-(mid+1))` (where `right` = current index), to the `cnt` and return it.

```cpp
#include <bits/stdc++.h>
using namespace std;

void merge(vector<int> &arr, int low, int mid, int high) {
    vector<int> temp; // temporary array
    int left = low;      // starting index of left half of arr
    int right = mid + 1;   // starting index of right half of arr

    //storing elements in the temporary array in a sorted manner//
    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {
            temp.push_back(arr[left]);
            left++;
        }
        else {
            temp.push_back(arr[right]);
            right++;
        }
    }

    // if elements on the left half are still left //
    while (left <= mid) {
        temp.push_back(arr[left]);
        left++;
    }

    //  if elements on the right half are still left //
    while (right <= high) {
        temp.push_back(arr[right]);
        right++;
    }

    //transferring all elements from temporary to arr //
    for (int i = low; i <= high; i++) {
        arr[i] = temp[i - low];
    }
}

int countPairs(vector<int> &arr, int low, int mid, int high) {
    int right = mid + 1;
    int cnt = 0;
    for (int i = low; i <= mid; i++) {
        // Use 2.0 or 2LL to prevent integer overflow if elements are large
        while (right <= high && arr[i] > 2LL * arr[right]) right++;
        cnt += (right - (mid + 1));
    }
    return cnt;
}

int mergeSort(vector<int> &arr, int low, int high) {
    int cnt = 0;
    if (low >= high) return cnt;
    int mid = (low + high) / 2 ;
    cnt += mergeSort(arr, low, mid);  // left half
    cnt += mergeSort(arr, mid + 1, high); // right half
    cnt += countPairs(arr, low, mid, high); //Modification
    merge(arr, low, mid, high);  // merging sorted halves
    return cnt;
}

int team(vector <int> & skill, int n)
{
    return mergeSort(skill, 0, n - 1);
}

int main()
{
    vector<int> a = {4, 1, 2, 3, 1};
    int n = 5;
    int cnt = team(a, n);
    cout << "The number of reverse pairs is: "
         << cnt << endl;
    return 0;
}
```
### üìä Complexity Analysis

- **Time Complexity:** $O(2N \log N)$
    - Inside the `mergeSort()` we call `merge()` and `countPairs()` except `mergeSort()` itself. Now, inside the function `countPairs()`, though we are running a nested loop, we are actually iterating the left half once and the right half once in total. That is why the time complexity is $O(N)$. And the `merge()` function also takes $O(N)$. The `mergeSort()` takes $O(\log N)$ time complexity. Therefore, the overall time complexity will be $O(\log N \times (N+N)) = O(2N \log N)$.

- **Space Complexity:** $O(N)$
    - As in the merge sort, we use a temporary array to store elements in sorted order.
