## Length of the longest subarray with zero Sum

**Problem Statement:**  
Given an array containing both positive and negative integers, we have to find the length of the longest subarray with the sum of all elements equal to `0`.

---

>### Examples:

### Example 1:  
**Input:**  `N = 6, array[] = {9, -3, 3, -1, 6, -5}`   
**Result:**  `5`   
**Explanation:**  
 The following subarrays sum to zero:  
- `{-3, 3}`  
- `{-1, 6, -5}`  
- `{-3, 3, -1, 6, -5}`  
The length of the longest subarray with a sum of zero is 5.  

---

### Example 2:
**Input:** `N = 8, array[] = {6, -2, 2, -8, 1, 7, 4, -10}`  
**Result:**  `8`  
**Explanation:**  
 Subarrays with sum zero:  
- `{-2, 2}`  
- `{-8, 1, 7}`  
- `{-2, 2, -8, 1, 7}`  
- `{6, -2, 2, -8, 1, 7, 4, -10}`  
The length of the longest subarray with a sum of zero is 8.  

---

## Brute Force Approach

### Algorithm:
1.  Initialize a variable `max = 0`, which stores the length of the longest subarray with a sum of 0.
2.  Traverse the array from the start and initialize a variable `sum = 0`, which stores the sum of the subarray starting with the current index.
3.  Traverse from the next element of the current index up to the end of the array. Each time, add the element to the sum and check if it is equal to 0.
4.  If `sum = 0`, check if the length of the subarray so far is greater than `max`, and if yes, update `max`.
5.  Continue adding elements and repeat the above step until the outer loop completes traversing all elements.
6.  Finally, return the `max`, which holds the length of the longest subarray with a sum of 0.

>*(Note: The code below implements the nested loop algorithm described above. The code provided in the prompt used a HashMap, which is the Optimal approach, so the code here has been adjusted to match the Brute Force description.)*


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to compute the length of the longest subarray with sum 0
    int solve(vector<int>& a) {
        // store best length found so far
        int maxLen = 0;

        int n = a.size();

        // Traverse the array from the start
        for (int i = 0; i < n; i++) {

            // Initialize sum for subarray starting at i
            int sum = 0;
            
            // Traverse from the current element to the end
            for (int j = i; j < n; j++) {
                // Add current element to sum
                sum += a[j];

                // If sum becomes 0, update maxLen
                if (sum == 0) {
                    maxLen = max(maxLen, j - i + 1);
                }
            }
        }

        // return best length
        return maxLen;
    }
};

int main() {
    // sample input
    vector<int> a = {9, -3, 3, -1, 6, -5};
    
    Solution obj;
    // print result
    cout << obj.solve(a) << endl;
    
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N^2), where `N` is the size of the array. This is because we are using two nested loops to check all possible subarrays.
- **Space Complexity:** O(1), as we are not using any additional data structures that grow with input size. We are only using a few variables to store the maximum length and the current sum.

---

## Optimal Approach

### Algorithm:
1.  Initialize a variable `sum = 0`, which stores the sum of elements traversed so far, and another variable `max = 0`, which stores the length of the longest subarray with sum zero.
2.  Declare a `HashMap<Integer, Integer>` to store the prefix sum of every element as a key and its index as a value.
3.  Traverse the array and add the array element to the `sum`.
4.  If `sum = 0`, update `max` with the maximum value between `max` and `current_index + 1`, as the subarray from the start to the current index has a sum of 0.
5.  If `sum` is not equal to zero, check the HashMap to see if we've encountered this sum before.
6.  If the HashMap contains the sum, this indicates that a subarray with the same sum exists (meaning the sum of elements between the previous index and the current index is 0). Update `max` with `max(max, current_index - map[sum])`.
7.  If the sum is not found in the HashMap, insert `(sum, current_index)` into the HashMap to store the prefix sum until the current index.
8.  After traversing the entire array, the `max` variable will hold the length of the longest subarray with a sum equal to zero. Return `max`.


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// compute length of the longest subarray with sum 0
int maxLen(int A[], int n) {
  // map prefix sum -> first index seen
  unordered_map<int, int> mpp;
  // best length so far
  int maxi = 0;
  // running prefix sum
  int sum = 0;

  // iterate over the array
  for (int i = 0; i < n; i++) {
    // update running sum
    sum += A[i];

    // if sum is zero, subarray [0..i] has zero sum
    if (sum == 0) {
      // update best length
      maxi = i + 1;
    }
    // otherwise check if this sum was seen before
    else {
      // when seen, zero-sum segment between previous index + 1 and i
      if (mpp.find(sum) != mpp.end()) {

        // maximize length
        maxi = max(maxi, i - mpp[sum]);
      }
      // first time seeing this sum
      else {
        // record index
        mpp[sum] = i;
      }
    }
  }

  // return best length
  return maxi;
}

// program entry
int main() {
  // sample input
  int A[] = {9, -3, 3, -1, 6, -5};
  // compute size
  int n = sizeof(A) / sizeof(A[0]);
  // print result
  cout << maxLen(A, n) << endl;
  // exit
  return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N), as we traverse the array once and `unordered_map` operations take `O(1)` time on average.
- **Space Complexity:** O(N), as we require a hashmap to store prefix sums and their indices. In the worst case, all prefix sums are unique.
