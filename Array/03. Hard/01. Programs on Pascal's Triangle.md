## Programs on Pascal's Triangle

**Problem Statement:**  
In Pascal’s triangle, each number is the sum of the two numbers directly above it.

---

>### Examples:

### Example 1:
**Input:** N = 5, r = 5, c = 3  
**Output:**  
Element at position (r, c): 6  
N-th row of Pascal’s triangle: 1 4 6 4 1  

First n rows of Pascal’s triangle: 5x5
``` text
         
Row->0          1  
Row->1         1 1   
Row->2        1 2 1   
Row->3       1 3 3 1   
Row->4      1 4 6 4 1    
```
      
**Explanation:** Pascal's triangle for the first 5 rows is shown above.  

---

### Example 2:
**Input:** N = 1, r = 1, c = 1  
**Output:**   
Element at position (r, c): 1  
N-th row of Pascal’s triangle: 1  
First n rows of Pascal’s triangle: 1  
**Explanation:** N = 1 is the base case of Pascal's triangle.  

---

## Program - 1 (Generate Pascal Triangle) 

### Algorithm:
To generate the entire Pascal’s Triangle for the first N rows, we can start with the first row containing a single 1 and iteratively build each subsequent row using the property that every element (except the first and last) is the sum of the two elements directly above it from the previous row. The first and last elements of each row are always 1. By storing the previous row, we can calculate the next row easily. This process continues until we have constructed all N rows, resulting in the complete Pascal’s Triangle structure.


### C++ Code: 
```cpp
#include <bits/stdc++.h>
using namespace std;

// Class containing Pascal's Triangle generation logic
class Solution {
public:
    // Function to generate Pascal's Triangle up to numRows
    vector<vector<int>> generate(int numRows) {
        // Result vector to hold all rows
        vector<vector<int>> triangle;

        // Loop for each row
        for (int i = 0; i < numRows; i++) {
            // Create a row with size (i+1) and initialize all elements to 1
            vector<int> row(i + 1, 1);

            // Fill elements from index 1 to i-1 (middle values)
            for (int j = 1; j < i; j++) {
                // Each element = sum of two elements above it
                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
            }

            // Add current row to the triangle
            triangle.push_back(row);
        }
        return triangle;
    }
};

int main() {
    Solution obj;
    int n = 5;

    // Generate and print Pascal's Triangle
    vector<vector<int>> result = obj.generate(n);
    for (auto &row : result) {
        for (auto &val : row) cout << val << " ";
        cout << endl;
    }
}
```
### Complexity Analysis:
- **Time Complexity:** $O(N^2)$, we generate all the elements in the first N rows sequentially, one by one.
- **Space Complexity:** $O(N^2)$, additional space used for storing the entire Pascal triangle.

---

## Program - 2 (Find element at the given row and column)

### Algorithm:
To find the element at the coordinates (R, C), where R is the row number, and C is the Column number, we can simply simulate the generation of Pascal's triangle for R rows. In Pascal’s Triangle, the element at row R and column C corresponds to the binomial coefficient $(r-1)C(c-1)$. To calculate this binomial coefficient, we can simply apply the formula of binomial coefficient, i.e., $\frac{(r-1)!}{(c-1)! (r-c)!}$.

Instead of computing full factorials (which can overflow and be slow), we can multiply and divide in a loop to compute the coefficient efficiently.   

**Note:** We use R−1 and C−1 to convert the 1-based user input into the 0-based format required by the binomial coefficient formula.

### nCr (Binomial Coefficient):

**Formula**  
  `nCr = n! / (r! * (n-r)!)`

 Example 1: `7C2`  
`7C2 = 7! / (2! * 5!)`

Cancel `5!`:  
`7C2 = (7 * 6 * 5!) / (2 * 1 * 5!)`  
`7C2 = (7 * 6) / (2 * 1)`  
`7C2 = 21`  

 Example 2: `10C3`  
`10C3 = 10! / (3! * 7!)`.  

Cancel `7!`:  
`10C3 = (10 * 9 * 8 * 7!) / (3 * 2 * 1 * 7!)`  
`10C3 = (10 * 9 * 8) / (3 * 2 * 1)`  

Write as stepwise division:  
`10C3 = (10/1) * (9/2) * (8/3) = 120`  

---

###  C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Computes nCr (binomial coefficient) using multiplicative formula
long long nCr(int n, int r) {
    long long res = 1;

    // Optional: use a smaller r to reduce iterations
    r = min(r, n - r);

    for (int i = 0; i < r; i++) {
        res = res * (n - i);
        res = res / (i + 1);
    }
    return res;
}

int main() {
    int n = 5, r = 2;
    cout << "nCr(" << n << "," << r << ") = " << nCr(n, r) << "\n"; // 10
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(min(c, r-c)), The loop runs for min(c−1, r−c) iterations because binomial coefficients are symmetric.
- **Space Complexity:** O(1), constant additional space is used.

---

## Program - 3 (Print nth row)

### Brute force:
**Algorithm Steps (Print nth row using nCr):**  

1. Read `n` (row number, 1-based).
2. For each column `c` from `1` to `n`:
   - Compute the value as: `(n-1)C(c-1)`
   - Print it.
3. End line.

*(Because the nth row of Pascal’s Triangle is formed by the binomial coefficients of `(n-1)`.)*


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Compute nCr using multiplicative formula
long long nCr(int n, int r) {
    long long res = 1;
    r = min(r, n - r);              // use smaller r

    for (int i = 0; i < r; i++) {
        res = res * (n - i);
        res = res / (i + 1);
    }
    return res;
}

int main() {
    int n = 5;                      // row number (1-based)

    // nth row of Pascal's Triangle has n elements:
    // value at column c (1-based) = (n-1)C(c-1)
    for (int c = 1; c <= n; c++) {
        cout << nCr(n - 1, c - 1) << " ";
    }
    cout << "\n";

    return 0;
}
```

### Complexity Analysis:

Let `n` be the row number.

**Time Complexity:**  
- We print `n` elements.
- Each element uses `nCr(n-1, c-1)` computed by a loop of `r = min(c-1, (n-1)-(c-1))`.
- In the worst case, `r` can be about `(n-1)/2`, so one `nCr` call is `O(n)`.

Total time:
- `n` calls × `O(n)` each ⇒ **O(n^2)**

* **Space Complexity:**  
- Only a few variables are used (no extra arrays).

**Space = O(1)**

---

### Optimal Approach:
#### Algorithm:
To print the Nth row of the Pascal triangle, we can take advantage of the relationship between the Nth element and binomial coefficients.

In Pascal's triangle, the Nth row contains the binomial coefficients C(N-1, 0), C(N-1, 1), and so on till C(N-1, N-1). Thus, we can simply calculate all these values to return the Nth row of pascal triangle.

Instead of computing full factorials, we can start with the first value as 1, and use the relation C(n, k) = C(n, k−1) × (n−k+1) / k to compute the next value from the previous one in constant time.


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Class containing Pascal's Triangle row generation logic
class Solution {
public:
    // Function to generate the Nth row of Pascal's Triangle
    vector<long long> getNthRow(int n) {
        // Result vector to store the row
        vector<long long> row;
        
        // First value of the row is always 1
        long long val = 1;
        row.push_back(val);
        
        // Compute remaining values using the relation:  C(n, k) = C(n, k-1) * (n-k) / k
        for (int i = 1; i < n; i++) {
            val = val * (n - i) / i;
            row.push_back(val);
        }
        
        return row;
    }
};

int main() {
    int n = 5; // Example: 5th row
    Solution sol;
    vector<long long> result = sol.getNthRow(n);

    // Print the row
    for (auto num : result) {
        cout << num << " ";
    }
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N), we iterate N times to compute each element of the row in O(1) time using the direct relation.
- **Space Complexity:** O(N), additional space used for storing the Nth row.
