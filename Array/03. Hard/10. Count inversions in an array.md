## ğŸ“ Count inversions in an array

**Problem Statement:**  
Given an array of `N` integers, count the inversions of the array (using merge-sort).

*Inversion of an array:* for all `i & j < size of array`, if `i < j` then you have to find pair `(A[i],A[j])` such that `A[j] < A[i]`.

---

>### ğŸ’¡ Examples:

### Example 1:
**Input Format:** `N = 5, array[] = {1,2,3,4,5}`  
**Result:** `0`  
**Explanation:** We have a sorted array, and the sorted array has 0 inversions, as for `i < j`, you will never find a pair such that `A[j] < A[i]`. A clearer example: 2 has index 1 and 5 has index 4, now 1 < 5 but 2 < 5, so this is not an inversion.

---

### Example 2:
**Input Format:** `N = 5, array[] = {5,4,3,2,1}`  
**Result:** `10`  
**Explanation:** We have a reverse-sorted array, and we will get the maximum inversions, as for `i < j`, we will always find a pair  
such that `A[j] < A[i]`.  
Example: 5 has index 0 and 3 has index 2 now (5,3) pair is inversion as 0 < 2 and 5 > 3, which will satisfy our conditions, and for a reverse sorted array we will get maximum inversions, and that is `(n)*(n-1) / 2`. For the above given array, there are 4 + 3 + 2 + 1 = 10 inversions.  
So all possible inversions are:
- `(0,1)`, `(0,2)`, `(0,3)`, `(0,4)`  
- `(1,2)`, `(1,3)`, `(1,4)`  
- `(2,3)`, `(2,4)`  
- `(3,4)`  

---

### Example 3:
**Input Format:** `N = 5, array[] = {5,3,2,1,4}`  
**Result:** `7`  
**Explanation:** There are 7 pairs (5,1), (5,3), (5,2), (5,4),(3,2), (3,1), (2,1), and we have left 2 pairs (2,4) and (1,4) as both do not satisfy our condition.  

**Points:**  
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  INVERSION = A pair (i, j) where i < j but arr[i] > arr[j]  â”‚
â”‚                                                             â”‚
â”‚  KEY INSIGHT:                                               â”‚
â”‚  â€¢ Counts "out of order" pairs                              â”‚
â”‚  â€¢ Measures distance from sorted state                      â”‚
â”‚  â€¢ 0 inversions = Sorted                                    â”‚
â”‚  â€¢ n(n-1)/2 inversions = Reverse sorted                     â”‚
â”‚                                                             â”‚
â”‚  APPLICATIONS:                                              â”‚
â”‚  â€¢ Minimum swaps to sort                                    â”‚
â”‚  â€¢ Similarity between rankings                              â”‚
â”‚  â€¢ Recommendation systems                                   â”‚
â”‚  â€¢ Data disorder measurement                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¢ Brute Force Approach

### Algorithm:
An inversion in an array is defined as a pair of indices (i, j) such that i < j and a[i] > a[j]. This measures how far the array is from being sorted. To count inversions, the brute force way is to compare every element with all elements to its right and increment the counter whenever we find an inversion.

1.  Initialize a counter `cnt = 0`.
2.  Use two nested loops:
    *   Outer loop runs for each element `a[i]`.
    *   Inner loop checks all elements `a[j]` where `j > i`.
3.  If `a[i] > a[j]`, increment `cnt`.
4.  After traversing all pairs, return `cnt` as the number of inversions.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Function to count the number of inversions in an array
// An inversion is a pair (i, j) such that i < j and arr[i] > arr[j]
int numberOfInversions(vector<int>& a, int n) {
    int cnt = 0; // Initialize inversion count
    // Check all pairs
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (a[i] > a[j]) cnt++; // Increment count if inversion found
        }
    }
    return cnt; // Return total inversions
}

int main() {
    vector<int> a = {5, 4, 3, 2, 1};
    int n = a.size();
    int cnt = numberOfInversions(a, n);
    cout << "The number of inversions is: " << cnt << endl;
    return 0;
}
```
### ğŸ“Š Complexity Analysis:
- **Time Complexity:** O(N^2), as every pair is checked.
- **Space Complexity:** O(1), since no extra space is used apart from variables.

---

## ğŸ§  Optimal Approach

### Algorithm:
The brute force approach compares all pairs, but that takes $O(N^2)$ time. 
We can optimize this using the *Merge Sort* algorithm. While merging two sorted halves, if an element in the left half is greater than an element in the right half, then all remaining elements in the left half will also be greater than that right element (because the left half is already sorted). This allows us to count multiple inversions in one step, instead of checking each pair individually.

1.  Apply merge sort recursively to divide the array into two halves.
2.  During the *merge* step:
    *   Compare elements at `arr[left]` and `arr[right]`.
    *   If `arr[left] <= arr[right]`, place `arr[left]` into the temp array and move `left++`.
    *   Otherwise, place `arr[right]` into the temp array. Since `arr[left] > arr[right]`, all elements from `arr[left]` to `arr[mid]` form inversions with `arr[right]`. So add `(mid - left + 1)` to the inversion count.
3.  Copy the merged elements back into the original array.
4.  The total inversion count is the sum of:
    *   Inversions in the left half
    *   Inversions in the right half
    *   Inversions across the halves (counted during merge)

```cpp
#include <bits/stdc++.h>
using namespace std;

// Function to merge two halves and count inversions
int merge(vector<int> &arr, int low, int mid, int high) {
    // Temporary array to store merged elements
    vector<int> temp;

    // Starting index of left half
    int left = low;
    // Starting index of right half
    int right = mid + 1;

    // Variable to count inversions
    int cnt = 0;

    // Merge elements in sorted order and count inversions
    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {
            temp.push_back(arr[left]);
            left++;
        } else {
            temp.push_back(arr[right]);

            // Modification: If left > right, then all elements 
            // from left to mid are greater than right.
            cnt += (mid - left + 1); // All remaining left elements are inversions
            right++;
        }
    }

    // If left half still has elements
    while (left <= mid) {
        temp.push_back(arr[left]);
        left++;
    }

    // If right half still has elements
    while (right <= high) {
        temp.push_back(arr[right]);
        right++;
    }

    // Copy back to original array
    for (int i = low; i <= high; i++) {
        arr[i] = temp[i - low];
    }

    // Return inversion count
    return cnt;
}

// Merge sort function that counts inversions
int mergeSort(vector<int> &arr, int low, int high) {
    // Variable to store inversion count
    int cnt = 0;

    // Base case
    if (low >= high) return cnt;

    int mid = (low + high) / 2;

    // Count inversions in the left half
    cnt += mergeSort(arr, low, mid);

    // Count inversions in the right half
    cnt += mergeSort(arr, mid + 1, high);

    // Count inversions during merge
    cnt += merge(arr, low, mid, high);

    return cnt;
}

// Function to get number of inversions
int numberOfInversions(vector<int>& a, int n) {
    return mergeSort(a, 0, n - 1);
}

int main() {
    // Input array
    vector<int> a = {5, 4, 3, 2, 1};
    int n = a.size();

    // Count inversions
    int cnt = numberOfInversions(a, n);

    cout << "The number of inversions are: " << cnt << endl;

    return 0;
}
```
### ğŸ“Š Complexity Analysis:
- **Time Complexity:** O(N log N), since it is based on merge sort.
- **Space Complexity:** O(N), for the temporary array used during merging.
