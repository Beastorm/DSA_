## 3 Sum | Find triplets that add up to a zero

**Problem Statement:**  
Given an array of N integers, your task is to find unique triplets that add up to give a sum of zero. In short, you need to return an array of all the unique triplets [arr[a], arr[b], arr[c]] such that i!=j, j!=k, k!=i, and their sum is equal to zero.

**Pre-requisite:** 2 Sum Problem

**3Sum Criteria (Simple)**  

- Choose **3 different elements** from the array (different indices).
- Their sum must be **0**.
- Return **unique triplets** only (same values in different order count as the same triplet).

**Examples**  

**Example 1**  
 `nums = [-1, 0, 1, 2, -1, -4]`  
 Valid triplets:
- `[-1, -1, 2]`  → `-1 + -1 + 2 = 0`
- `[-1, 0, 1]`   → `-1 + 0 + 1 = 0`  
Note: `[-1, 1, 0]` is the same as `[-1, 0, 1]`, so include it only once.

**Example 2**  
`nums = [0, 0, 0, 0]`  
Valid triplets:
- `[0, 0, 0]` (only once)

**Example 3**  
`nums = [1, 2, -2, -1]`  
No triplet sums to 0 → `[]`.

---

## Brute Force Approach

### Algorithm
**Intuition:**
This method is simple. We check every possible group of three numbers using three loops. If their sum equals the target (0), we keep them. Before storing, we sort the triplet so that we only keep unique ones (e.g., `[-1, 0, 1]` and `[0, -1, 1]` are considered the same).

**Steps:**
1.  Use a `set` data structure to store the triplets. This ensures that we only store unique triplets.
2.  Run the first loop (`i`) from the start to the end of the array.
3.  Inside it, run the second loop (`j`) from `i + 1` to the end.
4.  Then run the third loop (`k`) from `j + 1` to the end.
5.  For every three numbers `arr[i]`, `arr[j]`, and `arr[k]`, check if their sum equals 0.
6.  If the sum is 0, create a temporary vector with these three values, sort the vector, and insert it into the set.
7.  Finally, convert the set into a vector and return it.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve 3-sum problem
class Solution {
public:
    // Function to find triplets with sum zero
    vector<vector<int>> threeSum(vector<int>& arr, int n) {
        // Store unique triplets
        set<vector<int>> st;

        // First loop for first element
        for (int i = 0; i < n; i++) {
            // Second loop for second element
            for (int j = i + 1; j < n; j++) {
                // Third loop for third element
                for (int k = j + 1; k < n; k++) {
                    // If the triplet sum is zero
                    if (arr[i] + arr[j] + arr[k] == 0) {
                        // Store sorted triplet to avoid duplicates
                        vector<int> temp = {arr[i], arr[j], arr[k]};
                        sort(temp.begin(), temp.end());
                        st.insert(temp);
                    }
                }
            }
        }

        // Convert set to vector
        vector<vector<int>> ans(st.begin(), st.end());
        return ans;
    }
};

// Driver code
int main() {
    vector<int> arr = {-1, 0, 1, 2, -1, -4};
    int n = arr.size();
    Solution obj;
    vector<vector<int>> res = obj.threeSum(arr, n);

    for (auto &triplet : res) {
        for (auto &num : triplet) cout << num << " ";
        cout << endl;
    }
    return 0;
}
```
### Complexity Analysis

**Time Complexity:** O(N^3 * log(no. of unique triplets)), where N = size of the array.
**Reason:** Here, we are mainly using 3 nested loops. And inserting triplets into the set takes O(log(no. of unique triplets)) time complexity. But we are not considering the time complexity of sorting, as we are just sorting 3 elements every time.

**Space Complexity:** O(2 * no. of the unique triplets) as we are using a set data structure and a list to store the triplets.

---

## Better Approach

### Algorithm
**Intuition:**
Earlier, we used three loops to find triplets that sum to zero. But now, we aim to do the same using just two loops. To do this, we will calculate the third number needed to complete the triplet instead of looping to find it.

The idea is simple: if we already have two numbers, we can figure out what the third number should be to make the sum zero. Instead of checking all possible third numbers, we just check if the required number is already present using a set, which helps us search quickly.

We must be careful not to put all numbers in the set from the beginning to avoid using the same element index twice. Therefore, we use a HashSet that is refreshed for every iteration of the outer loop, storing elements encountered so far in the inner loop.

**Steps:**
1.  Start by creating a set (`ans`) to store the final unique triplets.
2.  Use the first loop to go through each number one by one (index `i`).
3.  Inside the first loop, create a "hashset" (`st`) to store elements seen in the current iteration.
4.  Run the second loop (index `j`) starting from `i + 1`.
5.  Calculate the number needed to complete the triplet: `third = -(arr[i] + arr[j])`.
6.  Check if `third` exists in the `hashset`:
    *   If it exists, we found a valid triplet. Sort the triplet `{arr[i], arr[j], third}` and insert it into the `ans` set.
7.  Insert `arr[j]` into the `hashset` so it can be used as a potential "third" element for future iterations of `j`.
8.  Finally, return all the triplets collected in the `ans` set.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve 3-sum problem
class Solution {
public:
    // Function to find triplets with sum zero
    vector<vector<int>> threeSum(vector<int>& arr, int n) {
        // Store unique triplets
        set<vector<int>> ans;

        // First loop for first element
        for (int i = 0; i < n; i++) {
            // Set to store elements seen in this iteration
            set<int> hashset;

            // Second loop for second element
            for (int j = i + 1; j < n; j++) {
                // Calculate the third element needed
                int third = -(arr[i] + arr[j]);

                // If third already in set, we found a triplet
                if (hashset.find(third) != hashset.end()) {
                    vector<int> temp = {arr[i], arr[j], third};
                    sort(temp.begin(), temp.end());
                    ans.insert(temp);
                }

                // Add current element to the set
                hashset.insert(arr[j]);
            }
        }

        // Convert set to vector
        return vector<vector<int>>(ans.begin(), ans.end());
    }
};

// Driver code
int main() {
    vector<int> arr = {-1, 0, 1, 2, -1, -4};
    int n = arr.size();
    Solution obj;
    vector<vector<int>> res = obj.threeSum(arr, n);

    for (auto &triplet : res) {
        for (auto &num : triplet) cout << num << " ";
        cout << endl;
    }
    return 0;
}
```
### Complexity Analysis

- **Time Complexity:** $O(N^2 \times \log(\text{no. of unique triplets}))$
    - **Reason:** We are using 2 nested loops to traverse the array. Additionally, inserting the triplets into the set takes $O(\log(\text{no. of unique triplets}))$ time complexity. We do not consider the time complexity of sorting as we are just sorting 3 elements every time.

- **Space Complexity:** $O(2 \times \text{no. of the unique triplets}) + O(N)$
    - **Reason:** We are using a set data structure and a list to store the unique triplets, and we use an extra $O(N)$ space for the `hashset` to store array elements during the iteration.


---

## Optimal Approach

### Algorithm
**Intuition:**
This is an improved version of the previous solution. We remove the extra set (used for unique triplets) and the HashSet (used for quick searching).

By sorting the array first, we can:
1.  Easily skip repeated numbers by checking if the current number is the same as the previous one.
2.  Ensure all triplets are unique without storing them in a set.
3.  Instead of using a HashSet to find triplets, we use the **two-pointer method**:
    *   One pointer moves forward from the left, the other backward from the right.
    *   We adjust their positions depending on whether the total is greater than, less than, or equal to the target.

**Approach Steps:**
1.  **Sort** the array first.
2.  Fix the first number using a loop (`i`) from the beginning to the end of the array.
3.  **Skip** the number if it is the same as the previous one (to avoid duplicates).
4.  Use two pointers:
    *   `left`: starts right after the fixed number.
    *   `right`: starts from the last element of the array.
5.  While the `left` pointer is before the `right` pointer:
    *   If the `sum` is greater than 0 → move the `right` pointer one step left.
    *   If the `sum` is less than 0 → move the `left` pointer one step right.
    *   If the `sum` equals 0 → store the triplet, then move both pointers while **skipping duplicates** for both the left and right pointers.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve 3-sum problem
class Solution {
public:
    // Function to find triplets with sum zero
    vector<vector<int>> threeSum(vector<int>& arr, int n) {
        // Sort the array
        sort(arr.begin(), arr.end());
        // Store final result
        vector<vector<int>> ans;

        // First loop for first element
        for (int i = 0; i < n; i++) {
            // Skip duplicates for first element
            if (i > 0 && arr[i] == arr[i - 1]) continue;

            // Two pointers
            int left = i + 1, right = n - 1;

            // Find pairs for current arr[i]
            while (left < right) {
                int sum = arr[i] + arr[left] + arr[right];

                if (sum == 0) {
                    ans.push_back({arr[i], arr[left], arr[right]});
                    left++, right--;

                    // Skip duplicates for left
                    while (left < right && arr[left] == arr[left - 1]) left++;
                    // Skip duplicates for right
                    while (left < right && arr[right] == arr[right + 1]) right--;
                }
                else if (sum < 0) left++;
                else right--;
            }
        }
        return ans;
    }
};

// Driver code
int main() {
    vector<int> arr = {-1, 0, 1, 2, -1, -4};
    int n = arr.size();
    Solution obj;
    vector<vector<int>> res = obj.threeSum(arr, n);

    for (auto &triplet : res) {
        for (auto &num : triplet) cout << num << " ";
        cout << endl;
    }
    return 0;
}
```

### Complexity Analysis

- **Time Complexity:** $O(N \log N) + O(N^2)$, as the pointer `i` is running for approximately $N$ times. And both the pointers `left` and `right` combined can run for approximately $N$ times, including the operation of skipping duplicates. So the total time complexity will be $O(N^2)$.

- **Space Complexity:** $O(\text{no. of triplets})$, This space is only used to store the answer. We are not using any extra space to solve this problem. So, from that perspective, space complexity can be written as $O(1)$.
  
