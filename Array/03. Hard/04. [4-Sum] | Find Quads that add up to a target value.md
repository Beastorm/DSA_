## 4 Sum | Find Quads that add up to a target value

**Problem Statement:**   
Given an array of N integers, your task is to find unique quads that add up to give a target value. In short, you need to return an array of all the unique quadruplets, `[arr[a], arr[b], arr[c], arr[d]]` such that their sum is equal to a given target.

>Note: `a`, `b`, `c` and `d` are also distinct and lies between 0 to `n-1` (both inclusive).

---

>### Examples:
**Example 1:**  
**Input Format:** `arr[] = [1,0,-1,0,-2,2], target = 0`  
**Result:** `[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]`  
**Explanation:** We have to find unique quadruplets from the array such that the sum of those elements is equal to the target sum, given that it is 0. The result obtained is such that the sum of the quadruplets yields 0.  

**Example 2:**  
**Input Format:** `arr[] = [4,3,3,4,4,2,1,2,1,1], target = 9`  
**Result:** `[[1,1,3,4],[1,2,2,4],[1,2,3,3]]`  
**Explanation:** The sum of all the quadruplets is equal to the target, i.e., 9.  

---

## Brute Force Approach

### Algorithm:
1.  Create a set to keep unique groups of four numbers.
2.  Use the first loop from the start of the array to the end to choose the first number (`arr[i]`).
3.  Inside it, run a second loop starting from the next position (`i+1`) to choose the second number (`arr[j]`).
4.  Then, run a third loop starting from the next position after the second number (`j+1`) to choose the third number (`arr[k]`).
5.  Finally, run a fourth loop starting from the next position after the third number (`k+1`) to choose the fourth number (`arr[l]`).
6.  Check if the total of these four numbers equals the target value. Note: Cast to `long long` to avoid integer overflow during addition.
7.  If yes, arrange the four numbers in sorted order and add them to the set.
8.  Once all loops are done, return the set as a list of unique groups of four numbers.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find quadruplets with sum = target
    vector<vector<int>> fourSum(vector<int>& arr, int target) {
        // Get size of array
        int n = arr.size();
        // Use set to avoid duplicate quadruplets
        set<vector<int>> st;

        // First loop - pick first element
        for (int i = 0; i < n; i++) {
            // Second loop - pick second element
            for (int j = i + 1; j < n; j++) {
                // Third loop - pick third element
                for (int k = j + 1; k < n; k++) {
                    // Fourth loop - pick fourth element
                    for (int l = k + 1; l < n; l++) {
                        // Calculate the sum of four chosen numbers
                        long long sum = (long long)arr[i] + arr[j] + arr[k] + arr[l];
                        // Check if sum matches target
                        if (sum == target) {
                            // Store quadruplet in sorted order
                            vector<int> temp = {arr[i], arr[j], arr[k], arr[l]};
                            sort(temp.begin(), temp.end());
                            // Insert into set to ensure uniqueness
                            st.insert(temp);
                        }
                    }
                }
            }
        }
        // Convert set into vector of quadruplets
        return vector<vector<int>>(st.begin(), st.end());
    }
};

int main() {
    // Input array
    vector<int> arr = {1, 0, -1, 0, -2, 2};
    // Target sum
    int target = 0;

    // Create object
    Solution obj;
    // Get all quadruplets
    vector<vector<int>> ans = obj.fourSum(arr, target);

    // Print result
    for (auto quad : ans) {
        for (int num : quad) cout << num << " ";
        cout << endl;
    }
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(N^4)$, where $N$ is the size of the array.
    - **Reason:** Here, we are using 4 nested loops to cover all possible quadruplets. Inserting quadruplets into the set takes logarithmic time, making the exact complexity $O(N^4 \times \log(\text{unique quadruplets}))$.

- **Space Complexity:** $O(2 \times \text{no. of the unique quadruplets})$
    - **Reason:** We are using a set data structure and a list to store the unique quadruplets.
 
---

## Better Approach

### Algorithm:
**Intuition:**    
To improve upon the brute force approach, we can reduce the number of nested loops from four to three. Similar to the 3 Sum problem, we can fix two numbers (`arr[i]` and `arr[j]`) and iterate for the third number (`arr[k]`). For the fourth number, instead of looping again, we calculate the specific value required to reach the target sum and check if it exists in a HashSet.

**Steps:**    
1.  Create a set (`st`) to keep only unique groups of four numbers.
2.  Run the first loop (`i`) from the start to the end of the array.
3.  Inside it, run the second loop (`j`) from `i + 1` to the end.
4.  Before starting the third loop, define a **HashSet** (`seen`) to store elements encountered between indices `j` and `k`.
5.  Run the third loop (`k`) from `j + 1` to the end.
6.  Calculate the fourth number needed: `required = target - (arr[i] + arr[j] + arr[k])`.
7.  Check if this `required` number is already in the `seen` HashSet.
    *   If yes, we have found a valid quadruplet. Sort the four numbers and add them to the main set `st`.
8.  Add the current element `arr[k]` to the `seen` HashSet so it can be paired with future elements in the `k` loop.
9.  After all loops finish, return the set as a list of unique groups of four numbers.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find all unique quadruplets
    vector<vector<int>> fourSum(vector<int>& arr, int target) {
        int n = arr.size();
        set<vector<int>> st;  

        // First loop - pick first number
        for (int i = 0; i < n; i++) {
            // Second loop - pick second number
            for (int j = i + 1; j < n; j++) {
                // HashSet to store numbers seen in the current j iteration
                unordered_set<long long> seen;

                // Third loop - pick third number
                for (int k = j + 1; k < n; k++) {
                    // Find the required fourth number
                    long long required = (long long)target - arr[i] - arr[j] - arr[k];

                    // If the required number is already in the set, we found a quadruplet
                    if (seen.count(required)) {
                        vector<int> temp = {arr[i], arr[j], arr[k], (int)required};
                        sort(temp.begin(), temp.end());
                        st.insert(temp);
                    }

                    // Add the current third number into the set
                    seen.insert(arr[k]);
                }
            }
        }

        // Convert set into vector and return
        return vector<vector<int>>(st.begin(), st.end());
    }
};

int main() {
    vector<int> arr = {1, 0, -1, 0, -2, 2};
    int target = 0;

    Solution obj;
    vector<vector<int>> ans = obj.fourSum(arr, target);

    for (auto quad : ans) {
        for (int num : quad) cout << num << " ";
        cout << endl;
    }
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(N^3 \times \log(M))$, where $N$ is the size of the array and $M$ is the number of unique quadruplets.
    - **Reason:** We are mainly using 3 nested loops. Inside the loops, we perform operations on the `set` data structure (inserting the unique quadruplets), which takes logarithmic time complexity.

- **Space Complexity:** $O(2 \times \text{no. of the quadruplets}) + O(N)$
    - **Reason:** We use a set data structure and a list to store the unique quadruplets, which accounts for the first term. The second term $O(N)$ is for the `unordered_set` used to store array elements during the execution of the loops.

---

## Optimal Approach

**Intuition:**    
We can optimize the space complexity and handle duplicates more elegantly by sorting the array first. This allows us to use the *two-pointer technique* for the last two numbers (similar to the 3-Sum problem) instead of using a HashSet. This reduces the auxiliary space complexity to $O(1)$ (ignoring the space for the output).

**Algorithm:**   
1.  *Sort* the array first.
2.  Use the first loop (`i`) to pick the first number. *Skip* it if it is the same as the previous one (`arr[i] == arr[i-1]`) to avoid duplicates.
3.  Inside it, use the second loop (`j`) to pick the second number. Also, *skip* it if it repeats the previous one (`arr[j] == arr[j-1]`).
4.  Set two pointers: one just after the second number (`left = j + 1`) and one at the end of the array (`right = n - 1`).
5.  While the `left` pointer is before the `right` pointer:
    *   Calculate the total sum of the four chosen numbers. *Note:* Use `long long` to avoid integer overflow.
    *   If the total *equals* the target:
        *   Save the quadruplet.
        *   Move both pointers inward.
        *   *Skip duplicates* for both `left` and `right` pointers to ensure uniqueness.
    *   If the total is *less than* the target, move the `left` pointer one step forward to increase the total.
    *   If the total is *greater than* the target, move the `right` pointer one step backward to reduce the total.
6.  After all loops finish, return the list of unique groups.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find all unique quadruplets
    vector<vector<int>> fourSum(vector<int>& arr, int target) {
        int n = arr.size();
        vector<vector<int>> ans;

        // Step 1: Sort array
        sort(arr.begin(), arr.end());

        // Step 2: First loop for first number
        for (int i = 0; i < n; i++) {
            // Skip duplicates for first number
            if (i > 0 && arr[i] == arr[i - 1]) continue;

            // Step 3: Second loop for second number
            for (int j = i + 1; j < n; j++) {
                // Skip duplicates for the second number
                if (j > i + 1 && arr[j] == arr[j - 1]) continue;

                // Step 4: Two pointers for the remaining two numbers
                int left = j + 1, right = n - 1;
                while (left < right) {
                    long long sum = (long long)arr[i] + arr[j] + arr[left] + arr[right];

                    if (sum == target) {
                        ans.push_back({arr[i], arr[j], arr[left], arr[right]});

                        // Move left pointer skipping duplicates
                        while (left < right && arr[left] == arr[left + 1])
                            left++;
                            
                        // Move right pointer skipping duplicates
                        while (left < right && arr[right] == arr[right - 1])
                            right--;

                        left++;
                        right--;
                    }
                    else if (sum < target) left++;
                    else right--;
                }
            }
        }
        return ans;
    }
};

int main() {
    vector<int> arr = {1, 0, -1, 0, -2, 2};
    int target = 0;

    Solution obj;
    vector<vector<int>> ans = obj.fourSum(arr, target);

    for (auto quad : ans) {
        for (int num : quad) cout << num << " ";
        cout << endl;
    }
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** $O(N^3)$, as each of the pointers `i` and `j` runs for approximately `N` times. And both the pointers `k` and `l` combined can run for approximately `N` times, including the operation of skipping duplicates. So the total time complexity will be $O(N^3)$.

- **Space Complexity:** $O(\text{no. of quadruplets})$, as this space is only used to store the answer. We are not using any extra space to solve this problem. So, from that perspective, space complexity can be written as $O(1)$.
