## Count the number of subarrays with given xor K

**Problem Statement:** Given an array of integers A and an integer k. Find the total number of subarrays having the bitwise XOR of all elements equal to k.

### Examples

**Input:** `A = [4, 2, 2, 6, 4] , k = 6`  
**Output:** `4`  
**Explanation:** The subarrays having XOR of their elements as 6 are `[4, 2]`, `[4, 2, 2, 6, 4]`, `[2, 2, 6]`, `[6]`.  

**Input:** `A = [5, 6, 7, 8, 9], k = 5`  
**Output:** `2`  
**Explanation:** The subarrays having XOR of their elements as 5 are `[5]` and `[5, 6, 7, 8, 9]`.  

---

## Brute-Force Approach

### Algorithm
We need to find the total number of subarrays (continuous segments of the array) such that the XOR of all elements in that subarray equals k. A brute force way would be to consider every possible subarray of the array and check its XOR.

1.  Initialize a `count` to 0 for storing the number of valid subarrays.
2.  Loop through each index `i` as the starting point of the subarray.
3.  Set a variable `xorVal = 0` for maintaining the running XOR of the current subarray.
4.  Loop through each index `j` from `i` to `n-1` to extend the subarray.
5.  Update `xorVal` by taking `xorVal = xorVal ^ A[j]`.
6.  If `xorVal` equals `k`, increment the `count` by 1.
7.  After all iterations, return the `count` as the total number of subarrays.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to count subarrays with XOR equal to k
    int countSubarraysXOR(vector<int>& A, int k) {
        // Initialize count of valid subarrays
        int count = 0;
        // Traverse all starting points
        for (int i = 0; i < A.size(); i++) {
            // Maintain xor of current subarray
            int xorVal = 0;
            // Extend subarray till end
            for (int j = i; j < A.size(); j++) {
                // Update xor
                xorVal ^= A[j];
                // If xor equals k, increment count
                if (xorVal == k) {
                    count++;
                }
            }
        }
        return count;
    }
};

int main() {
    // Input array
    vector<int> A = {4, 2, 2, 6, 4};
    // Target xor
    int k = 6;

    Solution sol;
    cout << sol.countSubarraysXOR(A, k) << endl;
    return 0;
}
```
### Complexity Analysis
- **Time Complexity:** O(N^2), we generate all possible subarrays to check their XOR.
- **Space Complexity:** O(1), constant amount of extra space is used.

---

## Optimal Approach

### Algorithm
The brute force approach checks all possible subarrays and computes their XOR, but this quickly becomes inefficient for large arrays because it requires checking every pair of indices. Instead, we can make use of prefix XORs. A prefix XOR at index $i$ represents the XOR of all elements from the start up to $i$. Using this, the XOR of any subarray can be derived by taking the XOR of two prefix XOR values.

Now, to find whether a subarray ending at the current position has XOR equal to $k$, we only need to check if there was an earlier prefix XOR such that when we combine it with the current prefix XOR, the result is $k$. In other words, the condition becomes $prefixXor[r] \oplus prefixXor[l-1] = k$. By properties of XOR, this is equivalent to $prefixXor[l-1] = prefixXor[r] \oplus k$.

We keep track of how many times each prefix XOR has appeared using a hashmap (or dictionary). Whenever we find one that matches, we increase our count. This way, instead of checking all subarrays, we just use the hashmap and solve it much faster.

**Steps:**
1.  Initialize a hashmap to store how many times each prefix XOR has appeared. Initialize it with `{0: 1}` to handle cases where the subarray starting from index 0 has XOR $k$.
2.  Keep a variable to store the current prefix XOR as we move through the array.
3.  Keep another variable to count the total number of subarrays with XOR equal to $k$.
4.  For each element in the array, update the prefix XOR by combining it with the current element.
5.  Calculate the required previous prefix XOR: `target = prefixXor ^ k`.
6.  Check if `target` exists in the hashmap. If yes, add its frequency from the hashmap to the count.
7.  Store or update the frequency of the current `prefixXor` in the hashmap.
8.  After processing all elements, the count will be the total number of subarrays with XOR equal to $k$.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to count subarrays with given XOR
    int countSubarrays(vector<int>& A, int k) {
        // Store frequency of prefix XORs
        unordered_map<int, int> freq;
        // Initialize with prefix XOR 0
        // This handles the case where the subarray starts from index 0
        freq[0] = 1;

        // Current prefix XOR
        int prefixXor = 0;
        // Answer count
        int count = 0;

        // Traverse array
        for (int num : A) {
            // Update prefix XOR
            prefixXor ^= num;

            // Compute required XOR (Y = XR ^ k)
            int target = prefixXor ^ k;

            // If target exists in map, add its frequency
            if (freq.find(target) != freq.end()) {
                count += freq[target];
            }

            // Store current prefix XOR in map
            freq[prefixXor]++;
        }
        return count;
    }
};

int main() {
    vector<int> A = {4, 2, 2, 6, 4};
    int k = 6;
    Solution sol;
    cout << sol.countSubarrays(A, k) << endl;
    return 0;
}
```
### Complexity Analysis
- **Time Complexity:** O(N), we traverse the entire array once to calculate prefix XOR and subarrays with given XOR.
- **Space Complexity:** O(N), an additional amount of extra space is used to store frequencies of prefix XOR in a hash map.
