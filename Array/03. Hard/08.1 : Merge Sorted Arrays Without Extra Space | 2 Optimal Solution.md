## ðŸ“ Merge Sorted Arrays Without Extra Space | 2 Optimal Solution
**Problem Statement:**    
You are given two sorted arrays, `arr1` (size $N$) and `arr2` (size $M$). Your task is to merge them into a sorted sequence.

**The Constraint:**  
You must modify the arrays *in-place* with $O(1)$ extra space. You *cannot* create a third array to store the result.

**The Goal:**  
After the operation:
1.  `arr1` should contain the *smallest* $N$ elements (sorted).
2.  `arr2` should contain the *remaining* $M$ largest elements (sorted).

---

>### ðŸ’¡ Example:

**Input:**  
*   `arr1` = `[1, 3, 5, 7]` (Sorted)
*   `arr2` = `[0, 2, 6, 8, 9]` (Sorted)

**Process:**  
We need to rearrange the numbers across both arrays so they form a continuous increasing sequence from the start of `arr1` to the end of `arr2`.

**Output:**  
*   `arr1` = `[0, 1, 2, 3]` (First 4 smallest elements)
*   `arr2` = `[5, 6, 7, 8, 9]` (Remaining 5 largest elements)

---

## Bruteforce

### Algorithm: Merge Two Sorted Arrays:

#### Input:
*   Two sorted arrays `arr1` of size `n`.
*   Two sorted arrays `arr2` of size `m`

#### Output:
*   `arr1` contains the first `n` smallest elements
*   `arr2` contains the remaining `m` elements in sorted order

#### Steps:
1.  Create a temporary array `arr3` of size `n + m`.
2.  Initialize three pointers:
    *   `left = 0` â†’ for `arr1`
    *   `right = 0` â†’ for `arr2`
    *   `index = 0` â†’ for `arr3`
3.  While `left < n` and `right < m`:
    *   If `arr1[left] â‰¤ arr2[right]`, copy `arr1[left]` to `arr3[index]` and increment `left`.
    *   Else, copy `arr2[right]` to `arr3[index]` and increment `right`.
    *   Increment `index`.
4.  Copy remaining elements of `arr1` (if any) into `arr3`.
5.  Copy remaining elements of `arr2` (if any) into `arr3`.
6.  Copy the first `n` elements of `arr3` back into `arr1`.
7.  Copy the remaining `m` elements of `arr3` back into `arr2`.
8.  End.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Merge two sorted arrays arr1 (size n) and arr2 (size m) in sorted order.
    // Result should be stored back: first n elements in arr1, remaining m in arr2.
    void merge(long long arr1[], long long arr2[], int n, int m) {
        vector<long long> arr3(n + m);

        int left = 0, right = 0, index = 0;

        // Merge both arrays into arr3
        while (left < n && right < m) {
            if (arr1[left] <= arr2[right])
               arr3[index++] = arr1[left++];
            else
               arr3[index++] = arr2[right++];
        }

        // Remaining elements
        while (left < n) arr3[index++] = arr1[left++];
        while (right < m) arr3[index++] = arr2[right++];

        // Copy back to arr1 and arr2
        for (int i = 0; i < n + m; i++) {
            if (i < n) arr1[i] = arr3[i];
            else arr2[i - n] = arr3[i];
        }
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    vector<long long> a(n), b(m);
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < m; i++) cin >> b[i];

    Solution sol;
    sol.merge(a.data(), b.data(), n, m);

    // Print final arr1 then arr2
    for (int i = 0; i < n; i++) cout << a[i] << (i + 1 == n ? '\n' : ' ');
    for (int i = 0; i < m; i++) cout << b[i] << (i + 1 == m ? '\n' : ' ');

    return 0;
}
```
### ðŸ“Š Complexity Analysis:
- **Time Complexity:** O(n + m), where `n` and `m` are the sizes of the two arrays. We traverse both arrays to merge them and iterate again to copy the values back.
- **Space Complexity:** O(n + m), as we create a temporary array `arr3` of size `n + m` to store the sorted elements.

---

## ðŸ§  Optimized Approach-I : O(1) Space Optimized 

#### Algorithm: Swap and Sort
This approach avoids using extra space by swapping elements to their correct arrays and then sorting them.

1.  *Initialize Pointers:* Set a pointer `left` to the last element of the first array (`n-1`) and a pointer `right` to the first element of the second array (`0`).
2.  *Compare and Swap:*
    *   While `left >= 0` and `right < m`:
    *   Compare `arr1[left]` and `arr2[right]`.
    *   If `arr1[left] > arr2[right]`, it means the larger element is in the left array (which should hold smaller elements), and the smaller element is in the right array. *Swap* them.
    *   Move pointers closer: Decrement `left` and increment `right`.
    *   If `arr1[left] <= arr2[right]`, the arrays are already partitioned correctly relative to each other (all necessary swaps are done). *Break* the loop.
3.  *Sort:* Since swapping disrupts the internal order of the arrays, apply `sort()` on `arr1` and `arr2` individually to ensure the final output is in non-decreasing order.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution{
public:
    // Merge two sorted arrays without using an extra array (swap + sort method)
    void merge(long long arr1[], long long arr2[], int n, int m) {
        int left = n - 1; // bigger elements will be at the end of arr1.
        int right = 0; // smaller element will be at the start of arr2.

        // Swap elements that are out of place
        while (left >= 0 && right < m) {
            // we need to throw bigger elements of arr1 to arr2 and put smaller element from arr2 in the aar1.
            if (arr1[left] > arr2[right]) {
                swap(arr1[left], arr2[right]);
                left--;
                right++;
            }
            // if arr1[left] is smaller than, we know that it will be smaller than the rest of the arr2 elements.
            else {
                break;
            }
        }

        // Re-sort both arrays to restore sorted order
        sort(arr1, arr1 + n);
        sort(arr2, arr2 + m);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    vector<long long> arr1(n), arr2(m);
    for (int i = 0; i < n; i++) cin >> arr1[i];
    for (int i = 0; i < m; i++) cin >> arr2[i];

    Solution sol;
    sol.merge(arr1.data(), arr2.data(), n, m);

    // Print final arr1 then arr2
    for (int i = 0; i < n; i++) cout << arr1[i] << (i + 1 == n ? '\n' : ' ');
    for (int i = 0; i < m; i++) cout << arr2[i] << (i + 1 == m ? '\n' : ' ');

    return 0;
}
```
### ðŸ“Š Complexity Analysis:
- **Time Complexity:** O(n log n + m log m)
    - The while loop runs in O(min(n, m)).
    - Sorting `arr1` takes O(n log n) and `arr2` takes O(m log m).
- **Space Complexity:** O(1)
    - No extra data structure is used for merging; modifications are done in-place.

---

##  ðŸ§  Optimized Approach-II : O(1) Space Optimized (Gap Method)

### Algorithm:
Here is the algorithm in 5 concise steps:

1.  *Initialize Gap:* Calculate total length `len = n + m` and initial `gap = ceil(len / 2)`.
2.  *Outer Loop:* Continue the process as long as `gap > 0`.
3.  *Set Pointers:* Initialize `left = 0` and `right = gap`.
4.  *Traverse & Swap:* Loop while `right < len`:
    *   *Identify Array:* Check if pointers fall in `arr1` (index `< n`) or `arr2` (index `â‰¥ n`).
    *   *Compare:* If element at `left` > element at `right`, *SWAP* them.
    *   *Move:* Increment `left` and `right`.
5.  *Reduce Gap:** After traversing, update `gap = ceil(gap / 2)`. Stop if the gap was already 1.

---

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Helper function to swap elements if they are in the wrong order
    void swapIfGreater(long long arr1[], long long arr2[], int ind1, int ind2) {
        if (arr1[ind1] > arr2[ind2]) {
            swap(arr1[ind1], arr2[ind2]);
        }
    }

public:
    // Function to merge the arrays
    void merge(long long arr1[], long long arr2[], int n, int m) {
        // Total length of the virtual combined array
        int len = n + m;

        // Calculate initial gap: ceil((n + m) / 2)
        int gap = (len / 2) + (len % 2);

        while (gap > 0) {
            int left = 0;
            int right = left + gap;

            while (right < len) {
                // CASE 1: Left pointer in arr1[], Right pointer in arr2[]
                if (left < n && right >= n) {
                 // Convert to arr2's 0-based index, right should point 0,1 indexes, etc. of arr2.
                    swapIfGreater(arr1, arr2, left, right - n); }
                    
                // CASE 2: Both pointers in arr2[]
                else if (left >= n) {
                    swapIfGreater(arr2, arr2, left - n, right - n);
                }
                
                // CASE 3: Both pointers in arr1[]
                else {
                    swapIfGreater(arr1, arr1, left, right);
                }

                // Move pointers forward
                left++; 
                right++;
            }

            // Break if we just finished the gap=1 iteration
            if (gap == 1) break;

            // Reduce gap: ceil(gap / 2)
            gap = (gap / 2) + (gap % 2);
        }
    }
};

int main() {
    // Example Input
    long long arr1[] = {1, 3, 5, 7};
    long long arr2[] = {0, 2, 6, 8, 9};
    int n = sizeof(arr1) / sizeof(arr1[0]);
    int m = sizeof(arr2) / sizeof(arr2[0]);

    Solution obj;
    obj.merge(arr1, arr2, n, m);

    cout << "After Merging: \n";
    cout << "Arr1: ";
    for (int i = 0; i < n; i++) cout << arr1[i] << " ";
    cout << "\nArr2: ";
    for (int i = 0; i < m; i++) cout << arr2[i] << " ";
    cout << endl;

    return 0;
}
```

### ðŸ“Š Complexity Analysis:
*   **Time Complexity:** $O((N+M) \times \log(N+M))$
    *   The gap reduction loop runs for $\log(N+M)$ times, and the inner loop traverses $(N+M)$ elements.
*   **Space Complexity:** $O(1)$
    *   We are sorting in-place without using extra arrays.


