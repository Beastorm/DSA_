## next_permutation: find next lexicographically greater permutation

**Problem Statement:**  
Given an array `Arr[]` of integers, rearrange the numbers of the given array into the lexicographically **next greater permutation** of numbers.

If such an arrangement is not possible, rearrange to the **lowest possible order** (i.e., sorted in ascending order).


### Examples

**Example 1:**

**Input:** `Arr[] = {1, 3, 2}`  
**Output:** `{2, 1, 3}`  

**Explanation:**  
All permutations of `{1,2,3}` are:  
`{1,2,3}`, `{1,3,2}`, `{2,1,3}`, `{2,3,1}`, `{3,1,2}`, `{3,2,1}`.  
So, the next permutation just after `{1,3,2}` is `{2,1,3}`.

**Example 2:**  

**Input:** `Arr[] = {3, 2, 1}`  
**Output:** `{1, 2, 3}`  

**Explanation:**  
As we see all permutations of `{1,2,3}`, we find `{3,2,1}` at the last position.  
So, we have to return the **lowest permutation**.

---

## Brute-Force Approach

### Algorithm

The brute force approach to find the next permutation is to:

1. Find **all possible permutations** of the array.
2. Sort all these permutations lexicographically.
3. Find the current permutation in this sorted list.
4. Return the permutation that appears **right after** the current one.
5. If the current permutation is the **last** in the list, return the **first** permutation (i.e., the smallest one).

Steps:

1. Generate all permutations of the array and store them in a list.
2. Sort the list of permutations.
3. Linearly search for the current permutation.
4. If found at index `i`:
   - If `i` is the last index, return the first permutation.
   - Else, return the permutation at index `i + 1`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the next permutation
    vector<int> nextPermutation(vector<int>& nums) {
        // Store all permutations
        vector<vector<int>> all;

        // Generate all permutations
        sort(nums.begin(), nums.end());
        do {
            all.push_back(nums);
        } while (next_permutation(nums.begin(), nums.end()));

        // Traverse the list to find the current permutation
        for (int i = 0; i < all.size(); i++) {
            if (all[i] == nums) {
                // If it's the last permutation
                if (i == all.size() - 1)
                    return all[0];
                // Return the next one
                return all[i + 1];
            }
        }

        // Return original if not found (shouldn't happen)
        return nums;
    }
};

int main() {
    Solution sol;
    vector<int> nums = {1, 2, 3};

    vector<int> result = sol.nextPermutation(nums);

    for (int x : result) cout << x << " ";
    cout << endl;

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N! \cdot N)$  
  We generate all possible permutations of the array, which is $N!$ permutations, and each permutation is of length $N$ (copying/comparing takes $O(N)$). 
  So overall time is $O(N! \cdot N)$.

* **Space Complexity:** $O(N!)$  
  We store all permutations in a vector of vectors. In the worst case, this requires space proportional to the number of permutations, 
  i.e., $N!$ (each storing an array of size $N$).

---

### Optimal Approach

**Algorithm**

We want to rearrange the array to form the **next greater permutation**. If that's not possible (i.e., it's already the last permutation in lexicographic order), we return the **smallest** one (i.e., sorted ascendingly).

To find this next permutation with minimal change:

1. **Find the "breaking point":**  
   Traverse from the end and find the first index `i` such that `nums[i] < nums[i + 1]`.  
   This index is the position where we can make a small increase to get the next permutation.

2. **If no breaking point exists:**  
   That means the entire array is in **descending order** (e.g., `[3,2,1]`), which is the last permutation.  
   In this case, simply **reverse the whole array** to get the first permutation (smallest).

3. **Find the element just larger than `nums[index]`:**  
   Again, traverse from the end, and find the first element greater than `nums[index]`. Swap them.

4. **Reverse the suffix:**  
   Finally, reverse the subarray to the right of `index` (`[index+1 ... end]`) to make it as small as possible, giving the next lexicographically minimal configuration after the swap.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class
class Solution {
public:
    // Function to find next permutation
    void nextPermutation(vector<int>& nums) {
        // Set index to -1
        int index = -1;

        // Find the first decreasing element from the end
        for (int i = nums.size() - 2; i >= 0; i--) {
            // If a smaller element is found
            if (nums[i] < nums[i + 1]) {
                // Store index
                index = i;
                break;
            }
        }

        // If no such index found
        if (index == -1) {
            // Reverse the entire array
            reverse(nums.begin(), nums.end());
            return;
        }

        // Find element just greater than nums[index]
        for (int i = nums.size() - 1; i > index; i--) {
            // Swap the two
            if (nums[i] > nums[index]) {
                swap(nums[i], nums[index]);
                break;
            }
        }

        // Reverse the part after index
        reverse(nums.begin() + index + 1, nums.end());
    }
};

// Main function
int main() {
    // Input array
    vector<int> nums = {1, 2, 3};

    // Create object
    Solution sol;

    // Call the function
    sol.nextPermutation(nums);

    // Print result
    for (int num : nums) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

### Complexity Analysis

Let `n = nums.size()`.  
Let `P` = number of permutations (`P = n!` if all elements are distinct).

 * **Time**  
   1. Generate all permutations:
      - Runs `P` times
      - Each step copies the array (`O(n)`) and `next_permutation` is `O(n)`
      - Total: `O(P * n)`
   
   2. Search for the current permutation in `all`:
      - Up to `P` checks
      - Each check compares vectors in `O(n).`
      - Total: `O(P * n)`

   Overall:
   - **Time = `O(P * n)`**, i.e. **`O(n * n!)`** when all elements are distinct.

* **Space**  
   - Stores all permutations: `P` vectors, each of size `n.`
   
   So:
   - **Space = `O(P * n)`**, i.e. **`O(n * n!)`**.
