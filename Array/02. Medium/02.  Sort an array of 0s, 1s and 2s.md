## Sort an array of 0s, 1s and 2s

**Problem Statement:**  
Given an array `nums` consisting of only `0`, `1`, or `2`. Sort the array in non-decreasing order. The sorting must be done **in-place**, without making a copy of the original array.

---

>### Examples

### Example 1:
**Input:** `nums = [1, 0, 2, 1, 0]`  
**Output:** `[0, 0, 1, 1, 2]`  
**Explanation:** The `nums` array in sorted order has 2 zeroes, 2 ones, and 1 two.

---
### Example 2:
**Input:** `nums = [0, 0, 1, 1, 1]`  
**Output:** `[0, 0, 1, 1, 1]`  
**Explanation:** The `nums` array in sorted order has 2 zeroes, 3 ones, and zero twos.

---

## Brute Force Approach

### Algorithm:

We are given an array containing only 0s, 1s, and 2s. Since the values are fixed and known, the simplest approach is to first **count** how many 0s, 1s, and 2s are present in the array. After counting, we overwrite the original array based on the frequency of these values: first fill it with 0s, then 1s, then 2s. This does not require any extra array and modifies the input array in-place.

1. Initialize three counters to count the frequency of 0s, 1s, and 2s.
2. Loop through the array once and count each number.
3. In the second phase, fill the array based on the frequency of each number: first 0s, then 1s, then 2s.


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to sort the array containing only 0s, 1s, and 2s
    void sortZeroOneTwo(vector<int>& nums) {
        // Initialize count variables for 0s, 1s, and 2s
        int count0 = 0, count1 = 0, count2 = 0;

        // Count the frequency of 0s, 1s, and 2s in the array
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] == 0) count0++;
            else if(nums[i] == 1) count1++;
            else count2++;
        }

        // Overwrite the array with the counted values
        int index = 0;

        // Fill with 0s
        while(count0--) {
            nums[index++] = 0;
        }

        // Fill with 1s
        while(count1--) {
            nums[index++] = 1;
        }

        // Fill with 2s
        while(count2--) {
            nums[index++] = 2;
        }
    }
};

// Driver code
int main() {
    vector<int> nums = {1, 0, 2, 1, 0};

    Solution obj;
    obj.sortZeroOneTwo(nums);

    for(int x : nums) {
        cout << x << " ";
    }

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n)$  
  We traverse the array twice: once to count, once to overwrite. Each traversal is $O(n)$.

* **Space Complexity:** $O(1)$  
  We use only a constant number of counters regardless of the input size. No extra array is used.

---

## Better Approach: Counting 0s, 1s, and 2s

### Algorithm:

Since the array contains only `0`s, `1`s, and `2`s, we can exploit this limited range of values to count how many of each element exists. Once we know how many `0`s, `1`s, and `2`s are in the array, we can simply overwrite the original array by placing that many `0`s, then `1`s, and then `2`s in order. This approach avoids sorting and gives a linear-time, constant-space solution.

1. Initialize three counters to zero: one each for `0`s, `1`s, and `2`s.
2. Traverse the entire array and increment the respective counter based on the element value.
3. After counting, overwrite the array:
   - Place all `0`s first (based on count of `0`s).
   - Then all `1`s (based on count of `1`s).
   - Then all `2`s (based on count of `2`s).


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to sort an array containing only 0s, 1s, and 2s
    void sortZeroOneTwo(vector<int>& nums) {
        // Count of 0s, 1s, and 2s
        int cnt0 = 0, cnt1 = 0, cnt2 = 0;

        // First pass: Count the number of 0s, 1s, and 2s
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) cnt0++;
            else if (nums[i] == 1) cnt1++;
            else cnt2++;
        }

        // Second pass: Fill the array with 0s, then 1s, then 2s

        // Fill the first 'cnt0' elements with 0
        for (int i = 0; i < cnt0; i++) {
            nums[i] = 0;
        }

        // Fill the next 'cnt1' elements with 1
        for (int i = cnt0; i < cnt0 + cnt1; i++) {
            nums[i] = 1;
        }

        // Fill the remaining elements with 2
        for (int i = cnt0 + cnt1; i < nums.size(); i++) {
            nums[i] = 2;
        }
    }
};

// Driver code
int main() {
    vector<int> nums = {0, 2, 1, 2, 0, 1};

    Solution sol;
    sol.sortZeroOneTwo(nums);

    cout << "After sorting:" << endl;
    for (int i = 0; i < nums.size(); i++) {
        cout << nums[i] << " ";
    }
    cout << endl;

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n)$  
  We make two passes through the array: one for counting and one for updating. So the total time is proportional to the size of the array.

* **Space Complexity:** $O(1)$  
  Only three integer variables (`cnt0`, `cnt1`, `cnt2`) are used for counting. No extra space is used proportional to the input size.
  

---

## Optimal Approach: Dutch National Flag Algorithm

### Algorithm:

This approach is a direct implementation of the **Dutch National Flag** algorithm.

We divide the array into three partitions using three pointers – `low`, `mid`, and `high`:

- From index `0` to `low-1` → only `0`s
- From index `low` to `mid-1` → only `1`s
- From index `high+1` to `n-1` → only `2`s
- The range from `mid` to `high` is the **unsorted zone** we’re scanning and fixing.

At each step:

- If `arr[mid] == 0`, it belongs to the left section  
  → swap with `arr[low]`, move both `low++` and `mid++`.
- If `arr[mid] == 1`, it’s already in the middle section  
  → just move `mid++`.
- If `arr[mid] == 2`, it belongs to the right section  
  → swap with `arr[high]`, move only `high--`.

When you swap with `high`, you **do not** move `mid` because the element that comes from the `high` position might still be `0` or `2` and needs to be processed.

This ensures we **sort the array in a single pass** without using extra space.

**Steps:**

1. Start with three pointers at the beginning (`low`, `mid`) and end (`high`) of the array.
2. Iterate while `mid <= high`:
   - If the current element belongs to the front section (`0`):
     - Swap it with the element at `low`.
     - Move both `low++` and `mid++`.
   - If the current element belongs to the middle section (`1`):
     - Move `mid++`.
   - If the current element belongs to the end section (`2`):
     - Swap it with the element at `high`.
     - Move `high--`.
3. Repeat until all elements are in their correct zones.


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to sort array containing 0s, 1s, and 2s using Dutch National Flag Algorithm
    void sortZeroOneTwo(vector<int>& nums) {
        // Initialize three pointers: low, mid starting from 0, high from the end of the array
        int low = 0, mid = 0, high = nums.size() - 1;

        // Process elements until the mid pointer crosses the high pointer
        while (mid <= high) {
            // If the current element is 0, swap with low and move both pointers forward
            if (nums[mid] == 0) {
                swap(nums[mid], nums[low]);
                mid++;
                low++;
            }
            // If current element is 1, it's already in the correct place → move mid forward
            else if (nums[mid] == 1) {
                mid++;
            }
            // If the current element is 2, swap with high and move only the high pointer backward
            else {
                swap(nums[mid], nums[high]);
                high--;
            }
        }
    }
};

// Driver code
int main() {
    Solution obj;
    vector<int> nums = {2, 0, 2, 1, 1, 0};

    obj.sortZeroOneTwo(nums);

    for (int val : nums)
        cout << val << " ";

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n)$  
  The array is traversed only once using the `mid` pointer. Each element is checked at most once, and swaps are done in constant time.

* **Space Complexity:** $O(1)$  
  Only a few integer pointers (`low`, `mid`, `high`) are used. Sorting is done in-place, requiring no additional space.
