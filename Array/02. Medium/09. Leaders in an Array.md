## Leaders in an Array

**Problem Statement:**  
Given an array, a **leader** is an element that is **strictly greater than all the elements to its right**. The rightmost element is always a leader.

---

### Examples

**Example 1:**

**Input:**  
`arr = [4, 7, 1, 0]`  

**Output:**  
`7 1 0`  

**Explanation:**  
The rightmost element (`0`) is always a leader.  
`7` and `1` are greater than all the elements to their right, making them leaders as well.

---

**Example 2:**

**Input:**  
`arr = [10, 22, 12, 3, 0, 6]`  

**Output:**  
`22 12 6`  

**Explanation:**  
- `6` is a leader because there are no elements after it.  
- `12` is greater than all the elements to its right (`3, 0, 6`).  
- `22` is greater than `12, 3, 0, 6`, so it is also a leader.

---

## Brute Force Approach

### Algorithm

In this brute force approach, we check for each element if it is greater than all the elements to its right.

1. Use an **outer loop** to pick each element `nums[i]` as a candidate leader.
2. Use an **inner loop** from `i+1` to the end to check if any element to the right is **greater than or equal** to `nums[i]`.
3. If such an element is found, `nums[i]` is **not** a leader.
4. If no element to the right is greater than or equal, then `nums[i]` is a **leader** and is added to the answer list.
5. Return the list of leaders.

```cpp
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find leaders in an array.
    vector<int> leaders(vector<int>& nums) {
        vector<int> ans;

        // Iterate through each element in nums
        for (int i = 0; i < nums.size(); i++) {
            bool leader = true;

            /* Check whether nums[i] is greater
               than all elements to its right */
            for (int j = i + 1; j < nums.size(); j++) {
                if (nums[j] >= nums[i]) {
                    /* If any element to the right is greater 
                       or equal, nums[i] is not a leader */
                    leader = false;
                    break;
                }
            }

            // If nums[i] is a leader, add it to the ans vector
            if (leader) {
                ans.push_back(nums[i]);
            }
        }

        // Return the leaders 
        return ans;
    }
};

int main() {
    vector<int> nums = {1, 2, 5, 3, 1, 2};

    // Create an instance of the Solution class
    Solution finder;

    // Get leaders using class method
    vector<int> ans = finder.leaders(nums);

    cout << "Leaders in the array are: ";
    for (int i = 0; i < ans.size(); i++) {
        cout << ans[i] << " ";
    }
    cout << endl;

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N^2)$  
  Where $N$ is the size of the input array. This is because we have a nested loop where the outer loop runs $N$ times, and the inner loop runs up to $N$ times 
  in the worst case.

* **Space Complexity:** $O(1)$  
  As we are using only a constant amount of extra space for variables (the space for the answer array is typically not counted as extra space 
  since it is the required output).

---

## Optimal Approach

**Algorithm**

1. The last element of the array is **always a leader**, since there are no elements to its right.
2. Initialize:
   - `max` = last element (`nums[n-1]`)
   - `ans` = list of leaders, initially containing the last element.
3. Traverse the array from **right to left**, starting from index `n-2` down to `0`:
   - If `nums[i] > max`, then `nums[i]` is a leader:
     - Push it into `ans`
     - Update `max = nums[i]`
4. After iterating, `ans` contains leaders in **reverse order of appearance**, so reverse `ans` to restore original left-to-right order.
5. Return `ans`.

```cpp
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the leaders in an array.
    vector<int> leaders(vector<int>& nums) {
        vector<int> ans;
        
        if(nums.empty()) {
            return ans;
        }
        
        // Last element of the vector is always a leader
        int max = nums[nums.size() - 1];
        ans.push_back(nums[nums.size() - 1]);
        
        // Check elements from right to left
        for (int i = nums.size() - 2; i >= 0; i--) {
            if (nums[i] > max) {
                ans.push_back(nums[i]);
                max = nums[i];
            }
        }
        
        /* Reverse the vector to match
           the required output order */
        reverse(ans.begin(), ans.end());
        
        // Return the leaders
        return ans;
    }
};

int main() {
    vector<int> nums = {10, 22, 12, 3, 0, 6};
    
    // Create an instance of the Solution class
    Solution finder;
    
    // Get leaders using the class method
    vector<int> ans = finder.leaders(nums);
    
    cout << "Leaders in the array are: ";
    for (int i = 0; i < ans.size(); i++) {
        cout << ans[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

### Complexity Analysis

* **Time Complexity:** $O(N)$  
  Where $N$ is the size of the input array. We traverse the array only once from right to left.

* **Space Complexity:** $O(1)$  
  Apart from the output vector of leaders, which is required to store the result, we use only a constant amount of extra space.
