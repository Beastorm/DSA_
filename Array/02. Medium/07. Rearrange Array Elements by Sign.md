## Re-arrange Array Elements by Sign

**Problem Statement:**  
There’s an array `A` of size `N` with an equal number of positive and negative elements.  
Without altering the relative order of positive and negative elements, you must return an array of **alternately positive and negative** values.


### Examples

**Example 1:**

**Input:**  
`arr[] = {1, 2, -4, -5}, N = 4`  

**Output:**  
`1 -4 2 -5`  

**Explanation:**  
Positive elements = `1, 2`  
Negative elements = `-4, -5`  
To maintain relative ordering, `1` must occur before `2`, and `-4` must occur before `-5`.


**Example 2:**  

**Input:**  
`arr[] = {1, 2, -3, -1, -2, -3}, N = 6`  

**Output:**  
`1 -3 2 -1 3 -2`  

**Explanation:**  
Positive elements = `1, 2, 3`  
Negative elements = `-3, -1, -2`  
To maintain relative ordering:
- `1` comes before `2`, and `2` comes before `3`.
- `-3` comes before `-1`, and `-1` comes before `-2`.

---

## Brute Force Approach

### Algorithm

1. Since the number of positive and negative elements are the same, we first separate them:
   - Put all positive numbers into an array `pos`.
   - Put all negative numbers into an array `neg`.
2. After segregating each of the positive and negative elements, we start putting them **alternately back** into array `A`.
3. The array must begin with a **positive number**, and the start index is `0`, so:
   - All positive numbers will be placed at **even indices** (`2 * i`).
   - All negative numbers will be placed at **odd indices** (`2 * i + 1`), where `i` is the index into `pos` / `neg` while traversing them simultaneously.
4. This approach uses multiple traversals over the data (to split and then to merge back).

```cpp
#include <bits/stdc++.h>
using namespace std;

// Class to encapsulate array operations
class ArrayManipulator {
public:
    // Function to rearrange elements so that positives and negatives alternate
    vector<int> RearrangeBySign(vector<int>& A, int n) {
        vector<int> pos; // Vector to store positive numbers
        vector<int> neg; // Vector to store negative numbers

        // Step 1: Separate positives and negatives
        for (int i = 0; i < n; i++) {
            if (A[i] > 0)
                pos.push_back(A[i]); // Add positive to pos[]
            else
                neg.push_back(A[i]); // Add negative to neg[]
        }

        // Step 2: Place positives at even indices and negatives at odd indices
        for (int i = 0; i < n / 2; i++) {
            A[2 * i] = pos[i];      // Even index → positive
            A[2 * i + 1] = neg[i];  // Odd index → negative
        }

        return A; // Return the rearranged array
    }
};

// Driver code
int main() {
    int n = 4;
    vector<int> A{1, 2, -4, -5};

    // Create an object of the class
    ArrayManipulator obj;

    // Call the function and get the result
    vector<int> ans = obj.RearrangeBySign(A, n);

    // Print the rearranged array
    for (int i = 0; i < ans.size(); i++) {
        cout << ans[i] << " ";
    }

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N + N/2) \approx O(N)$  
  - $O(N)$ for traversing the array once to segregate positives and negatives.  
  - $O(N/2)$ for writing them back alternately into the original array.  
  Here, $N$ is the size of the array `A`.

* **Space Complexity:** $O(N/2 + N/2) = O(N)$  
  - $N/2$ space for the `pos` array (positive elements).  
  - $N/2$ space for the `neg` array (negative elements).  
  So, overall auxiliary space is linear in $N$.

---

## Optimal Approach

**Algorithm**

In this optimal approach, we will try to solve the problem in a **single pass** and arrange the array elements in the correct order during that pass itself.

- We know that the resultant array must start with a **positive element**, so we initialize:
  - `posIndex = 0`  → next position for a positive number (even index)
  - `negIndex = 1`  → next position for a negative number (odd index)
- Traverse the array once:
  - When we see a positive element, place it at `ans[posIndex]` and increase `posIndex` by 2.
  - When we see a negative element, place it at `ans[negIndex]` and increase `negIndex` by 2.
- Because the number of positive and negative numbers is equal and we place them alternately, by the end of the traversal, the entire array will be rearranged correctly.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Define a class to handle array manipulation
class ArrayManipulator {
public:
    // Function to rearrange elements by alternating sign
    vector<int> rearrangeBySign(vector<int>& A) {
        int n = A.size();

        // Create a result array of size n initialized with 0
        vector<int> ans(n, 0);

        // posIndex will store the index for the next positive number (even index)
        // negIndex will store the index for the next negative number (odd index)
        int posIndex = 0, negIndex = 1;

        // Loop through the original array
        for (int i = 0; i < n; i++) {
            if (A[i] < 0) {
                // Place negative numbers at odd indices
                ans[negIndex] = A[i];
                negIndex += 2;
            } else {
                // Place positive numbers at even indices
                ans[posIndex] = A[i];
                posIndex += 2;
            }
        }

        return ans;
    }
};

int main() {
    // Initialize the input array
    vector<int> A = {1, 2, -4, -5};

    // Create an object of the class
    ArrayManipulator obj;

    // Call the rearrange function
    vector<int> result = obj.rearrangeBySign(A);

    // Print the rearranged array
    for (int num : result) {
        cout << num << " ";
    }

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(N)$  
  $O(N)$ for traversing the array once and placing positives and negatives simultaneously using pointers, where $N$ is the size of the array `A`.

* **Space Complexity:** $O(N)$  
  Extra space is used to store the rearranged elements separately in an auxiliary array of size $N$.
