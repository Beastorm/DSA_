## Stock Buy And Sell  

**Problem Statement:**  
You are given an array of prices where `prices[i]` is the price of a given stock on day `i`. You want to maximize your profit by choosing a single day to **buy** one stock and choosing a **different day in the future** to **sell** that stock.  
Return the maximum profit you can achieve from this transaction.  
If you cannot achieve any profit, return `0`.

---

### Examples

**Input:** `prices = [7,1,5,3,6,4]`  
**Output:** `5`  
**Explanation:**  
Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = `6 - 1 = 5`.  
Note: Buying on day 2 and selling on day 1 is not allowed because you must buy **before** you sell.  

**Input:** `prices = [7,6,4,3,1]`  
**Output:** `0`  
**Explanation:**  
In this case, no transactions are done, and the max profit = 0.

---

## Brute Force Approach

### Algorithm

We try every possible pair of days (buy day and sell day after buy) and calculate the profit.  
The **maximum profit** among all these pairs is our answer. If no profit is possible, return `0`.

1. Loop through all days to consider each as a possible **buy** day.
2. For each buy day, loop through all **future** days to consider them as **sell** days.
3. Calculate the profit for each `(buy, sell)` pair: `prices[sell] - prices[buy]`.
4. Track the maximum profit seen over all pairs.
5. Return the maximum profit (or `0` if it never becomes positive).

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate max profit using brute force
    int stockbuySell(vector<int>& prices) {
        // Initialize max profit to 0
        int maxProfit = 0;

        // Loop through each day as a potential buy day
        for(int i = 0; i < prices.size(); i++) {
            // Loop through each future day as a potential sell day
            for(int j = i + 1; j < prices.size(); j++) {
                // Calculate the profit
                int profit = prices[j] - prices[i];

                // Update max profit if this is higher
                maxProfit = max(maxProfit, profit);
            }
        }

        // Return the maximum profit
        return maxProfit;
    }
};

// Driver code
int main() {
    Solution sol;
    vector<int> prices = {7, 1, 5, 3, 6, 4};
    cout << "Max Profit: " << sol.stockbuySell(prices) << endl;
    return 0;
}
```

### Complexity Analysis

* **Time Complexity:** $O(n^2)$  
  Because for each element, we are checking every future element using nested loops.

* **Space Complexity:** $O(1)$  
  No extra space is used, only variables for storing the maximum profit.

---

### Optimal Approach: Single Pass (Track Min Price)

**Algorithm**

The idea is to track the minimum price so far while traversing the array and calculate the profit if we sold today. This way, we can constantly update the maximum profit without using nested loops. We’re basically simulating:

- What’s the lowest price we’ve seen so far?
- What’s the profit if we sold today?
- Is it better than our best so far?

Steps:

1. Initialize a variable `minPrice` to store the minimum price so far, set it to a very large value initially (e.g., `INT_MAX`).
2. Initialize a variable `maxProfit` to store the maximum profit seen so far, set it to `0` initially.
3. Loop through each `price` in the array:
   - Update `minPrice` if the current price is smaller.
   - Otherwise, calculate the profit if the stock were bought at `minPrice` and sold at the current `price`.
   - Update `maxProfit` if this new profit is higher.
4. Return `maxProfit` after the loop ends.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate maximum profit using a single pass
    int stockbuySell(vector<int>& prices) {
        // Initialize the minimum price to a large number
        int minPrice = INT_MAX;

        // Initialize the maximum profit to 0
        int maxProfit = 0;

        // Traverse each price in the array
        for (int price : prices) {
            // If current price is less than minPrice, update minPrice
            if (price < minPrice) {
                minPrice = price;
            }
            // Else calculate profit and update maxProfit if it's greater
            else {
                maxProfit = max(maxProfit, price - minPrice);
            }
        }

        // Return the maximum profit found
        return maxProfit;
    }
};

// Driver code
int main() {
    Solution obj;
    vector<int> prices = {7, 1, 5, 3, 6, 4};

    cout << obj.stockbuySell(prices) << endl;

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(n)$  
  We traverse the price array exactly once, doing only constant-time work per element.

* **Space Complexity:** $O(1)$  
  We use only a couple of variables (`minPrice`, `maxProfit`) regardless of input size.
