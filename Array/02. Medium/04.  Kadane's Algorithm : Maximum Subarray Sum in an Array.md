## Kadane's Algorithm: Maximum Subarray Sum in an Array

**Problem Statement:**  
Given an integer array `nums`, find the subarray with the largest sum and return the sum of the elements present in that subarray.

A **subarray** is a contiguous non-empty sequence of elements within an array.

---

### Examples

**Example 1:**

**Input:**  
`nums = [2, 3, 5, -2, 7, -4]`  

**Output:**  
`15`  

**Explanation:**  
The subarray from index `0` to index `4` has the largest sum = `15`, which is the maximum sum of any contiguous subarray.

---

**Example 2:**

**Input:**  
`nums = [-2, -3, -7, -2, -10, -4]`  

**Output:**  
`-2`  

**Explanation:**  
The largest sum is `-2`, which comes from taking the element at index `0` or index `3` as the subarray.  
Since all numbers are negative, the subarray with the least negative number gives the largest sum.

---

## Brute Force

### Algorithm

1. Iterate through the array with variable `i`, which represents the **starting index** of each subarray.  
   The possible values for `i` range from `0` to `n-1`, where `n` is the size of the array.
2. Inside the first loop, run another loop with variable `j` that represents the **ending index** of the subarray.  
   For each `i`, `j` can range from `i` to `n-1`.
3. For each subarray defined by `i` and `j`, iterate through its elements to calculate the sum.
4. Maintain a variable `maxi` to store the **maximum sum** encountered so far during the iteration.
5. At each step, compare the current subarray sum with the current `maxi` value.  
   If the current sum is greater, update `maxi` with the new sum.
6. Finally, after completing all iterations, return `maxi`, which holds the maximum sum of any subarray.

```cpp
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the maximum sum of subarrays
    int maxSubArray(vector<int>& nums) {
        
        // Initialize maximum sum with the smallest possible integer
        int maxi = INT_MIN; 

        // Iterate over each starting index of subarrays
        for (int i = 0; i < nums.size(); i++) {
            
            // Iterate over each ending index of subarrays starting from i
            for (int j = i; j < nums.size(); j++) {
                
                // Variable to store the sum of the current subarray
                int sum = 0; 

                // Calculate the sum of subarray nums[i...j]
                for (int k = i; k <= j; k++) {
                    sum += nums[k];
                }

                // Update maxi with the maximum of its current value and the sum of the current subarray
                maxi = max(maxi, sum);
            }
        }
        
        // Return the maximum subarray sum found
        return maxi; 
    }
};

int main() {
    vector<int> arr = { -2, 1, -3, 4, -1, 2, 1, -5, 4};
    
    // Create an instance of the Solution class
    Solution sol;
    
    int maxSum = sol.maxSubArray(arr);
    
    // Print the max subarray sum
    cout << "The maximum subarray sum is: " << maxSum << endl;
    return 0;
}
```

### Complexity Analysis

* **Time Complexity:** $O(N^3)$  
  Where $N$ is the size of the array. This is because we have three nested loops: one for the starting index, one for the ending index, and one for calculating the sum of the subarray.

* **Space Complexity:** $O(1)$  
  As we are using a constant amount of space for variables, regardless of the input size.

---

### Better Approach: Prefix Sum Optimization (Still Brute-Force)

**Algorithm**

1. Iterate through the array with variable `i`, which represents the **starting index** of each subarray. The possible values for `i` range from `0` to `n-1`, where `n` is the size of the array.
2. Inside the first loop, iterate again with variable `j` to signify the **ending index** of the subarray and the current element of the subarray. For each `i`, `j` can range from `i` to `n-1`.
3. For each subarray defined by `[i, j]`, **add** the current element `nums[j]` to the running sum `sum` (which holds the sum of `nums[i..j-1]`).
4. Keep track of the **maximum sum** encountered during the iteration using a variable, say `maxi`, and update it whenever a greater sum is found.
5. Once all iterations are complete, return `maxi` as the maximum sum of all subarrays.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the maximum sum of subarrays
    int maxSubArray(vector<int>& nums) {
        
        // Initialize maximum sum with the smallest possible integer
        int maxi = INT_MIN; 

        // Iterate over each starting index of subarrays
        for (int i = 0; i < nums.size(); i++) {
            
            // Variable to store the sum of the current subarray
            int sum = 0; 
            
            // Iterate over each ending index of subarrays starting from i
            for (int j = i; j < nums.size(); j++) {
                
                // Add the current element nums[j] to the sum i.e. sum of nums[i...j-1]
                sum += nums[j];

                // Update maxi with the maximum of its current value and the sum of the current subarray
                maxi = max(maxi, sum);
            }
        }

        // Return the maximum subarray sum found
        return maxi;
    }
};

int main() {
    vector<int> arr = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };

    // Create an instance of the Solution class
    Solution sol;

    int maxSum = sol.maxSubArray(arr);

    // Print the max subarray sum
    cout << "The maximum subarray sum is: " << maxSum << endl;

    return 0;
}
```

### Complexity Analysis

* **Time Complexity:** $O(N^2)$  
  Where $N$ is the size of the array. This is because we have two nested loops: one for the starting index and one for the ending index of the subarray.

* **Space Complexity:** $O(1)$  
  As we are using a constant amount of space for variables, regardless of the input size.

---

### Optimal Approach: Kadaneâ€™s Algorithm

**Algorithm**

1. Iterate through the array using a variable `i`. During each iteration, add the current element `arr[i]` to a running sum variable `sum`.
2. Keep track of the maximum sum encountered during the iteration by comparing the current sum with the previous maximum sum (`maxi`), and update it if the current sum is greater.
3. If at any point `sum` becomes negative, reset it to `0`, as a negative sum won't contribute positively to the overall maximum sum.
4. Continue the iteration until all elements in the array are processed.
5. Finally, return the maximum sum stored in `maxi`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the maximum sum of subarrays
    int maxSubArray(vector<int>& nums) {
        
        // maximum sum
        long long maxi = LLONG_MIN; 
        
        // current sum of subarray
        long long sum = 0; 
        
        // Iterate through the array
        for (int i = 0; i < nums.size(); i++) {
            
            // Add current element to the sum
            sum += nums[i]; 
            
            // Update maxi if the current sum is greater
            if (sum > maxi) {
                maxi = sum; 
            }
            
            // Reset sum to 0 if it becomes negative
            if (sum < 0) {
                sum = 0; 
            }
        }
        
        // Return the maximum subarray sum found
        return maxi;
    }
};

int main() {
    vector<int> arr = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };

    // Create an instance of the Solution class
    Solution sol;

    int maxSum = sol.maxSubArray(arr);

    // Print the max subarray sum
    cout << "The maximum subarray sum is: " << maxSum << endl;

    return 0;
}
```

### Complexity Analysis

* **Time Complexity:** $O(n)$  
  Where $n$ is the number of elements in the array. We traverse the array only once.

* **Space Complexity:** $O(1)$  
  We use a constant amount of space for variables.

---

### Follow Up

**Question:**  
Can you print the subarray that has the maximum sum?

**Algorithm / Intuition**

1. Start iterating through the array, maintaining a running sum `sum`.
2. Maintain a variable `start` to track the starting index of the **current** subarray.
3. Maintain two variables `ansStart` and `ansEnd` to store the starting and ending indices of the **best (maximum sum)** subarray found so far; initialize them to `-1`.
4. At each index `i`:
   - If `sum == 0`, set `start = i` (potential start of a new subarray).
   - Add `nums[i]` to `sum`.
   - If `sum` becomes greater than the previous maximum `maxi`, update:
     - `maxi = sum`
     - `ansStart = start`
     - `ansEnd = i`
   - If `sum` becomes negative, reset `sum = 0` (discard this subarray and start fresh from the next index).
5. After the loop ends, `ansStart` and `ansEnd` indicate the subarray with the maximum sum.
6. Print or return the elements from `nums[ansStart]` to `nums[ansEnd]`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the maximum sum of subarrays and print the subarray having the maximum sum
    int maxSubArray(vector<int>& nums) {
        
        // maximum sum
        long long maxi = LLONG_MIN; 
        
        // current sum of subarray
        long long sum = 0;
        
        // starting index of current subarray
        int start = 0; 
        
        // indices of the maximum sum subarray
        int ansStart = -1, ansEnd = -1; 
        
        // Iterate through the array
        for (int i = 0; i < nums.size(); i++) {
            
            // update starting index if sum is reset
            if (sum == 0) {
                start = i;
            }
            
            // add current element to the sum
            sum += nums[i]; 
            
            /* Update maxi and subarray indices
               if current sum is greater */
            if (sum > maxi) {
                maxi = sum;
                ansStart = start;
                ansEnd = i;
            }
            
            // Reset sum to 0 if it becomes negative
            if (sum < 0) {
                sum = 0;
            }
        }
        
        // Printing the subarray
        cout << "The subarray is: [";
        for (int i = ansStart; i <= ansEnd; i++) {
            cout << nums[i] << " ";
        }
        cout << "]" << endl;
        
        // Return the maximum subarray sum found
        return maxi;
    }
};

int main() {
    vector<int> arr = { -2, 1, -3, 4, -1, 2, 1, -5, 4 };

    // Create an instance of the ********Solution class
    Solution sol;

    int maxSum = sol.maxSubArray(arr);

    // Print the max subarray sum
    cout << "The maximum subarray sum is: " << maxSum << endl;

    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(n)$  
  Where $n$ is the number of elements in the array. We traverse the array only once.

* **Space Complexity:** $O(1)$  
  We use a constant amount of space for variables.
