## Rotate Matrix by 90° Clockwise:

Original matrix:
```
1  2  3  4
5  6  7  8
9  10 11 12
13 14 15 16
```

After 90° clockwise rotation:
```
13 9  5 1
14 10 6 2
15 11 7 3
16 12 8 4
```

### Naive Approach- Index mapping (0-based):  
An element at `(i, j)` in the original goes to `(j, n-1-i)` in the rotated matrix.

*Formula:*
`rotated[j][n-1-i] = original[i][j]`

*Example mappings for* `n = 4`
- `(0,0) → (0,3)`
- `(0,1) → (1,3)`
- `(0,2) → (2,3)`
- `(0,3) → (3,3)`

- `(1,0) → (0,2)`
- `(1,1) → (1,2)`
- `(1,2) → (2,2)`
- `(1,3) → (3,2)`
      
Here are the column indices of the original matrix, same as the row indices of the rotated matrix,
and the sum of the row indices of the original matrix and the rotated column index is  equal to the number of columns/rows, .ie, `i+x = 4`.
`i+x=n-1``
So, `x= n-1-i`.
So, `(j, n-1-i)`.

*General relation:*
- `i + newCol = n - 1`
- so `newCol = n - 1 - i`
- and `newRow = j`

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> a[i][j];
    }

    // Naive rotation using extra matrix
    vector<vector<int>> rotated(n, vector<int>(n, 0));

    // Mapping: (i, j) -> (j, n-1-i)
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            rotated[j][n - 1 - i] = a[i][j];
        }
    }

    // Print rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << rotated[i][j] << (j + 1 == n ? '\n' : ' ');
        }
    }

    return 0;
}
```
<ins>**Complexity Analysis:**</ins>

Let the matrix be `n × n`.

- **Time:** `O(n^2)`  
  (we visit and place each of the `n*n` elements exactly once)

- **Space:** `O(n^2)`  
  (we create an extra `n × n` matrix `rotated`)

  ---
  
## Optimized Approach- n-place 90° Clockwise Rotation: 
  
<ins>**Algorithm Steps:**</ins>

1. Read `n` and input the `n × n` matrix `a`.
2. *Transpose* the matrix (swap across the main diagonal):
   - for `i = 0..n-1`
   - for `j = i+1..n-1`
   - swap `a[i][j]` and `a[j][i]`
3. *Reverse each row*:
   - for every row `i`, reverse `a[i]`
4. Print the rotated matrix.

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> a[i][j];
    }

    // Rotate 90° clockwise in-place:
    // 1) transpose
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(a[i][j], a[j][i]);
        }
    }

    // 2) reverse each row
    for (int i = 0; i < n; i++) {
        reverse(a[i].begin(), a[i].end());
    }

    // Print rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << a[i][j] << (j + 1 == n ? '\n' : ' ');
        }
    }

    return 0;
}
```
<ins>**Complexity Analysis (In-place rotation):**</ins>

Let the matrix be `n × n`.

- **Time:** `O(n^2)`
  - Transpose does about `n(n-1)/2` swaps → `O(n^2)`
  - Reversing all rows touches `n*n` elements → `O(n^2)`

- **Space:** `O(1)` extra
  - Rotation is done in the same matrix (only constant extra variables)

---

## Rotate Matrix by 180° (for an n × n matrix)

Example (original):
```
1  2  3  4
5  6  7  8
9  10 11 12
13 14 15 16
```

After 180° rotation:
```
16 15 14 13
12 11 10 9
8  7  6  5
4  3  2  1
```

### Approach- I (90° + 90°):
Rotate the matrix 90° clockwise two times.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Rotate square matrix 90 degrees clockwise (in-place)
static void rotate90Clockwise(vector<vector<int>>& a) {
    int n = (int)a.size();

    // transpose
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(a[i][j], a[j][i]);
        }
    }
    // reverse each row
    for (int i = 0; i < n; i++) {
        reverse(a[i].begin(), a[i].end());
    }
}

int main() {
    int n;
    cin >> n;

    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> a[i][j];
    }

    // 180° = 90° + 90°
    rotate90Clockwise(a);
    rotate90Clockwise(a);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << a[i][j] << (j + 1 == n ? '\n' : ' ');
        }
    }

    return 0;
}
```
<ins>**Complexity Analysis (180° as 90° + 90°):**</ins>

Let the matrix be `n × n`.

- One 90° rotation does:
  - transpose: `O(n^2)`
  - reverse each row: `O(n^2)`.
  - so total `O(n^2)`

- Doing it twice:
  - `2 * O(n^2) = O(n^2)`

- **Time:** `O(n^2)`  
- **Space:** `O(1)` extra (in-place)

---

### Approach-II (180° rotation = Column-wise reverse + Row-wise reverse):
<ins>**Algorithm Steps:**</ins>   

1. Input the `n × n` matrix.
2. *Column-wise reverse (vertical flip):*
   - Swap row `0` with row `n-1`.
   - Swap row `1` with row `n-2`.
   - Continue until the middle.
3. *Row-wise reverse (horizontal flip):*
   - Reverse every row of the matrix.
4. The matrix is now rotated by *180°*.

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> a[i][j];
    }

    // 180° rotation = reverse rows (top <-> bottom) + reverse each row (left <-> right)

    // 1) Column-wise reverse (flip vertically): swap row i with row (n-1-i)
    for (int i = 0; i < n / 2; i++) {
        swap(a[i], a[n - 1 - i]);
    }

    // 2) Row-wise reverse (flip horizontally): reverse each row
    for (int i = 0; i < n; i++) {
        reverse(a[i].begin(), a[i].end());
    }

    // Print rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << a[i][j] << (j + 1 == n ? '\n' : ' ');
        }
    }

    return 0;
}
```
<ins>**Complexity Analysis:**</ins>

Let the matrix be `n × n`.

- **Column-wise reverse (swap rows):** swaps about `n/2` rows, each swap involves `n` elements → `O(n^2)`
- **Row-wise reverse:** reverse `n` rows, each of length `n` → `O(n^2)`.

- **Time:** `O(n^2)`  
- **Space:** `O(1)` extra (in-place)

---

## Rotate Matrix 90° Anti-Clockwise (`n × n`):

Original matrix:
```
1  2  3  4
5  6  7  8
9  10 11 12
13 14 15 16
```

After 90° anti-clockwise rotation:
```
4 8 12 16
3 7 11 15
2 6 10 14
1 5 9  13
```

### Approach-I (Index Mapping):

For a square matrix `n × n` (0-based indexing):
*Mapping rule*:  
An element at old position `(i, j)` moves to:

- new position: `(n - 1 - j, i)`

*Formula*:  
`rotated[n - 1 - j][i] = original[i][j]`

*Simple meaning*  
- old **column `j`** becomes new **row** (counted from bottom) → `n-1-j`
- old **row `i`** becomes new **column** → `i`

*Quick examples `(n = 4)`*
- `(0,0) → (3,0)`  (top-left goes to bottom-left)
- `(0,3) → (0,0)`  (top-right goes to top-left)
- `(2,1) → (2,2)`

<ins>**Algorithm Steps:**</ins>

1. Read `n` and input the `n × n` matrix `original`.
2. Create a new `n × n` matrix, `rotated` filled with `0`.
3. For each cell `(i, j)` in `original`:
   - place it in `rotated` using:
     - `rotated[n - 1 - j][i] = original[i][j]`
4. Print `rotated`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<vector<int>> original(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> original[i][j];
    }

    // Naive rotation (uses extra matrix) using index mapping:
    // (i, j) -> (n-1-j, i) for 90° anti-clockwise
    vector<vector<int>> rotated(n, vector<int>(n, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            rotated[n - 1 - j][i] = original[i][j];
        }
    }

    // Print rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << rotated[i][j] << (j + 1 == n ? '\n' : ' ');
        }
    }

    return 0;
}
```
<ins>**Complexity Analysis:**</ins>

Let the matrix be `n × n`.

- **Time:** `O(n^2)` (we visit each element once)
- **Space:** `O(n^2)` (extra `rotated` matrix)

---

### Approach- II (90° Clockwise):

Derivation: 90° Anti-Clockwise = 270° Clockwise

<ins>**Angle logic:**</ins>  
- One full rotation = `360°`
- A `90°` anti-clockwise turn means moving `90°` to the left.
- The same final position can be reached by rotating the remaining angle to the right:

`clockwise angle = 360° - 90° = 270°`

So:
*90° anti-clockwise = 270° clockwise*

*As repeated 90° clockwise rotations*
`270° clockwise = 90° + 90° + 90° clockwise`

So:
*90° anti-clockwise = 3 × (90° clockwise)*

<ins>**Algorithm Steps:**</ins>  
1. Apply a 90° clockwise rotation 3 times.
2. The final matrix is equal to a 90° anti-clockwise rotation.

```cpp
#include <bits/stdc++.h>
using namespace std;

static void rotate90Clockwise(vector<vector<int>>& a) {
    int n = (int)a.size();

    // transpose
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(a[i][j], a[j][i]);
        }
    }
    // reverse each row
    for (int i = 0; i < n; i++) {
        reverse(a[i].begin(), a[i].end());
    }
}

int main() {
    int n;
    cin >> n;

    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> a[i][j];

    // 90° anti-clockwise = 270° clockwise = 3 times 90° clockwise
    rotate90Clockwise(a);
    rotate90Clockwise(a);
    rotate90Clockwise(a);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            cout << a[i][j] << (j + 1 == n ? '\n' : ' ');
    }
    return 0;
}
```
<ins>**Complexity Analysis:**</ins>

Let the matrix be `n × n`.

- One 90° clockwise rotation takes `O(n^2)` time (transpose + reverse rows).
- Doing it 3 times: `3 * O(n^2) = O(n^2)`.

- **Time:** `O(n^2)`  
- **Space:** `O(1)` extra (in-place)

---

## 90° Anti-Clockwise Rotation (In-place Using Transpose):

<ins>**Algo Steps:**</ins>  
1. *Transpose* the matrix.
2. *Reverse each column*.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> a[i][j];

    // 1) Transpose
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(a[i][j], a[j][i]);
        }
    }

    // 2) Reverse each column
    for (int col = 0; col < n; col++) {
        int top = 0, bottom = n - 1;
        while (top < bottom) {
            swap(a[top][col], a[bottom][col]);
            top++;
            bottom--;
        }
    }

    // Print result
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            cout << a[i][j] << (j + 1 == n ? '\n' : ' ');
    }

    return 0;
}
```
<ins>**Complexity Analysis:**</ins>

Let the matrix be `n × n`.

- **Time:** 
- Transpose: swaps about `n(n-1)/2` elements → `O(n^2)`
- Reverse columns: each of `n` columns has `n` elements → `O(n^2)`

*Total Time:* `O(n^2)`

- **Space**  
  Done in-place using a few variables.

*Space:* `O(1)` extra

---

## Rotate Matrix by `k` times (each time = 90° clockwise):

- `1` time  → `90°`
- `2` times → `180°`
- `3` times → `270°`
- `4` times → `360°` (same as original)

<ins>**Important:**</ins>  
Rotating 4 times returns the matrix to the original position, so only `k % 4` matters.

<ins>**Algo Steps:**</ins>  
1. Compute `k = k % 4`
2. Repeat `k` times:
   - call `rotate90(matrix)` (90° clockwise)

<ins>**Example:**</ins>   
If `k = 30`:
- `k % 4 = 2`
- rotate the matrix *2 times* (i.e., `180°`)

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Rotate square matrix 90° clockwise in-place
void rotate90Clockwise(vector<vector<int>>& a) {
    int n = (int)a.size();

    // transpose
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(a[i][j], a[j][i]);
        }
    }
    // reverse each row
    for (int i = 0; i < n; i++) {
        reverse(a[i].begin(), a[i].end());
    }
}

// Rotate by k times (each time = 90° clockwise)
void rotateKTimes(vector<vector<int>>& a, int k) {
    if (a.empty()) return;
    int n = (int)a.size();
    if ((int)a[0].size() != n) return; // only for n x n

    k %= 4; // only 0..3 rotations matter
    while (k--) rotate90Clockwise(a);
}

int main() {
    int n, k;
    cin >> n >> k;

    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> a[i][j];
    }

    rotateKTimes(a, k);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << a[i][j] << (j + 1 == n ? '\n' : ' ');
        }
    }

    return 0;
}
```
<ins>**Complexity Analysis:**</ins>  

Let the matrix be `n × n`.

- One 90° clockwise rotation takes `O(n^2)` time.
- We do it `k % 4` times (at most 3 times), so time is:
  - `(k % 4) * O(n^2)` which is still *`O(n^2)`*

- **Time:** `O(n^2)`  
- **Space:** `O(1)` extra (in-place)

