## Binary Search in a Sorted 2D-Array and Other problems based on this:

Matrix (4 × 5):
```
2   6   10  14  18
20  24  27  29  38
47  52  78  93  102
108 111 200 218 320
```
Target: `x = 52`

---

### Naive Approach - I (Linear Search):
<ins>**Algo Steps:**</ins>  
- Traverse every element:
  - for `i = 0 .. rows-1`
    - for `j = 0 .. cols-1`
      - if `a[i][j] == x` return `1`
- If not found, return `0`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int rows, cols;
    cin >> rows >> cols;

    vector<vector<int>> a(rows, vector<int>(cols));
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) cin >> a[i][j];
    }

    int x;
    cin >> x;

    // Naive search
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (a[i][j] == x) {
                cout << 1 << "\n"; // found
                return 0;
            }
        }
    }

    cout << 0 << "\n"; // not found
    return 0;
}
```
<ins>**Complexity Analysis:**</ins>
- **Time:** `O(rows * cols)` (checks each cell in worst case)
- **Space:** `O(1)`

---

## Optimized Approach - II (Binary Search):
<ins>**Idea:**</ins>  
1. First, find the row in which the target `x` can lie.
2. Then apply **Binary Search** in that row.

<ins>**Row check condition:**</ins>  
For each row `i`:
- `matrix[i][0] <= x <= matrix[i][m-1]`  
(where `m` = number of columns)

*Example (x = 52):*
- Row 0 range: `2 ... 18`  → not possible
- Row 1 range: `20 ... 38` → not possible
- Row 2 range: `47 ... 102` → possible ✅  
So, we binary search only in row 2.

<ins>**Important note (assumption):**<ins>   
You can stop after finding the correct row only if:
- `last element of row i < first element of row i+1`.  
(i.e., row ranges are increasing and do not overlap)

<ins>**Algo steps:**<ins>   
- For each row `i`:
  - If `matrix[i][0] <= x && x <= matrix[i][m-1]`:
    - Binary search in row `i`
    - If found return `1`, else return `0`.
- Return `0`

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> mat(n, vector<int>(m));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) cin >> mat[i][j];
    }

    int x;
    cin >> x;

    // Step 1: Find the row where x can lie
    for (int i = 0; i < n; i++) {
        if (mat[i][0] <= x && x <= mat[i][m - 1]) {

            // Step 2: binary search in that row
            int l = 0, r = m - 1;
            while (l <= r) {
                int mid = l + (r - l) / 2;

                if (mat[i][mid] == x) {
                    cout << 1 << "\n";
                    return 0;
                } else if (mat[i][mid] < x) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }

            // x is not present in this row
            cout << 0 << "\n";
            return 0;
        }
    }

    // x does not fit in any row range
    cout << 0 << "\n";
    return 0;
}
```
<ins>**Complexity Analysis:**</ins>  

Let `n` = number of rows, `m` = number of columns.

- Row range check scans rows: `O(n)`.
- Binary search in one row: `O(log m)`.

- **Total time:** `O(n + log m)`  
- **Space:** `O(1)`

---

##  Approach - III (Row-Major Order):  

<ins>**When this works?**</ins>   
This approach works if the matrix is sorted like a 1D sorted array:
- each row is sorted left→right
- `matrix[i][m-1] < matrix[i+1][0]` (next row starts with a bigger element)

<ins>**Idea:**</ins>   
Treat the `n × m` matrix as a *1D array* of size `n*m` in *row-major* order.

Index mapping:
- `row = mid / m`
- `col = mid % m`

So `matrix[row][col]` is the element at 1D index `mid`.

<ins>**Algorithm Steps:**</ins>   
1. Set `low = 0`, `high = n*m - 1`
2. While `low <= high`:
   - `mid = (low + high) / 2`
   - Convert `mid` to `(row, col)`
   - Compare `matrix[row][col]` with `x`
3. Return found/not found

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> mat(n, vector<int>(m));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) cin >> mat[i][j];
    }

    int x;
    cin >> x;

    int low = 0, high = n * m - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        int row = mid / m;
        int col = mid % m;

        if (mat[row][col] == x) {
            cout << 1 << "\n";
            return 0;
        } else if (mat[row][col] < x) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    cout << 0 << "\n";
    return 0;
}
```
<ins>**Complexity Analysis:**</ins>   

Let `n` = rows, `m` = columns.

- We binary search over `n*m` elements.
- Number of steps in binary search = `O(log(n*m))`
- Each step does O(1) work (convert `mid` to `(row, col)` and compare).

- **Time:** `O(log(n*m))`  
- **Space:** `O(1)`  

---

## Search in a sorted `row-wise` and `column-wise` 2D-matrix:

(Every row is sorted left→right AND every column is sorted top→bottom)

<ins>**Example:**</ins>   
Matrix (N = 5, M = 5), target x = 50:

```
4  8  15  25   60
18 22 26  42   80
36 40 45  68  104
48 50 72  83  130
70 99 114 128 170
```

### Naive Approach -I (Naive Linear Search):

<ins>**Dry idea with `x = 50`:**</ins>   
- Start at `60` (top-right). `60 > 50` → left
- Go to `25`. `25 < 50` → down
- Go to `42`. `42 < 50` → down
- Go to `68`. `68 > 50` → left
- Go to `45`. `45 < 50` → down
- Go to `72`. `72 > 50` → left
- Go to `50`. Found

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;

    vector<vector<int>> mat(N, vector<int>(M));
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) cin >> mat[i][j];
    }

    int x;
    cin >> x;

    // Naive search: check every element
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (mat[i][j] == x) {
                cout << 1 << "\n";   // found
                return 0;
            }
        }
    }

    cout << 0 << "\n";               // not found
    return 0;
}
```

<ins>**Complexity Analysis:**<ins>   
- **Time:** `O(N*M)` (may check all elements)
- **Space:** `O(1)`

---

## Approach -II (Staircase Search):

<ins>**Intuition:</ins>   
In a matrix where:
- rows are sorted left → right
- columns are sorted top → bottom

We want a starting point where:
- one move always makes values *smaller*  
- the other move always makes values *larger*  

Then, comparing with `x` gives a clear decision every time, and we can discard the whole row/column.

<ins>**Why is the top-right chosen?**</ins>   
At top-right `mat[0][M-1]`:
- Moving **left** (`j--`) → values **decrease**  
- Moving **down** (`i++`) → values **increase**  

So:
- If `mat[i][j] > x` → go **left** (everything below is even bigger)  
- If `mat[i][j] < x` → go **down** (everything left is even smaller)  

This removes one row or one column per step → fast `O(N+M)`.  

<ins>**Why not top-left / bottom-right?**</ins>  
- **Top-left:** right and down both increase → not a clear single choice.  
- **Bottom-right:** left and up both decrease → not a clear single choice.  

<ins>**Note:**</ins>   
You can also start from **bottom-left** (same idea: up decreases, right increases).  
So, at each step, you can discard one full row or one full column.

<ins>**Algorithm Steps:**<ins>   
1. Set `i = 0` (top row), `j = M-1` (last column).
2. While `i < N` and `j >= 0`:
   - If `mat[i][j] == x` → found.
   - If `mat[i][j] < x` → move down (`i++`).
   - If `mat[i][j] > x` → move left (`j--`).
3. If the loop ends, the element is not found.

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;

    vector<vector<int>> mat(N, vector<int>(M));
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) cin >> mat[i][j];
    }

    int x;
    cin >> x;

    // Staircase search from top-right
    int i = 0, j = M - 1;
    while (i < N && j >= 0) {
        if (mat[i][j] == x) {
            cout << 1 << "\n"; // found
            return 0;
        } else if (mat[i][j] < x) {
            i++; // move down
        } else {
            j--; // move left
        }
    }

    cout << 0 << "\n"; // not found
    return 0;
}
```
<ins>**Complexity Analysis:**<ins>   

- Each step moves either *one row down* or *one column left*.  
- So total moves are at most `N + M`.  

- **Time:** `O(N + M)`   
- **Space:** `O(1)`
