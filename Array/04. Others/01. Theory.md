## 2D Array Notes (typed + corrected)

### 1) Row-major vs Column-major
A 2D array can be stored in memory in two common ways:

- *Row-major order*: store row 0 completely, then row 1, then row 2, ...
- *Column-major order*: store column 0 completely, then column 1, then column 2, ...

Example matrix (rows = 4, cols = 3), shown as `a[row][col]`:

Row 0: `a[0][0]  a[0][1]  a[0][2]`  
Row 1: `a[1][0]  a[1][1]  a[1][2]`  
Row 2: `a[2][0]  a[2][1]  a[2][2]`  
Row 3: `a[3][0]  a[3][1]  a[3][2]`

**In-memory layout (row-major)**  
Index: `0  1  2  3  4  5  6  7  8  9  10 11`  
Data : `00 01 02 10 11 12 20 21 22 30 31 32`


### 2) Convert (row, col) to 1D index (row-major)
If number of columns = `C`:

- `index = row * C + col`

Example: for `(row, col) = (2, 1)` and `C = 3`  
`index = 2*3 + 1 = 7`


### 3) Convert 1D index to (row, col) (row-major)
If number of columns = `C`:

- `row = index / C`.
- `col = index % C`.


### 4) Why we must pass column size in C/C++ 2D arrays
When you pass a 2D array to a function in C/C++, the compiler must know the **number of columns** to calculate the address of `a[i][j]`.

Address formula (row-major):

- `address(a[i][j]) = base + (i * C + j) * sizeof(element)`

So in a function, you write something like:
```cpp
void print(int a[][C]) { ... }
```
---
## Programs on Matrix 2D

### Add Two Matrices

**Condition**  
Both matrices must have the **same number of rows and columns**:
- `rows(A) = rows(B)`
- `cols(A) = cols(B)`

**Rule**  
Add element by element:
- `C[i][j] = A[i][j] + B[i][j]`

**Algorithm**  
1. Create a result matrix `C` of the same size.
2. For each row `i` from `0` to `rows-1`:
   - For each column `j` from `0` to `cols-1`:
     - `C[i][j] = A[i][j] + B[i][j]`
3. Output `C`.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int rows, cols;
    cin >> rows >> cols;

    vector<vector<int>> A(rows, vector<int>(cols));
    vector<vector<int>> B(rows, vector<int>(cols));
    vector<vector<int>> C(rows, vector<int>(cols));

    // Input matrix A
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) cin >> A[i][j];
    }

    // Input matrix B
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) cin >> B[i][j];
    }

    // Add matrices: C = A + B
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }

    // Print result matrix C
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << C[i][j] << (j + 1 == cols ? '\n' : ' ');
        }
    }

    return 0;
}
```
### Complexity Analysis
- **Time:** `O(R*C)` (add each cell once)
- **Space:** `O(R*C)` (result matrix)

---

## Search an Element in a 2D Array

### Idea
Check every cell until you find the target.

### Algorithm
1. For each row `i` from `0` to `rows-1`:
2. For each column `j` from `0` to `cols-1`:
   - If `a[i][j] == x`, element found.

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int rows, cols;
    cin >> rows >> cols;

    vector<vector<int>> a(rows, vector<int>(cols));
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) cin >> a[i][j];
    }

    int x;
    cin >> x;

    bool found = false;
    int r = -1, c = -1;

    for (int i = 0; i < rows && !found; i++) {
        for (int j = 0; j < cols; j++) {
            if (a[i][j] == x) {
                found = true;
                r = i; c = j;
                break;
            }
        }
    }

    if (found) cout << "Found at (" << r << "," << c << ")\n";
    else cout << "Not Found\n";

    return 0;
}
```
### Complexity Analysis
- **Time:** `O(rows * cols)` (may scan all cells in worst case)
- **Space:** `O(1)`

---

## Reverse Each Row of a Matrix

### Idea
For every row, swap the first and last elements, then move inward.

### Algorithm
1. For each row `i`:
   - set `l = 0`, `r = cols - 1`
   - while `l < r`:
     - swap `a[i][l]` and `a[i][r]`
     - `l++`, `r--`

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int rows, cols;
    cin >> rows >> cols;

    vector<vector<int>> a(rows, vector<int>(cols));
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) cin >> a[i][j];
    }

    // Reverse each row
    for (int i = 0; i < rows; i++) {
        int l = 0, r = cols - 1;
        while (l < r) {
            swap(a[i][l], a[i][r]);
            l++;
            r--;
        }
    }

    // Print matrix
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            cout << a[i][j] << (j + 1 == cols ? '\n' : ' ');
        }
    }

    return 0;
}
```
### Complexity Analysis:
- **Time:** `O(rows * cols)` (each element is swapped at most once per row)
- **Space:** `O(1)`

---

## Row Index with Maximum Row Sum

### Idea
Find the sum of each row and track which row has the maximum sum.

### Algorithm
1. Set `maxSum = -âˆž`, `maxRow = -1`.
2. For each row `i`:
   - compute `rowSum = sum of all elements in row i`
   - if `rowSum > maxSum`, update `maxSum = rowSum` and `maxRow = i`
3. Output `maxRow`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int rows, cols;
    cin >> rows >> cols;

    vector<vector<int>> a(rows, vector<int>(cols));
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) cin >> a[i][j];
    }

    long long maxSum = LLONG_MIN;
    int maxRow = -1;

    for (int i = 0; i < rows; i++) {
        long long rowSum = 0;
        for (int j = 0; j < cols; j++) rowSum += a[i][j];

        if (rowSum > maxSum) {
            maxSum = rowSum;
            maxRow = i;
        }
    }

    cout << maxRow << "\n";
    return 0;
}
```
### Complexity Analysis
- **Time:** `O(rows * cols)` (sum each row)
- **Space:** `O(1)`

---
## Sum of Diagonal Elements (Square Matrix Only)

### Condition
Matrix must be square: `rows == cols == n`.

### Diagonals
- **Primary diagonal:** `a[i][i]`
- **Secondary diagonal:** `a[i][n-1-i]`

### Algorithm
1. Set `sum1 = 0`, `sum2 = 0`.
2. For `i = 0` to `n-1`:
   - `sum1 += a[i][i]`
   - `sum2 += a[i][n-1-i]`
3. If you need **both diagonals together**:
   - `total = sum1 + sum2`
   - if `n` is odd, subtract middle element once: `total -= a[n/2][n/2]`

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> a[i][j];
    }

    long long primary = 0, secondary = 0;

    for (int i = 0; i < n; i++) {
        primary += a[i][i];
        secondary += a[i][n - 1 - i];
    }

    long long total = primary + secondary;

    // If n is odd, the middle element is counted twice
    if (n % 2 == 1) total -= a[n / 2][n / 2];

    cout << "Primary diagonal sum: " << primary << "\n";
    cout << "Secondary diagonal sum: " << secondary << "\n";
    cout << "Sum of both diagonals: " << total << "\n";

    return 0;
}
```
### Complexity Analysis
- **Time:** `O(n)` (one loop over diagonal indices)
- **Space:** `O(1)`

