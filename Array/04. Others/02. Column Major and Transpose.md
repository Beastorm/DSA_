## Column Major Order

Let:
- `R = rowCount`
- `C = colCount`

### 1) (row, col) → 1D index (Column-major):
*Correct formula:*
- `index = col * R + row`

Example: `(R = 3, C = 3)`
Matrix shown as `a[row][col]`:

``` text
00 01 02  
10 11 12  
20 21 22
```

In-memory representation (column-major):

Index: `0 1 2 3 4 5 6 7 8`. 
Data : `00 10 20 01 11 21 02 12 22`

### 2) 1D index → (row, col) (Column-major):

- `row = index % R`
- `col = index / R`

Example: `index = 8`, `R = 3`
- `row = 8 % 3 = 2`
- `col = 8 / 3 = 2`

---

## 2D Vector (C++):

<ins>**Declaration:**</ins>  
- `vector<vector<int>> matrix;`
- `vector<vector<int>> matrix(rows, vector<int>(cols, 0));`  
  *(creates a `rows × cols` matrix filled with `0`)*

<ins>**Find number of rows and columns:**</ins>
- `rows = matrix.size();`
- `cols = matrix[0].size();` *(only if `rows > 0`)*

``` cpp
vector<vector<int>> matrix; 
// empty 2D vector (0 rows)

int rows = 3, cols = 4;
vector<vector<int>> matrix2(rows, vector<int>(cols, 0));
// creates a 3x4 matrix filled with 0

// matrix2 looks like:
/* 0 0 0 0
   0 0 0 0
   0 0 0 0  */

```
``` text
matrix2[0][1] = 5;
matrix2[2][3] = 9;

// now:
0 5 0 0
0 0 0 0
0 0 0 9

```
---

## 1. Wave form traversal:

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<vector<int>> matrix = {
        {3, 6, 4, 2},
        {7, 8, 11, 5},
        {9, 3, 2, 1},
        {12, 8, 5, 9}
    };

    int rows = matrix.size();
    int cols = matrix[0].size();

    // Wave traversal column-wise:
    // even column: top -> bottom
    // odd column: bottom -> top
    for (int j = 0; j < cols; j++) {
        if (j % 2 == 0) {
            for (int i = 0; i < rows; i++) {
                cout << matrix[i][j] << " ";
            }
        } else {
            for (int i = rows - 1; i >= 0; i--) {
                cout << matrix[i][j] << " ";
            }
        }
    }

    cout << "\n";
    return 0;
}
```
<ins>**Complexity Analysis:**</ins> 
- **Time:** `O(rows * cols)` (visits every element once)
- **Space:** `O(1)` (only loop variables)

---

## 2. Spiral Traversal of a Matrix:

We print the matrix in a spiral order using 4 boundaries:
top-> (starting row)
bottom-> (ending row)
left-> (starting column)
right-> (ending column)

``` text

Matrix (6 x 6)                    right
                                    v
                0   1   2   3   4   5
              +---+---+---+---+---+---+
    top > 0   | 1 | 2 | 3 | 4 | 5 | 6 | 
              +---+---+---+---+---+---+
          1   | 7 | 8 | 9 |10 |11 |12 | 
              +---+---+---+---+---+---+
          2   |13 |14 |15 |16 |17 |18 | 
              +---+---+---+---+---+---+
          3   |19 |20 |21 |22 |23 |24 | 
              +---+---+---+---+---+---+
          4   |25 |26 |27 |28 |29 |30 | 
              +---+---+---+---+---+---+
 bottom > 5   |31 |32 |33 |34 |35 |36 | 
              +---+---+---+---+---+---+
                ^                       
              left                     
                                   
```

*Boundaries:*
top = 0, bottom = 5, left = 0, right = 5

*Spiral direction order:*
1) top row     : left -> right
2) right col   : top  -> bottom
3) bottom row  : right -> left
4) left col    : bottom -> top

``` cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> spiralOrder(const vector<vector<int>>& a) {
    int rows = (int)a.size();
    if (rows == 0) return {};
    int cols = (int)a[0].size();

    int top = 0, bottom = rows - 1;
    int left = 0, right = cols - 1;

    vector<int> ans;
    ans.reserve(rows * cols);

    while (top <= bottom && left <= right) {
        // 1) top row: left -> right
        for (int j = left; j <= right; j++) ans.push_back(a[top][j]);
        top++;

        // 2) right col: top -> bottom
        for (int i = top; i <= bottom; i++) ans.push_back(a[i][right]);
        right--;

        // 3) bottom row: right -> left
        if (top <= bottom) {
            for (int j = right; j >= left; j--) ans.push_back(a[bottom][j]);
            bottom--;
        }

        // 4) left col: bottom -> top
        if (left <= right) {
            for (int i = bottom; i >= top; i--) ans.push_back(a[i][left]);
            left++;
        }
    }

    return ans;
}

int main() {
    vector<vector<int>> a = {
        { 1,  2,  3,  4,  5,  6},
        { 7,  8,  9, 10, 11, 12},
        {13, 14, 15, 16, 17, 18},
        {19, 20, 21, 22, 23, 24},
        {25, 26, 27, 28, 29, 30},
        {31, 32, 33, 34, 35, 36}
    };

    vector<int> res = spiralOrder(a);

    for (int x : res) cout << x << " ";
    cout << "\n";
    return 0;
}
```
<ins>**Complexity Analysis:**</ins>
- **Time:** `O(rows * cols)` (each element is visited once)
- **Space:** `O(1)` extra, `O(rows * cols)` only for the output list

---

## 3. Transpose of Matrix:

``` text
1  2  3  4
5  6  7  8
9  1  1  2
1  3  4  5
```
*Meaning of Transpose:*
Swap rows and columns:

- `T[j][i] = A[i][j]`

### Naive Approach (using a new matrix):
``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<vector<int>> A(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> A[i][j];
    }

    // Naive transpose using extra matrix
    vector<vector<int>> T(n, vector<int>(n, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            T[j][i] = A[i][j];
        }
    }

    // Print transpose
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << T[i][j] << (j + 1 == n ? '\n' : ' ');
        }
    }

    return 0;
}
```

<ins>**Complexity Analysis:**</ins>
- **Time:** `O(n^2)` (visit each cell once)
- **Space:** `O(n^2)` (extra transpose matrix)

---

### Optimal Approach- Transpose Matrix In-Place (Only for Square Matrix `n × n`):

``` text
a00 a01 a02 a03  
a10 a11 a12 a13  
a20 a21 a22 a23  
a30 a31 a32 a33  
```
<ins>**Note:**</ins>  
In-place transpose is possible only when `rows == cols` (square matrix).

Main diagonal stays same: `a00, a11, a22, a33`
Swap elements symmetric about the diagonal:
- swap `a01 <-> a10`
- swap `a02 <-> a20`
- swap `a03 <-> a30`
- swap `a12 <-> a21`
- swap `a13 <-> a31`
- swap `a23 <-> a32`

``` cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<vector<int>> a(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> a[i][j];
    }

    // In-place transpose (only for square matrix)
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(a[i][j], a[j][i]);
        }
    }

    // Print transposed matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << a[i][j] << (j + 1 == n ? '\n' : ' ');
        }
    }

    return 0;
}
```
<ins>**Complexity Analysis:**</ins>
Let the matrix be `n × n`.

* **Time Complexity:**  
    We swap only the elements *above the main diagonal*:
    - For `i = 0`, `j` runs `1 .. n-1` → `(n-1)` swaps  
    - For `i = 1`, `j` runs `2 .. n-1` → `(n-2)` swaps  
    - ...
    - For `i = n-2`, `j` runs `n-1 .. n-1` → `1` swap  
    
    Total swaps:
    `(n-1) + (n-2) + ... + 1 = n(n-1)/2`
    
    Each swap is `O(1)`, so:
    
    *Time = O(n^2)*

* **Space Complexity:**  
    We only use a few variables (`i`, `j`) and swap in the same matrix.

    *Space = O(1)*

