# üìù Find the repeating and missing numbers

**Problem Statement:** Given an integer array `nums` of size `n` containing values from `[1, n]` and each value appears exactly once in the array, except for `A`, which appears twice and `B` which is missing.
Return the values `A` and `B`, as an array of size 2, where `A` appears in the 0-th index and `B` in the 1st index.

**Note:** You are not allowed to modify the original array.

### üí° Examples

**Example 1:**
**Input:**  
 `nums = [3, 5, 4, 1, 1]`  
**Output:**  
 `[1, 2]`
**Explanation:**
 1 appears twice in the array, and 2 is missing from the array. So the output is `[1, 2]`.

**Example 2:**  
**Input:**  
 `nums = [1, 2, 3, 6, 7, 5, 7]`  
**Output:**  
 `[7, 4]`  
**Explanation:**
 7 appears twice in the array, and 4 is missing from the array. So the output is `[7, 4]`.

---

## üê¢ Brute Force Approach

### Algorithm
1.  Iterate through the array from numbers `1` to `N`, where `N` is the size of the array.
2.  For each integer `i`, use linear search to count its occurrence in the given array.
3.  If an element has an occurrence of 2, store it as the `repeating` element.
4.  If an element has an occurrence of 0, store it as the `missing` element.
5.  If both repeating and missing elements are found, break the loop early.
6.  Finally, return the two elements that have occurrences of 2 and 0, respectively.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find repeating and missing numbers
    vector<int> findMissingRepeatingNumbers(vector<int>& nums) {
        
        // Size of the array
        int n = nums.size(); 
        int repeating = -1, missing = -1;

        // Find the repeating and missing number:
        for (int i = 1; i <= n; i++) {
            
            // Count the occurrences:
            int cnt = 0;
            
            for (int j = 0; j < n; j++) {
                if (nums[j] == i) cnt++;
            }

            // Check if i is repeating or missing
            if (cnt == 2) repeating = i;
            else if (cnt == 0) missing = i;

            // If both repeating and missing are found, break out of loop
            if (repeating != -1 && missing != -1)
                break;
        }
        
        // Return {repeating, missing}
        return {repeating, missing};
    }
};

int main() {
    vector<int> nums = {3, 1, 2, 5, 4, 6, 7, 5};
    
    // Create an instance of Solution class
    Solution sol;

    vector<int> result = sol.findMissingRepeatingNumbers(nums);
    
    // Print the repeating and missing numbers found
    cout << "The repeating and missing numbers are: {" << result[0] << ", " << result[1] << "}\n";
    
    return 0;
}
```
### üìä Complexity Analysis
- **Time Complexity:** O(N^2), where N is the size of the array. This is because we are iterating through the array for each integer from 1 to N, leading to a nested loop.
- **Space Complexity:** O(1), as we are using a constant amount of space for the variables `repeating` and `missing`, regardless of the input size.

---

## üß† Better Approach

### Algorithm
1.  Declare a hash array of size `N+1` where `N` is the range of numbers in the array (from 1 to `N`). This hash array will store the frequency of each element.
2.  Iterate through the given array and for each element encountered, update the frequency in the hash array.
3.  Once all elements are processed, iterate through the hash array and identify the two elements: one with frequency 2 and one with frequency 0.
4.  Return the two elements that have frequencies of 2 and 0, respectively.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find repeating and missing numbers
    vector<int> findMissingRepeatingNumbers(vector<int>& nums) {
        
        // Size of the array
        int n = nums.size(); 
        
        // Hash array to count occurrences
        // Using vector instead of static array for dynamic sizing based on n
        vector<int> hash(n + 1, 0);
        
        // Update the hash array:
        for (int i = 0; i < n; i++) {
            hash[nums[i]]++;
        }

        int repeating = -1, missing = -1;
        
        // Find the repeating and missing number:
        for (int i = 1; i <= n; i++) {
            if (hash[i] == 2) {
                repeating = i;
            } else if (hash[i] == 0) {
                missing = i;
            }

            /* If both repeating and missing 
            are found, break out of loop*/
            if (repeating != -1 && missing != -1) {
                break;
            }
        }
        
        // Return {repeating, missing}
        return {repeating, missing};
    }
};

int main() {
    vector<int> nums = {3, 1, 2, 5, 4, 6, 7, 5};
    
    // Create an instance of Solution class
    Solution sol;

    vector<int> result = sol.findMissingRepeatingNumbers(nums);
    
    // Print the repeating and missing numbers found
    cout << "The repeating and missing numbers are: {" << result[0] << ", " << result[1] << "}\n";
    
    return 0;
}
```
### üìä Complexity Analysis
- **Time Complexity:** O(2*N), where N is the size of the array. This is because we are iterating through the array once to build the hash array and then iterating through the hash array to find the repeating and missing numbers.
- **Space Complexity:** O(N), as we are using an additional hash array of size N+1 to store the frequency of each element.

---

## üöÄ Optimal Approach 1

### Algorithm
1.  First, calculate the sum of all elements in the given array, denoted as `S`, and the sum of natural numbers from 1 to `N`, denoted as `Sn`. The formula for `Sn` is $\frac{N \times (N + 1)}{2}$.
2.  Now calculate `S - Sn`. This gives us `X - Y`, where `X` is the repeating number and `Y` is the missing number. Let's call this `val1`.
    $$val1 = X - Y = S - S_n$$
3.  Next, calculate the sum of squares of all elements in the array, denoted as `S2`, and the sum of squares of the first `N` numbers, denoted as `S2n`. The formula for `S2n` is $\frac{N \times (N + 1) \times (2N + 1)}{6}$.
4.  Now calculate `S2 - S2n`. This gives us $X^2 - Y^2$. Let's call this `val2`.
    $$val2 = X^2 - Y^2 = S2 - S2n$$
5.  From the equations $S - Sn = X - Y$ and $S2 - S2n = X^2 - Y^2$, we can compute $X + Y$ using the formula $(S2 - S2n) / (S - Sn)$ because $X^2 - Y^2 = (X - Y)(X + Y)$.
    $$X + Y = \frac{val2}{val1}$$
6.  Using the values of $X + Y$ and $X - Y$, we can solve for $X$ and $Y$ through simple addition and subtraction.
    $$X = \frac{(X + Y) + (X - Y)}{2}$$
    $$Y = X - (X - Y)$$
7.  Finally, return the values of $X$ (the repeating number) and $Y$ (the missing number).

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find repeating and missing numbers
    vector<int> findMissingRepeatingNumbers(vector<int>& nums) {
        
        // Size of the array
        long long n = nums.size(); 

        // Sum of first n natural numbers
        long long SN = (n * (n + 1)) / 2;
        
        // Sum of squares of first n natural numbers
        long long S2N = (n * (n + 1) * (2 * n + 1)) / 6;

        // Calculate actual sum (S) and sum of squares (S2) of array elements
        long long S = 0, S2 = 0;
        for (int i = 0; i < n; i++) {
            S += nums[i];
            S2 += (long long)nums[i] * (long long)nums[i];
        }

        //Compute the difference values: val1 = X - Y
        long long val1 = S - SN; 
        
        // val2 = S2 - S2n = X^2 - Y^2  
        long long val2 = S2 - S2N; 

        //Calculate X + Y using X + Y = (X^2 - Y^2) / (X - Y)  
        val2 = val2 / val1;

        /* Calculate X and Y from X + Y and X - Y
         X = ((X + Y) + (X - Y)) / 2
         Y = X - (X - Y)*/
         
        long long x = (val1 + val2) / 2;
        long long y = x - val1;

        // Return the results as {repeating, missing}
        return {(int)x, (int)y};
    }
};

int main() {
    vector<int> nums = {3, 1, 2, 5, 4, 6, 7, 5};
    
    // Create an instance of Solution class
    Solution sol;

    vector<int> result = sol.findMissingRepeatingNumbers(nums);
    
    // Print the repeating and missing numbers found
    cout << "The repeating and missing numbers are: {" << result[0] << ", " << result[1] << "}\n";
    
    return 0;
}
```
### üìä Complexity Analysis
- **Time Complexity:** O(N), where N is the size of the array. This is because we are iterating through the array to calculate the sums and sums of squares.
- **Space Complexity:** O(1), as we are using a constant amount of space for variables, regardless of the input size.

---

## üöÄ Optimal Approach 2

### Algorithm
1.  First, iterate through the array and calculate the XOR of all the elements in the array and the numbers from 1 to N. Store the result in a variable called `xr`. This `xr` will be equivalent to $X \oplus Y$ (where X is repeating, Y is missing).
2.  To find the position of the first set bit from the right, perform a bitwise AND operation between `xr` and the negation of `xr - 1`, i.e., `xr & ~(xr - 1)`. This will give the bit position of the first set bit (the rightmost 1).
3.  Initialize two variables, `zero` and `one`. We will group all numbers (from the array and the range 1 to N) into two groups based on whether this specific bit is 0 or 1.
4.  For each element in the array and for each number from 1 to N:
    *   If the bit at the specific position is 1, XOR the number with the variable `one`.
    *   If the bit is 0, XOR the number with the variable `zero`.
5.  All duplicates will cancel out in their respective buckets. After processing all elements, `zero` and `one` will hold the two unique numbers (the repeating number and the missing number).
6.  To identify which is which, traverse the entire array and check how many times the number stored in `zero` appears.
    *   If `zero` appears twice, it is the repeating number; otherwise, it is the missing number.
    *   The other number corresponds to the other category.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find repeating and missing numbers
    vector<int> findMissingRepeatingNumbers(vector<int>& nums) {
        
        // size of the array
        int n = nums.size(); 

        int xr = 0;

        for (int i = 0; i < n; i++) {
            // XOR of all elements in nums
            xr = xr ^ nums[i]; 
            
            // XOR of numbers from 1 to n
            xr = xr ^ (i + 1);  
        }

        // Get the rightmost set bit in xr
        // Note: (xr & -xr) is also a valid way to get the rightmost set bit
        int number = (xr & ~(xr - 1));

        //Group the numbers based on the differentiating bit
        // Number that falls into the 0 group
        int zero = 0; 
        
        // Number that falls into the 1 group
        int one = 0;  

        for (int i = 0; i < n; i++) {
            
            // Check if nums[i] belongs to the 1 group based on the differentiating bit
            if ((nums[i] & number) != 0) {
                
                // XOR operation to find numbers in the 1 group
                one = one ^ nums[i];
                
            } else {
                // XOR operation to find numbers in the 0 group
                zero = zero ^ nums[i]; 
            }
        }

        // Group numbers from 1 to n based on differentiating bit
        for (int i = 1; i <= n; i++) {
            
            /* Check if i belongs to the 1 group 
            based on the differentiating bit*/
            if ((i & number) != 0) {
                
                // XOR operation to find numbers in the 1 group
                one = one ^ i; 
                
            } else {
                // XOR operation to find numbers in the 0 group
                zero = zero ^ i; 
            }
        }

        // Count occurrences of zero in nums
        int cnt = 0; 

        for (int i = 0; i < n; i++) {
            if (nums[i] == zero) {
                cnt++;
            }
        }

        if (cnt == 2) {
            // zero is the repeating number, one is the missing number
            return {zero, one}; 
        }
        
        // one is the repeating number, zero is the missing number*/
        return {one, zero}; 
    }
};

int main() {
    vector<int> nums = {3, 1, 2, 5, 4, 6, 7, 5};
    
    // Create an instance of Solution class
    Solution sol;

    vector<int> result = sol.findMissingRepeatingNumbers(nums);
    
    // Print the repeating and missing numbers found
    cout << "The repeating and missing numbers are: {" << result[0] << ", " << result[1] << "}\n";
    
    return 0;
}
```
### üìä Complexity Analysis
- **Time Complexity:** O(N), where N is the size of the array. This is because we are iterating through the array to calculate the XOR values.
- **Space Complexity:** O(1), as we are using a constant amount of space for variables, regardless of the input size.
