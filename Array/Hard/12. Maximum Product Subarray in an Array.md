# Maximum Product Subarray in an Array

**Problem Statement:** Given an array that contains both negative and positive integers, find the maximum product subarray.

### Examples

**Input:** `Nums = [1,2,3,4,5,0]`  
**Output:** `120`  
**Explanation:**   
In the given array, `1×2×3×4×5` gives maximum product value.  

**Input:** `Nums = [1,2,-3,0,-4,-5]`  
**Output:** `20`  
**Explanation:**   
In the given array, `(-4)×(-5)` gives maximum product value.  

---

## Brute-Force Approach

### Algorithm
In the brute force method, we generate all possible subarrays and calculate the product of each subarray. We track the maximum product found among all. Use two nested loops, the outer loop picks the starting index of the subarray and the inner loop picks the ending index. For every subarray defined by start and end, calculate the product and update the maximum product if the current subarray's product is larger.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // This function finds the maximum product
    // of any contiguous subarray using brute force
    int maxProduct(vector<int>& nums) {
        // Initialize the answer with the first element
        int maxProd = nums[0];

        // Outer loop picks the starting index
        for (int i = 0; i < nums.size(); i++) {
            // Initialize current product to 1
            int prod = 1;

            // Inner loop picks the ending index
            for (int j = i; j < nums.size(); j++) {
                // Multiply current number to product
                prod *= nums[j];

                // Update maximum product if needed
                maxProd = max(maxProd, prod);
            }
        }

        // Return the result
        return maxProd;
    }
};

int main() {
    // Sample input
    vector<int> nums = {2, 3, -2, 4};

    // Create Solution object
    Solution sol;

    // Print the result
    cout << sol.maxProduct(nums);

    return 0;
}
```

### Complexity Analysis
- **Time Complexity:** O(N^2), we check the product of all possible subarrays using two nested loops.
- **Space Complexity:** O(1), No extra space is used.

---

## Optimal Approach - 1

### Algorithm
The product of elements in a subarray can become large when there are positive numbers, but negative numbers and zeros make it tricky. A negative number can flip a large product into a negative one, but if we meet another negative later, the sign flips back to positive. Therefore, to capture all possible max products, we do two things:
1.  Traverse the array from left to right (prefix) to build cumulative product.
2.  Traverse the array from right to left (suffix) to catch subarrays ending at the back (helpful when max product is at the end or due to even negatives).
3.  Reset the product to 1 whenever a zero is found, as it breaks the subarray continuity.
4.  By comparing products in both directions at each step, we ensure we don’t miss any possible maximum.

```cpp
#include <bits/stdc++.h>
using namespace std;

// This function returns the maximum product subarray
// using prefix and suffix traversal
class Solution {
public:
    int maxProductSubArray(vector<int>& arr) {
        // Store size of array
        int n = arr.size();

        // Initialize prefix and suffix product
        int pre = 1, suff = 1;

        // Initialize answer to negative infinity
        int ans = INT_MIN;

        // Traverse from both left and right
        for (int i = 0; i < n; i++) {
            // Reset prefix if zero
            if (pre == 0) pre = 1;

            // Reset suffix if zero
            if (suff == 0) suff = 1;

            // Multiply prefix with current element from front
            pre *= arr[i];

            // Multiply suffix with current element from back
            suff *= arr[n - i - 1];

            // Update the maximum of all products seen so far
            ans = max(ans, max(pre, suff));
        }

        // Return the final answer
        return ans;
    }
};

int main() {
    // Sample input
    vector<int> arr = {2, 3, -2, 4};

    // Create object of solution
    Solution obj;

    // Call the function and print the result
    cout << obj.maxProductSubArray(arr) << endl;

    return 0;
}
```
### Complexity Analysis
- **Time Complexity:** O(N), every element of array is visited once.
- **Space Complexity:** O(1), constant number of variables are used.

---

## Optimal Approach - 2

### Algorithm
In a product-based subarray problem, a negative number can flip the sign, turning a big minimum into a potential maximum. So, we track both the maximum and minimum products at each step. This helps handle negative numbers effectively.

1.  Start by setting the answer, current max product, and current min product to the first number.
2.  For each number in the array starting from the second:
    *   If the number is negative, **swap** current max and min. This is because multiplying a maximum (positive) by a negative makes it a minimum, and multiplying a minimum (negative) by a negative makes it a maximum.
    *   If the product of the current number and previous max is larger than the number itself, update current max to that product; otherwise, set it to the number (starting a new subarray).
    *   Similarly, if the product of the current number and previous min is smaller, update current min; otherwise, set it to the number.
3.  If the current max is greater than the answer so far, update the answer.
4.  Return the answer at the end.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // This function returns the maximum product
    // of any contiguous subarray using optimized approach
    int maxProduct(vector<int>& nums) {
        // Initialize answer, max and min product as first element
        int res = nums[0];
        int maxProd = nums[0];
        int minProd = nums[0];

        // Traverse from second element
        for (int i = 1; i < nums.size(); i++) {
            // Store current number
            int curr = nums[i];

            // If current number is negative, swap max and min
            if (curr < 0) swap(maxProd, minProd);

            // Update max and min product ending at current index
            maxProd = max(curr, maxProd * curr);
            minProd = min(curr, minProd * curr);

            // Update global result
            res = max(res, maxProd);
        }

        // Return the result
        return res;
    }
};

int main() {
    vector<int> nums = {2, 3, -2, 4};
    Solution sol;
    cout << sol.maxProduct(nums);
    return 0;
}
```
### Complexity Analysis
- **Time Complexity:** O(N), every element of array is visited once.
- **Space Complexity:** O(1), only constant variables are used.
