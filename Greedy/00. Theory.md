## Greedy Algorithms

### ðŸ§  Intuition
A **Greedy Algorithm** builds a solution piece by piece, always choosing the **most immediate benefit** (locally optimal choice) at that specific moment.

It assumes that by making the **best choice right now**, you will end up with the **best overall result** (globally optimal).

**Analogy:**
You are hiking and want to reach the highest peak. A greedy strategy is: "At every step, just take the steepest step upwards."
*   **Pros:** Very fast and simple.
*   **Cons:** You might get stuck on a smaller hill instead of the highest mountain (local maximum vs global maximum).

### ðŸ“ General Algorithm
1.  **Selection Criteria:** Decide what makes an item "best" (e.g., highest value, earliest finish time, lowest cost).
2.  **Sort:** Sort the input data based on this criterion.
3.  **Iterate:** Go through the sorted items.
4.  **Select:** If the current item fits the constraints, take it. Otherwise, discard it.

---

## Local Maximum vs Global Maximum

### ðŸ”ï¸ The Concept (Mountain Analogy)

Imagine a large mountain range with many peaks.

- **Global Maximum:** The absolute highest peak in the entire mountain range (Example: Mt. Everest).
- **Local Maximum:** A peak that is higher than everything immediately around it, but not necessarily the highest overall.

---

### ðŸŽ¯ Greedy Algorithm Context

Greedy algorithms make decisions based on the current situation (locally).

#### Scenario: Reaching the Highest Peak
You start walking. At every step, you choose the path that goes **UP**.

1.  **Greedy Choice:** "Take the steepest step up right now."
2.  **Result:** You climb until you can't go up anymore.
3.  **Outcome:**
    - You might reach the top of a small hill (**Local Maximum**) and get stuck because going anywhere else means going down.
    - You missed the giant mountain next to it (**Global Maximum**) because getting there required going down into a valley first (which Greedy refused to do).

---

### âš–ï¸ Comparison Table

| Feature | Local Maximum | Global Maximum |
| :--- | :--- | :--- |
| **Definition** | Best solution within a small neighborhood | Best solution among all possible solutions |
| **Scope** | Short-term view | Long-term view |
| **Greedy finds?** | **Yes** (always) | **Maybe** (only for specific problems) |
| **Example** | Winning a battle but losing the war | Winning the war |

### ðŸ”‘ Key Takeaway
Greedy algorithms are **fast** but **risky**. They guarantee finding a local maximum, but they only find the global maximum for specific problems (like Fractional Knapsack or Activity Selection).

---

## How to Identify a Greedy Problem ðŸ•µï¸â€â™‚ï¸

Identifying if a problem can be solved with a Greedy approach is tricky because Greedy doesn't always work. Look for these two key properties:

### 1. Greedy Choice Property
You can make a decision that looks best **right now** and never have to reconsider it.
- **Immediate Action:** Just pick the largest/smallest/earliest item.
- **No Backtracking:** Once you make a choice, you don't need to change it later.

> **Test:** "If I pick the optimal item now, does it solve a sub-problem without messing up future choices?"

## 2. Optimal Substructure
An optimal solution to the entire problem contains optimal solutions to the sub-problems.
- If you take the "best" first step, the problem reduces to a smaller version of the same problem.

---

### ðŸš© Common Keywords & Patterns

If you see these phrases in a problem statement, suspect Greedy:

*   **"Maximum / Minimum"** (Optimization problems)
*   **"Most / Least"**
*   **"Earliest / Latest"**
*   **"Continuous / Fractional"** (e.g., Fractional Knapsack vs 0/1 Knapsack)
*   **Sorting is possible** based on some attribute (Start time, Cost, Weight, Ratio).

---

### ðŸ§ª The "Proof by Contradiction" Test (Mental Check)

To be sure, Greedy works. Try this thought experiment:
1.  Assume the Greedy choice is **NOT** part of the optimal solution.
2.  Try to swap your Greedy choice into the optimal solution.
3.  If the solution stays valid and the result is **equal to or better** than the optimal one, then Greedy works.

### ðŸš« When is it NOT Greedy?
*   If picking an item prevents you from picking a *better combination* later (Dependencies).
*   **0/1 Knapsack:** Picking the heaviest item might fill the bag so you can't fit two smaller items that are worth more together. (Needs Dynamic Programming).
*   **Longest Path:** Taking the longest edge first might lead to a dead end.






