## Greedy Algorithms

### ðŸ§  Intuition
A **Greedy Algorithm** builds a solution piece by piece, always choosing the **most immediate benefit** (locally optimal choice) at that specific moment.

It assumes that by making the **best choice right now**, you will end up with the **best overall result** (globally optimal).

**Analogy:**
You are hiking and want to reach the highest peak. A greedy strategy is: "At every step, just take the steepest step upwards."
*   **Pros:** Very fast and simple.
*   **Cons:** You might get stuck on a smaller hill instead of the highest mountain (local maximum vs global maximum).

### ðŸ“ General Algorithm
1.  **Selection Criteria:** Decide what makes an item "best" (e.g., highest value, earliest finish time, lowest cost).
2.  **Sort:** Sort the input data based on this criterion.
3.  **Iterate:** Go through the sorted items.
4.  **Select:** If the current item fits the constraints, take it. Otherwise, discard it.

---

## Local Maximum vs Global Maximum

### ðŸ”ï¸ The Concept (Mountain Analogy)

Imagine a large mountain range with many peaks.

- **Global Maximum:** The absolute highest peak in the entire mountain range (Example: Mt. Everest).
- **Local Maximum:** A peak that is higher than everything immediately around it, but not necessarily the highest overall.

---

### ðŸŽ¯ Greedy Algorithm Context

Greedy algorithms make decisions based on the current situation (locally).

#### Scenario: Reaching the Highest Peak
You start walking. At every step, you choose the path that goes **UP**.

1.  **Greedy Choice:** "Take the steepest step up right now."
2.  **Result:** You climb until you can't go up anymore.
3.  **Outcome:**
    - You might reach the top of a small hill (**Local Maximum**) and get stuck because going anywhere else means going down.
    - You missed the giant mountain next to it (**Global Maximum**) because getting there required going down into a valley first (which Greedy refused to do).

---

### âš–ï¸ Comparison Table

| Feature | Local Maximum | Global Maximum |
| :--- | :--- | :--- |
| **Definition** | Best solution within a small neighborhood | Best solution among all possible solutions |
| **Scope** | Short-term view | Long-term view |
| **Greedy finds?** | **Yes** (always) | **Maybe** (only for specific problems) |
| **Example** | Winning a battle but losing the war | Winning the war |

### ðŸ”‘ Key Takeaway
Greedy algorithms are **fast** but **risky**. They guarantee finding a local maximum, but they only find the global maximum for specific problems (like Fractional Knapsack or Activity Selection).

---

## How to Identify a Greedy Problem ðŸ•µï¸â€â™‚ï¸

Identifying if a problem can be solved with a Greedy approach is tricky because Greedy doesn't always work. Look for these two key properties:

### 1. Greedy Choice Property
You can make a decision that looks best **right now** and never have to reconsider it.
- **Immediate Action:** Just pick the largest/smallest/earliest item.
- **No Backtracking:** Once you make a choice, you don't need to change it later.

> **Test:** "If I pick the optimal item now, does it solve a sub-problem without messing up future choices?"

### 2. Optimal Substructure
An optimal solution to the entire problem contains optimal solutions to the sub-problems.
- If you take the "best" first step, the problem reduces to a smaller version of the same problem.

---

### ðŸš© Common Keywords & Patterns

If you see these phrases in a problem statement, suspect Greedy:

*   **"Maximum / Minimum"** (Optimization problems)
*   **"Most / Least"**
*   **"Earliest / Latest"**
*   **"Continuous / Fractional"** (e.g., Fractional Knapsack vs 0/1 Knapsack)
*   **Sorting is possible** based on some attribute (Start time, Cost, Weight, Ratio).

---

### ðŸ§ª The "Proof by Contradiction" Test (Mental Check)

To be sure, Greedy works. Try this thought experiment:
1.  Assume the Greedy choice is **NOT** part of the optimal solution.
2.  Try to swap your Greedy choice into the optimal solution.
3.  If the solution stays valid and the result is **equal to or better** than the optimal one, then Greedy works.

### ðŸš« When is it NOT Greedy?
*   If picking an item prevents you from picking a *better combination* later (Dependencies).
*   **0/1 Knapsack:** Picking the heaviest item might fill the bag so you can't fit two smaller items that are worth more together. (Needs Dynamic Programming).
*   **Longest Path:** Taking the longest edge first might lead to a dead end.

---

## How to Decide if Greedy Will Work ðŸ¤”

There is no perfect formula, but the best way is to **compare it with Dynamic Programming (DP)**.

- **Greedy:** Makes a choice and never looks back.
- **DP:** Tries all choices (conceptually) and finds the best combination.

We check if making a "selfish" (local) choice ruins future possibilities.

---

### Example 1: Activity Selection (Greedy Works âœ…)

**Problem:** You have meetings with `[start, end]` times. Attend max meetings.
- Meeting A: `[1, 3]`
- Meeting B: `[2, 5]`
- Meeting C: `[4, 6]`

**Greedy Strategy:** Always pick the meeting that **ends earliest**.
1. Pick A `[1, 3]`.
2. Can't pick B (starts at 2, overlap).
3. Pick C `[4, 6]`.
**Result:** 2 meetings.

**Why it works:**
Finishing early frees up **more time** for future meetings. There is no hidden penalty for finishing early. The "space" left for other meetings is maximized.

---

### Example 2: 0/1 Knapsack (Greedy Fails âŒ)

**Problem:** Bag capacity = **5kg**. Maximize value.
- Item 1: 5kg, Value $60
- Item 2: 3kg, Value $50
- Item 3: 2kg, Value $40

**Greedy Strategy 1 (Max Value):**
1. Pick Item 1 ($60). Bag full (5/5).
**Total Value:** $60.

**Optimal Strategy (DP):**
1. Pick Item 2 + Item 3 ($50 + $40 = $90). Weight (3+2 = 5kg).
**Total Value:** $90.

**Why Greedy Failed:**
By greedily picking the most valuable item ($60), we used up **all the space** and blocked a better combination of smaller items ($50+$40). The "greedy choice" had a long-term penalty.

---

### Example 3: Coin Change (Can vary âš ï¸)

**Problem:** Make sum **$6**.

#### Scenario A (Standard Coins): 1, 2, 5
**Greedy (Largest coin first):**
1. Pick 5. Remaining: 1.
2. Pick 1. Remaining: 0.
**Result:** 2 coins (5+1). **Optimal.**

#### Scenario B (Custom Coins): 1, 3, 4
**Greedy (Largest coin first):**
1. Pick 4. Remaining: 2.
2. Pick 1. Remaining: 1.
3. Pick 1. Remaining: 0.
**Result:** 3 coins (4+1+1).

**Optimal Strategy:**
1. Pick 3. Remaining: 3.
2. Pick 3. Remaining: 0.
**Result:** 2 coins (3+3).

**Conclusion:** Greedy works for standard US/Indian currency systems, but fails for arbitrary coin systems (needs DP).

---

### âš¡ Quick Decision Guide

1.  **Can I sort it?** Does sorting by time/cost/value simplify the problem immediately? -> *Maybe Greedy.*
2.  **Is it fractional?** Can I take "half" an item? -> *Always Greedy.*
3.  **Do choices conflict?** Does picking 'A' prevent 'B' and 'C'? If 'B+C' is better than 'A', Greedy fails.




