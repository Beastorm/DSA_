## Job Sequencing Problem (Greedy)

**Problem Statement:**  
Given a set of `N` jobs where each job `i` has a `deadline` and a `profit`.
Each job takes **1 unit of time** to complete.
A job can be completed **only if it is finished before or on its deadline**.

**Task:** Maximize the total profit and find the number of jobs done.

---
## Approach Brute Force:
### Intuition:
To get the maximum profit, we should prioritize the **highest paying jobs**.
However, we must also be careful about deadlines.

**Greedy Strategy:**
1. Sort jobs in **descending order of profit**.
2. Try to schedule each job as **late as possible** (closest to its deadline).
   - *Why late?* Because scheduling it early might block a slot for another job that has an earlier deadline.
3. Use an array (timeline) to keep track of occupied time slots.

---

### ðŸ” Example Walkthrough:

**Jobs:** `(id, deadline, profit)`
1. `(1, 4, 20)`
2. `(2, 1, 10)`
3. `(3, 1, 40)`
4. `(4, 1, 30)`

**Step 1: Sort by Profit (Descending)**
1. `(3, 1, 40)`
2. `(4, 1, 30)`
3. `(1, 4, 20)`
4. `(2, 1, 10)`

**Max Deadline = 4**. Timeline array: `[-1, -1, -1, -1, -1]` (Index 0 unused).

**Step 2: Assign Slots (Late as possible)**

1. **Job 3 (Profit 40, Deadline 1):**
   - Check slot 1. Empty? Yes.
   - Assign Job 3 to Slot 1.
   - Timeline: `[x, 3, -1, -1, -1]`
   - **Profit: 40**

2. **Job 4 (Profit 30, Deadline 1):**
   - Check slot 1. Empty? No (Occupied by Job 3).
   - No earlier slots > 0.
   - **Skip Job 4.**

3. **Job 1 (Profit 20, Deadline 4):**
   - Check slot 4. Empty? Yes.
   - Assign Job 1 to Slot 4.
   - Timeline: `[x, 3, -1, -1, 1]`
   - **Profit: 40 + 20 = 60**

4. **Job 2 (Profit 10, Deadline 1):**
   - Check slot 1. Empty? No.
   - **Skip Job 2.**

**Final Result:** 2 Jobs done, Profit 60.

---

### ðŸ’» Code (C++):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Job {
    int id;
    int deadline;
    int profit;
};

// Sort by Profit Descending
bool comparator(Job a, Job b) {
    return a.profit > b.profit;
}

void JobScheduling(Job arr[], int n) {
    sort(arr, arr + n, comparator);

    // Find max deadline to size our timeline array
    int maxDeadline = 0;
    for (int i = 0; i < n; i++) maxDeadline = max(maxDeadline, arr[i].deadline);

    // Timeline array: slot[i] stores Job ID done at time i
    vector<int> slot(maxDeadline + 1, -1);

    int countJobs = 0, jobProfit = 0;

    for (int i = 0; i < n; i++) {
    
        // Find a free slot for this job (start from its deadline backwards)
        for (int j = arr[i].deadline; j > 0; j--) {
            if (slot[j] == -1) {
            
                slot[j] = arr[i].id;
                countJobs++;
                
                jobProfit += arr[i].profit;
                
                break;
            }
        }
    }

    cout << "Jobs done: " << countJobs << endl;
    cout << "Total Profit: " << jobProfit << endl;
}

int main() {
    Job arr[] = {{1, 4, 20}, {2, 1, 10}, {3, 1, 40}, {4, 1, 30}};
    int n = sizeof(arr) / sizeof(arr[0]);
    JobScheduling(arr, n);
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N log N) + O(N * M)**
  - **O(N log N)** is required to sort the jobs in descending order of profit.
  - **O(N * M)** is the worst-case time for the nested loop, where `N` is the number of jobs and `M` is the maximum deadline. For each job, we might iterate backwards through the timeline array of size `M`.
  
- **Space Complexity:** **O(M)**
  - We use an auxiliary array `slot` of size `M + 1` (where `M` is the maximum deadline) to keep track of booked time slots.

---

## Approach DSU:

###  Intuition:
The standard greedy approach sorts jobs by profit and then linearly searches backward for the latest available slot. If the max deadline is `M`, this linear search costs `O(M)`. For `N` jobs, total time is `O(N * M)`.

To optimize this linear search, we can treat time slots as a set. When a slot `t` is taken, we want to efficiently find the **next available slot** strictly less than `t`.

**Disjoint Set Union (DSU)** is perfect for this:
- Imagine each time slot `i` points to itself initially (`parent[i] = i`).
- When we occupy slot `i`, we unite it with `i-1`.
- Now, `find(i)` will point to `find(i-1)`.
- If we try to take slot `i` again, `find(i)` essentially jumps over the occupied slot directly to the next free one to the left.

This effectively compresses the path of occupied slots, turning the `O(M)` search into nearly `O(1)`.


### Algorithm:

1.  **Sort:** Sort all jobs in descending order of profit.
2.  **Max Deadline:** Find the maximum deadline `M` among all jobs to size our DSU array.
3.  **Init DSU:** Create `parent` array of size `M+1`. Initialize `parent[i] = i`.
4.  **Iterate Jobs:** For each job with deadline `d`:
    - Find the latest available slot: `slot = find(d)`.
    - **If `slot > 0`:**
        - Assign the job to this slot.
        - Add profit and increment count.
        - **Union:** Mark slot as taken by linking it to the previous slot: `parent[slot] = slot - 1`.
    - **If `slot == 0`:** No available slot exists for this job (discard it).
5.  **Return:** Total count and total profit.

---

### C++ Code:
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric> // For max_element

using namespace std;

struct Job {
    int id;
    int dead;
    int profit;
};

/*
 Sort jobs in decreasing order of profit
*/
bool comp(Job a, Job b) {
    return a.profit > b.profit;
}

/*
 DSU find function
 Finds the latest available slot <= num
*/
int find(int num, vector<int> &parent) {
    if (num == parent[num])
        return num;

    // Path compression
    return parent[num] = find(parent[num], parent);
}

class Solution {
public:
    vector<int> JobScheduling(Job arr[], int n) {

        // Sort jobs by profit (descending)
        sort(arr, arr + n, comp);

        // Find maximum deadline
        int maxDeadline = 0;
        for (int i = 0; i < n; i++)
            maxDeadline = max(maxDeadline, arr[i].dead);

        // DSU parent array: parent[i] points to the next available slot <= i
        vector<int> parent(maxDeadline + 1);
        for (int i = 0; i <= maxDeadline; i++)
            parent[i] = i;

        vector<int> ans(2, 0);
        // ans[0] = number of jobs done
        // ans[1] = total profit

        // Try to schedule each job
        for (int i = 0; i < n; i++) {

            // Find the latest available slot for this job using DSU
            // Instead of a linear scan, this is nearly O(1)
            int availableSlot = find(arr[i].dead, parent);

            if (availableSlot > 0) {
                // Job can be scheduled at availableSlot
                ans[0]++;                       // Increment job count
                ans[1] += arr[i].profit;        // Add profit

                // Union: Mark this slot as occupied by pointing it to slot-1
                // So next time we search for this slot, we get directed to slot-1
                parent[availableSlot] = find(availableSlot - 1, parent);
            }
        }

        return ans;
    }
};

int main() {
    Job arr[] = {{1, 4, 20}, {2, 1, 10}, {3, 1, 40}, {4, 1, 30}};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    Solution ob;
    vector<int> result = ob.JobScheduling(arr, n);
    
    cout << "Jobs done: " << result[0] << endl;
    cout << "Total Profit: " << result[1] << endl;
    
    return 0;
}
```
### â± Complexity Analysis:

- **Time Complexity:**
   - **Sorting:** `O(N log N)`
   - **DSU Operations:** We perform `N` find operations. With path compression, each takes `O(Î±(M))`, which is nearly constant ($\le 4$).
   - **Total:** **O(N log N + N)**  *(Effective)*

- **Space Complexity:**
   - **O(M)** for the `parent` array, where `M` is the maximum deadline.
