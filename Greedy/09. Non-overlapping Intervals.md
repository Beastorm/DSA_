## Non-overlapping Intervals (Greedy Approach)

**Problem Statement:**   
Given a collection of intervals `[start, end]`.
**Task:** Find the **minimum number of intervals you need to remove** to make the rest of the intervals non-overlapping.

---

### ðŸ§  Intuition:
This is almost identical to the **N Meetings in One Room** problem.
Instead of maximizing meetings, we want to minimize removals.
Since `Total Intervals = Kept + Removed`, minimizing removed intervals is the same as **maximizing kept intervals**.

**Strategy:**
1. Sort intervals by **End Time**.
2. Greedily pick intervals that finish earliest and don't overlap with the previous one.
3. Count how many we kept.
4. Answer = Total Intervals - Count Kept.

*(Alternatively, sort by end time and count overlaps directly)*.

---

### ðŸ” Example Walkthrough:
**Input:** `[[1,2], [2,3], [3,4], [1,3]]`.

**Step 1: Sort by End Time**
1. `[1,2]` (Ends 2)
2. `[2,3]` (Ends 3)
3. `[1,3]` (Ends 3)
4. `[3,4]` (Ends 4)

**Step 2: Greedily Keep Non-overlapping**
- **Pick** `[1,2]`. End = 2.
- Check `[2,3]`: Start (2) >= End (2). **Keep**. New End = 3.
- Check `[1,3]`: Start (1) < End (3). **Overlap! Remove.**
- Check `[3,4]`: Start (3) >= End (3). **Keep**. New End = 4.

**Total Removed:** 1 (`[1,3]`)

---

### ðŸ’» Code (C++):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Comparator to sort by end time
bool compare(vector<int>& a, vector<int>& b) {
    return a[1] < b[1];
}

int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    if (intervals.empty()) return 0;

    // 1. Sort by end time
    sort(intervals.begin(), intervals.end(), compare);

    int count = 0; // Count of intervals to remove
    int lastEnd = intervals[0][1]; // End time of last kept interval

    // 2. Iterate starting from the second interval
    for (int i = 1; i < intervals.size(); i++) {

        // If current start < last end, it overlaps
        if (intervals[i][0] < lastEnd) {

            count++; // We must remove this one (greedy choice: keep the one ending sooner)
        } else {

            // No overlap, update last end
            lastEnd = intervals[i][1];
        }
    }

    return count;
}

int main() {
    vector<vector<int>> intervals = {{1,2}, {2,3}, {3,4}, {1,3}};
    cout << "Minimum intervals to remove: " << eraseOverlapIntervals(intervals) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N log N)**
  - **Sorting** the intervals based on their end times is the dominant operation, taking `O(N log N)`.
  - The subsequent iteration through the sorted intervals is a single pass, taking `O(N)`.

- **Space Complexity:** **O(1)**
  - We assume the sorting algorithm works in-place (e.g., `std::sort` in C++ usually uses introsort, which has `O(log N)` stack depth, but auxiliary space is considered constant relative to input size for logic purposes).
  - We use only a few integer variables (`count`, `lastEnd`) for tracking.
