## Insert Interval (Logic/Greedy)

**Problem Statement:**  
Given a set of **non-overlapping** intervals sorted by start time, insert a `newInterval` into the intervals (merge if necessary).
  
**Task:** Return the new sorted list of intervals.

---

### ðŸ§  Intuition:
Since the original list is already sorted, we can iterate through it once and handle three cases for each interval:

1.  **Before Merge:** Current interval ends before new interval starts. (No overlap, just add current).
2.  **Overlapping:** Current interval overlaps with new interval.
    - We don't add yet.
    - We **merge** them: `newStart = min`, `newEnd = max`.
3.  **After Merge:** Current interval starts after the new interval ends.
    - If we haven't added the merged interval yet, add it now.
    - Then add the current interval.

**Strategy:** Linear Scan.

---

### ðŸ” Example Walkthrough:
**Intervals:** `[[1,3], [6,9]]`, **New:** `[2,5]`

1.  **Check `[1,3]`:**
    - Ends at 3. New starts at 2. `3 >= 2`? Yes. **Overlap.**
    - Merge: `start = min(1, 2) = 1`, `end = max(3, 5) = 5`.
    - New Merged Interval: `[1, 5]`.
2.  **Check `[6,9]`:**
    - Starts at 6. Merged ends at 5. `6 > 5`? Yes. **After.**
    - Add Merged `[1, 5]`.
    - Add Current `[6, 9]`.

**Result:** `[[1,5], [6,9]]`

---

### ðŸ’» Code (C++):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
    vector<vector<int>> result;
    int i = 0;
    int n = intervals.size();

    // 1. Add all intervals ending before newInterval starts
    while (i < n && intervals[i][1] < newInterval[0]) {
        result.push_back(intervals[i]);
        i++;
    }

    // 2. Merge overlapping intervals
    // While current interval overlaps with newInterval
    // Overlap condition: start of current <= end of new
    while (i < n && intervals[i][0] <= newInterval[1]) {
        newInterval[0] = min(newInterval[0], intervals[i][0]);
        newInterval[1] = max(newInterval[1], intervals[i][1]);
        i++;
    }
    result.push_back(newInterval);

    // 3. Add remaining intervals
    while (i < n) {
        result.push_back(intervals[i]);
        i++;
    }

    return result;
}

int main() {
    vector<vector<int>> intervals = {{1,3}, {6,9}};
    vector<int> newInterval = {2,5};
    
    vector<vector<int>> ans = insert(intervals, newInterval);
    
    cout << "Result: ";
    for (auto v : ans) cout << "[" << v[0] << "," << v[1] << "] ";
    cout << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N)**
  - We perform a single pass through the given list of intervals.
  - Each interval is visited and processed exactly once.

- **Space Complexity:** **O(N)**
  - We create a new vector to store the result, which in the worst case (no merging) contains `N + 1` intervals.
  - If we do not count the return space, auxiliary space is **O(1)**.
