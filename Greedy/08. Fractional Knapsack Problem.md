## Fractional Knapsack Problem (Greedy Approach)

**Problem Statement:**   
Given `N` items, each with a `weight` and a `value`. You have a knapsack with capacity `W`.
You can break items to take a fraction of them.
**Task:** Find the maximum total value you can carry in the knapsack.

---

### ðŸ§  Intuition:
Since we can take fractions, we should prioritize items that give the **most value per unit of weight**. It's like buying the most expensive spice first to fill your jar.

**Greedy Strategy:**
1. Calculate the **ratio** `(value / weight)` for each item.
2. Sort items in **descending order** of this ratio.
3. Iterate through the sorted items:
   - If the full item fits, take it all.
   - If it doesn't fit, take as much as possible (fill the remaining space) and stop.

---

### ðŸ” Example Walkthrough:

**Capacity (W):** 50
**Items:**
1. Val: 60, Wt: 10
2. Val: 100, Wt: 20
3. Val: 120, Wt: 30

**Step 1: Calculate Ratios**
- Item 1: `60 / 10 = 6.0`
- Item 2: `100 / 20 = 5.0`
- Item 3: `120 / 30 = 4.0`

**Step 2: Sort Descending**
Order: Item 1 > Item 2 > Item 3.

**Step 3: Fill Knapsack**
1. **Item 1:** Fits? Yes (10 <= 50).
   - Take all 10kg.
   - Value = 60.
   - Remaining Capacity = 50 - 10 = 40.
2. **Item 2:** Fits? Yes (20 <= 40).
   - Take all 20kg.
   - Value = 60 + 100 = 160.
   - Remaining Capacity = 40 - 20 = 20.
3. **Item 3:** Fits? No (30 > 20).
   - Take remaining capacity (20kg).
   - Fraction = `20 / 30`.
   - Value added = `120 * (20/30) = 80`.
   - Total Value = 160 + 80 = 240.
   - Capacity full. Stop.

**Final Answer:** 240.

---

### ðŸ’» Code (C++):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Item {
    int value;
    int weight;
};

// Comparator to sort by Value/Weight ratio descending
bool compare(Item a, Item b) {
    double r1 = (double)a.value / a.weight;
    double r2 = (double)b.value / b.weight;
    return r1 > r2;
}

double fractionalKnapsack(int W, Item arr[], int n) {
    // Sort based on ratio
    sort(arr, arr + n, compare);

    int curWeight = 0;
    double finalValue = 0.0;

    for (int i = 0; i < n; i++) {
        // If adding Item won't overflow, add it completely
        if (curWeight + arr[i].weight <= W) {
            curWeight += arr[i].weight;
            finalValue += arr[i].value;
        }
        
        // If we can't add a full Item, add a fractional part
        else {
            int remain = W - curWeight;
            finalValue += arr[i].value * ((double)remain / arr[i].weight);  // This calculates the **fraction** of the item we can take.
            break; // Knapsack is full
        }
    }
    return finalValue;
}

int main() {
    int W = 50;
    Item arr[] = {{60, 10}, {100, 20}, {120, 30}};
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Maximum value we can obtain = " << fractionalKnapsack(W, arr, n) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N log N)**
  - **Sorting** the items based on their value-to-weight ratio takes `O(N log N)`.
  - The subsequent linear pass to select items takes `O(N)`.
  - The overall complexity is dominated by the sorting step.

- **Space Complexity:** **O(1)**
  - We assume the sorting is done in-place.
  - Only a constant amount of extra space is used for variables like `curWeight` and `finalValue`.
