## Job Sequencing Problem (Greedy)

**Problem Statement:**  
Given a set of `N` jobs where each job `i` has a `deadline` and a `profit`.
Each job takes **1 unit of time** to complete.
A job can be completed **only if it is finished before or on its deadline**.

**Task:** Maximize the total profit and find the number of jobs done.

---

### ðŸ§  Intuition:
To get the maximum profit, we should prioritize the **highest paying jobs**.
However, we must also be careful about deadlines.

**Greedy Strategy:**
1. Sort jobs in **descending order of profit**.
2. Try to schedule each job as **late as possible** (closest to its deadline).
   - *Why late?* Because scheduling it early might block a slot for another job that has an earlier deadline.
3. Use an array (timeline) to keep track of occupied time slots.

---

### ðŸ” Example Walkthrough:

**Jobs:** `(id, deadline, profit)`
1. `(1, 4, 20)`
2. `(2, 1, 10)`
3. `(3, 1, 40)`
4. `(4, 1, 30)`

**Step 1: Sort by Profit (Descending)**
1. `(3, 1, 40)`
2. `(4, 1, 30)`
3. `(1, 4, 20)`
4. `(2, 1, 10)`

**Max Deadline = 4**. Timeline array: `[-1, -1, -1, -1, -1]` (Index 0 unused).

**Step 2: Assign Slots (Late as possible)**

1. **Job 3 (Profit 40, Deadline 1):**
   - Check slot 1. Empty? Yes.
   - Assign Job 3 to Slot 1.
   - Timeline: `[x, 3, -1, -1, -1]`
   - **Profit: 40**

2. **Job 4 (Profit 30, Deadline 1):**
   - Check slot 1. Empty? No (Occupied by Job 3).
   - No earlier slots > 0.
   - **Skip Job 4.**

3. **Job 1 (Profit 20, Deadline 4):**
   - Check slot 4. Empty? Yes.
   - Assign Job 1 to Slot 4.
   - Timeline: `[x, 3, -1, -1, 1]`
   - **Profit: 40 + 20 = 60**

4. **Job 2 (Profit 10, Deadline 1):**
   - Check slot 1. Empty? No.
   - **Skip Job 2.**

**Final Result:** 2 Jobs done, Profit 60.

---

### ðŸ’» Code (C++):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Job {
    int id;
    int deadline;
    int profit;
};

// Sort by Profit Descending
bool comparator(Job a, Job b) {
    return a.profit > b.profit;
}

void JobScheduling(Job arr[], int n) {
    sort(arr, arr + n, comparator);

    // Find max deadline to size our timeline array
    int maxDeadline = 0;
    for (int i = 0; i < n; i++) maxDeadline = max(maxDeadline, arr[i].deadline);

    // Timeline array: slot[i] stores Job ID done at time i
    vector<int> slot(maxDeadline + 1, -1);

    int countJobs = 0, jobProfit = 0;

    for (int i = 0; i < n; i++) {
        // Find a free slot for this job (start from its deadline backwards)
        for (int j = arr[i].deadline; j > 0; j--) {
            if (slot[j] == -1) {
                slot[j] = arr[i].id;
                countJobs++;
                jobProfit += arr[i].profit;
                break;
            }
        }
    }

    cout << "Jobs done: " << countJobs << endl;
    cout << "Total Profit: " << jobProfit << endl;
}

int main() {
    Job arr[] = {{1, 4, 20}, {2, 1, 10}, {3, 1, 40}, {4, 1, 30}};
    int n = sizeof(arr) / sizeof(arr[0]);
    JobScheduling(arr, n);
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N log N) + O(N * M)**
  - **O(N log N)** is required to sort the jobs in descending order of profit.
  - **O(N * M)** is the worst-case time for the nested loop, where `N` is the number of jobs and `M` is the maximum deadline. For each job, we might iterate backwards through the timeline array of size `M`.
  
- **Space Complexity:** **O(M)**
  - We use an auxiliary array `slot` of size `M + 1` (where `M` is the maximum deadline) to keep track of booked time slots.
