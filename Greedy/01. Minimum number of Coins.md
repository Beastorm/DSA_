## Minimum Number of Coins
**Problem Statement:**   
Given an infinite supply of coins with specific denominations, find the **minimum number of coins** needed to make a specific `value`.

**Note:** The Greedy approach only works for standard currency systems (like Indian: 1, 2, 5, 10, 20, 50, 100, 500, 1000). For arbitrary systems, you need Dynamic Programming.

---

## ðŸ§  Intuition
To minimize the count of coins, we should take the **largest possible coin** first.
If we want to make Rs. 49:
- Taking Rs. 1 coins = 49 coins (Bad)
- Taking Rs. 20 coins first reduces the remaining amount drastically (Better)

**Strategy:**
1. Sort coins in descending order (largest to smallest).
2. For each coin, take as many as possible until the `value` becomes smaller than the coin.
3. Move to the next smaller coin.

---

## ðŸ’» Code (C++)

```cpp
#include <iostream>
#include <vector>
using namespace std;

void minCoins(int value) {
    // Standard Indian Currency (must be sorted descending for greedy)
    int denominations[] = {1000, 500, 100, 50, 20, 10, 5, 2, 1};
    int n = sizeof(denominations) / sizeof(denominations[0]);
    
    vector<int> result;
    
    for (int i = 0; i < n; i++) {
        // While the current coin can fit in the remaining value
        while (value >= denominations[i]) {
            value -= denominations[i];
            result.push_back(denominations[i]);
        }
    }
    
    // Output
    cout << "Total Coins Used: " << result.size() << endl;
    cout << "Coins: ";
    for (int coin : result) {
        cout << coin << " ";
    }
    cout << endl;
}

int main() {
    int amount = 49;
    minCoins(amount);
    return 0;
}
```
**Output:**   
```
Total Coins Used: 5
Coins: 20 20 5 2 2 
```

### Complexity Analysis

- **Time Complexity:** **O(V)**
  where `V` is the value to be changed.
  - In the worst case (e.g., if denominations include only 1), the inner `while` loop runs `V` times.
  - Although faster with larger denominations, the complexity is technically dominated by the value.

- **Space Complexity:** **O(1)**
  - The denominations array is fixed in size.
  - We might store the result in a vector, but auxiliary space for calculation is constant.

---

### âš ï¸ Important Warning:

The Greedy approach does **NOT** work for all coin systems.

#### Example Failure
**Coins:** `{1, 3, 4}`
**Target:** `6`

1.  **Greedy (Largest First):**
    - Picks 4. Remaining: 2.
    - Picks 1. Remaining: 1.
    - Picks 1. Remaining: 0.
    - **Total:** 3 coins (4 + 1 + 1)

2.  **Optimal Solution:**
    - Picks 3. Remaining: 3.
    - Picks 3. Remaining: 0.
    - **Total:** 2 coins (3 + 3)

**Conclusion:** For arbitrary coin systems, Greedy fails. Use **Dynamic Programming** instead.

### Why Greedy Fails Here? âŒ

Greedy fails because it makes a **local optimal choice** without considering the future consequences.

In the `{1, 3, 4}` example for target `6`:

1.  **Greedy Choice:** Picking `4` seems best initially because it reduces the remaining sum the most ($6 - 4 = 2$).
2.  **The Trap:** By picking `4`, we are left with `2`. The coin `3` is now useless because it's greater than `2`. We are forced to use multiple `1`s.
3.  **Optimal Path:** If we had "sacrificed" the immediate gain of picking `4` and picked `3` instead, we would be left with `3`, allowing us to pick `3` again.

**Greedy creates a "bad remainder"** that forces inefficient moves later. DP checks all remainders to find the best path.
