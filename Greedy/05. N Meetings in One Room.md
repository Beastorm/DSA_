## N Meetings in One Room (Greedy Approach)

**Problem Statement:**   
There is **one meeting room**. You are given `N` meetings with `(start, end)` times.
You need to select the **maximum number of meetings** such that no two meetings overlap.

---
## Appraoch
### Intuition:
To fit the most meetings into a single room, you want each meeting to finish as **quickly as possible**.
The sooner a meeting ends, the sooner the room becomes free for the next one.

**Greedy Strategy:**
1. Sort all meetings by their **End Time**.
2. Pick the first meeting (ends earliest).
3. Pick the next meeting only if its `start time` is **greater** than the `end time` of the previously selected meeting.

---

### ðŸ’» Code (C++):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Meeting {
    int start;
    int end;
    int pos;
};

// Comparator: Sort by End Time ascending
bool comparator(Meeting m1, Meeting m2) {
    if (m1.end < m2.end) return true;
    else if (m1.end > m2.end) return false;
    else return m1.pos < m2.pos; // Tie-breaker: smaller index first
}

void maxMeetings(int s[], int e[], int n) {
    vector<Meeting> meet(n);
    for (int i = 0; i < n; i++) {
        meet[i].start = s[i];
        meet[i].end = e[i];
        meet[i].pos = i + 1;
    }

    // 1. Sort by finish time
    sort(meet.begin(), meet.end(), comparator);

    vector<int> answer;
    
    // 2. Always pick the first meeting
    int limit = meet[0].end;
    answer.push_back(meet[0].pos);

    // 3. Iterate and check for non-overlapping
    for (int i = 1; i < n; i++) {
        if (meet[i].start > limit) {
            limit = meet[i].end;
            answer.push_back(meet[i].pos);
        }
    }

    // Output
    cout << "Maximum Meetings: " << answer.size() << endl;
    cout << "Selected Meeting IDs: ";
    for (int id : answer) cout << id << " ";
    cout << endl;
}

int main() {
    int start[] = {1, 3, 0, 5, 8, 5};
    int end[] =   {2, 4, 6, 7, 9, 9};
    int n = sizeof(start) / sizeof(start[0]);
    maxMeetings(start, end, n);
    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** $O(N log N)$
  - **Sorting** the array of meetings based on end times takes `O(N log N)`.
  - The subsequent linear iteration to select meetings takes `O(N)`.
  - The total time is dominated by the sorting step.

- **Space Complexity:** $O(N)$
  - We use an auxiliary vector of size `N` to store the `Meeting` objects (start, end, index).
  - An additional vector is used to store the IDs of selected meetings (up to `N` in the worst case).
