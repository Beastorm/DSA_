## Shop in Candy Store (Greedy Approach)

**Problem Statement:**
In a candy store, there are `N` different types of candies available.
For every candy you buy, you can get **K other candies for free**.

**Task:** Find the **minimum** and **maximum** amount of money required to buy all `N` candies.

---

### ðŸ§  Intuition:

### 1. For Minimum Cost
To spend the least money, you should:
- **Buy** the **cheapest** candies.
- **Get free** the **most expensive** candies.

**Strategy:**
1. Sort prices in **ascending** order.
2. Buy from the **start** (cheapest).
3. For every buy, pick `K` candies from the **end** (most expensive) as free.

### 2. For Maximum Cost
To spend the most money (e.g., to support the shop), you should:
- **Buy** the **most expensive** candies.
- **Get free** the **cheapest** candies.

**Strategy:**
1. Sort prices in **ascending** order.
2. Buy from the **end** (most expensive).
3. For every buy, pick `K` candies from the **start** (cheapest) as free.

---

### ðŸ’» Code (C++):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

using namespace std;

vector<int> candyStore(int candies[], int N, int K) {
    // 1. Sort the candies by price
    sort(candies, candies + N);

    int minCost = 0;
    int maxCost = 0;

    // Calculate Min Cost
    int buy = 0;
    int free = N - 1;
    while (buy <= free) {
        minCost += candies[buy]; // Buy cheapest
        buy++;
        free -= K; // Take K most expensive for free
    }

    // Calculate Max Cost
    buy = N - 1;
    free = 0;
    while (free <= buy) {
        maxCost += candies[buy]; // Buy most expensive
        buy--;
        free += K; // Take K cheapest for free
    }

    return {minCost, maxCost};
}

int main() {
    int N = 4;
    int K = 2;
    int candies[] = {3, 2, 1, 4};

    vector<int> result = candyStore(candies, N, K);
    cout << "Min Cost: " << result[0] << endl;
    cout << "Max Cost: " << result[1] << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N log N)**
  - **Sorting** the array takes `O(N log N)`.
  - The linear traversal to calculate min/max cost takes `O(N)`.
  - The overall complexity is dominated by the sorting step.

- **Space Complexity:** **O(1)**
  - We only use a few variables for tracking indices and sums.
  - Sorting is assumed to be in-place.
