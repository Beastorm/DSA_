## Assign Mice to Holes (Greedy Approach)

**Problem Statement:**   
There are `N` mice and `N` holes placed at distinct positions on a straight line (1D number line).
Each mouse takes 1 minute to travel 1 unit of distance.
A mouse can move left or right. Only one mouse can go into one hole.

**Task:** Assign mice to holes so that the **time taken by the last mouse** to enter a hole is **minimized**.

---

### ðŸ§  Intuition:
To minimize the maximum time (bottleneck), we don't want any single mouse to travel a very long distance while a closer hole is available but taken by someone else.

**The "Sorting Strategy" (Greedy):**
- The mouse at the far left should naturally go to the hole at the far left.
- The mouse at the far right should go to the hole at the far right.
- Crossing paths (e.g., left mouse to right hole, right mouse to left hole) always increases the maximum travel distance.

**Algorithm:**
1. Sort the mice positions.
2. Sort the hole positions.
3. The `i-th` mouse goes to the `i-th` hole.
4. Calculate the time `|Mouse[i] - Hole[i]|` for all `i`.
5. The answer is the **maximum** of these times.

---

### ðŸ’» Code (C++):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

int assignMiceHoles(int N, vector<int>& mice, vector<int>& holes) {
    // 1. Sort both arrays
    sort(mice.begin(), mice.end());
    sort(holes.begin(), holes.end());

    int maxTime = 0;

    // 2. Pair the i-th mouse with the i-th hole
    for (int i = 0; i < N; i++) {
        int time = abs(mice[i] - holes[i]);
        maxTime = max(maxTime, time);
    }

    return maxTime;
}

int main() {
    vector<int> mice = {4, -4, 2};
    vector<int> holes = {4, 0, 5};
    int N = mice.size();

    cout << "Minimum Max Time: " << assignMiceHoles(N, mice, holes) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N log N)**
  - **Sorting** both the mice and holes arrays takes `O(N log N)`.
  - The subsequent loop to find the maximum difference takes `O(N)`.
  - Thus, the overall time complexity is dominated by the sorting step.

- **Space Complexity:** **O(1)**
  - We perform sorting in-place (assuming standard library sort usage on mutable vectors).
  - Only a few variables are used for calculations, requiring constant extra space.
