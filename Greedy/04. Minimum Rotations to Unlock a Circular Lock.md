## Minimum Rotations to Unlock a Circular Lock (Greedy)

**Problem Statement:**   
You are given a circular lock with 3 wheels, each having digits `0-9`.
The lock currently shows a starting code (e.g., "123").
You want to reach a target unlocking code (e.g., "567").

**Constraint:**   
- The wheels are circular: `0` is adjacent to `9` (going backward from 0 gives 9, going forward from 9 gives 0).
- You can rotate each wheel independently forward or backward.

**Task:** Find the **minimum total rotations** required.

---

### ðŸ§  Intuition (Greedy Choice)
Since each wheel moves independently, we can solve the problem for each digit separately and sum the results.

For any single-digit change (say, `a` to `b`), there are only two paths:
1.  **Forward:** `|a - b|`
2.  **Backward (Circular):** `10 - |a - b|`

**Example:** Change `1` to `9`.
- Path 1 (Direct): `|1 - 9| = 8` moves.
- Path 2 (Circular): `10 - 8 = 2` moves (1 -> 0 -> 9).
- **Greedy:** Choose `min(8, 2) = 2`.

---

### ðŸ’» Code (C++):

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

int rotationCount(int input, int unlock_code) {
    int rotations = 0;

    // Process digit by digit (last digit to first)
    // Assuming 3-digit inputs as per typical problem constraints
    // If generic, use strings.
    while (input > 0 || unlock_code > 0) {
        int d1 = input % 10;
        int d2 = unlock_code % 10;

        // Path 1: Direct difference
        int diff = abs(d1 - d2);

        // Path 2: Wrap around (10 - diff)
        int wrapAround = 10 - diff;

        // Add the minimum of the two
        rotations += min(diff, wrapAround);

        input /= 10;
        unlock_code /= 10;
    }
    return rotations;
}

int main() {
    int current = 2345;
    int target = 5432;
    cout << "Total rotations: " << rotationCount(current, target) << endl;
    return 0;
}
```
### Complexity Analysis

- **Time Complexity:** **O(D)**
  - Where `D` is the number of digits in the lock (constant for a fixed-size lock, e.g., 3 or 4).
  - If the input is generalized as a string of length `N`, the complexity is **O(N)** as we iterate through each digit once.

- **Space Complexity:** **O(1)**
  - We only use a few integer variables to store sums and differences.
