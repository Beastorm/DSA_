## Task Scheduler (Math/Greedy)

**Problem Statement:**  
Given a list of tasks (characters `A`-`Z`) and a cooling time `n`.
Same tasks must be separated by `n` units of time.  

**Task:** Minimum time to complete all.

---

### üß† Intuition:
To minimize time, we want to maximize the overlap of different tasks within the cooling periods. The "bottleneck" is the **most frequent task**.

**Strategy:**
1. Find the frequency of the most frequent task (`maxFreq`).
2. Imagine arranging the most frequent task (say 'A') with `n` gaps between them:
   `A _ _ A _ _ A`
3. Number of chunks (groups ending with A, except the last one) = `maxFreq - 1`.
4. Empty slots in chunks = `(maxFreq - 1) * n`.
5. Fill these empty slots with other tasks.
6. If we have more tasks than slots, we just widen the gaps (time = total tasks).
7. If we have fewer tasks, idle time remains.

**Formula:**
`Time = (maxFreq - 1) * (n + 1) + Count of MaxFreq Tasks`

*(Corner case: Result can never be less than `tasks.size()`)*

---

### üîç Example Walkthrough:
**Tasks:** `[A, A, A, B, B, B]`, **n:** `2`

1. **Frequencies:** A: 3, B: 3.
2. **Max Freq:** 3 (A).
3. **Structure:** `A _ _ A _ _ A`
   - Groups: `3 - 1 = 2`.
   - Length of group: `n + 1 = 3`.
   - Base Time: `2 * 3 = 6` (`A _ _ A _ _`).
4. **Add Last Chunk:**
   - How many tasks have max freq? A and B. Count = 2.
   - Total: `6 + 2 = 8`.
   - Arrangement: `A B _ A B _ A B` (Wait, idle calculation handles this).

**Direct Math:**
- `(3 - 1) * (2 + 1) + 2`
- `2 * 3 + 2 = 8`.

**Wait, check actual fill:** `A B idle A B idle A B`. Length 8. Correct.

---

### üíª Code (C++):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int leastInterval(vector<char>& tasks, int n) {
    // 1. Count how many times each task appears
    // We use a fixed array because there are only 26 letters
    vector<int> freq(26, 0);
    int maxFreq = 0;
    
    // Loop through all tasks
    for (char c : tasks) {
        freq[c - 'A']++;
        // Keep track of the highest frequency we find
        maxFreq = max(maxFreq, freq[c - 'A']);
    }

    // 2. See how many tasks have the same highest frequency
    // E.g., if A:3, B:3, C:2 -> maxFreq is 3, and 2 tasks (A, B) have it
    int maxFreqCount = 0;
    for (int f : freq) {
        if (f == maxFreq) {
            maxFreqCount++;
        }
    }

    // 3. Calculate time using the formula logic:
    // Imagine chunks separated by cooling time.
    // Chunk size = n + 1 (1 for the task, n for the gap)
    // We have (maxFreq - 1) full chunks.
    // The last chunk is just the count of tasks with max frequency.
    int result = (maxFreq - 1) * (n + 1) + maxFreqCount;

    // 4. Important Check:
    // We can never finish faster than the total number of tasks.
    // If our formula gives a smaller number, it means we had plenty of
    // other tasks to fill the gaps perfectly without idle time.
    return max(result, (int)tasks.size());
}

int main() {
    vector<char> tasks = {'A','A','A','B','B','B'};
    int n = 2;
    cout << "Minimum Time: " << leastInterval(tasks, n) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N)**
  - We perform a single pass through the `tasks` vector to count frequencies, where `N` is the total number of tasks.
  - Iterating over the frequency array takes constant time (at most 26 operations).

- **Space Complexity:** **O(1)**
  - We use a fixed-size integer array (`freq` of size 26) to store character counts.
  - This space requirement does not grow with the input size `N`.
