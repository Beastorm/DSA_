## Single-Threaded CPU (Greedy + Heap)

**Problem Statement:**   
You are given `N` tasks labeled from `0` to `N-1`. Each task is represented by a 2D array `tasks[i] = [enqueueTime, processingTime]`.
You have a CPU that can process only one task at a time.

**Rules:**
1. If the CPU is idle and no tasks are available, it remains idle until the next task arrives.
2. If multiple tasks are available, the CPU chooses the one with the **shortest processing time**.
3. If there is a tie in processing time, the task with the **smallest index** is chosen.

**Task:** Return the order in which the CPU processes the tasks.

---
## Approach

### üß† Intuition:
This is a simulation problem that requires making the best choice at every step (Greedy).

1. **Time Progression:** We need to simulate time. We can't just iterate from 1 to T because time gaps can be large. Instead, we jump to specific "event" times (when tasks arrive or when a task finishes).
2. **Waiting Queue:** Tasks that have arrived but haven't been processed need to be stored.
3. **Selection Strategy:** Among waiting tasks, we need the one with **min processing time**. This screams **Min-Heap (Priority Queue)**.

**Strategy:**
- Sort tasks by `enqueueTime` so we know who arrives first.
- Maintain a `currentTime`.
- Add all tasks that have arrived by `currentTime` into the Min-Heap.
- Pick the best task from the Heap, advance `currentTime`, and repeat.

---

### üîç Example Walkthrough:

**Input Tasks:** `[[1,2], [2,4], [3,2], [4,1]]`
Indices: `0: [1,2]`, `1: [2,4]`, `2: [3,2]`, `3: [4,1]`

**Sorting:** Already sorted by arrival.

**Simulation:**
1. **Time = 0:** No tasks available.
   - Jump time to first task arrival: **Time = 1**.
2. **Time = 1:**
   - Task 0 arrives `[1,2]`. Add to Heap: `{(2, 0)}`.
   - CPU picks `{2, 0}`.
   - Processing... Time becomes `1 + 2 = 3`.
   - **Result:** `[0]`
3. **Time = 3:**
   - Tasks arriving between 1 and 3:
     - Task 1 `[2,4]`. Add to Heap: `{(4, 1)}`.
     - Task 2 `[3,2]`. Add to Heap: `{(2, 2)}`.
   - Heap: `{(2, 2), (4, 1)}`.
   - CPU picks `{2, 2}` (min processing time).
   - Processing... Time becomes `3 + 2 = 5`.
   - **Result:** `[0, 2]`
4. **Time = 5:**
   - Tasks arriving between 3 and 5:
     - Task 3 `[4,1]`. Add to Heap: `{(1, 3)}`.
   - Heap: `{(1, 3), (4, 1)}`.
   - CPU picks `{1, 3}` (min processing time).
   - Processing... Time becomes `5 + 1 = 6`.
   - **Result:** `[0, 2, 3]`
5. **Time = 6:**
   - No new arrivals.
   - Heap: `{(4, 1)}`.
   - CPU picks `{4, 1}`.
   - Processing... Time becomes `6 + 4 = 10`.
   - **Result:** `[0, 2, 3, 1]`

---

### üíª Code (C++):

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

// To store the original index after sorting
struct Task {
    int enqueueTime;
    int processingTime;
    int index;
};

// Comparator for sorting initial tasks by Enqueue Time
bool compareTasks(const Task& a, const Task& b) {
    return a.enqueueTime < b.enqueueTime;
}

// Comparator for Min-Heap: {processingTime, index}
// If processingTime is the same, the smaller index comes first
typedef pair<int, int> PII; // {procTime, index}

vector<int> getOrder(vector<vector<int>>& tasks) {
    int n = tasks.size();
    vector<Task> sortedTasks(n);
    
    // 1. Store original indices
    for(int i=0; i<n; ++i) {
        sortedTasks[i] = {tasks[i][0], tasks[i][1], i};
    }
    
    // 2. Sort by arrival time
    sort(sortedTasks.begin(), sortedTasks.end(), compareTasks);
    
    vector<int> result;

    // Min-Heap stores {processingTime, originalIndex}
    // Automatically handles the tie-breaking rule because pair comparison checks first element, then second
    priority_queue<PII, vector<PII>, greater<PII>> pq;
    
    long long currentTime = 0;
    int i = 0;
    
    while(i < n || !pq.empty()) {
        // If the heap is empty and the current time is less than the next task arrival, jump to time
        if (pq.empty() && currentTime < sortedTasks[i].enqueueTime) {
            currentTime = sortedTasks[i].enqueueTime;
        }
        
        // Add all tasks that have arrived by currentTime
        while(i < n && sortedTasks[i].enqueueTime <= currentTime) {
            pq.push({sortedTasks[i].processingTime, sortedTasks[i].index});
            i++;
        }
        
        // Process the best task from the heap
        auto [procTime, index] = pq.top();
        pq.pop();
        
        currentTime += procTime;
        result.push_back(index);
    }
    
    return result;
}

int main() {
    vector<vector<int>> tasks = {{1,2}, {2,4}, {3,2}, {4,1}};
    vector<int> order = getOrder(tasks);
    
    cout << "Processing Order: ";
    for(int idx : order) cout << idx << " ";
    cout << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N log N)**
  - **Sorting** the tasks based on enqueue time takes `O(N log N)`.
  - **Heap Operations:** In the simulation loop, each task is pushed onto the priority queue once and popped once. Since insertion and deletion in a heap take `O(log N)`, processing all `N` tasks contributes another `O(N log N)`.
  - The overall complexity remains `O(N log N)`.

- **Space Complexity:** **O(N)**
  - We use an auxiliary vector to store `sortedTasks`.
  - The priority queue can hold up to `N` tasks in the worst case (if all tasks arrive before the first one finishes processing).
