## House Robber - Circular Arrangement

**Problem Statement:**   
A thief needs to rob money in a street where the houses are arranged in a **circular manner**. This means the **first** and the **last** house are adjacent to each other. The constraint is that if two adjacent houses are robbed, the police will be notified.

Given an integer array `Arr` representing money at each house, return the maximum amount of money the thief can rob without alerting the police.

---

>### Examples:

### Example 1:
**Input:** `money = [2, 1, 4, 9]`  
**Output:** `10`  
**Explanation:** Rob house 1 (`2`) and house 3 (`4`)? No. Rob house 2 (`1`) and house 4 (`9`) -> Total `10`. Note: Cannot rob 1st (`2`) and 4th (`9`) together because they are circular neighbors.

### Example 2:
**Input:** `money = [1, 5, 2, 1, 6]`  
**Output:** `11`  
**Explanation:** Optimal loot is from house 2 (`5`) and house 5 (`6`). Total `11`.

---

## Approach - Space Optimization

### Algorithm:

This problem is a variation of the classic **House Robber** problem, but with a circular constraint.

Since houses are arranged in a circle, the **first house** and the **last house** are adjacent. This means we cannot rob both of them in the same plan.

To handle this, we split the problem into two linear subproblems:
1.  **Case 1 (Exclude First House):** Consider houses from index `1` to `n-1`.
2.  **Case 2 (Exclude Last House):** Consider houses from index `0` to `n-2`.

The final answer is simply:
`max(solve(arr1), solve(arr2))`

### Solve Function (Linear House Robber)
The `solve()` function calculates the maximum loot for a linear array using **space-optimized dynamic programming**:
- **`prev`**: Stores the maximum loot ending at the previous house (`i-1`).
- **`prev2`**: Stores the maximum loot ending at the house before the previous one (`i-2`).

At each step `i`:
- **Pick:** Current house value + `prev2`
- **Not Pick:** `prev`
- **Update:** `curr = max(pick, notPick)`, then shift `prev2` and `prev`.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to solve the linear house robber problem (no circular arrangement)
long long int solve(vector<int>& arr) {
    // Get the size of the array
    int n = arr.size();
    
    // If there's only one house, return its value
    if (n == 1) return arr[0];

    // prev stores the maximum sum till the previous index
    long long int prev = arr[0];

    // prev2 stores the maximum sum till the index before the previous
    long long int prev2 = 0;

    // Loop through houses starting from index 1
    for (int i = 1; i < n; i++) {
        // Option 1: Pick the current house and add the value from prev2
        long long int pick = arr[i];
        if (i > 1) pick += prev2;

        // Option 2: Skip the current house, take prev
        long long int nonPick = prev;

        // Choose the maximum of pick and nonPick
        long long int cur_i = max(pick, nonPick);

        // Update prev2 and prev for the next iteration
        prev2 = prev;
        prev = cur_i;
    }
    // prev will contain the maximum loot possible
    return prev;
}

// Function to solve the circular house robber problem
long long int robStreet(int n, vector<int> &arr) {
    // If there are no houses, return 0
    if (n == 0) return 0;

    // If there is only one house, return its value
    if (n == 1) return arr[0];

    // Create two arrays:
    // arr1 excludes the first house
    // arr2 excludes the last house
    vector<int> arr1, arr2;
    for (int i = 0; i < n; i++) {
        if (i != 0) arr1.push_back(arr[i]);
        if (i != n - 1) arr2.push_back(arr[i]);
    }

    // Compute maximum loot for both cases and return the maximum
    long long int ans1 = solve(arr1);
    long long int ans2 = solve(arr2);
    return max(ans1, ans2);
}

// Driver code
int main() {
    // Example input
    vector<int> arr{1, 5, 1, 2, 6};
    int n = arr.size();

    // Output the maximum loot possible
    cout << robStreet(n, arr);
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** **O(N)**
  - `N` is the number of houses.
  - We run the `solve()` function twice (once for each sub-array).
  - Each `solve()` function iterates through the array once in linear time.
  - Total time â‰ˆ `O(N) + O(N) = O(N)`.

- **Space Complexity:** **O(1)**
  - We use the space-optimized approach within the `solve()` function.
  - Only a few variables (`prev`, `prev2`, `curr`) are used to store the running maximums.
  - No full DP array is allocated.
