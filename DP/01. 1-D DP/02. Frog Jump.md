## Frog Jump

**Problem Statement:**   
Given several stairs and a frog, the frog wants to climb from the `0th` stair to the `(N-1)th` stair. At a time, the frog can climb either one or two steps. A `height[N]` array is also given. Whenever the frog jumps from a stair `i` to stair `j`, the energy consumed in the jump is `abs(height[i]- height[j])`, where `abs()` means the absolute difference. We need to return the minimum energy that can be used by the frog to jump from stair `0` to stair `N-1`.

---

>### Examples:

### Example 1:
**Input:** heights = [2, 1, 3, 5, 4]  
**Output:** 2  
**Explanation:** One possible route can be:
- 0th step -> 2nd Step = abs(2 - 3) = 1
- 2nd step -> 4th step = abs(3 - 4) = 1  
**Total = 1 + 1 = 2.**

---

### Example 2:
**Input:** heights = [7, 5, 1, 2, 6]  
**Output:** 9  
**Explanation:** One possible route can be:
- 0th step -> 1st Step = abs(7 - 5) = 2
- 1st step -> 3rd step = abs(5 - 2) = 3
- 3rd step -> 4th step = abs(2 - 6) = 4  
**Total = 2 + 3 + 4 = 9.**

---
### Ques: Why the Greedy Approach Fails for Frog Jump?

A greedy approach would mean making the **locally optimal** choice at each step (e.g., choosing the jump that costs the least energy right now). However, this does not guarantee the **global minimum** energy.

#### Example Counter-Case:
`heights = [30, 10, 60, 10, 60, 50]`

**Greedy Logic:**
- Start at index 0 (height 30).
- Option 1: Jump to index 1 (height 10) → cost `|30-10| = 20`.
- Option 2: Jump to index 2 (height 60) → cost `|30-60| = 30`.
- Greedy picks **index 1** (cost 20).

From index 1 (height 10):
- Option 1: Jump to index 2 (height 60) → cost `|10-60| = 50`.
- Option 2: Jump to index 3 (height 10) → cost `|10-10| = 0`.
- Greedy picks **index 3** (cost 0).

...and so on.

**The Problem:**   
Choosing the smallest jump *now* might force you into a huge jump *later*.
- Taking a slightly more expensive jump initially might allow you to skip a very high-cost jump later or land on a "bridge" to an easier path.

**Conclusion:**   
Since the optimal path depends on future costs that a greedy choice cannot see, we must explore all possibilities (Recursion) or build the solution from subproblems (DP).

---

## Approach

### Intuition for Frog Jump (Recursive Solution):

The **Frog Jump** problem is a variation of the Climbing Stairs problem, but with an added **cost** (energy consumed) associated with each jump. The intuition is built on exploring all possible paths the frog can take to reach the last stone while minimizing the total energy.

### 1. The Core Decision:
At any stone $i$, the frog has two choices to move forward:
1.  **Jump to the next stone ($i+1$):** The energy spent is $|height[i] - height[i+1]|$.
2.  **Jump over one stone ($i+2$):** The energy spent is $|height[i] - height[i+2]|$.

### 2. Thinking Top-Down (Recursive Logic):
To find the minimum energy to reach stone `ind`, we look at the stones the frog could have jumped *from*:
* **From `ind - 1`:** Energy spent = `f(ind - 1)` + absolute height difference between stone `ind` and `ind - 1`.
* **From `ind - 2`:** Energy spent = `f(ind - 2)` + absolute height difference between stone `ind` and `ind - 2`.

The answer for stone `ind` is simply the **minimum** of these two choices.
### 3. Base Case:
* **Stone 0:** If the frog is already at the first stone (index 0), no jumps are needed. The energy spent is **0**.
* **Stone 1:** Since there is no stone at index `-1`, the frog can only come from stone 0.

### 4. Transition from Recursion to DP

| Step | Reason |
| :--- | :--- |
| **Recursive** | We explore every single path. Many stones are visited repeatedly via different jump combinations, making it $O(2^n)$. |
| **Memoization** | We store the minimum energy required to reach stone `i` in a `dp` array. If we need to calculate it again, we just look it up. |
| **Tabulation** | We start from stone 0 and calculate the minimum energy for stone 1, then stone 2, up to stone $n-1$, ensuring we always have the answers to previous subproblems. |
| **Space Optimization** | To calculate energy for stone `i`, we only need the results for `i-1` and `i-2`. We can discard the rest of the array and just use two variables. |

### C++ Code:

``` cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

// Recursive Solution
int frogJumpRecursive(int ind, vector<int>& heights) {
    if (ind == 0) return 0;
    
    // Always possible to jump from the previous stone
    int left = frogJumpRecursive(ind - 1, heights) + abs(heights[ind] - heights[ind - 1]);
    
    // Initialize with a very large value to ensure this path is ignored 
    // if the 'if' condition below is not met (e.g., at index 1)
    int right = INT_MAX;
    
    // Only possible to jump from 2 stones back if we are at index 2 or higher
    if (ind > 1) {
        right = frogJumpRecursive(ind - 2, heights) + abs(heights[ind] - heights[ind - 2]);
    }
    
    // If 'right' was never updated, min will automatically pick 'left'
    return min(left, right);
}

// Memoization Solution (Top-Down)
int frogJumpMemo(int ind, vector<int>& heights, vector<int>& dp) {
    if (ind == 0) return 0;
    if (dp[ind] != -1) return dp[ind];
    
    int left = frogJumpMemo(ind - 1, heights, dp) + abs(heights[ind] - heights[ind - 1]);
    int right = INT_MAX;
    
    if (ind > 1) {
        right = frogJumpMemo(ind - 2, heights, dp) + abs(heights[ind] - heights[ind - 2]);
    }
    
    return dp[ind] = min(left, right);
}

// Tabulation Solution (Bottom-Up)
int frogJumpTabulation(int n, vector<int>& heights) {
    vector<int> dp(n, 0);
    dp[0] = 0;
    
    for (int i = 1; i < n; i++) {
        int left = dp[i - 1] + abs(heights[i] - heights[i - 1]);
        int right = INT_MAX;
        
        if (i > 1) {
            right = dp[i - 2] + abs(heights[i] - heights[i - 2]);
        }
        
        dp[i] = min(left, right);
    }
    
    return dp[n - 1];
}

// Space Optimization Solution
int frogJumpSpaceOptimized(int n, vector<int>& heights) {
    int prev = 0;
    int prev2 = 0;
    
    for (int i = 1; i < n; i++) {
        int left = prev + abs(heights[i] - heights[i - 1]);
        int right = INT_MAX;
        
        if (i > 1) {
            right = prev2 + abs(heights[i] - heights[i - 2]);
        }
        
        int curr = min(left, right);
        prev2 = prev;
        prev = curr;
    }
    
    return prev;
}

int main() {
    vector<int> heights = {2, 1, 3, 5, 4};
    int n = heights.size();
    
    // Recursive
    cout << "Recursive: " << frogJumpRecursive(n - 1, heights) << endl;
    
    // Memoization
    vector<int> dp(n, -1);
    cout << "Memoization: " << frogJumpMemo(n - 1, heights, dp) << endl;
    
    // Tabulation
    cout << "Tabulation: " << frogJumpTabulation(n, heights) << endl;
    
    // Space Optimization
    cout << "Space Optimized: " << frogJumpSpaceOptimized(n, heights) << endl;
    
    return 0;
}
```

### Complexity Analysis:

### Recursive Solution
- **Time Complexity:** `O(2^N)` (Exponential)
  - At each step, we have 2 choices (jump 1 step or jump 2 steps), leading to a binary recursion tree.
- **Space Complexity:** `O(N)`
  - Recursion stack depth is `N` in the worst case (jumping 1 step at a time).

### Memoization (Top-Down)
- **Time Complexity:** `O(N)`
  - We solve each subproblem (index) only once.
- **Space Complexity:** `O(N) + O(N)`
  - `O(N)` for the DP array.
  - `O(N)` for the recursion stack.

### Tabulation (Bottom-Up)
- **Time Complexity:** `O(N)`
  - A single loop runs from `1` to `N-1`.
- **Space Complexity:** `O(N)`
  - `O(N)` for the DP array to store results.

### Space Optimization
- **Time Complexity:** `O(N)`
  - A single loop runs from `1` to `N-1`.
- **Space Complexity:** `O(1)`
  - We only store the last two results (`prev` and `prev2`), removing the need for a full array.
