## Frog Jump

**Problem Statement:**   
Given several stairs and a frog, the frog wants to climb from the `0th` stair to the `(N-1)th` stair. At a time, the frog can climb either one or two steps. A `height[N]` array is also given. Whenever the frog jumps from a stair `i` to stair `j`, the energy consumed in the jump is `abs(height[i]- height[j])`, where `abs()` means the absolute difference. We need to return the minimum energy that can be used by the frog to jump from stair `0` to stair `N-1`.

---

>### Examples:

### Example 1:
**Input:** heights = [2, 1, 3, 5, 4]  
**Output:** 2  
**Explanation:** One possible route can be:
- 0th step -> 2nd Step = abs(2 - 3) = 1
- 2nd step -> 4th step = abs(3 - 4) = 1  
**Total = 1 + 1 = 2.**

---

### Example 2:
**Input:** heights = [7, 5, 1, 2, 6]  
**Output:** 9  
**Explanation:** One possible route can be:
- 0th step -> 1st Step = abs(7 - 5) = 2
- 1st step -> 3rd step = abs(5 - 2) = 3
- 3rd step -> 4th step = abs(2 - 6) = 4  
**Total = 2 + 3 + 4 = 9.**

---

### Ques: Why the Greedy Approach Fails for Frog Jump?

A greedy approach would mean making the **locally optimal** choice at each step (e.g., choosing the jump that costs the least energy right now). However, this does not guarantee the **global minimum** energy.

#### Example Counter-Case:
`heights = [30, 10, 60, 10, 60, 50]`

**Greedy Logic:**
- Start at index 0 (height 30).
- Option 1: Jump to index 1 (height 10) → cost `|30-10| = 20`.
- Option 2: Jump to index 2 (height 60) → cost `|30-60| = 30`.
- Greedy picks **index 1** (cost 20).

From index 1 (height 10):
- Option 1: Jump to index 2 (height 60) → cost `|10-60| = 50`.
- Option 2: Jump to index 3 (height 10) → cost `|10-10| = 0`.
- Greedy picks **index 3** (cost 0).

...and so on.

**The Problem:**   
Choosing the smallest jump *now* might force you into a huge jump *later*.
- Taking a slightly more expensive jump initially might allow you to skip a very high-cost jump later or land on a "bridge" to an easier path.

**Conclusion:**   
Since the optimal path depends on future costs that a greedy choice cannot see, we must explore all possibilities (Recursion) or build the solution from subproblems (DP).

---

### C++ Code:

``` cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

// Recursive Solution
int frogJumpRecursive(int ind, vector<int>& heights) {
    if (ind == 0) return 0;
    
    int left = frogJumpRecursive(ind - 1, heights) + abs(heights[ind] - heights[ind - 1]);
    int right = INT_MAX;
    
    if (ind > 1) {
        right = frogJumpRecursive(ind - 2, heights) + abs(heights[ind] - heights[ind - 2]);
    }
    
    return min(left, right);
}

// Memoization Solution (Top-Down)
int frogJumpMemo(int ind, vector<int>& heights, vector<int>& dp) {
    if (ind == 0) return 0;
    if (dp[ind] != -1) return dp[ind];
    
    int left = frogJumpMemo(ind - 1, heights, dp) + abs(heights[ind] - heights[ind - 1]);
    int right = INT_MAX;
    
    if (ind > 1) {
        right = frogJumpMemo(ind - 2, heights, dp) + abs(heights[ind] - heights[ind - 2]);
    }
    
    return dp[ind] = min(left, right);
}

// Tabulation Solution (Bottom-Up)
int frogJumpTabulation(int n, vector<int>& heights) {
    vector<int> dp(n, 0);
    dp[0] = 0;
    
    for (int i = 1; i < n; i++) {
        int left = dp[i - 1] + abs(heights[i] - heights[i - 1]);
        int right = INT_MAX;
        
        if (i > 1) {
            right = dp[i - 2] + abs(heights[i] - heights[i - 2]);
        }
        
        dp[i] = min(left, right);
    }
    
    return dp[n - 1];
}

// Space Optimization Solution
int frogJumpSpaceOptimized(int n, vector<int>& heights) {
    int prev = 0;
    int prev2 = 0;
    
    for (int i = 1; i < n; i++) {
        int left = prev + abs(heights[i] - heights[i - 1]);
        int right = INT_MAX;
        
        if (i > 1) {
            right = prev2 + abs(heights[i] - heights[i - 2]);
        }
        
        int curr = min(left, right);
        prev2 = prev;
        prev = curr;
    }
    
    return prev;
}

int main() {
    vector<int> heights = {2, 1, 3, 5, 4};
    int n = heights.size();
    
    // Recursive
    cout << "Recursive: " << frogJumpRecursive(n - 1, heights) << endl;
    
    // Memoization
    vector<int> dp(n, -1);
    cout << "Memoization: " << frogJumpMemo(n - 1, heights, dp) << endl;
    
    // Tabulation
    cout << "Tabulation: " << frogJumpTabulation(n, heights) << endl;
    
    // Space Optimization
    cout << "Space Optimized: " << frogJumpSpaceOptimized(n, heights) << endl;
    
    return 0;
}
```

### Complexity Analysis:

### Recursive Solution
- **Time Complexity:** `O(2^N)` (Exponential)
  - At each step, we have 2 choices (jump 1 step or jump 2 steps), leading to a binary recursion tree.
- **Space Complexity:** `O(N)`
  - Recursion stack depth is `N` in the worst case (jumping 1 step at a time).

### Memoization (Top-Down)
- **Time Complexity:** `O(N)`
  - We solve each subproblem (index) only once.
- **Space Complexity:** `O(N) + O(N)`
  - `O(N)` for the DP array.
  - `O(N)` for the recursion stack.

### Tabulation (Bottom-Up)
- **Time Complexity:** `O(N)`
  - A single loop runs from `1` to `N-1`.
- **Space Complexity:** `O(N)`
  - `O(N)` for the DP array to store results.

### Space Optimization
- **Time Complexity:** `O(N)`
  - A single loop runs from `1` to `N-1`.
- **Space Complexity:** `O(1)`
  - We only store the last two results (`prev` and `prev2`), removing the need for a full array.
