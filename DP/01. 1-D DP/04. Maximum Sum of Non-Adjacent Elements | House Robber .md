## Maximum Sum of Non-Adjacent Elements | House Robber 

**Problem Statement:**  
Given an array of `N` positive integers, return the maximum sum of a subsequence such that no two elements of the subsequence are adjacent elements in the array.

---

>### Examples:

### Example 1:
**Input:** `nums = [1, 2, 4]`  
**Output:** `5`  
**Explanation:** Subsequence `{1, 4}` gives the maximum sum.

### Example 2:
**Input:** `nums = [2, 1, 4, 9]`  
**Output:** `11`  
**Explanation:** Subsequence `{2, 9}` gives the maximum sum.

---

## Approach - Recursive

### Intuition:
The core idea is the **"Pick or Don't Pick"** strategy.
For any element at index `i`, we have two choices to maximize the sum:

1.  **Pick the element:** If we pick `nums[i]`, we cannot pick the adjacent element `nums[i-1]`. So, we must add the result from `i-2`.
2.  **Don't Pick the element:** If we skip `nums[i]`, we can take the result from `i-1` (since we didn't pick the current one, the adjacent constraint isn't violated).

We want the maximum of these two options: `max(pick, notPick)`.

### Algorithm:

### Recursive Relation
Let `f(ind)` be the maximum sum up to index `ind`.

- **Base Cases:**
  - `f(0) = nums[0]` (If only one element, pick it).
  - `f(<0) = 0` (Out of bounds contributes nothing).

- **Transitions:**
  - `pick = nums[ind] + f(ind - 2)`
  - `notPick = 0 + f(ind - 1)`
  - `f(ind) = max(pick, notPick)`


### C++ Code:
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Recursive Solution
int solveRecursive(int ind, vector<int>& nums) {
    // Base Case: If index becomes negative, we return 0
    if (ind < 0) return 0;
    
    // Base Case: If index is 0, we simply pick that element
    if (ind == 0) return nums[0];

    // Pick: Add current element and move to index-2 (to skip adjacent)
    int pick = nums[ind] + solveRecursive(ind - 2, nums);

    // Not Pick: Skip current element and move to index-1
    int notPick = 0 + solveRecursive(ind - 1, nums);

    return max(pick, notPick);
}

int main() {
    vector<int> nums = {2, 1, 4, 9};
    int n = nums.size();
    
    // Start from the last index
    cout << "Maximum Sum: " << solveRecursive(n - 1, nums) << endl;
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(2^N)**
  - At every step, we make two recursive calls (pick and not pick).
  - This creates a binary recursion tree of depth `N`.
  - Hence, the complexity is exponential.

- **Space Complexity:** **O(N)**
  - This is due to the recursion stack space, which can go up to depth `N` in the worst case.


---


## Approach - Memoization

### Algorithm:

To find the maximum sum of a subsequence with non-adjacent elements, we use the **pick/non-pick technique** with dynamic programming.

### The Recursive Logic (Pick/Non-Pick)
At every index `i` of the array, we have two choices:

1.  **Pick the element:**
    - If we pick `arr[i]`, we add its value to our sum.
    - Constraint: We cannot pick the adjacent element `arr[i-1]`.
    - Next step: Move to `i-2`.
    - **Formula:** `pick = arr[i] + f(i-2)`

2.  **Not Pick the element:**
    - If we don't pick `arr[i]`, we simply move to the next available element.
    - Next step: Move to `i-1`.
    - **Formula:** `notPick = 0 + f(i-1)`

**Recurrence Relation:**
`f(i) = max( pick, notPick )`

### Why Memoization?
A direct recursive implementation recalculates the same subproblems repeatedly.
**Memoization** optimizes this by storing the result of each index in a `dp` array.
- Before computing `f(i)`, check if `dp[i]` exists.
- If yes, return `dp[i]`.
- If no, compute `max(pick, notPick)`, store it in `dp[i]`, and return.   

![Overlapping Subproblems in Recursion Tree](https://github.com/Beastorm/DSA_/blob/dbebecd35c570c4d0b3f2d6571af2616ea1ac2e2/junk/overlapping_sub.png?raw=true)  
*Visual representation of overlapping subproblems in the recursion tree for `f(4)`. Blue nodes represent the first time a state is computed, while red nodes indicate redundant recalculations that Dynamic Programming avoids.*


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Recursive function with memoization
    int solve(vector<int>& arr, int i, vector<int>& dp) {
        // If index is negative, no element to pick
        if (i < 0) return 0;

        // If at first element, return its value
        if (i == 0) return arr[0];

        // Return already computed value
        if (dp[i] != -1) return dp[i];

        // Include current and move 2 back
        int pick = arr[i] + solve(arr, i - 2, dp);

        // Exclude current and move 1 back
        int notPick = solve(arr, i - 1, dp);

        // Store and return the max of both choices
        return dp[i] = max(pick, notPick);
    }

    // Main function to be called externally
    int maximumNonAdjacentSum(vector<int>& arr) {
        int n = arr.size();

        // DP array initialized with -1
        vector<int> dp(n, -1);

        // Start solving from the last index
        return solve(arr, n - 1, dp);
    }
};

int main() {
    vector<int> arr = {2, 1, 4, 9};
    Solution obj;

    // Output the result
    cout << obj.maximumNonAdjacentSum(arr);
    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** **O(N)**
  - `N` is the total number of elements in the array.
  - Using memoization, each subproblem (index) is solved exactly once.
  - Subsequent calls for the same index return the stored answer in **O(1)** time.

- **Space Complexity:** **O(N) + O(N)**
  - **O(N)** for the memoization array (`dp`).
  - **O(N)** for the recursion stack space (auxiliary space) in the worst case.

---

## Approach - Tabulation

### Algorithm:

To optimize space and runtime by avoiding recursion stack overhead, we use the **tabulation (bottom-up DP)** approach.

1.  **Initialize DP Array:** Create an array `dp` of size `N` to store the maximum sum at each index.
2.  **Base Case:** Set `dp[0] = nums[0]`. If there's only one element, the max sum is just that element.
3.  **Second Element:** For index 1, `dp[1] = max(nums[0], nums[1])`.
4.  **Iterate:** For `i` from 2 to `N-1`:
    - **Pick:** Add current element + sum from two steps back: `pick = nums[i] + dp[i-2]`.
    - **Not Pick:** Take the sum from the previous step: `notPick = dp[i-1]`.
    - **Store:** `dp[i] = max(pick, notPick)`.
5.  **Result:** The last element `dp[N-1]` contains the maximum possible sum.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to return the maximum sum of non-adjacent elements
    int maximumNonAdjacentSum(vector<int>& arr) {
        // Get the size of the array
        int n = arr.size();

        // If the array has only one element, return it
        if (n == 1) return arr[0];

        // Initialize dp array of size n
        vector<int> dp(n);

        // Base case: only one element
        dp[0] = arr[0];

        // Base case: max of first or second element
        dp[1] = max(arr[0], arr[1]);

        // Iterate from 3rd element onwards
        for (int i = 2; i < n; i++) {
            // Either take current and add dp[i-2]
            // Or skip current and take dp[i-1]
            dp[i] = max(arr[i] + dp[i - 2], dp[i - 1]);
        }

        // Final result at last index
        return dp[n - 1];
    }
};

int main() {
    vector<int> arr = {2, 1, 4, 9};
    Solution obj;
    cout << obj.maximumNonAdjacentSum(arr);
    return 0;
}

```

### Complexity Analysis:

- **Time Complexity:** **O(N)**
  - We iterate through the array once using a loop.
  - Each iteration involves constant-time operations.

- **Space Complexity:** **O(N)**
  - We use an extra `dp` array of size `N` to store the maximum sums.
  - This approach avoids the recursion stack space.

---

### Approach - Space Optimization

### Algorithm:

In the tabulation approach, we used an entire array to store results. However, to compute the value at any index `i`, we only need the results from `i-1` and `i-2`.

We can optimize space by tracking only two variables:
- `prev`: Maximum sum up to index `i-1`.
- `prev2`: Maximum sum up to index `i-2`.

**Steps:**
1.  Initialize `prev = nums[0]` and `prev2 = 0`.
2.  Iterate from `i = 1` to `N-1`:
    - **Pick:** `pick = nums[i] + prev2`
    - **Not Pick:** `notPick = prev`
    - **Current Max:** `curr = max(pick, notPick)`
    - **Shift:** Update `prev2 = prev` and `prev = curr`.
3.  The final answer is stored in `prev`.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to return the maximum sum of non-adjacent elements
    int maxSum(vector<int>& nums) {
        // Handle edge case for empty input
        if (nums.empty()) return 0;

        // Initialize two tracking sums
        int prev2 = 0;
        int prev = nums[0];

        // Traverse through the array
        for (int i = 1; i < nums.size(); i++) {
            // Include current by adding it to two steps back
            int include = nums[i] + prev2;

            // Exclude current by taking the previous best
            int exclude = prev;

            // Choose max of include and exclude
            int curr = max(include, exclude);

            // Update tracking variables
            prev2 = prev;
            prev = curr;
        }

        // Final result is stored in prev
        return prev;
    }
};

int main() {
    vector<int> arr = {3, 2, 5, 10, 7};
    Solution obj;
    cout << obj.maxSum(arr) << endl;
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** **O(N)**
  - We iterate through the array once using a single loop.
  - Each operation inside the loop takes constant time.

- **Space Complexity:** **O(1)**
  - We only use a constant amount of extra space (`prev`, `prev2`, `curr`) regardless of the input size.
