## Frog Jump with k Distances

**Problem Statement:**   
A frog wants to climb a staircase with `n` steps. Given an integer array `heights`, where `heights[i]` contains the height of the `i`th step, and an integer `k`.

To jump from the `i`th step to the `j`th step, the frog requires `abs(heights[i] - heights[j])` energy, where `abs()` denotes the absolute difference.

The frog can jump from the `i`th step to **any step** in the range `[i + 1, i + k]`, provided it exists.

**Goal:** Return the minimum amount of energy required by the frog to go from the 0th step to the `(n-1)`th step.

---

>### Examples:

### Example 1:
**Input:** `heights = [10, 5, 20, 0, 15], k = 2`  
**Output:** `15`  
**Explanation:**
- 0th step -> 2nd step, cost = abs(10 - 20) = 10
- 2nd step -> 4th step, cost = abs(20 - 15) = 5  
**Total cost = 10 + 5 = 15.**

### Example 2:
**Input:** `heights = [15, 4, 1, 14, 15], k = 3`  
**Output:** `2`  
**Explanation:**
- 0th step -> 3rd step, cost = abs(15 - 14) = 1
- 3rd step -> 4th step, cost = abs(14 - 15) = 1  
**Total cost = 1 + 1 = 2.**
---

## Approach- Recursive:


### Intuition:
The frog wants to reach the last stair with minimum energy. Unlike the standard problem (1 or 2 steps), here the frog can jump `1, 2, ..., k` steps.
At any step `i`, to find the minimum cost to reach it, we should look back at all possible previous steps `(i-1, i-2, ..., i-k)` from which we could have jumped.
The cost to reach `i` is `min(cost to reach j + jump energy)` for all valid `j`.

### Algorithm:
We define a function `solve(ind)` which returns the minimum cost to reach index `ind`.

1.  **Base Case:** If `ind == 0`, cost is `0`.
2.  **Recursive Step:**
    - Initialize `minCost = INT_MAX`.
    - Loop `j` from `1` to `k`.
    - If `ind - j >= 0` (valid previous step):
        - Calculate `jumpCost = solve(ind - j) + abs(height[ind] - height[ind-j])`.
        - Update `minCost = min(minCost, jumpCost)`.
3.  **Return:** `minCost`.

### C++ Code:
``` cpp
#include <iostream>
#include <vector>
#include <climits>
#include <cmath>
using namespace std;

// Function to find the minimum cost to reach the end using recursion
int solveRecursive(int ind, vector<int>& height, int k) {
    // Base case: If we are at the beginning (index 0), no cost is needed.
    if (ind == 0) return 0;

    int minCost = INT_MAX;

    // Loop through all possible jumps from 1 to k
    for (int j = 1; j <= k; j++) {
        // Check if the jump is within bounds
        if (ind - j >= 0) {
            // Calculate cost for this jump
            int jumpCost = solveRecursive(ind - j, height, k) + abs(height[ind] - height[ind - j]);
            // Update the minimum cost
            minCost = min(minCost, jumpCost);
        }
    }
    return minCost;
}

int main() {
    vector<int> height = {30, 10, 60, 10, 60, 50};
    int n = height.size();
    int k = 2;
    cout << "Minimum cost (Recursive): " << solveRecursive(n - 1, height, k) << endl;
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** **O(K^N)**
  - In the worst case (e.g., `k=2` is similar to Fibonacci), each step branches into `k` recursive calls.
  - This creates an exponential tree of height `N`, leading to `O(K^N)` complexity.

- **Space Complexity:** **O(N)**
  - This is due to the recursion stack depth, which goes up to `N` in the worst case (jumping 1 step at a time).

---

## Memoization Approach 

### Algorithm:

This problem is a variation of the classic "Frog Jump" problem, where the frog can jump up to `k` steps instead of just 1 or 2.

**Goal:** Reach the last stair (index `n-1`) with the minimum cost.
**Cost:** Jumping from stair `i` to `j` costs `|height[i] - height[j]|`.

We use **recursion with memoization** (top-down DP) to solve this efficiently.

### Steps:
1.  **Base Case:** If we are at index `0`, the cost is `0` (start point).
2.  **Memoization Check:** Before computing, check if `dp[ind]` is already calculated. If yes, return the stored value.
3.  **Recursive Step:** To find the min cost to reach `ind`:
    - Iterate `j` from `1` to `k`.
    - Calculate cost coming from `ind - j`:
      `jumpCost = f(ind - j) + abs(height[ind] - height[ind - j])`
    - Take the **minimum** of all valid `jumpCost` values.
4.  **Store & Return:** Save the result in `dp[ind]` and return it.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to find the minimum cost to reach index 'ind' using at most 'k' jumps
int solveUtil(int ind, vector<int>& height, vector<int>& dp, int k) {
    // Base case: starting point has zero cost
    if (ind == 0) return 0;

    // Return already computed result
    if (dp[ind] != -1) return dp[ind];

    // Initialize minimum steps as a large value
    int mmSteps = INT_MAX;

    // Try all possible jumps from 1 to k
    for (int j = 1; j <= k; j++) {
        // Ensure jump does not go out of bounds
        if (ind - j >= 0) {
            // Cost of taking the jump
            int jump = solveUtil(ind - j, height, dp, k) + abs(height[ind] - height[ind - j]);
            // Store the minimum cost
            mmSteps = min(jump, mmSteps);
        }
    }
    // Save the result in the dp array
    return dp[ind] = mmSteps;
}

// Function to get the minimum cost to reach the end
int solve(int n, vector<int>& height, int k) {
    // DP array initialized to -1
    vector<int> dp(n, -1);
    // Start recursion from the last index
    return solveUtil(n - 1, height, dp, k);
}

// Driver code
int main() {
    // Heights of stones
    vector<int> height{30, 10, 60, 10, 60, 50};
    int n = height.size();
    int k = 2;

    // Output the minimum cost
    cout << solve(n, height, k) << endl;
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(N * K)
  - **N** is the number of stairs.
  - **K** is the maximum jump allowed.
  - For each step `i` (from 0 to N-1), we iterate through `k` possible jumps to find the minimum cost.
  - Total operations roughly equal `N * K`.

- **Space Complexity:** O(N)
  - **DP Array:** We use an array of size `N` to store the minimum energy for each step.
  - **Recursion Stack:** In the recursive solution, the stack depth can go up to `N`.

---

## Tabulation Approach - Frog Jump with K Steps

### Algorithm:

In this variation of the classic frog jump problem, the frog can jump from any stone to one of the previous `k` stones. The cost of each jump is the absolute difference in height between the stones. The goal is to minimize the total cost to reach the last stone starting from the first.

Instead of using recursion with memoization, we can solve this iteratively using **bottom-up dynamic programming**. This avoids recursion stack overhead and builds the solution efficiently.

### Steps:
1.  **Initialize DP Array:**
    - Create `dp[n]` where `dp[i]` represents the min cost to reach stone `i`.
    - Set `dp[0] = 0` (starting point).

2.  **Iterate Through Stones:**
    - Loop `i` from `1` to `n-1` (target stones).
    - For each `i`, initialize `minSteps = INT_MAX`.

3.  **Try All Jumps:**
    - Loop `j` from `1` to `k`.
    - If `i - j >= 0` (valid previous stone):
      `jump = dp[i - j] + abs(height[i] - height[i - j])`
      `minSteps = min(minSteps, jump)`

4.  **Store Result:**
    - Set `dp[i] = minSteps`.

5.  **Final Answer:**
    - Return `dp[n - 1]`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to compute the minimum cost to reach the end using at most 'k' jumps
int solveUtil(int n, vector<int>& height, vector<int>& dp, int k) {
    // Base case: cost to reach the first stone is 0
    dp[0] = 0;

    // Iterate over each stone
    for (int i = 1; i < n; i++) {
        // Initialize the minimum cost for this stone as large value
        int mmSteps = INT_MAX;

        // Try all possible jump lengths from 1 to k
        for (int j = 1; j <= k; j++) {
            // Ensure jump doesn't go out of bounds
            if (i - j >= 0) {
                // Cost of jumping from (i - j) to i
                int jump = dp[i - j] + abs(height[i] - height[i - j]);
                // Keep track of the minimum cost
                mmSteps = min(mmSteps, jump);
            }
        }

        // Store the computed minimum cost for this stone
        dp[i] = mmSteps;
    }

    // The last element of dp stores the answer
    return dp[n - 1];
}

// Main function to solve the problem
int solve(int n, vector<int>& height, int k) {
    // Initialize DP array with -1
    vector<int> dp(n, -1);
    // Fill DP array iteratively
    return solveUtil(n, height, dp, k);
}

// Driver code
int main() {
    // Heights of stones
    vector<int> height{30, 10, 60, 10, 60, 50};
    int n = height.size();
    int k = 2;

    // Output result
    cout << solve(n, height, k) << endl;
    return 0;
}

```

### Complexity Analysis

- T**ime Complexity:** **O(N × K)**
  - We have a loop iterating from `1` to `N-1`.
  - Inside this loop, we have a nested loop iterating up to `K` times to check all possible previous steps.
  - Total operations ≈ `N × K`.

- **Space Complexity:** **O(N)**
  - We use an array `dp` of size `N` to store the minimum cost for each step.
