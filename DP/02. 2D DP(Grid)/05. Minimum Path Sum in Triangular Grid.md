## Minimum Path Sum in Triangular Grid

**Problem Statement:**   
Given a 2D integer array named `triangle` with `n` rows:
- The first row contains **1 element**
- Each succeeding row contains **one more element** than the row above it

Return the **minimum falling path sum** from the **first row** to the **last row**.

**Movement Rules:**
From any cell, movement is allowed only to:
- the **bottom** cell
- the **bottom-right** cell

---

>### Examples:

### Example 1:
**Input:**  
```triangle = 
[
[1], 
[1, 2], 
[1, 2, 4]
]
```

**Output:** `3`   
**Explanation:**  
One possible route: Start at 1st row → bottom → bottom

---

### Example 2:
**Input:**  
```
triangle = [
[1], 
[4, 7], 
[4, 10, 50], 
[-50, 5, 6, -100]
]
```
**Output:** `-42`  
**Explanation:**  
One possible route: Start at 1st row → bottom-right → bottom-right → bottom-right

---

## Approach - Recursive

### Intuition:
At each cell in the triangle, we have **two choices** for the next step: go **directly down** or **down-right**. The goal is to find the path from the top to the bottom that gives the **minimum sum**.  

We can solve this **recursively** by computing the minimum path sum from each cell to the bottom, and combining it with the current cell's value.

### Algorithm:
1. Start from the top of the triangle `(0, 0)`.
2. For a cell `(row, col)`:
   - If it is the **last row**, return its value.
   - Otherwise:
     - Compute `down = minPath(row + 1, col)`  
     - Compute `downRight = minPath(row + 1, col + 1)`
     - Return `triangle[row][col] + min(down, downRight)`
3. The result for `(0, 0)` is the **minimum falling path sum**.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function to find minimum falling path sum
int findMinPath(int row, int col, vector<vector<int>> &triangle, int n) {
    // Base case: last row
    if (row == n - 1)
        return triangle[row][col];

    // Recursive calls
    int down = findMinPath(row + 1, col, triangle, n);
    int downRight = findMinPath(row + 1, col + 1, triangle, n);

    // Return the minimum path sum from the current cell
    return triangle[row][col] + min(down, downRight);
}

// Function to return minimum total path sum
int minimumTotal(vector<vector<int>> &triangle) {
    int n = triangle.size();
    return findMinPath(0, 0, triangle, n);
}

int main() {
    int n;
    cout << "Enter number of rows in triangle: ";
    cin >> n;

    vector<vector<int>> triangle(n);

    cout << "Enter the triangle values row by row:" << endl;
    for (int i = 0; i < n; i++) {
        triangle[i].resize(i + 1);
        for (int j = 0; j <= i; j++) {
            cin >> triangle[i][j];
        }
    }

    int result = minimumTotal(triangle);
    cout << "Minimum falling path sum is: " << result << endl;

    return 0;
}
```

### Complexity Analysis:
- **Time:** O(2^n) (exponential) for recursive solution  
- **Space:** O(n) recursion stack  

> Optimization: Use **DP (memoization or bottom-up)** to reduce time to O(n²).

---

## Approach - Memoization

### Intuition:
This problem is similar to **Minimum Path Sum in a Grid**, but here:

- The input is a **triangle**, not a rectangular grid.
- The destination is **any cell in the last row**, not a fixed cell.

At each cell, we have **two choices**:

1. Move **directly down**.
2. Move **diagonally down-right**.

Our goal is to find the **path from the top to the bottom row with the minimum sum**.


### Why Greedy Doesn't Work?
A natural idea is to take a **greedy approach**, always choosing the cheaper option locally.  

**Example:**  
- **Greedy path**: At each step, pick the smaller of the two options.
- **Problem**: Local minimum may lead to a **higher total sum** later.

Hence, we need to consider **all possible paths**, which leads to a **recursive solution**.


### Outlines:

1. **Recursive Idea**:  
   - Start from the top cell `(0, 0)`.  
   - At each cell `(row, col)`, compute the minimum sum for **both possible moves**:
     - `down = minPath(row + 1, col)`
     - `downRight = minPath(row + 1, col + 1)`  
   - Return `triangle[row][col] + min(down, downRight)`.

2. **Base Case**:  
   - If `row` is the last row, return the value of that cell (`triangle[row][col]`).

3. **Memoization**:  
   - Use a **2D DP table** to store results of subproblems.  
   - If a cell `(row, col)` is already computed, **reuse the value** instead of recomputing.


### Algorithm Steps:
1. Initialize a DP table with size `n x n` and values `-1`.
2. Define a recursive function `minPath(row, col, triangle, dp)`:
   - If `row == n-1`, return `triangle[row][col]`.
   - If `dp[row][col] != -1`, return `dp[row][col]`.
   - Compute:
     ```cpp
     down = minPath(row + 1, col, triangle, dp);
     downRight = minPath(row + 1, col + 1, triangle, dp);
     dp[row][col] = triangle[row][col] + min(down, downRight);
     return dp[row][col];
     ```
3. Call `minPath(0, 0, triangle, dp)` to get the **minimum falling path sum**.

---
### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the problem
class Solution {
public:
    // Recursive function with memoization
    int solve(int i, int j, vector<vector<int>> &triangle, int n, vector<vector<int>> &dp) {
        // If value already computed
        if (dp[i][j] != -1)
            return dp[i][j];

        // If at bottom row
        if (i == n - 1)
            return triangle[i][j];

        // Compute both downward and diagonal moves
        int down = triangle[i][j] + solve(i + 1, j, triangle, n, dp);
        int diag = triangle[i][j] + solve(i + 1, j + 1, triangle, n, dp);

        // Store and return min path sum
        return dp[i][j] = min(down, diag);
    }

    // Function to start the process
    int minimumPathSum(vector<vector<int>> &triangle) {
        int n = triangle.size();
        vector<vector<int>> dp(n, vector<int>(n, -1));
        return solve(0, 0, triangle, n, dp);
    }
};

// Main function
int main() {
    Solution obj;
    vector<vector<int>> triangle{
        {1},
        {2, 3},
        {3, 6, 7},
        {8, 9, 6, 10}
    };
    cout << obj.minimumPathSum(triangle);
    return 0;
}
```

---

### Complexity Analysis:
- **Time:** O(n²) → Each cell is computed at most once.  
- **Space:** O(n²) for DP table + O(n) recursion stack.  

> Memoization avoids **recomputing overlapping subproblems** and makes the solution efficient.

---


## Approach - Tabulation

### Intuition:
Tabulation is a **bottom-up dynamic programming approach**.  
Instead of starting from the top and using recursion, we start from the **base case (last row)** and move **upwards**, filling a DP table with minimum path sums.


### Algorithm:

1. **Create a DP Table**  
   - Make a 2D table `dp` with the same dimensions as the triangle.  
   - `dp[i][j]` will store the **minimum path sum from cell `(i,j)` to the bottom**.

2. **Initialize Base Case**  
   - Fill the **last row** of `dp` with the values from the **last row of the triangle**.

3. **Fill DP Table from Bottom to Top**  
   - For each row from `n-2` to `0` (second-last row to top row):  
     - For each cell `(i, j)` in the row:  
       ```cpp
       dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1]);
       ```
     - Here, `dp[i+1][j]` is the **downward path** and `dp[i+1][j+1]` is the **diagonal path**.

4. **Result**  
   - After filling the table, `dp[0][0]` contains the **minimum falling path sum** from top to bottom.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the triangle minimum path sum
class Solution {
public:
    // Function to compute the minimum path sum using tabulation
    int minimumPathSum(vector<vector<int>> &triangle, int n) {
        // Create a 2D dp array to store intermediate results
        vector<vector<int>> dp(n, vector<int>(n, 0));

        // Initialize the last row of dp with triangle values
        for (int j = 0; j < n; j++) {
            dp[n - 1][j] = triangle[n - 1][j];
        }

        // Traverse from the second-last row to the top
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i; j >= 0; j--) {
                // Calculate sum from down and diagonal paths
                int down = triangle[i][j] + dp[i + 1][j];
                int diag = triangle[i][j] + dp[i + 1][j + 1];

                // Store the minimum of the two paths
                dp[i][j] = min(down, diag);
            }
        }

        // Return the minimum path sum from the top
        return dp[0][0];
    }
};

// Main function to run the code
int main() {
    // Define the triangle
    vector<vector<int>> triangle{
        {1},
        {2, 3},
        {3, 6, 7},
        {8, 9, 6, 10}
    };

    // Get the number of rows
    int n = triangle.size();

    // Create an object of the Solution class
    Solution solver;

    // Print the result
    cout << solver.minimumPathSum(triangle, n);

    return 0;
}
```

### Complexity Analysis:
- **Time:** O(n²) → Each cell is visited once.  
- **Space:** O(n²) → DP table stores all intermediate results.  

> This approach avoids recursion and stack overhead, making it efficient and easy to understand.


---

## Approach - Space Optimization

### Intuition:
In the **tabulation approach**, each cell `dp[i][j]` depends **only on the row immediately below**:

```dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1]) ```

- This means we **don’t need the entire DP table**, just the **next row** to compute the current row.
- Using this observation, we can **reduce space complexity** from O(n²) to O(n).


### Algorithm:

1. **Initialize Front Row**  
   - Let `front` represent the **next row** (initially the last row of the triangle).

2. **Iterate from Bottom to Top**  
   - For each row `i` from `n-2` to `0`:  
     - Create a temporary row `cur` of the same size as `i+1`.  
     - For each cell `(i, j)` in the row:
       ```cpp
       cur[j] = triangle[i][j] + min(front[j], front[j+1]);
       ```
     - Update `front = cur` after processing the row.

3. **Result**  
   - After processing all rows, `front[0]` contains the **minimum falling path sum**.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Define a class to hold the solution
class Solution {
public:
    // Function to calculate the minimum path sum in a triangle
    int minimumPathSum(vector<vector<int>> &triangle, int n) {
        
        // Create an array to store the values of the row below
        vector<int> front(n, 0);
        
        // Create an array to store the values of the current row
        vector<int> cur(n, 0);
        
        // Initialize front with values from the last row of the triangle
        for (int j = 0; j < n; j++) {
            front[j] = triangle[n - 1][j];
        }

        // Traverse the triangle from bottom to top
        for (int i = n - 2; i >= 0; i--) {
            
            // Traverse each element in the current row
            for (int j = i; j >= 0; j--) {
                
                // Calculate the sum when going down
                int down = triangle[i][j] + front[j];
                
                // Calculate the sum when going diagonally
                int diagonal = triangle[i][j] + front[j + 1];
                
                // Store the minimum of the two in the current row
                cur[j] = min(down, diagonal);
            }

            // Move current row values to the front for next iteration
            front = cur;
        }

        // Return the final answer from the top of the triangle
        return front[0];
    }
};

// Main function to test the solution
int main() {
    
    // Create the triangle
    vector<vector<int>> triangle{
        {1},
        {2, 3},
        {3, 6, 7},
        {8, 9, 6, 10}
    };

    // Get number of rows
    int n = triangle.size();

    // Create object of Solution
    Solution obj;

    // Call the function and print the result
    cout << obj.minimumPathSum(triangle, n);

    return 0;
}
```

### Complexity Analysis:
- **Time:** O(n²) → Each cell is visited once.  
- **Space:** O(n) → Only two rows (`cur` and `front`) are used.

> This approach is optimal for large triangles, as it avoids storing the entire DP table.

