## 3-D Ninja and His Friends

**Problem Statement:**  
We are given an `N x M` matrix where each cell contains some chocolates.  
`mat[i][j]` represents the number of chocolates in cell `(i, j)`.

There are two friends:
- **Alice**, who starts at cell `(0, 0)`
- **Bob**, who starts at cell `(0, M-1)`

Both Alice and Bob can move **only downward** to the next row in one of the following three directions:
- Down `(↓)` → `(i+1, j)`
- Down-left `(↙)` → `(i+1, j-1)`
- Down-right `(↘)` → `(i+1, j+1)`

When Alice and Bob visit a cell, they collect **all chocolates** from that cell.
- If both visit the **same cell**, chocolates are counted **only once**.
- They are **not allowed to move outside** the matrix boundaries.

The task is to return the **maximum number of chocolates** Alice and Bob can collect together.

---

>### Examples:

### Example 1:
**Input:** R = 3, C = 4
```
GRID = [
[2, 3, 1, 2],
[3, 4, 2, 2],
[5, 6, 3, 5]
]
```
**Output:** 21

---

### Example 2:
**Input:** R = 2, C = 3
```
GRID = [
[4, 1, 2],
[7, 3, 5]
]
```
**Output:** 22


---

### Goal:
Compute the **maximum total chocolates** Alice and Bob can collect while moving from the top row to the bottom row, following the allowed movement rules.

---

## Approach - Recursive

### Intuition:
- Alice and Bob move **together**, one row at a time.
- At each row:
  - Alice is at column `j1`
  - Bob is at column `j2`
- From any cell, each can move **down, down-left, or down-right**.
- They **collect chocolates** from the cells they visit:
  - If both land on the **same cell**, chocolates are counted **once**.
- To get the **maximum total chocolates**, we must explore **all valid movement combinations**.
- Since the state depends on **row + Alice’s column + Bob’s column**, we use **3-D DP**.

---

### Algorithm:

1. **Define State**
solve(i, j1, j2)

Returns the **maximum chocolates collectable** from row `i` to the last row,
when Alice is at `j1` and Bob is at `j2`.

2. **Base Case**
- If either `j1` or `j2` goes out of bounds → return `-∞`
- If `i` is the last row:
  - If `j1 == j2` → return `grid[i][j1]`
  - Else → return `grid[i][j1] + grid[i][j2]`

3. **Recursive Case**
- Try all **9 combinations** of moves:
  - Alice: `{-1, 0, +1}`
  - Bob: `{-1, 0, +1}`
- For each move:
  ```
  chocolates at current row
  + solve(i+1, new_j1, new_j2)
  ```
- Take the **maximum** of all possibilities.

4. **Final Answer**
solve(0, 0, M-1)


---

### Key Insight:
- Two people moving simultaneously → **3 indices needed**
- Current gain + best future gain → **add values**
- Overlapping states → optimize using **memoization / DP**


### C++ Code:
``` cpp

#include <bits/stdc++.h>
using namespace std;

int solve(int i, int j1, int j2,
          vector<vector<int>>& grid,
          int n, int m) {

    // Out of bounds
    if (j1 < 0 || j1 >= m || j2 < 0 || j2 >= m)
        return -1e9;

    // Last row
    if (i == n - 1) {
        if (j1 == j2)
            return grid[i][j1];
        else
            return grid[i][j1] + grid[i][j2];
    }

    int maxi = -1e9;

    // Try all 9 movement combinations
    for (int dj1 = -1; dj1 <= 1; dj1++) {
        for (int dj2 = -1; dj2 <= 1; dj2++) {

            int value;
            if (j1 == j2)
                value = grid[i][j1];
            else
                value = grid[i][j1] + grid[i][j2];

            value += solve(i + 1, j1 + dj1, j2 + dj2, grid, n, m);
            maxi = max(maxi, value);
        }
    }

    return maxi;
}

int main() {
    int n = 3, m = 4;
    vector<vector<int>> grid = {
        {2, 3, 1, 2},
        {3, 4, 2, 2},
        {5, 6, 3, 5}
    };

    cout << solve(0, 0, m - 1, grid, n, m);
    return 0;
}

```
### Complexity Analysis:
- **Time:** Exponential (≈ 9ⁿ)
- **Space:** O(N) recursion stack

---

## Approach - Memoization

### Problem Overview:
Alice and Bob start from fixed positions at the top of a grid and move **row by row** until the last row.  
At each step, they must choose moves that **maximize the total chocolates collected**.

### Why Greedy Fails?
A greedy approach chooses the move with the **maximum chocolates at the current step**, but:
- The grid values are uneven
- A locally optimal choice can block better choices later

So, we must explore **all possible paths** using recursion.

### State Definition:
At any moment, the state is defined by:
- `row` → current row
- `col1` → Alice’s column
- `col2` → Bob’s column

This forms a **3D state: (row, col1, col2)**

### Base Cases:
- **Out of bounds**:  
  If Alice or Bob moves outside the grid → return a very small value (invalid path).
- **Last row**:
  - If `col1 == col2` → count chocolates once
  - Else → count chocolates from both cells

### Exploring All Moves:
- Alice can move: `down-left`, `down`, `down-right`
- Bob can move: `down-left`, `down`, `down-right`
- Total combinations per step: **3 × 3 = 9**

For each combination, recursively calculate the result.

### Choosing the Best Option:
- Try all 9 move combinations
- Pick the one that gives the **maximum total chocolates**

### Memoization:
- Many states repeat during recursion
- Use a **3D DP table**: `dp[row][col1][col2]`
- If a state is already computed:
  - Return the stored value
- Else:
  - Compute, store, and return it

### Key Idea:
> Convert an exponential recursive solution into an efficient one by caching overlapping subproblems using memoization.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve Ninja and his friends using memoization
class Solution {
public:
    // Recursive function with memoization
    int solve(int i, int j1, int j2, int n, int m,
              vector<vector<int>>& grid,
              vector<vector<vector<int>>>& dp) {
        // Out of boundary check
        if (j1 < 0 || j1 >= m || j2 < 0 || j2 >= m)
            return -1e9;
        
        // Base case: last row
        if (i == n - 1) {
            if (j1 == j2) return grid[i][j1];
            else return grid[i][j1] + grid[i][j2];
        }
        
        // If already computed, return it
        if (dp[i][j1][j2] != -1) return dp[i][j1][j2];
        
        // Take chocolates from current cell(s)
        int maxi = -1e9;
        int curr = (j1 == j2) ? grid[i][j1] : grid[i][j1] + grid[i][j2];
        
        // Try all 9 moves
        for (int dj1 = -1; dj1 <= 1; dj1++) {
            for (int dj2 = -1; dj2 <= 1; dj2++) {
                int ans = curr + solve(i + 1, j1 + dj1, j2 + dj2,
                                       n, m, grid, dp);
                maxi = max(maxi, ans);
            }
        }
        // Store result
        return dp[i][j1][j2] = maxi;
    }
    
    // Main function to call
    int maximumChocolates(int n, int m, vector<vector<int>>& grid) {
        vector<vector<vector<int>>> dp(n,
            vector<vector<int>>(m, vector<int>(m, -1)));
        return solve(0, 0, m - 1, n, m, grid, dp);
    }
};

// Driver code
int main() {
    vector<vector<int>> grid = {
        {2, 3, 1, 2},
        {3, 4, 2, 2},
        {5, 6, 3, 5}
    };
    int n = grid.size(), m = grid[0].size();
    Solution obj;
    cout << obj.maximumChocolates(n, m, grid) << endl;
    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** **O(N × M × M × 9)**  
  - There are at most `N × M × M` unique states `(row, col1, col2)`
  - For each state, we try **9 possible move combinations**
  - Hence, overall time complexity is **O(N × M × M)** (constant factor 9)


- **Space Complexity:** **O(N) + O(N × M × M)**  
  - **O(N)** → recursion stack space (maximum depth equals number of rows)
  - **O(N × M × M)** → 3D DP table for memoization


- **Summary:**
  - Time: **O(N × M²)**
  - Space: **O(N × M²)** (including recursion stack)

---

## Approach - Tabulation

### Algorithm:

### Steps to Convert Recursive Solution to Tabulation

Tabulation uses the same **3D DP table** as memoization.  
Each state `dp[row][col1][col2]` represents the **maximum chocolates collected** when:
- Alice is at `(row, col1)`
- Bob is at `(row, col2)`

### Base Setup:

Since recursion stops at the **last row**, we initialize it first:

- If `col1 == col2`  
  → `dp[lastRow][col1][col2] = grid[lastRow][col1]`
- Else  
  → `dp[lastRow][col1][col2] = grid[lastRow][col1] + grid[lastRow][col2]`

### Filling the Table:

- Traverse rows **from second-last row to the first row**
- For each `(col1, col2)` pair:
  - Try all **9 move combinations**:
    - Alice: `{down, down-left, down-right}`
    - Bob: `{down, down-left, down-right}`
  - For every valid move:
    - Add current row chocolates
    - Add value from `dp[row + 1][newCol1][newCol2]`
  - Store the **maximum** of all 9 possibilities in  
    `dp[row][col1][col2]`

### Final Answer:

- The result is stored at  
  `dp[0][0][M - 1]`  
- This represents Alice starting at the leftmost cell and Bob at the rightmost cell in the top row.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve Ninja and his friends using tabulation
class Solution {
public:
    int maximumChocolates(int n, int m, vector<vector<int>>& grid) {
        // 3D DP table
        vector<vector<vector<int>>> dp(n,
            vector<vector<int>>(m, vector<int>(m, 0)));
        
        // Base case: last row
        for (int j1 = 0; j1 < m; j1++) {
            for (int j2 = 0; j2 < m; j2++) {
                if (j1 == j2) dp[n-1][j1][j2] = grid[n-1][j1];
                else dp[n-1][j1][j2] = grid[n-1][j1] + grid[n-1][j2];
            }
        }
        
        // Fill DP table bottom-up
        for (int i = n - 2; i >= 0; i--) {
            for (int j1 = 0; j1 < m; j1++) {
                for (int j2 = 0; j2 < m; j2++) {
                    int maxi = -1e9;
                    int curr = (j1 == j2) ? grid[i][j1] 
                                          : grid[i][j1] + grid[i][j2];
                    // Try all 9 moves
                    for (int dj1 = -1; dj1 <= 1; dj1++) {
                        for (int dj2 = -1; dj2 <= 1; dj2++) {
                            int newJ1 = j1 + dj1;
                            int newJ2 = j2 + dj2;
                            if (newJ1 >= 0 && newJ1 < m &&
                                newJ2 >= 0 && newJ2 < m) {
                                maxi = max(maxi, curr + 
                                           dp[i+1][newJ1][newJ2]);
                            } else {
                                maxi = max(maxi, (int)-1e9);
                            }
                        }
                    }
                    dp[i][j1][j2] = maxi;
                }
            }
        }
        return dp[0][0][m-1];
    }
};

// Driver code
int main() {
    vector<vector<int>> grid = {
        {2, 3, 1, 2},
        {3, 4, 2, 2},
        {5, 6, 3, 5}
    };
    int n = grid.size(), m = grid[0].size();
    Solution obj;
    cout << obj.maximumChocolates(n, m, grid) << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N × M × M) × 9**
  - The 3D DP table has `N × M × M` states  
  - For each state, we check **9 possible move combinations**  
  - Hence, total time complexity is `O(N × M × M × 9)`

- **Space Complexity:** **O(N × M × M)**
  - A 3D DP array of size `N × M × M` is used
  - No recursion is involved, so **stack space is eliminated**

---

## Approach - Space Optimization

### Space Optimization Idea:
To compute the value for any cell, we only need results from the **next row**.  
So, instead of maintaining a full 3D DP table, we can optimize space by using **two 2D tables** and updating them row by row.

### Algorithm:

1. **Initialize**
   - Create a 2D table `front` of size `M × M`
   - Fill `front` using the **last row** of the grid:
     - If Alice and Bob are in the same cell → count chocolates once
     - Otherwise → add chocolates from both cells

2. **Create Current Row Table**
   - Create another 2D table `cur` of size `M × M`

3. **Fill Rows Bottom-Up**
   - Traverse rows from `N-2` down to `0`
   - For every pair of columns `(j1, j2)`:
     - Try all **9 possible move combinations**
     - Use values from `front` to compute the best result
     - Store the maximum value in `cur[j1][j2]`

4. **Update**
   - After completing one row, copy `cur` into `front`

### Final Answer
- The result is stored in  
  **`front[0][M-1]`**,  
  which represents Alice starting at column `0` and Bob at column `M-1` in the first row

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve Ninja and his friends using space optimization
class Solution {
public:
    int maximumChocolates(int n, int m, vector<vector<int>>& grid) {
        // Next row dp array
        vector<vector<int>> next(m, vector<int>(m, 0));
        // Current row dp array
        vector<vector<int>> curr(m, vector<int>(m, 0));
        
        // Base case: last row
        for (int j1 = 0; j1 < m; j1++) {
            for (int j2 = 0; j2 < m; j2++) {
                if (j1 == j2) next[j1][j2] = grid[n-1][j1];
                else next[j1][j2] = grid[n-1][j1] + grid[n-1][j2];
            }
        }
        
        // Fill DP table bottom-up
        for (int i = n - 2; i >= 0; i--) {
            for (int j1 = 0; j1 < m; j1++) {
                for (int j2 = 0; j2 < m; j2++) {
                    int maxi = -1e9;
                    int currChoco = (j1 == j2) ? grid[i][j1] 
                                               : grid[i][j1] + grid[i][j2];
                    // Try all 9 moves
                    for (int dj1 = -1; dj1 <= 1; dj1++) {
                        for (int dj2 = -1; dj2 <= 1; dj2++) {
                            int newJ1 = j1 + dj1;
                            int newJ2 = j2 + dj2;
                            if (newJ1 >= 0 && newJ1 < m &&
                                newJ2 >= 0 && newJ2 < m) {
                                maxi = max(maxi, currChoco + 
                                           next[newJ1][newJ2]);
                            } else {
                                maxi = max(maxi, (int)-1e9);
                            }
                        }
                    }
                    curr[j1][j2] = maxi;
                }
            }
            // Move current row to next row
            next = curr;
        }
        // Answer is starting position
        return next[0][m-1];
    }
};

// Driver code
int main() {
    vector<vector<int>> grid = {
        {2, 3, 1, 2},
        {3, 4, 2, 2},
        {5, 6, 3, 5}
    };
    int n = grid.size(), m = grid[0].size();
    Solution obj;
    cout << obj.maximumChocolates(n, m, grid) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N × M × M × 9)**  
  - There are `N × M × M` states (row, Alice column, Bob column)
  - For each state, we check **9 possible move combinations**
  - Hence, total time complexity is `O(N*M*M*9)`

- **Space Complexity:** **O(M × M)**  
  - We use two 2D arrays (`front` and `cur`) of size `M × M`
  - No recursion stack is used
  - Therefore, space complexity is `O(M*M)`


