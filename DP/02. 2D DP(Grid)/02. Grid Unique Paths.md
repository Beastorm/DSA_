## Grid Unique Paths

**Problem Statement:**  
Given two integers `m` and `n`, representing the number of rows and columns of a 2D array named `matrix`.
Return the number of **unique ways** to go from the top-left cell (`matrix[0][0]`) to the bottom-right cell (`matrix[m-1][n-1]`).

**Movement is allowed only in two directions from a cell:**

- Right
- Down

---

>### Examples:

### Example 1:

**Input:** m = 3, n = 2    
**Output:** 3   


**Explanation:**
There are 3 unique ways to go from the top-left to the bottom-right cell:

```
Right → Down → Down

Down → Right → Down

Down → Down → Right
```

### Example 2:

**Input:** m = 2, n = 4   
**Output:** 4   

**Explanation:** 
There are 4 unique ways to go from the top-left to the bottom-right cell:
```
Down → Right → Right → Right

Right → Down → Right → Right

Right → Right → Down → Right

Right → Right → Right → Down
```

---

## Approach - Recursive

### Intuition:

- You start at the **top-left corner** `(0,0)` of a grid and want to reach the **bottom-right corner** `(m-1,n-1)`.  
- You can move only **right** or **down**.  
- To reach a cell `(i,j)`, you must come either from:  
  - The cell **above** `(i-1,j)`  
  - The cell **to the left** `(i,j-1)`  
- Therefore, the **total ways to reach `(i,j)`** = ways to reach `(i-1,j)` + ways to reach `(i,j-1)`.


### Algorithm:

1. **Recursive Idea**  
   - If at `(0,0)`, return 1 (start position).  
   - If out of bounds, return 0.  
   - Otherwise:
     ```
     paths(i,j) = paths(i-1,j) + paths(i,j-1)
     ```

2. **DP / Memoization (Optional)**  
   - Create a 2D array `dp[i][j]` to store results of subproblems.  
   - Before calculating `paths(i,j)`, check if `dp[i][j]` is already computed.  
   - This avoids recalculating overlapping subproblems.

3. **Return Result**  
   - Return `paths(m-1,n-1)` as the total number of unique paths.


**Note:**  
- **Intuition:** Each cell depends only on the **top and left neighbors**.  
- **Algorithm:** Recursively sum paths from top and left, and optionally use DP to optimize.

### C++ Code:
``` cpp
#include <iostream>
#include <vector>
using namespace std;

// Pure Recursive Solution (Top-Down)
int countPaths(int i, int j) {
    // If we reach the start cell, we found a path
    if (i == 0 && j == 0) return 1;

    // If we go out of bounds (negative index), no path exists
    if (i < 0 || j < 0) return 0;

    // Explore the two possible directions we could have come from
    int up = countPaths(i - 1, j);
    int left = countPaths(i, j - 1);

    return up + left;
}

int main() {
    int m = 3, n = 2;
    // We start from the bottom-right corner (m-1, n-1)
    cout << "Total Unique Paths: " << countPaths(m - 1, n - 1) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**
  - Recursive solution: **O(2^(m+n))** → exponential, because each cell branches into 2 recursive calls.
  - DP / Memoization solution: **O(m * n)** → each subproblem is computed once.

- **Space Complexity:**
  - Recursive solution: **O(m+n)** → recursion stack for maximum depth.
  - DP solution: **O(m * n)** → for storing the DP table.
  - Optimized DP (1D array): **O(n)** → only store one row at a time.

---


## Approach - Memoization

### Algorithm:

1. **Declare a DP array**  
   - Create a 2D array `dp[m][n]`, where `m` and `n` are the dimensions of the grid.  
   - `dp[i][j]` stores the total number of ways to reach from `(0,0)` to `(i,j)`.

2. **Initialize the DP array**  
   - Fill the `dp` array with `-1` to indicate that no subproblem has been solved yet.

3. **Handle overlapping subproblems**  
   - When encountering a subproblem `(i,j)`, check if `dp[i][j] != -1`.  
   - If true, the subproblem is already solved, so **return the stored value** instead of recalculating.

4. **Solve unsolved subproblems**  
   - If `dp[i][j] == -1`, calculate the number of unique paths to `(i,j)`.  
   - Store the result in `dp[i][j]` for future reference.  
   - This ensures that overlapping subproblems can be solved in **O(1)** time when reused.

5. **Return the final result**  
   - The value in `dp[m-1][n-1]` gives the total number of unique paths from the top-left to the bottom-right cell.


### Key Points:

- Memoization avoids recalculating overlapping subproblems.  
- Each cell `(i,j)` is calculated **only once**.  
- Time complexity reduces from exponential to **O(m*n)**.  
- Space complexity is **O(m*n)** for the DP table plus recursion stack.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    //Function to solve the problem using recursion
    int func(int i, int j, vector<vector<int>>& dp){
        // Base case
        if (i == 0 && j == 0)  return 1;

        /* If we go out of bounds or reach 
        a blocked cell, there are no ways.*/
        if (i < 0 || j < 0)  return 0;
        
        /* If we have already computed the number 
        of ways for this cell, return it.*/
        if (dp[i][j] != -1)  return dp[i][j];

        /* Calculate the number of ways by
        moving up and left recursively.*/
        int up = func(i - 1, j, dp);
        int left = func(i, j - 1, dp);

        // Store the result in dp table and return it.
        return dp[i][j] = up + left;
    }
public:
    /*Function to count the total ways
    to reach (0,0) from (m-1,n-1)*/
    int uniquePaths(int m, int n) {
        /* Initialize a memoization table (dp) to
        store the results of subproblems.*/
        vector<vector<int>> dp(m, vector<int>(n, -1));
        
        //Return the total count(0 based indexing)
        return func(m-1,n-1, dp);
    }
};
int main() {
    int m = 3;
    int n = 2;
    
    //Create an instance of the Solution class
    Solution sol;
    
    // Call the countWays function and print the result.
    cout << "Number of ways: " << sol.uniquePaths(m, n) << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  O(m * n), where `m` is the number of rows and `n` is the number of columns.  
  - Reason: We fill a 2D DP array of size `m x n`, and each cell takes constant time to compute.

- **Space Complexity:**  
  O(m * n), due to storing the DP array, which keeps track of the number of unique paths to each cell.

---

## Approach - Tabulation

### Algorithm:

1. **Declare a DP array**  
   - Create a 2D array `dp[m][n]`, where `m` and `n` are the number of rows and columns of the grid.  
   - `dp[i][j]` stores the total number of ways to reach the cell `(i,j)` from `(0,0)`.

2. **Initialize the base case**  
   - The starting position has only one way to reach itself:  
     ```
     dp[0][0] = 1
     ```

3. **Fill the DP array iteratively**  
   - Use two nested loops:
     - Outer loop: `i` from 0 to `m-1` (rows)  
     - Inner loop: `j` from 0 to `n-1` (columns)
   - For each cell `(i,j)`, calculate the number of ways to reach it:
     ```
     dp[i][j] = 0
     if i > 0: dp[i][j] += dp[i-1][j]   # ways from top
     if j > 0: dp[i][j] += dp[i][j-1]   # ways from left
     ```

4. **Return the final result**  
   - After filling all cells, the value in `dp[m-1][n-1]` contains the total number of unique paths to reach the bottom-right corner.  
   - Return `dp[m-1][n-1]`.

### Diagram:
![Unique Paths Diagram](https://raw.githubusercontent.com/Beastorm/DSA_/c99e643110e368d81aa943ab694a936b57955faf/junk/unique_path.png)

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution
{
private:
    // Function to solve the problem using tabulation
    int func(int m, int n, vector<vector<int>> &dp)
    {
        // Loop through the grid using two nested loops
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {

                // Base condition
                if (i == 0 && j == 0)
                {
                    dp[i][j] = 1;
                    /* Skip the rest of the loop and
                    continue with the next iteration.*/
                    continue;
                }

                /* Initialize variables to store the number
                of ways from cell above (up) and left (left)*/
                int up = 0;
                int left = 0;

                /* If we are not at first row (i > 0), update
                'up' with the value from the cell above.*/
                if (i > 0)
                    up = dp[i - 1][j];

                /* If we are not in the first column (j > 0),
                update 'left' with the value from the cell to the left.*/
                if (j > 0)
                    left = dp[i][j - 1];

                /* Calculate the number of ways to reach the
                current cell by adding 'up' and 'left'.*/
                dp[i][j] = up + left;
            }
        }

        // The result is stored in the bottom-right cell (m-1, n-1).
        return dp[m - 1][n - 1];
    }

public:
    /*Function to count the total ways
    to reach (0,0) from (m-1,n-1)*/
    int uniquePaths(int m, int n)
    {
        /* Initialize a memoization table (dp) to
        store the results of subproblems.*/
        vector<vector<int>> dp(m, vector<int>(n, -1));

        // Return the total count(0 based indexing)
        return func(m, n, dp);
    }
};
int main()
{
    int m = 3;
    int n = 2;

    // Create an instance of the Solution class
    Solution sol;

    // Call the countWays function and print the result.
    cout << "Number of ways: " << sol.uniquePaths(m, n) << endl;

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:**  
  O(m * n), where `m` is the number of rows and `n` is the number of columns.  
  - Reason: We fill a 2D DP array of size `m x n`, and each cell takes constant time to compute.

- **Space Complexity:**  
  O(m * n), due to the 2D DP array used to store the results of subproblems.  
  - **Optimization:** Can be reduced to O(n) using a 1D array and updating it in place.

---

## Approach - Space Optimized

### Algorithm:

1. **Observation**  
   - From the tabulation approach, we have:  
     ```
     dp[i][j] = dp[i-1][j] + dp[i][j-1]
     ```  
   - To calculate `dp[i][j]`, we only need the **previous row** and the **current row**, so we can optimize space.

2. **Use two arrays**  
   - `prev[]` → stores the previous row  
   - `temp[]` → stores the current row during iteration  

3. **Initialization**  
   - Initialize `prev[]` to all zeros (or as per the starting row).  
   - `temp[]` will hold the values for the current row during computation.

4. **Iterate over rows**  
   - For each row `i`:
     - For each column `j`:
       ```
       temp[j] = 0
       if i > 0: temp[j] += prev[j]    # value from previous row
       if j > 0: temp[j] += temp[j-1]  # value from left in current row
       ```
   - After completing the row, assign `prev = temp` for the next iteration.

5. **Return the result**  
   - After processing all rows, `prev[n-1]` contains the total number of unique paths to reach the bottom-right corner.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    //Function to solve the problem using space optimization.
    int func(int m, int n){
        /* Initialize a vector to represent 
        the previous row of the grid.*/
        vector<int> prev(n, 0);

        // Iterate through the rows of the grid.
        for (int i = 0; i < m; i++) {
            /* Create a temporary vector to
            represent the current row.*/
            vector<int> temp(n, 0);

            for (int j = 0; j < n; j++) {
                // Base case
                if (i == 0 && j == 0) {
                    temp[j] = 1;
                    continue;
                }

            /* Initialize variables to store the number
            of ways from the cell above (up) and left (left).*/
            int up = 0;
            int left = 0;

            /* If we are not in the first row (i > 0), update
            'up' with the value from the previous row.*/
            if (i > 0)
                up = prev[j];

            /* If we are not in the first column (j > 0),
            update 'left' with the value from the current row.*/
            if (j > 0)
                left = temp[j - 1];

            /* Calculate the number of ways to reach the
            current cell by adding 'up' and 'left'.*/
            temp[j] = up + left;
        }

        /* Update the previous row with values 
        calculated for the current row.*/
        prev = temp;
    }

    /* The result is stored in the last
    cell of the previous row (n-1).*/
    return prev[n - 1];
}
public:
    /*Function to count the total ways
    to reach (0,0) from (m-1,n-1)*/
    int uniquePaths(int m, int n) {
        
        //Return the total count(0 based indexing)
        return func(m, n);
    }
};
int main() {
    int m = 3;
    int n = 2;
    
    //Create an instance of the Solution class
    Solution sol;
    
    // Call the countWays function and print the result.
    cout << "Number of ways: " << sol.uniquePaths(m, n) << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  O(m * n), where `m` is the number of rows and `n` is the number of columns.  
  - Reason: Each cell in the grid is visited exactly once.

- **Space Complexity:**  
  O(n), because we are using two arrays of size `n` to store the current and previous rows.  
  - This is a significant optimization compared to the 2D DP array used in previous approaches.
