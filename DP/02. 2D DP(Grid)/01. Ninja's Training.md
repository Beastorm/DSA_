## Ninja's Training

**Problem Statement:**   
A Ninja decides to train for `N` days. On each day, he can perform one of three activities:
1.  Running
2.  Fighting Practice
3.  Learning New Moves

Each activity gives certain **merit points** on each day.
The constraint is: The Ninja **cannot perform the same activity on two consecutive days**.

**Task:** Find the maximum merit points the Ninja can earn over `N` days.

---

>### Examples:

### Example 1:
**Input:** `points = [[10, 40, 70], [20, 50, 80], [30, 60, 90]]`  
**Output:** `210`  
**Explanation:**
- Day 0: Activity 2 (70 points)
- Day 1: Activity 1 (50 points)
- Day 2: Activity 2 (90 points)
- Total = 70 + 50 + 90 = 210.

---

### Example 2:
**Input:** `points = [[18, 11, 19], [4, 13, 7], [1, 8, 13]]`  
**Output:** `45`  
**Explanation:**
- Day 0: Activity 2 (19 points)
- Day 1: Activity 1 (13 points)
- Day 2: Activity 2 (13 points)
- Total = 19 + 13 + 13 = 45.

---

## Approach - Recursion

### Intuition:
The Ninja wants to maximize points over `N` days, but cannot repeat the same task on consecutive days. This means the decision for today depends on what was done yesterday (or tomorrow, depending on perspective).

We can think of this **day by day**:
- On Day `N`, if I choose Task 0, then on Day `N-1`, I can only choose Task 1 or Task 2.
- I should pick the option that gives me the maximum *future* sum.

Since we need to try all valid combinations and pick the best one, this suggests **Recursion**. Since we traverse day-by-day and the "last activity" matters, our state is defined by `(day, last_activity)`.


### Algorithm:

**Function `solve(day, last_task)`**:
Returns the max points from day `0` to `day`, given that `last_task` was performed on `day + 1`.

1.  **Base Case (`day == 0`):**
    - We are on the first day.
    - We can pick any task `0, 1, 2` EXCEPT `last_task`.
    - Return the maximum of the valid options.

2.  **Recursive Step (`day > 0`):**
    - Initialize `maxi = 0`.
    - Try every possible task `i` (0, 1, 2) for the current day.
    - **Condition:** Only proceed if `i != last_task`.
    - **Calculate:** `points = points[day][i] + solve(day - 1, i)`.
    - Update `maxi` with the maximum points found.

3.  **Initial Call:**
    - `solve(n - 1, 3)`
    - We start from the last day. `3` is a dummy value indicating "no restriction" for the very first choice.


### C++ Code:
``` cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// Recursive Function
// day: Current day index (from N-1 down to 0)
// last: The activity performed on the previous day (day+1).
//       Values: 0, 1, 2 for activities. 3 means 'no activity' (for the first day).
int solveRecursive(int day, int last, vector<vector<int>>& points) {
    
    // Base Case: Day 0
    if (day == 0) {
        int maxi = 0;
        // Check all 3 activities
        for (int task = 0; task < 3; task++) {
            if (task != last) { // Can't repeat last activity
                maxi = max(maxi, points[0][task]);
            }
        }
        return maxi;
    }

    int maxi = 0;
    // Iterate through all 3 possible activities for the current day
    for (int task = 0; task < 3; task++) {
        if (task != last) {
            // Calculate points: current activity + max points from previous days
            int point = points[day][task] + solveRecursive(day - 1, task, points);
            maxi = max(maxi, point);
        }
    }
    return maxi;
}

int ninjaTraining(int n, vector<vector<int>>& points) {
    // Start from the last day (n-1)
    // Pass '3' as 'last' because on the first day (conceptually day n), there was no previous activity restriction
    return solveRecursive(n - 1, 3, points);
}

int main() {
    vector<vector<int>> points = {
        {10, 40, 70},
        {20, 50, 80},
        {30, 60, 90}
    };
    int n = points.size();
    cout << "Maximum Points: " << ninjaTraining(n, points) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(3^N)**
  - For every day (from `N-1` down to `0`), we have 3 choices (activities).
  - In each recursive step, we branch out to roughly 2 or 3 sub-problems.
  - This creates an exponential recursion tree, specifically around `3^N`.

- **Space Complexity:** **O(N)**
  - This is the recursion stack space.
  - The depth of the recursion tree goes from day `N-1` to day `0`, so the stack depth is `N`.

---
## Approach - Memoization

### Algorithm:

We use **top-down Dynamic Programming** (recursion + caching) to solve the problem efficiently.

1.  **State Definition:**
    - `f(day, last)` returns the max points earned from day `0` to `day`, given that the activity on `day + 1` was `last`.
    - `day` ranges from `0` to `N-1`.
    - `last` ranges from `0` to `3` (0, 1, 2 are activities; 3 is "no restriction").

2.  **Memoization Table:**
    - Create a 2D array `dp[N][4]` initialized to `-1`.
    - Before computing any state, check `dp[day][last]`. If it's not `-1`, return the stored value.

3.  **Recursive Steps:**
    - **Base Case (Day 0):** Iterate through activities `0, 1, 2`. If `activity != last`, take the maximum point value among them.
    - **Recursive Step:** For `day > 0`, try all activities `task` (0, 1, 2).
      - If `task != last`, compute `points = points[day][task] + f(day-1, task)`.
      - Store the maximum of these computed points in `dp[day][last]`.

4.  **Initial Call:**
    - `f(N-1, 3)` gives the answer.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function to calculate the maximum points for the ninja training
int f(int day, int last, vector<vector<int>> &points, vector<vector<int>> &dp) {
    // If the result for this day and the last activity is already calculated, return it
    if (dp[day][last] != -1) return dp[day][last];

    // Base case: When we reach the first day (day == 0)
    if (day == 0) {
        int maxi = 0;
        // Calculate the maximum points for the first day by choosing an activity
        // different from the last one
        for (int i = 0; i <= 2; i++) {
            if (i != last)
                maxi = max(maxi, points[0][i]);
        }
        // Store the result in the dp array and return it
        return dp[day][last] = maxi;
    }

    int maxi = 0;
    // Iterate through the activities for the current day
    for (int i = 0; i <= 2; i++) {
        if (i != last) {
            // Calculate the points for the current activity and add it to the
            // maximum points obtained so far (recursively calculated)
            int activity = points[day][i] + f(day - 1, i, points, dp);
            maxi = max(maxi, activity);
        }
    }

    // Store the result in the dp array and return it
    return dp[day][last] = maxi;
}

// Function to find the maximum points for ninja training
int ninjaTraining(int n, vector<vector<int>> &points) {
    // Create a memoization table (dp) to store intermediate results
    vector<vector<int>> dp(n, vector<int>(4, -1));
    // Start the recursive calculation from the last day with no previous activity
    return f(n - 1, 3, points, dp);
}

int main() {
    // Define the points matrix
    vector<vector<int>> points = {{10, 40, 70},
                                   {20, 50, 80},
                                   {30, 60, 90}};

    int n = points.size();  // Get the number of days
    // Call the ninjaTraining function to find the maximum points and print the result
    cout << ninjaTraining(n, points);
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N)**
  - Total unique states = `N` (days) × `4` (last activity choices) = `4N`.
  - For each state, we loop through `3` possible activities.
  - Total operations ≈ `N × 4 × 3` ≈ `12N`, which simplifies to **O(N)**.

- **Space Complexity:** **O(N)**
  - **DP Array:** We use a 2D array of size `N × 4`, taking **O(N)** space.
  - **Recursion Stack:** The recursion goes `N` days deep, taking **O(N)** stack space.
  - Total space ≈ `O(N) + O(N) = O(N)`.
  
---

## Approach - Tabulation

### Algorithm:

This is a **bottom-up** Dynamic Programming approach. We build the solution starting from Day 0 up to Day N-1.

1.  **Define DP Table:**
    - Create a 2D array `dp[N][4]`.
    - `dp[day][last]` represents the maximum points possible up to `day`, considering that the activity on `day + 1` was `last`.
    - The `last` index ranges from 0-3, where 0, 1, 2 are actual activities and 3 means "no activity performed next" (used for the final answer).

2.  **Base Case (Day 0):**
    - For day 0, we calculate the max points for every possible `last` activity (0, 1, 2, 3).
    - `dp[0][0] = max(points[0][1], points[0][2])`
    - `dp[0][1] = max(points[0][0], points[0][2])`
    - `dp[0][2] = max(points[0][0], points[0][1])`
    - `dp[0][3] = max(points[0][0], points[0][1], points[0][2])`

3.  **Iterate (Days 1 to N-1):**
    - Loop through `day` from 1 to `N-1`.
    - For each day, loop through `last` (0 to 3) representing the restriction from the next day.
    - Inside, iterate through `task` (0 to 2) to pick the current day's activity.
    - If `task != last`, calculate `point = points[day][task] + dp[day-1][task]`.
    - Store the maximum in `dp[day][last]`.

4.  **Result:**
    - The answer is stored in `dp[N-1][3]`.


### Diagram:

![Ninja Training DP Table](https://github.com/Beastorm/DSA_/blob/fdf12c07e07fa866831f3de54b207f3d425b73c6/junk/ninja.png?raw=true)  
*DP Table filling for the Ninja Training problem. Rows represent days, columns represent the restricted activity (last activity). The final answer is in the last row, column 3 (no restriction).*

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to find the maximum points for ninja training
int ninjaTraining(int n, vector<vector<int>>& points) {
  // Create a 2D DP (Dynamic Programming) table to store the maximum points
  // dp[i][j] represents the maximum points at day i, considering the last activity as j
  vector<vector<int>> dp(n, vector<int>(4, 0));

  // Initialize the DP table for the first day (day 0)
  dp[0][0] = max(points[0][1], points[0][2]);
  dp[0][1] = max(points[0][0], points[0][2]);
  dp[0][2] = max(points[0][0], points[0][1]);
  dp[0][3] = max(points[0][0], max(points[0][1], points[0][2]));  // Max points for day 0 considering any activity

  // Iterate through the days starting from day 1
  for (int day = 1; day < n; day++) {
    // For each day, check all possible "last activities" (0, 1, 2, or no previous activity 3)
    for (int last = 0; last < 4; last++) {
      dp[day][last] = 0; // Initialize dp[day][last] to 0
      // Iterate through the tasks (activities) for the current day
      for (int task = 0; task <= 2; task++) {
        // If the current task is different from the last task, we can perform this task
        if (task != last) {
          // Calculate the points for the current activity and add it to the maximum points obtained
          // on the previous day with the previous task
          int activity = points[day][task] + dp[day - 1][task];
          // Update the maximum points for the current day and last activity
          dp[day][last] = max(dp[day][last], activity);
        }
      }
    }
  }

  // The maximum points for the last day with any activity can be found in dp[n-1][3]
  return dp[n - 1][3];
}

int main() {
  // Define the points matrix (points for each activity over days)
  vector<vector<int>> points = {{10, 40, 70},
                                 {20, 50, 80},
                                 {30, 60, 90}};
  int n = points.size();  // Get the number of days
  
  // Call the ninjaTraining function to find the maximum points and print the result
  cout << ninjaTraining(n, points);
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N)**
  - We have a nested loop structure:
    - Outer loop runs for `N` days.
    - Middle loop runs for `4` possible values of `last` activity.
    - Inner loop runs for `3` possible `task` choices.
  - Total operations: `N × 4 × 3 = 12N`, which simplifies to **O(N)**.

- **Space Complexity:** **O(N)**
  - We maintain a 2D DP table of size `N × 4`.
  - Space required is **O(N)** (specifically `4N`).

---

## Approach - Space Optimization

### Algorithm:

Instead of maintaining a full 2D table `dp[N][4]`, we only need the values from the **previous day** to compute the current day's values.

1.  **State Representation:**
    - Use a 1D array `prev` of size 4.
    - `prev[last]` stores the max points earned up to `day-1`, given that the activity on `day` is `last`.

2.  **Base Case (Day 0):**
    - Initialize `prev` for day 0.
    - `prev[0] = max(points[0][1], points[0][2])`
    - `prev[1] = max(points[0][0], points[0][2])`
    - `prev[2] = max(points[0][0], points[0][1])`
    - `prev[3] = max(points[0][0], points[0][1], points[0][2])`

3.  **Iterate (Day 1 to N-1):**
    - Create a `temp` array of size 4 for the current day.
    - For each `last` (0 to 3):
      - Set `temp[last] = 0`.
      - Iterate through `task` (0 to 2).
      - If `task != last`, update `temp[last] = max(temp[last], points[day][task] + prev[task])`.
    - Update `prev = temp`.

4.  **Result:**
    - Return `prev[3]`.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to find the maximum points for ninja training
int ninjaTraining(int n, vector<vector<int>>& points) {
  // Initialize a vector to store the maximum points for the previous day's activities
  vector<int> prev(4, 0);

  // Initialize the DP table for the first day (day 0)
  prev[0] = max(points[0][1], points[0][2]);
  prev[1] = max(points[0][0], points[0][2]);
  prev[2] = max(points[0][0], points[0][1]);
  prev[3] = max(points[0][0], max(points[0][1], points[0][2]));

  // Iterate through the days starting from day 1
  for (int day = 1; day < n; day++) {
    // Create a temporary vector to store the maximum points for the current day's activities
    vector<int> temp(4, 0);
    for (int last = 0; last < 4; last++) {
      temp[last] = 0;
      // Iterate through the tasks for the current day
      for (int task = 0; task <= 2; task++) {
        if (task != last) {
          // Calculate the points for the current activity and add it to the
          // maximum points obtained on the previous day (stored in prev)
          temp[last] = max(temp[last], points[day][task] + prev[task]);
        }
      }
    }
    // Update prev with the maximum points for the current day
    prev = temp;
  }

  // The maximum points for the last day with any activity can be found in prev[3]
  return prev[3];
}

int main() {
  // Define the points matrix
  vector<vector<int>> points = {{10, 40, 70},
                                 {20, 50, 80},
                                 {30, 60, 90}};
  int n = points.size();  // Get the number of days
  // Call the ninjaTraining function to find the maximum points and print the result
  cout << ninjaTraining(n, points);
}
```

### Complexity Analysis:

- **Time Complexity:** **O(N)**
  - We still iterate through `N` days.
  - For each day, we process `4` states of `last` and `3` activity choices.
  - Total operations ≈ `12N`, which is **O(N)**.

- **Space Complexity:** **O(1)**
  - We only use two arrays (`prev` and `temp`) of fixed size 4.
  - This reduces space from `O(N)` to **O(1)** (constant space).
