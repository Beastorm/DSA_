## Minimum Path Sum in a Grid

**Problem Statement:**   
Given an `m x n` grid filled with non-negative numbers, find a path from the **top-left** cell to the **bottom-right** cell which **minimizes the sum** of all numbers along its path.  

**Note:** You can **only move either down or right** at any point in time.

---

>### Example:

### Example 1:
**Input:**  
```text
grid = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
```

**Output:** 21   
**Explanation:** Minimum sum is achieved via path 5->9->5->2, i.e., 21.

---

### Example 2:
**Input:**
``` text
grid = [
[1,2,3],
[4,5,6]
]
```
**Output:** 12   
**Explanation:**  Minimum sum is achieved via path 1->2->3->6, i.e., 12.

---
## Approach - Recursive

### Intuition:

To find the **minimum path sum** from $(0, 0)$ to $(m-1, n-1)$, we apply a greedy-recursive logic. Since we can only move **Right** or **Down**, it follows that to arrive at any cell $(i, j)$, we must have come from either the cell **above** $(i-1, j)$ or the cell to the **left** $(i, j-1)$.

To minimize the total cost at $(i, j)$, we simply take the value of the current cell and add it to the **minimum** of the path costs required to reach its two possible neighbors.

---

### Algorithm:

**Recursive Idea (Starting from Destination):**

1.  **Base Case - Source:** If you are at $(0, 0)$, the cost is just `grid[0][0]`.
2.  **Base Case - Out of Bounds:** If $i < 0$ or $j < 0$, return a very large value (like `1e9`). This ensures that when we use `min()`, these invalid paths are ignored.
3.  **Recursive Step:**
    * Calculate path sum from above: `up = grid[i][j] + f(i-1, j)`
    * Calculate path sum from left: `left = grid[i][j] + f(i, j-1)`
    * Return `min(up, left)`
---

### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

// Pure Recursive Function (Top-Down / Backward)
int findMinPathSum(int i, int j, vector<vector<int>> &grid) {
    // 1. Base case: reached the starting cell
    if (i == 0 && j == 0)
        return grid[0][0];

    // 2. Base case: out of bounds
    // Return a large value so min() ignores this path
    if (i < 0 || j < 0)
        return 1e9;

    // 3. Recursive calls: 
    // Find min cost to reach cell above or cell to the left
    int fromUp = findMinPathSum(i - 1, j, grid);
    int fromLeft = findMinPathSum(i, j - 1, grid);

    // Current cell value + minimum of the two incoming paths
    return grid[i][j] + min(fromUp, fromLeft);
}

int minPathSum(vector<vector<int>> &grid) {
    int m = grid.size();
    int n = grid[0].size();
    return findMinPathSum(m - 1, n - 1, grid);
}

int main() {
    vector<vector<int>> grid = {
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1}
    };

    cout << "Minimum Path Sum: " << minPathSum(grid) << endl; 
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(n × m)`  
  Each cell of the grid is computed only once due to memoization.

- **Space Complexity:**  
  `O(n × m)` for the memoization table  
  `O(n + m)` for the recursion stack in the worst case

- **Overall Space Complexity:**  
  `O(n × m)`


---


## Approach - Memoization

### Algorithm:

This question is a slight modification of the question discussed in **Grid Unique Path 2**.  
In the previous problem, there were obstacles, whereas this problem hasa  cost associated with a cell, and we need to return the minimum cost path.

### Why a Greedy Solution doesn’t work?

As we have to return the minimum path sum, the first approach that comes to our mind is to take a greedy approach and always form a path by locally choosing the cheaper option. This approach will not give us the correct answer. Let us look at this example to understand:

At every cell, we have two choices:
- to move right
- to move down

Our ultimate aim is to provide a path that provides us with the least path sum. Therefore, at every cell, we will make the choice to move which costs are less.


### Recursive + Memoization Approach

Therefore, the other alternative left to us is to generate all the possible paths and see which is the path with the minimum path sum. To generate all paths we will use recursion.

- Start from the bottom-right cell (destination) and move toward the top-left (starting point) recursively.
- For each cell, explore the minimum path sum by going either up or left (since we are moving backward in recursion).
- Use a 2D memoization table to store the results of subproblems to avoid recalculating them.
- The base case is the top-left cell where the path sum is simply the grid value at that position.
- If we go out of bounds (negative index), we return a large number to avoid considering invalid paths.
- At each step, take the grid value at the current cell and add it to the minimum of the path sums from the top and left cells, then memoize and return.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class containing the solution logic
class Solution {
public:
    // Function to calculate minimum path sum with memoization
    int minPath(int i, int j,
                vector<vector<int>> &grid,
                vector<vector<int>> &dp) {
        // If we are at (0,0), return that cell's value
        if (i == 0 && j == 0)
            return grid[0][0];

        // If out of bounds, return a large number
        if (i < 0 || j < 0)
            return 1e9;

        // If already computed, return from dp
        if (dp[i][j] != -1)
            return dp[i][j];

        // Compute path by going up
        int up = grid[i][j] +
                 minPath(i - 1, j, grid, dp);

        // Compute path by going left
        int left = grid[i][j] +
                   minPath(i, j - 1, grid, dp);

        // Store the minimum in dp and return
        return dp[i][j] = min(up, left);
    }

    // Main function that initializes dp and calls helper
    int minPathSum(vector<vector<int>> &grid) {
        int n = grid.size();
        int m = grid[0].size();

        // Create dp table initialized with -1
        vector<vector<int>> dp(n,
                vector<int>(m, -1));

        // Start from the bottom-right corner
        return minPath(n - 1, m - 1, grid, dp);
    }
};

// Driver function
int main() {
    vector<vector<int>> grid = {
        {5, 9, 6},
        {11, 5, 2}
    };

    Solution obj;
    cout << "Minimum sum path: "
         << obj.minPathSum(grid) << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(N × M)`  
  At maximum, there will be `N × M` recursive calls due to memoization.

- **Space Complexity:**  
  `O(N + M) + O(N × M)`  
  Additional space is used for the recursion stack and the memoization table.

---

## Approach - Tabulation

### Algorithm:

- Tabulation is a bottom-up approach where we solve the problem from the base case to the final answer.
- Create a `dp` array of size `n × m`.
- Initialize the base case:  
  `dp[0][0] = matrix[0][0]`
- Traverse the matrix using two nested loops from top-left to bottom-right.
- To compute `dp[i][j]`, we only need:
  - `dp[i-1][j]` (from top)
  - `dp[i][j-1]` (from left)
- For `i > 0` and `j > 0`:  
  `dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1])`
- If `i = 0` or `j = 0`, add `1e9` to the missing direction to reject that path.
- The final answer is stored in `dp[n-1][m-1]`.

### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the problem
class Solution {
public:
    // Function to calculate minimum path sum
    int minPathSum(vector<vector<int>> &matrix) {
        int n = matrix.size();
        int m = matrix[0].size();

        // Create DP table
        vector<vector<int>> dp(n, vector<int>(m, 0));

        // Fill the table
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {

                // First cell initialization
                if (i == 0 && j == 0)
                    dp[i][j] = matrix[i][j];
                else {
                    // Calculate from top
                    int up = matrix[i][j];
                    if (i > 0) up += dp[i - 1][j];
                    else up += 1e9;

                    // Calculate from left
                    int left = matrix[i][j];
                    if (j > 0) left += dp[i][j - 1];
                    else left += 1e9;

                    // Take minimum
                    dp[i][j] = min(up, left);
                }
            }
        }

        // Return result
        return dp[n - 1][m - 1];
    }
};

// Driver function
int main() {
    vector<vector<int>> matrix{
        {5, 9, 6},
        {11, 5, 2}
    };

    Solution obj;
    cout << "Minimum sum path: " << obj.minPathSum(matrix) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(N × M)`  
  The entire grid is visited at least once.

- **Space Complexity:**  
  `O(N × M)`  
  Space used for the DP array.

---

## Approach - Space Optimization

### Algorithm:

- From the relation  
  `dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1])`  
  We observe that only the previous row and the current row are required to compute the answer.
- Hence, we can optimize the space by using a 1D array instead of a 2D DP table.
- Initialize a dummy array `prev` representing the previous row and set all values to `0`.
- For each row:
  - Create a temporary array `temp` to store the current row values.
  - To compute `temp[j]`, use:
    - `prev[j]` → value from the top
    - `temp[j-1]` → value from the left
- After processing the current row, assign `temp` to `prev`.
- After the last row is processed, `prev[m-1]` contains the minimum path sum and is the final answer.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:

    // Function to find the minimum sum path in a grid
    int minSumPath(int n, int m, vector<vector<int>> &matrix) {
    
        // Create 1D vector for previous row
        vector<int> prev(m, 0);
    
        // Loop through each row
        for (int i = 0; i < n; i++) {
        
            // Create temp vector for current row
            vector<int> temp(m, 0);
        
            // Loop through each column
            for (int j = 0; j < m; j++) {
            
                // If at the start cell
                if (i == 0 && j == 0)
                    temp[j] = matrix[i][j];
                else {
                    
                    // Take up direction if valid
                    int up = matrix[i][j];
                    if (i > 0)
                        up += prev[j];
                    else
                        up += 1e9;
                    
                    // Take the left direction if valid
                    int left = matrix[i][j];
                    if (j > 0)
                        left += temp[j - 1];
                    else
                        left += 1e9;
                    
                    // Take the minimum of both directions
                    temp[j] = min(up, left);
                }
            }
    
            // Move current row to previous
            prev = temp;
        }
    
        // Return result at destination
        return prev[m - 1];
    }
};

int main() {
    vector<vector<int>> matrix{
        {5, 9, 6},
        {11, 5, 2}
    };

    int n = matrix.size();
    int m = matrix[0].size();
    
    Solution obj;
    
    cout << "Minimum sum path: " << obj.minSumPath(n, m, matrix) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(N × M)`  
  Every element of the grid is visited at least once.

- **Space Complexity:**  
  `O(N)`  
  Only one array is used to store row values.

