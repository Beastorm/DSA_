## Minimum Path Sum in a Grid

**Problem Statement:**   
Given an `m x n` grid filled with non-negative numbers, find a path from the **top-left** cell to the **bottom-right** cell which **minimizes the sum** of all numbers along its path.  

**Note:** You can **only move either down or right** at any point in time.

---

>### Example:

### Example 1:
**Input:**  
```text
grid = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
```

**Output:** 21   
**Explanation:** Minimum sum is achieved via path 5->9->5->2, i.e., 21.

---

### Example 2:
**Input:**
``` text
grid = [
[1,2,3],
[4,5,6]
]
```
**Output:** 12   
**Explanation:**  Minimum sum is achieved via path 1->2->3->6, i.e., 12.

---
## Approach - Recursive

### Minimum Path Sum | Pure Recursive Approach

If we remove the `dp` table entirely, we are left with a **pure recursive** solution. This approach is highly intuitive but inefficient because it recalculates the minimum path for the same cells many times over.

#### Intuition

At any given cell $(i, j)$, you are making a decision: "Should I arrive here from the top or from the left?" 
To answer that, you ask the same question for the neighbors $(i-1, j)$ and $(i, j-1)$. You keep branching out until you hit the very first cell $(0, 0)$.



---

#### Algorithm

1.  **Function Definition:** `minPath(i, j)` returns the minimum sum to reach cell $(i, j)$.
2.  **Base Case (Success):** If $i=0$ and $j=0$, you've reached the start. Return the value of `grid[0][0]`.
3.  **Base Case (Boundaries):** If $i < 0$ or $j < 0$, you've fallen off the grid. Return a very large number (e.g., `1e9`) so that `min()` will never choose this path.
4.  **The Recursive Steps:**
    * **Up:** Calculate the cost to reach the current cell if you came from above: `grid[i][j] + minPath(i-1, j)`
    * **Left:** Calculate the cost to reach the current cell if you came from the left: `grid[i][j] + minPath(i, j-1)`
5.  **Return:** The minimum of the **Up** path and the **Left** path.



---

#### Code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Pure recursive function without any memoization
    int minPath(int i, int j, vector<vector<int>> &grid) {
        // Base case: Reached the very first cell
        if (i == 0 && j == 0)
            return grid[0][0];

        // Base case: Out of bounds
        // Return a high value so this path is discarded by min()
        if (i < 0 || j < 0)
            return 1e9;

        // Path coming from the cell above
        int up = grid[i][j] + minPath(i - 1, j, grid);

        // Path coming from the cell to the left
        int left = grid[i][j] + minPath(i, j - 1, grid);

        // OR Current cell cost + the best path found so far
        // return grid[i][j] + min(up, left);

        
        // Return the minimum of the two possible paths
        return min(up, left);
    }

    int minPathSum(vector<vector<int>> &grid) {
        int n = grid.size();
        int m = grid[0].size();

        // Start from the bottom-right corner (n-1, m-1)
        return minPath(n - 1, m - 1, grid);
    }
};

int main() {
    vector<vector<int>> grid = {
        {5, 9, 6},
        {11, 5, 2}
    };

    Solution obj;
    cout << "Minimum sum path (Pure Recursion): " << obj.minPathSum(grid) << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(n × m)`  
  Each cell of the grid is computed only once due to memoization.

- **Space Complexity:**  
  `O(n × m)` for the memoization table  
  `O(n + m)` for the recursion stack in the worst case

- **Overall Space Complexity:**  
  `O(n × m)`


---


## Approach - Memoization

### Algorithm:

This question is a slight modification of the question discussed in **Grid Unique Path 2**.  
In the previous problem, there were obstacles, whereas this problem hasa  cost associated with a cell, and we need to return the minimum cost path.

### Why a Greedy Solution doesn’t work?

As we have to return the minimum path sum, the first approach that comes to our mind is to take a greedy approach and always form a path by locally choosing the cheaper option. This approach will not give us the correct answer. Let us look at this example to understand:

At every cell, we have two choices:
- to move right
- to move down

Our ultimate aim is to provide a path that provides us with the least path sum. Therefore, at every cell, we will make the choice to move which costs are less.


### Recursive + Memoization Approach

Therefore, the other alternative left to us is to generate all the possible paths and see which is the path with the minimum path sum. To generate all paths we will use recursion.

- Start from the bottom-right cell (destination) and move toward the top-left (starting point) recursively.
- For each cell, explore the minimum path sum by going either up or left (since we are moving backward in recursion).
- Use a 2D memoization table to store the results of subproblems to avoid recalculating them.
- The base case is the top-left cell where the path sum is simply the grid value at that position.
- If we go out of bounds (negative index), we return a large number to avoid considering invalid paths.
- At each step, take the grid value at the current cell and add it to the minimum of the path sums from the top and left cells, then memoize and return.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class containing the solution logic
class Solution {
public:
    // Function to calculate minimum path sum with memoization
    int minPath(int i, int j,
                vector<vector<int>> &grid,
                vector<vector<int>> &dp) {
        // If we are at (0,0), return that cell's value
        if (i == 0 && j == 0)
            return grid[0][0];

        // If out of bounds, return a large number
        if (i < 0 || j < 0)
            return 1e9;

        // If already computed, return from dp
        if (dp[i][j] != -1)
            return dp[i][j];

        // Compute path by going up
        int up = grid[i][j] +
                 minPath(i - 1, j, grid, dp);

        // Compute path by going left
        int left = grid[i][j] +
                   minPath(i, j - 1, grid, dp);

        // Store the minimum in dp and return
        return dp[i][j] = min(up, left);
    }

    // Main function that initializes dp and calls helper
    int minPathSum(vector<vector<int>> &grid) {
        int n = grid.size();
        int m = grid[0].size();

        // Create dp table initialized with -1
        vector<vector<int>> dp(n,
                vector<int>(m, -1));

        // Start from the bottom-right corner
        return minPath(n - 1, m - 1, grid, dp);
    }
};

// Driver function
int main() {
    vector<vector<int>> grid = {
        {5, 9, 6},
        {11, 5, 2}
    };

    Solution obj;
    cout << "Minimum sum path: "
         << obj.minPathSum(grid) << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(N × M)`  
  At maximum, there will be `N × M` recursive calls due to memoization.

- **Space Complexity:**  
  `O(N + M) + O(N × M)`  
  Additional space is used for the recursion stack and the memoization table.

---

## Approach - Tabulation

### Algorithm:

- Tabulation is a bottom-up approach where we solve the problem from the base case to the final answer.
- Create a `dp` array of size `n × m`.
- Initialize the base case:  
  `dp[0][0] = matrix[0][0]`
- Traverse the matrix using two nested loops from top-left to bottom-right.
- To compute `dp[i][j]`, we only need:
  - `dp[i-1][j]` (from top)
  - `dp[i][j-1]` (from left)
- For `i > 0` and `j > 0`:  
  `dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1])`
- If `i = 0` or `j = 0`, add `1e9` to the missing direction to reject that path.
- The final answer is stored in `dp[n-1][m-1]`.

### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Class to solve the problem
class Solution {
public:
    // Function to calculate minimum path sum
    int minPathSum(vector<vector<int>> &matrix) {
        int n = matrix.size();
        int m = matrix[0].size();

        // Create DP table
        vector<vector<int>> dp(n, vector<int>(m, 0));

        // Fill the table
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {

                // First cell initialization
                if (i == 0 && j == 0)
                    dp[i][j] = matrix[i][j];
                else {
                    // Calculate from top
                    int up = matrix[i][j];
                    if (i > 0) up += dp[i - 1][j];
                    else up += 1e9;

                    // Calculate from left
                    int left = matrix[i][j];
                    if (j > 0) left += dp[i][j - 1];
                    else left += 1e9;

                    // Take minimum
                    dp[i][j] = min(up, left);
                }
            }
        }

        // Return result
        return dp[n - 1][m - 1];
    }
};

// Driver function
int main() {
    vector<vector<int>> matrix{
        {5, 9, 6},
        {11, 5, 2}
    };

    Solution obj;
    cout << "Minimum sum path: " << obj.minPathSum(matrix) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(N × M)`  
  The entire grid is visited at least once.

- **Space Complexity:**  
  `O(N × M)`  
  Space used for the DP array.

---

## Approach - Space Optimization

### Algorithm:

- From the relation  
  `dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1])`  
  We observe that only the previous row and the current row are required to compute the answer.
- Hence, we can optimize the space by using a 1D array instead of a 2D DP table.
- Initialize a dummy array `prev` representing the previous row and set all values to `0`.
- For each row:
  - Create a temporary array `temp` to store the current row values.
  - To compute `temp[j]`, use:
    - `prev[j]` → value from the top
    - `temp[j-1]` → value from the left
- After processing the current row, assign `temp` to `prev`.
- After the last row is processed, `prev[m-1]` contains the minimum path sum and is the final answer.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:

    // Function to find the minimum sum path in a grid
    int minSumPath(int n, int m, vector<vector<int>> &matrix) {
    
        // Create 1D vector for previous row
        vector<int> prev(m, 0);
    
        // Loop through each row
        for (int i = 0; i < n; i++) {
        
            // Create temp vector for current row
            vector<int> temp(m, 0);
        
            // Loop through each column
            for (int j = 0; j < m; j++) {
            
                // If at the start cell
                if (i == 0 && j == 0)
                    temp[j] = matrix[i][j];
                else {
                    
                    // Take up direction if valid
                    int up = matrix[i][j];
                    if (i > 0)
                        up += prev[j];
                    else
                        up += 1e9;
                    
                    // Take the left direction if valid
                    int left = matrix[i][j];
                    if (j > 0)
                        left += temp[j - 1];
                    else
                        left += 1e9;
                    
                    // Take the minimum of both directions
                    temp[j] = min(up, left);
                }
            }
    
            // Move current row to previous
            prev = temp;
        }
    
        // Return result at destination
        return prev[m - 1];
    }
};

int main() {
    vector<vector<int>> matrix{
        {5, 9, 6},
        {11, 5, 2}
    };

    int n = matrix.size();
    int m = matrix[0].size();
    
    Solution obj;
    
    cout << "Minimum sum path: " << obj.minSumPath(n, m, matrix) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  
  `O(N × M)`  
  Every element of the grid is visited at least once.

- **Space Complexity:**  
  `O(N)`  
  Only one array is used to store row values.

