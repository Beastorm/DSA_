## Minimum/Maximum Falling Path Sum

**Problem Statement:**   
Given a 2D array `matrix` consisting of integer values, return the **maximum path sum** that can be obtained by starting at **any cell in the first row** and ending at **any cell in the last row**.  

**Movement rules**: From a cell `(i, j)`, you can move to:  

1. **Directly below** → `(i+1, j)`  
2. **Diagonally down-right** → `(i+1, j+1)`  
3. **Diagonally down-left** → `(i+1, j-1)`

---

>### Examples:

### Example 1:
**Input:**
```
matrix = [
[1, 2, 10, 4],
[100, 3, 2, 1],
[1, 1, 20, 2],
[1, 2, 2, 1]
]
```
**Output:** 105    
**Explanation:** One optimal route is: 2 -> 100 -> 1 -> 2


### Example 2:


**Input:**
``` 
matrix = [
[1, 4, 3, 1],
[2, 3, -1, -1],
[1, 1, -1, 8]
]
```
**Output:** 11   
**Explanation:** One optimal route is: 4 -> -1 -> 8

---

## Approach - Recursive

### Intuition:
- You start at **any cell in the first row** and move to the **last row**.  
- From a cell `(i, j)`, you can move:
  1. **Down** → `(i+1, j)`  
  2. **Down-left** → `(i+1, j-1)`  
  3. **Down-right** → `(i+1, j+1)`  
- The goal is to choose moves that give the **maximum total sum**.  
- This can be solved using **recursion** by exploring all paths and picking the maximum.


### Algorithm:
1. Define a recursive function `maxPath(i, j)` that returns the **maximum sum starting from cell `(i, j)`**.
2. **Base Case:** If `i` is the last row, return `matrix[i][j]`.
3. **Recursive Case:**  
```
down = maxPath(i+1, j)
downLeft = (j>0) ? maxPath(i+1, j-1) : INT_MIN
downRight = (j<m-1) ? maxPath(i+1, j+1) : INT_MIN
return matrix[i][j] + max(down, downLeft, downRight)
```
4. **Try all starting cells** in the first row and return the **maximum** among them.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function to find max falling path sum from cell (i, j)
int maxPath(int i, int j, vector<vector<int>> &matrix, int n, int m) {
    // Base case: last row
    if (i == n - 1)
        return matrix[i][j];

    // Move down
    int down = maxPath(i + 1, j, matrix, n, m);

    // Move down-left
    int downLeft = (j > 0) ? maxPath(i + 1, j - 1, matrix, n, m) : INT_MIN;

    // Move down-right
    int downRight = (j < m - 1) ? maxPath(i + 1, j + 1, matrix, n, m) : INT_MIN;

    // Return current value + maximum of the three moves
    return matrix[i][j] + max({down, downLeft, downRight});
}

// Function to find maximum falling path sum
int maximumPathSum(vector<vector<int>> &matrix) {
    int n = matrix.size();
    int m = matrix[0].size();
    int res = INT_MIN;

    // Try starting from every cell in the first row
    for (int j = 0; j < m; j++) {
        res = max(res, maxPath(0, j, matrix, n, m));
    }

    return res;
}

int main() {
    int n, m;
    cout << "Enter number of rows and columns: ";
    cin >> n >> m;

    vector<vector<int>> matrix(n, vector<int>(m));
    cout << "Enter matrix values:" << endl;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> matrix[i][j];

    int result = maximumPathSum(matrix);
    cout << "Maximum falling path sum is: " << result << endl;

    return 0;
}
```

### Complexity Analysis:
- **Time:** O(3^(n*m)) → Exponential (all possible paths).  
- **Space:** O(n) → Recursion stack.  

> Optimization: Use **memoization** or **bottom-up DP** to reduce time to O(n*m).


---

## Approach - Memoization

### Intuition:
- This problem is similar to **Minimum Path Sum in a Triangular Grid**, but with these differences:
  1. **Starting point** can be **any cell in the first row**.
  2. **Ending point** can be **any cell in the last row**.
- A **greedy approach** (choosing the locally best option at each step) **doesn’t work**, because a locally optimal move may lead to a suboptimal total path.
- Therefore, we need to explore **all possible paths** using **recursion** and use **memoization** to avoid redundant computations.


### Algorithm:

1. **Define a recursive function** `minPath(i, j)` / `maxPath(i, j)`:
   - Returns the **minimum/maximum falling path sum starting from cell `(i, j)`**.

2. **Base Case**:
   - If `i` is the **last row**, return `matrix[i][j]` (no further moves possible).

3. **Recursive Case**:
   - Consider the **three possible moves** from `(i, j)`:
     1. Down → `(i+1, j)`
     2. Diagonal left → `(i+1, j-1)` (if `j>0`)
     3. Diagonal right → `(i+1, j+1)` (if `j<m-1`)
   - Compute:
     ```cpp
     result = matrix[i][j] + maxOrMin(
                  down,
                  downLeft,
                  downRight
              );
     ```

4. **Memoization**:
   - Store the result of `(i, j)` in a **DP table**.
   - If a cell `(i, j)` is already computed, return the stored value instead of recomputing.

5. **Final Answer**:
   - Try **all cells in the first row** as starting points.
   - Return the **maximum/minimum** among them.


``` cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class for minimum falling path sum using memoization
class Solution {
public:
    // Recursive helper function to find min path sum starting at (row, col)
    int dfs(int row, int col, vector<vector<int>>& matrix, vector<vector<int>>& dp) {
        // If column is out of bounds, return a large number to ignore this path
        if (col < 0 || col >= matrix[0].size()) {
            return 1e9;
        }

        // If we are at the last row, return the value at (row, col)
        if (row == matrix.size() - 1) {
            return matrix[row][col];
        }

        // If result is already computed, return from dp
        if (dp[row][col] != -1) {
            return dp[row][col];
        }

        // Recursively compute min falling path sum for the next row:
        // directly below, below-left, and below-right
        int down = dfs(row + 1, col, matrix, dp);
        int downLeft = dfs(row + 1, col - 1, matrix, dp);
        int downRight = dfs(row + 1, col + 1, matrix, dp);

        // Calculate minimum path sum for current cell
        int ans = matrix[row][col] + min({down, downLeft, downRight});

        // Store in dp and return
        return dp[row][col] = ans;
    }

    // Main function to find minimum falling path sum
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();

        // Initialize dp with -1, indicating uncomputed states
        vector<vector<int>> dp(n, vector<int>(m, -1));

        int minSum = 1e9;

        // Try starting from each element in the first row
        for (int col = 0; col < m; col++) {
            minSum = min(minSum, dfs(0, col, matrix, dp));
        }

        return minSum;
    }
};

int main() {
    vector<vector<int>> matrix = {
        {1, 4, 3, 1},
        {2, 3, -1, -1},
        {1, 1, -1, 8}
    };

    Solution sol;
    cout << "Minimum Falling Path Sum: " << sol.minFallingPathSum(matrix) << endl;

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(N * M)  
  - Each cell `(i, j)` in the grid is computed **at most once** due to memoization.

- **Space Complexity:** O(N * M) + O(N)  
  - O(N * M) → Space used by the **memoization table**.  
  - O(N) → Space used by the **recursion stack** (maximum depth = number of rows).

---


## Approach - Tabulation

### Intuition:
To avoid the extra **recursive stack space** used in memoization, we convert the solution into a **bottom-up (tabulation) DP** approach.  
Since each cell depends only on the **previous row**, we can fill the DP table row by row from top to bottom.

### Algorithm:

1. **Initialize DP Table**
   - Create a 2D array `dp` of size `N x M`.
   - Copy the **first row** of the input matrix into `dp[0]`, since paths can start from any column in the first row.

2. **Fill DP Table**
   - Traverse rows from `i = 1` to `N-1`.
   - For each cell `(i, j)`, compute:
     ```cpp
     dp[i][j] = matrix[i][j] + minOrMax(
                    dp[i-1][j],            // from top
                    (j > 0 ? dp[i-1][j-1] : INF),   // from top-left
                    (j < M-1 ? dp[i-1][j+1] : INF)  // from top-right
                );
     ```
   - All required values are already computed since we move row by row.

3. **Final Answer**
   - The answer is the **minimum/maximum value in the last row** of the `dp` table.



### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class for minimum falling path sum using tabulation
class Solution {
public:
    // Function to find minimum falling path sum using bottom-up DP
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();

        // Create dp array same size as matrix
        vector<vector<int>> dp(n, vector<int>(m, 0));

        // Initialize last row of dp same as matrix last row
        for (int col = 0; col < m; col++) {
            dp[n - 1][col] = matrix[n - 1][col];
        }

        // Iterate from second last row up to first row
        for (int row = n - 2; row >= 0; row--) {
            for (int col = 0; col < m; col++) {
                // Initialize minimum path sum as large number
                int down = dp[row + 1][col];

                int downLeft = (col > 0) ? dp[row + 1][col - 1] : 1e9;

                int downRight = (col < m - 1) ? dp[row + 1][col + 1] : 1e9;

                // Calculate minimum path sum for current cell
                dp[row][col] = matrix[row][col] + min({down, downLeft, downRight});
            }
        }

        // Find minimum among first row elements
        int minSum = *min_element(dp[0].begin(), dp[0].end());
        return minSum;
    }
};

int main() {
    vector<vector<int>> matrix = {
        {1, 4, 3, 1},
        {2, 3, -1, -1},
        {1, 1, -1, 8}
    };

    Solution sol;
    cout << "Minimum Falling Path Sum: " << sol.minFallingPathSum(matrix) << endl;
    return 0;
}
```

### Complexity Analysis:
- **Time Complexity:** O(N * M)  
- **Space Complexity:** O(N * M)  

> This approach removes recursion overhead and ensures a clean iterative solution.

---

## Approach - Space Optimization

### Intuition:
From the DP relation:
```
dp[i][j] = matrix[i][j] + max(
dp[i-1][j],
dp[i-1][j-1],
dp[i-1][j+1]
)
```

we can see that to compute values for **row `i`**, we only need values from **row `i-1`**.  
So, instead of storing the entire DP table, we can optimize the space by keeping only **two rows**.


### Algorithm:

1. **Initialize Previous Row**
   - Create a 1D array `prev` of size `M`.
   - Copy the **first row** of the input matrix into `prev`.

2. **Iterate Row by Row**
   - For each row `i` from `1` to `N-1`:
     - Create a temporary array `cur` of size `M`.
     - For each column `j`:
       ```cpp
       cur[j] = matrix[i][j] + max(
                    prev[j],                      // from top
                    (j > 0 ? prev[j-1] : -INF),   // from top-left
                    (j < M-1 ? prev[j+1] : -INF)  // from top-right
                );
       ```
     - After computing the current row, assign:
       ```
       prev = cur
       ```

3. **Final Answer**
   - The result is the **maximum/minimum value in `prev`**, which represents the last row.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class for minimum falling path sum with space optimization
class Solution {
public:
    // Function to find minimum falling path sum using bottom-up DP with O(m) space
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();

        // Initialize dp with the last row of the matrix
        vector<int> dp(matrix[n - 1]);

        // Iterate from the second last row up to the first row
        for (int row = n - 2; row >= 0; row--) {
            vector<int> curr(m, 0);
            for (int col = 0; col < m; col++) {
                int down = dp[col];
                int downLeft = (col > 0) ? dp[col - 1] : 1e9;
                int downRight = (col < m - 1) ? dp[col + 1] : 1e9;

                // Calculate min path sum for current cell
                curr[col] = matrix[row][col] + min({down, downLeft, downRight});
            }
            dp = curr;  // update dp for next iteration
        }

        // Find minimum in dp (first row after iteration)
        return *min_element(dp.begin(), dp.end());
    }
};

int main() {
    vector<vector<int>> matrix = {
        {1, 4, 3, 1},
        {2, 3, -1, -1},
        {1, 1, -1, 8}
    };

    Solution sol;
    cout << "Minimum Falling Path Sum: " << sol.minFallingPathSum(matrix) << endl;
    return 0;
}

```

### Complexity Analysis:
- **Time Complexity:** O(N * M)  
- **Space Complexity:** O(M)  

> This approach is optimal and efficient, especially for large matrices.


