## Longest Bitonic Subsequence | (DP-46)

**Problem Statement:**   
Given an array `arr` of `n` integers, the task is to find the length of the longest bitonic sequence. A sequence is considered bitonic if it first increases, then decreases. The sequence does not have to be contiguous.

---

>### Examples:

### Example 1:
* **Input:** `arr = [5, 1, 4, 2, 3, 6, 8, 7]`
* **Output:** `6`
* **Explanation:** The longest bitonic sequence is `[1, 2, 3, 6, 8, 7]` with a length of 6. The sequence increases from 1 to 8 and then decreases at 7.

---

### Example 2:
* **Input:** `arr = [10, 20, 30, 40, 50, 40, 30, 20]`
* **Output:** `8`
* **Explanation:** The entire array is bitonic, increasing up to 50 and then decreasing. The length of the bitonic sequence is 8.

---

## Approach

### Algorithm:

1.  **Find the length of the Longest Increasing Subsequence (LIS):** For each element in the array, check all previous elements and find the longest increasing subsequence that ends at that element.
2.  For each element `i`, check all elements `j` before it (where `j < i`) to find the LIS by comparing elements `arr[j]` and `arr[i]`. If `arr[j] < arr[i]`, update the LIS for element `i` to be the maximum LIS of element `j + 1`.
3.  **Find the length of the Longest Decreasing Subsequence (LDS):** For each element in the array, check all subsequent elements and find the longest decreasing subsequence starting at that element.
4.  For each element `i`, check all elements `j` after it (where `j > i`) to find the LDS by comparing elements `arr[j]` and `arr[i]`. If `arr[j] < arr[i]`, update the LDS for element `i` to be the maximum LDS of element `j + 1`.
5.  **Combine LIS and LDS lengths:** For each element in the array, combine the lengths of the LIS and LDS at that element to get the length of the bitonic subsequence passing through that element.
6.  For each element `i`, combine `LIS[i]` and `LDS[i]`, subtracting 1 to avoid double-counting the peak element.
7.  **Track and return the maximum combined length:** Track the maximum combined length found, and return this value as the length of the longest bitonic subsequence.


---

### C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to return the length of the longest bitonic sequence
    int LongestBitonicSequence(vector<int>& arr) {
        int n = arr.size(); // Size of the array 
        
        // LIS_dp[i] stores the length of LIS ending at index i
        vector<int> LIS_dp(n, 1);  

        // To store the length of the longest bitonic sequence
        int maxLen = 0;

        // Computing the LIS DP array 
        for(int i = 0; i < n; i++) {

            // For each previous index
            for(int prev = 0; prev < i; prev++) {
                
                /* If the element at index i can be
                 included in the LIS ending at prev index */
                if(arr[prev] < arr[i] && LIS_dp[i] < LIS_dp[prev] + 1) {
                    LIS_dp[i] = LIS_dp[prev] + 1; // Update the DP value
                }
            }
        }
    
        // LDS_dp[i] stores the length of LDS starting from index i
        vector<int> LDS_dp(n, 1);  
        
        // Computing the LDS DP array 
        for(int i = n-1; i >= 0; i--) {

            // For each previous index
            for(int prev = n-1; prev > i; prev--) {
                
                /* If the element at index i can be
                 included in the LIS ending at prev index */
                if(arr[prev] < arr[i] && LDS_dp[i] < LDS_dp[prev] + 1) {
                    LDS_dp[i] = LDS_dp[prev] + 1; // Update the DP value
                }
            }
            
            // Update the maximum possible length of Longest Bitonic Sequence
            maxLen = max(maxLen, LIS_dp[i] + LDS_dp[i] - 1);
        }
        
        return maxLen;
    }
};

int main() {
    vector<int> arr = {5, 1, 4, 2, 3, 6, 8, 7};
    
    // Creating an object of the Solution class
    Solution sol;
    
    // Function call to get the length of the longest bitonic sequence
    int lengthOfLongestBitonicSequence = sol.LongestBitonicSequence(arr);
    
    // Output
    cout << "The length of the Longest Bitonic Sequence is: " << lengthOfLongestBitonicSequence << endl;
    
    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n^2)$
    * **Explanation:** Where $n$ is the number of elements in the array. This is because we are using two nested loops to calculate the LIS (Longest Increasing Subsequence) and another set of nested loops for the LDS (Longest Decreasing Subsequence) for each element.
* **Space Complexity:** $O(n)$
    * **Explanation:** Where $n$ is the number of elements in the array. This is due to the storage of the `LIS_dp` and `LDS_dp` arrays, which each require $O(n)$ space to store the results for each index.
