## Longest Increasing Subsequence | (DP-41)

**Problem Statement:**   
Given an integer array `nums`, return the length of the longest strictly increasing subsequence.

A subsequence is a sequence derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, `[3, 6, 2, 7]` is a subsequence of `[0, 3, 1, 6, 2, 2, 7]`.

The task is to find the length of the longest subsequence in which every element is greater than the previous one.

---

>### Examples:

### Example 1:

**Input:**
`nums = [10, 9, 2, 5, 3, 7, 101, 18]`

**Output:** `4`

**Explanation:**
The longest increasing subsequence is `[2, 3, 7, 101]`, and its length is 4.

## Example 2:

**Input:**
`nums = [0, 1, 0, 3, 2, 3]`

**Output:** `4`

**Explanation:**
The longest increasing subsequence is `[0, 1, 2, 3]`, and its length is 4.

---
## Approach - Recursive
### Intuition:
The logic is based on a **decision tree**. For every element in the array, we have two choices:
1.  **Exclude:** Skip the current element and move to the next.
2.  **Include:** If the current element is greater than the last element added to our subsequence, we add it and move to the next.

We explore both paths recursively and keep track of the maximum length found.

### Algorithm Steps:
1.  **Function Signature:** `solve(index, previous_index)`
2.  **Base Case:** If `index == n` (end of array), return `0`.
3.  **Choice 1 (Not Take):** The length is simply whatever the next index returns: `0 + solve(index + 1, previous_index)`.
4.  **Choice 2 (Take):** Check if `nums[index] > nums[previous_index]`.
    * If true (or if it's the first element), the length is `1 + solve(index + 1, index)`.
5.  **Return:** The maximum of the "Take" and "Not Take" results.

### C++ Code:

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

int getLIS(int ind, int prev_ind, vector<int>& nums) {
    // Base Case: reached the end of the array
    if (ind == nums.size()) {
        return 0;
    }

    // Step 1: Not Take the current element
    int len = 0 + getLIS(ind + 1, prev_ind, nums);

    // Step 2: Take the current element (if valid)
    if (prev_ind == -1 || nums[ind] > nums[prev_ind]) {
        len = max(len, 1 + getLIS(ind + 1, ind, nums));
    }

    return len;
}

int main() {
    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};
    // Initial call: index 0, previous index -1
    cout << "Length of LIS: " << getLIS(0, -1, nums) << endl;
    return 0;
}
```
### Complexity Analysis:
* **Time Complexity:** $O(2^n)$
    * **Explanation:** For every element in the array, the algorithm branches into two recursive calls: one where the element is "included" and one where it is "excluded." This creates a binary recursion tree with a maximum depth of $n$, resulting in $2^n$ possible subsets being explored.
* **Space Complexity:** $O(n)$
    * **Explanation:** This is the space used by the recursive stack. In the worst case, the recursion goes $n$ levels deep (one for each element in the input array) before it starts returning values.

---

## Approach - Memoization
### Intuition:
In the recursive approach, we notice that many subproblems are being recalculated. For example, `solve(4, 2)` might be called multiple times through different recursive branches. By storing the results of these subproblems in a **2D array (table)**, we ensure that each state `(index, prev_index)` is computed only once.

### Algorithm Steps:
1.  **Initialize a DP Table:** Create a 2D array `dp[n][n+1]` initialized to `-1`. 
    * The first dimension represents the current `index` ($0$ to $n-1$).
    * The second dimension represents the `prev_index`. Since `prev_index` starts at `-1`, we shift it by `+1` (mapping `-1` to `0`, `0` to `1`, etc.) to fit in the array.
2.  **Check Before Computing:** Inside the recursive function, check if `dp[ind][prev_ind + 1]` is not `-1`. If so, return the stored value.
3.  **Store After Computing:** Before returning the result of the "Take" vs "Not Take" logic, save it in the `dp` table.


### C++ Code:

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

int getLIS(int ind, int prev_ind, vector<int>& nums, vector<vector<int>>& dp) {
    // Base Case
    if (ind == nums.size()) {
        return 0;
    }

    // Check memoization table (prev_ind + 1 to handle the -1 case)
    if (dp[ind][prev_ind + 1] != -1) {
        return dp[ind][prev_ind + 1];
    }

    // Choice 1: Not Take
    int len = 0 + getLIS(ind + 1, prev_ind, nums, dp);

    // Choice 2: Take
    if (prev_ind == -1 || nums[ind] > nums[prev_ind]) {
        len = max(len, 1 + getLIS(ind + 1, ind, nums, dp));
    }

    // Store in DP table and return
    return dp[ind][prev_ind + 1] = len;
}

int main() {
    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};
    int n = nums.size();
    
    // dp[index][prev_index + 1]
    vector<vector<int>> dp(n, vector<int>(n + 1, -1));
    
    cout << "Length of LIS: " << getLIS(0, -1, nums, dp) << endl;
    return 0;
}
```
### Complexity Analysis

* **Time Complexity:** $O(n^2)$
    * **Explanation:** There are $n \times (n+1)$ unique states in our DP table (representing the combinations of `current_index` and `prev_index`). Since we store the result of each state and never recompute it, the total work is proportional to the size of the table.



* **Space Complexity:** $O(n^2) + O(n)$
    * **Explanation:** $O(n^2)$ space is required for the 2D DP table to store the results of the subproblems. The additional $O(n)$ space is for the auxiliary recursion stack used by the system during the depth-first traversal of the decision tree.

---

## Approach: Tabulation
### Intuition:
Tabulation is the **bottom-up** approach. Instead of starting from the first element and using recursion, we fill the DP table starting from the "base cases" (the end of the array) and work our way backward to the start. 

By using an iterative approach, we eliminate the risk of a stack overflow and remove the overhead of recursive function calls.


### Algorithm Steps:
1.  **Table Setup:** Create a 2D array `dp[n+1][n+1]` initialized to `0`.
    * Rows represent the `current_index` (from `n` down to `0`).
    * Columns represent the `prev_index` (shifted by +1 to handle the `-1` case).
2.  **Nested Loops:**
    * The outer loop runs `ind` from `n-1` down to `0`.
    * The inner loop runs `prev_ind` from `ind-1` down to `-1`.
3.  **Logic:**
    * **Exclude:** `len = dp[ind + 1][prev_ind + 1]`
    * **Include:** If `prev_ind == -1` or `nums[ind] > nums[prev_ind]`, then `len = max(len, 1 + dp[ind + 1][ind + 1])`.
4.  **Final Answer:** The value stored in `dp[0][0]` (representing `index 0` with `prev_index -1`).


### C++ Code:

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    // dp[ind][prev_ind + 1] initialized to 0
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));

    // Iterating backwards from the last element
    for (int ind = n - 1; ind >= 0; ind--) {
        for (int prev_ind = ind - 1; prev_ind >= -1; prev_ind--) {
            
            // Option 1: Not Take
            int len = dp[ind + 1][prev_ind + 1];

            // Option 2: Take
            if (prev_ind == -1 || nums[ind] > nums[prev_ind]) {
                len = max(len, 1 + dp[ind + 1][ind + 1]);
            }

            dp[ind][prev_ind + 1] = len;
        }
    }

    return dp[0][0];
}

int main() {
    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};
    cout << "Length of LIS: " << lengthOfLIS(nums) << endl;
    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n^2)$
    * **Explanation:** Two nested loops run approximately $n$ times each, visiting every state in the $n \times n$ table exactly once. Each cell in the table takes $O(1)$ time to compute.
* **Space Complexity:** $O(n^2)$
    * **Explanation:** We use a 2D array of size $(n+1) \times (n+1)$ to store the results. Notice that the $O(n)$ recursion stack space is now gone, but the table remains the dominant factor in memory usage.

---
## Approach - Space Optimization
### Intuition:
In the tabulation approach, when calculating the values for the current row (`ind`), we only ever reference the next row (`ind + 1`). This means we don't need to store the entire $n \times n$ table. We only need two rows:
1.  **`next`:** Stores the results of the next index (previously `dp[ind+1]`).
2.  **`curr`:** Stores the results being calculated for the current index (previously `dp[ind]`).

After each iteration of the outer loop, we move the values from `curr` to `next` and repeat.

### Algorithm Steps:
1.  **Initialize Two Rows:** Create two vectors, `next` and `curr`, both of size `n + 1`, initialized to `0`.
2.  **Iterate Backward:**
    * The outer loop runs `ind` from `n-1` down to `0`.
    * Inside, calculate values for `curr` using the `next` row.
3.  **Update Logic:**
    * `curr[prev_ind + 1]` is calculated based on `next[prev_ind + 1]` (Not Take) and `next[ind + 1]` (Take).
4.  **Shift:** After the inner loop, set `next = curr`.
5.  **Final Result:** Return `next[0]`.

---

### C++ Code:

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    vector<int> next(n + 1, 0);
    vector<int> curr(n + 1, 0);

    for (int ind = n - 1; ind >= 0; ind--) {
        for (int prev_ind = ind - 1; prev_ind >= -1; prev_ind--) {
            
            // Not Take
            int len = next[prev_ind + 1];

            // Take
            if (prev_ind == -1 || nums[ind] > nums[prev_ind]) {
                len = max(len, 1 + next[ind + 1]);
            }

            curr[prev_ind + 1] = len;
        }
        next = curr;
    }

    return next[0];
}

int main() {
    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};
    cout << "Length of LIS: " << lengthOfLIS(nums) << endl;
    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n^2)$
    * **Explanation:** We still have nested loops visiting every index and previous index combination, resulting in $n^2$ operations.
* **Space Complexity:** $O(n)$
    * **Explanation:** Instead of an $n \times n$ matrix, we only maintain two arrays of size $n$, significantly reducing memory usage for large inputs.
