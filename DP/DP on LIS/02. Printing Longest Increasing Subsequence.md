## Printing Longest Increasing Subsequence | (DP-42)

**Problem Description:**
Given an array of `n` integers `arr`, return the **Longest Increasing Subsequence (LIS)** that is **index-wise lexicographically smallest**.

The **Longest Increasing Subsequence (LIS)** is the longest subsequence where all elements are in strictly increasing order. A subsequence $A_1$ is index-wise lexicographically smaller than another subsequence $A_2$ if, at the first position where $A_1$ and $A_2$ differ, the element in $A_1$ appears earlier in the original array.

---

>### Examples:

### Example 1:
* **Input:** `arr = [10, 22, 9, 33, 21, 50, 41, 60, 80]`
* **Output:** `[10, 22, 33, 50, 60, 80]`
* **Explanation:** This is the longest sequence possible where each element is greater than the previous one.

### Example 2:
* **Input:** `arr = [1, 3, 2, 4, 6, 5]`
* **Output:** `[1, 3, 4, 6]`
* **Explanation:** Possible LIS sequences are `[1, 3, 4, 6]` and `[1, 2, 4, 6]`. `[1, 3, 4, 6]` is index-wise lexicographically smaller because at the first point of difference (index 1 vs index 2), the element `3` appears earlier in the array than `2`.

---

## Approach
### Algorithm:
To find the Longest Increasing Subsequence (LIS), we use a 1D DP array where each element at position $i$ stores the length of the LIS ending at index $i$ of the array.

To make this DP array we can follow any of the approaches learned while finding the length of the Longest Increasing Subsequence.

1.  **Compute DP:** After computing the length of the Longest Increasing Subsequence (LIS) for each element using dynamic programming, start from the element with the maximum LIS value.
2.  **Initialize:** Initialize an empty list or string to store the LIS elements in reverse order.
3.  **Backtrack:** From the element with the maximum LIS, move backward through the array to find elements that can form the LIS:
    * For the current element, look for a previous element that is smaller and whose LIS value is exactly one less than the current element's LIS.
    * Add that previous element to the LIS list and continue the process from that element.
4.  **Repeat:** Repeat this process until you reach the start of the LIS (where LIS value is 1).
5.  **Reverse:** Reverse the collected elements since they were collected backwards to get the actual LIS.


### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class for LIS with reconstruction using DP
class Solution {
public:
    // Function to return the LIS as a sequence (vector)
    vector<int> longestIncreasingSubsequence(vector<int> &nums) {
        int n = nums.size();

        // DP array to store the length of LIS ending at each index
        vector<int> dp(n, 1);

        // Array to store the previous index of LIS element for reconstruction
        vector<int> prev(n, -1);

        // Compute LIS length for each index
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {
                    // Update dp[i] and store previous index
                    dp[i] = dp[j] + 1;
                    prev[i] = j;
                }
            }
        }

        // Find the index of maximum LIS length
        int maxLen = 0, maxIndex = 0;
        for (int i = 0; i < n; i++) {
            if (dp[i] > maxLen) {
                maxLen = dp[i];
                maxIndex = i;
            }
        }

        // Reconstruct LIS sequence
        vector<int> lisSeq;
        int curr = maxIndex;
        while (curr != -1) {
            lisSeq.push_back(nums[curr]);
            curr = prev[curr];
        }

        // Reverse sequence as it was built backwards
        reverse(lisSeq.begin(), lisSeq.end());

        return lisSeq;
    }
};

int main() {
    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};

    Solution sol;
    vector<int> lis = sol.longestIncreasingSubsequence(nums);

    cout << "LIS: ";
    for (int x : lis) cout << x << " ";
    cout << endl;

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n^2)$
    * **Explanation:** The algorithm uses nested loops where the outer loop runs $n$ times and the inner loop runs up to $i$ times. This results in approximately $n(n+1)/2$ operations to compute the `dp` and `prev` arrays.
* **Space Complexity:** $O(n)$
    * **Explanation:** We maintain two primary arrays of size $n$: the `dp` array to store the lengths and the `prev` (or hash) array to store the predecessor indices for reconstruction. The final list used to store the sequence also takes $O(n)$ space.
