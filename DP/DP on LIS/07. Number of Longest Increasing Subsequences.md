## Number of Longest Increasing Subsequences | (DP-47)

**Problem Description:**   
Given an integer array `nums`, find the number of Longest Increasing Subsequences (LIS) in the array.

The Longest Increasing Subsequence (LIS) is the longest subsequence where all elements are in strictly increasing order.

**Prerequisite:** Longest increasing subsequence, Printing Longest Increasing Subsequence

---

>### Examples:

**Input:** `nums = [1, 3, 5, 4, 7]`
**Output:** `2`
**Explanation:** There are two LIS of length 4: `[1, 3, 4, 7]` and `[1, 3, 5, 7]`.

**Input:** `nums = [2, 2, 2, 2, 2]`
**Output:** `5` 
**Explanation:** All elements are the same, so every single element can form an LIS of length 1. There are 5 such subsequences.

---

## Approach

### Algorithm:

1.  **Dual Tracking:** In addition to the standard `dp` array for LIS length, maintain a `ct` (count) array. `dp[i]` stores the length of the LIS ending at index `i`, and `ct[i]` stores the number of such LIS ending at index `i`.
2.  **Initialization:** Set all `dp` and `ct` values to 1 initially.
3.  **Nested Iteration:** For each index `i`, check all `j < i`. If `arr[j] < arr[i]`:
    * If `dp[j] + 1 > dp[i]`: A strictly longer LIS is found. Update `dp[i] = dp[j] + 1` and reset the count `ct[i] = ct[j]`.
    * If `dp[j] + 1 == dp[i]`: Another LIS of the same maximum length is found. Accumulate the count: `ct[i] = ct[i] + ct[j]`.
4.  **Result Aggregation:** Find the global maximum length `maxi` in the `dp` array. Sum up `ct[i]` for all `i` where `dp[i] == maxi`.


### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int findNumberOfLIS(vector<int>& arr) {
        int n = arr.size();
        if (n == 0) return 0;

        vector<int> dp(n, 1);
        vector<int> ct(n, 1);
        int maxi = 1;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[j] < arr[i] && dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                    ct[i] = ct[j];
                }
                else if (arr[j] < arr[i] && dp[j] + 1 == dp[i]) {
                    ct[i] = ct[i] + ct[j];
                }
            }
            maxi = max(maxi, dp[i]);
        }

        int countLIS = 0;
        for (int i = 0; i < n; i++) {
            if (dp[i] == maxi) {
                countLIS += ct[i];
            }
        }

        return countLIS;
    }
};

int main() {
    vector<int> arr = {1, 5, 4, 3, 2, 6, 7, 2};
    Solution sol;
    cout << "The count of Longest Increasing Subsequences (LIS) is "   << sol.findNumberOfLIS(arr) << endl;
    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n^2)$
    * **Explanation:** For each element, we compare it with all previous elements to check if it can extend an increasing subsequence, leading to nested loops.

* **Space Complexity:** $O(n)$
    * **Explanation:** Space used to store the `dp` length array and the `ct` count array, both of which are proportional to the size of the input.
