## Minimum Cost to Cut the Stick | (DP-50)

**Problem Description:**   
We are given a stick of length $N$ and a `cuts` array of size $C$. The stick has markings as shown, and the cuts array depicts the marking at which the stick needs to be cut.
**Note:** It is necessary to make cuts at all the specified markings. Whenever we make a cut, we incur a cost. This cost is equal to the length of the stick on which we are making the cut.
We need to find the **minimum cost** incurred to cut the stick at all the cut points.

---

### Examples:

### Example 1:
* **Input:** `n = 7`, `cuts = [1, 3, 4, 5]`
* **Output:** `16`
* **Explanation:** Rearranging the cuts to be `[3, 5, 1, 4]` for example will lead to a scenario with total cost = 16.

### Example 2:
* **Input:** `n = 7`, `cuts = [1, 3, 6]`
* **Output:** `14`
* **Explanation:** The optimal order for cutting the stick is `[3, 1, 6]`. The cost will be $7 + 3 + 4 = 14$.

---

## Approach - Recursion

### Algorithm:

We need to minimize the cost incurred to cut the stick. Whenever we make a cut, we are changing the length of the stick, which in turn decides the cost. Therefore, the order in which we make the cuts changes the total cost. As discussed in **DP-48**, whenever the order of solving the problem comes into play, we can think in terms of **Partition DP**.

* **Initial Setup:** We are given a stick of size $N$ and the `cuts` array. Every element of the `cuts` array represents the marking at which one cut needs to be made. When we make a cut, we are dividing the stick into two different parts.
* **Sorting:** Before solving, we need to **sort the cuts array**. By sorting, we ensure that for any cut point we choose, the markings for the left portion are on the left side of the array and the markings for the right portion are on the right side.
* **Segment Boundaries:** Consider the stick as a segment defined by two boundaries (start and end positions). If there are no cuts to be made between these boundaries, the cost is zero.
* **Cost Calculation:** For each possible cut, calculate:
    1.  The **cost of cutting the current segment** (current length of the segment).
    2.  The cost of **recursively cutting the left sub-segment** (from start to the current cut).
    3.  The cost of **recursively cutting the right sub-segment** (from the current cut to the end).
* **Optimization:** Sum these costs to get the total cost for that choice of cut. Iterate through all possible cut positions and choose the one that results in the **minimum total cost**.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class to compute the minimum cost to cut a stick
class Solution {
public:
    // Recursive function to find the minimum cost to cut between indices i and j in cuts
    int findMinimumCost(int i, int j, vector<int> &cuts) {
        // Base case: no cuts to consider
        if (i > j) {
            return 0;
        }

        int mini = INT_MAX;

        // Try cutting at every position between i and j
        for (int ind = i; ind <= j; ind++) {
            // Cost of making the current cut plus
            // cost of cutting left and right sub-segments recursively
            int ans = cuts[j + 1] - cuts[i - 1] +
                      findMinimumCost(i, ind - 1, cuts) +
                      findMinimumCost(ind + 1, j, cuts);

            // Update minimum cost
            mini = min(mini, ans);
        }

        return mini;
    }

    // Function to calculate the minimum total cost to cut the stick
    int minimumCost(int n, int c, vector<int> &cuts) {
        // Add the two ends of the stick to the cuts array
        cuts.push_back(n);
        cuts.insert(cuts.begin(), 0);

        // Sort the cuts array
        sort(cuts.begin(), cuts.end());

        // Compute the minimum cost to make all cuts between indices 1 and c
        return findMinimumCost(1, c, cuts);
    }
};

int main() {
    vector<int> cuts = {3, 5, 1, 4};
    int c = cuts.size();
    int n = 7;

    Solution sol;
    cout << "The minimum cost incurred is: " << sol.minimumCost(n, c, cuts) << endl;

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(2^C)$
    * **Explanation:** Where $C$ is the number of cuts. In the worst case, we are exploring all possible permutations of cuts, leading to an exponential number of recursive calls.
* **Space Complexity:** $O(C)$
    * **Explanation:** This represents the maximum depth of the recursion stack, which is proportional to the number of cuts.

---

## Approach - Memoization

### Algorithm:

To optimize our time complexity, we can memoize our solution to prevent repeated computation of overlapping subproblems. 

**Steps to memoize the solution:**

1.  **Create a DP array:** Initialize a 2D array `dp` of size $[c+1][c+1]$, where $c$ is the number of cuts. This is because our pointers $i$ and $j$ can both range from $1$ to $c$.
2.  **Initialize:** Set all elements in the `dp` array to $-1$ to represent uncomputed states.
3.  **Check for existing results:** For any subproblem defined by boundaries $i$ and $j$, first check if `dp[i][j]` is not $-1$. If a value exists, return it immediately.
4.  **Compute and Store:** If the result is not yet computed, calculate it using the recursive logic. Before returning the final minimum cost for that segment, store it in `dp[i][j]`.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class to compute the minimum cost to cut a stick using memoization
class Solution {
public:
    // Recursive function with memoization to find the minimum cost between indices i and j in cuts
    int findMinimumCost(int i, int j, vector<int> &cuts, vector<vector<int>> &dp) {
        // Base case: no cuts to consider
        if (i > j) {
            return 0;
        }

        // Return precomputed result if available
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int mini = INT_MAX;

        // Try cutting at every position between i and j
        for (int ind = i; ind <= j; ind++) {
            // Calculate cost of current cut plus costs of left and right subproblems
            int ans = cuts[j + 1] - cuts[i - 1] +
                      findMinimumCost(i, ind - 1, cuts, dp) +
                      findMinimumCost(ind + 1, j, cuts, dp);

            // Update minimum cost
            mini = min(mini, ans);
        }

        // Store and return the minimum cost found
        return dp[i][j] = mini;
    }

    // Function to calculate the minimum total cost to cut the stick
    int minimumCost(int n, int c, vector<int> &cuts) {
        // Add the two ends of the stick to the cuts array
        cuts.push_back(n);
        cuts.insert(cuts.begin(), 0);

        // Sort the cuts array
        sort(cuts.begin(), cuts.end());

        // Create a DP table initialized with -1
        vector<vector<int>> dp(c + 1, vector<int>(c + 1, -1));

        // Compute minimum cost to make all cuts between indices 1 and c
        return findMinimumCost(1, c, cuts, dp);
    }
};

int main() {
    vector<int> cuts = {3, 5, 1, 4};
    int c = cuts.size();
    int n = 7;

    Solution sol;
    cout << "The minimum cost incurred is: " << sol.minimumCost(n, c, cuts) << endl;

    return 0;
}
```

### Complexity Analysis:

* **Time Complexity:** $O(c^3)$
    * **Explanation:** There are approximately $c^2$ states in our DP table. For each state, we iterate through the possible cuts in that segment, which takes $O(c)$ time.
* **Space Complexity:** $O(c^2) + O(c)$
    * **Explanation:** $O(c^2)$ is for the 2D DP table and $O(c)$ is the auxiliary recursion stack space.

---

## Approach - Tabulation

### Algorithm:

To optimize the solution further and eliminate the auxiliary space used by the recursion stack, we convert the memoized approach into a bottom-up (tabulation) approach.

**Steps to convert to tabulation:**

1.  **Handle Base Cases:** If $i > j$, the cost is 0. By initializing the entire `dp` array with 0, we handle this base case automatically.
2.  **Define Loop Directions:** In memoization (top-down), we start from the full range. In tabulation (bottom-up), we solve smaller segments first. To achieve this, the pointer $i$ moves backward from $c$ to 1, while $j$ moves forward from $i$ to $c$.
3.  **Implement Logic:** Nest a third loop to iterate through all possible cut indices (`ind`) between $i$ and $j$. The cost for a segment is the length of the current stick portion ($cuts[j+1] - cuts[i-1]$) plus the costs of the resulting subproblems stored in the `dp` table.


### C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class to compute minimum cost to cut a stick using tabulation (bottom-up DP)
class Solution {
public:
    // Function to calculate the minimum total cost to cut the stick using tabulation
    int minimumCost(int n, int c, vector<int> &cuts) {
        // Add the two ends of the stick to the cuts array
        cuts.push_back(n);
        cuts.insert(cuts.begin(), 0);

        // Sort the cuts array to ensure subproblems are independent
        sort(cuts.begin(), cuts.end());

        // Create a DP table initialized with 0
        vector<vector<int>> dp(c + 2, vector<int>(c + 2, 0));

        // Fill the DP table for all possible segments
        // i traverses backward from c to 1
        for (int i = c; i >= 1; i--) {
            // j traverses forward from i to c
            for (int j = i; j <= c; j++) {
                int mini = INT_MAX;

                // Try making a cut at every position between i and j
                for (int ind = i; ind <= j; ind++) {
                    // Cost = current segment length + left subproblem + right subproblem
                    int ans = cuts[j + 1] - cuts[i - 1] + dp[i][ind - 1] + dp[ind + 1][j];

                    // Update minimum cost
                    mini = min(mini, ans);
                }

                // Store the minimum cost in DP table
                dp[i][j] = mini;
            }
        }

        // The answer is the minimum cost to cut between indices 1 and c
        return dp[1][c];
    }
};

int main() {
    vector<int> cuts = {3, 5, 1, 4};
    int c = cuts.size();
    int n = 7;

    Solution sol;
    cout << "The minimum cost incurred is: " << sol.minimumCost(n, c, cuts) << endl;

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(c^3)$
    * **Explanation:** There are approximately $c^2$ states in our DP table. For each state $(i, j)$, we iterate through all possible cut positions (`ind`) between $i$ and $j$, which takes $O(c)$ time. This results in an overall cubic time complexity.
* **Space Complexity:** $O(c^2)$
    * **Explanation:** This is due to the additional space used for the 2D `dp` array of size $(c+2) \times (c+2)$ to store the minimum cost for every possible sub-segment of the stick.
