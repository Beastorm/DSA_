## Partition Array for Maximum Sum | Front Partition : DP 54

**Problem Description:**   
Given an integer array `arr` and an integer `k`, partition the array into contiguous subarrays of length at most `k`. After partitioning, each element in a subarray is replaced by the maximum element of that subarray. Return the **maximum possible sum** of the resulting array.

---

>### Examples:

### Example 1:
* **Input:** `arr = [1, 15, 7, 9, 2, 5, 10]`, `k = 3`
* **Output:** `84`
* **Explanation:** * Partition: `[1, 15, 7 | 9 | 2, 5, 10]`
    * Max values: `[15, 15, 15 | 9 | 10, 10, 10]`
    * Sum: $(15 \times 3) + (9 \times 1) + (10 \times 3) = 45 + 9 + 30 = 84$.

---

### Example 2:
* **Input:** `arr = [2, 2, 2, 2]`, `k = 2`
* **Output:** `8`
* **Explanation:** Partition as `[2, 2 | 2, 2]`. Each subarray's max is 2. Total sum = $2+2+2+2 = 8$.

---

## Better Approach (Memoization)

### Algorithm:

The core logic remains focused on the **Front Partition** technique. We explore all possible ways to cut the array into subarrays of length $1$ to $k$, starting from the current index. 

**Steps to memoize the solution:**

1.  **Initialize DP Table:** Create a 1D `dp` array of size `n` initialized to `-1` to store the maximum sum for each starting index.
2.  **Recursive Function:** Define a function `f(ind)` that calculates the maximum sum starting from index `ind`.
3.  **Base Case:** If `ind == n`, return 0 (no more elements to sum).
4.  **Explore Choices:** * Iterate through a range of partition lengths from $1$ to $k$. Let this loop be `j` from `ind` to `min(ind + k - 1, n - 1)`.
    * Track the `maxElement` within the current partition `[ind...j]`.
5.  **Calculate and Cache:** * The total sum for a choice is: `(length * maxElement) + f(j + 1)`.
    * Update the `dp[ind]` with the maximum of these values.
    * Return the cached value if the state has been visited before.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Recursive helper function to find max sum from 'start' index
    int helper(const vector<int>& arr, int k, int start, vector<int>& memo) {
        int n = (int)arr.size();

        // Base case: if start reached end, no elements left to partition
        if (start == n) return 0;

        // Return cached result if already computed for this start index
        if (memo[start] != -1) return memo[start];

        int maxSum = 0;    
        int maxElem = 0;   

        // Try partitions of length 1 to k starting at 'start'
        for (int length = 1; length <= k && start + length <= n; length++) {
            // Update max element for this partition length
            maxElem = max(maxElem, arr[start + length - 1]);

            // Calculate current sum: maxElem * length + recursive result for remaining array
            int currentSum = maxElem * length + helper(arr, k, start + length, memo);

            // Update maxSum if current partition leads to a higher sum
            maxSum = max(maxSum, currentSum);
        }

        // Memoize and return the best max sum for this start index
        return memo[start] = maxSum;
    }

public:
    // Public function to initiate recursive memoization
    int maxSumAfterPartitioning(vector<int>& arr, int k) {
        int n = (int)arr.size();

        // Initialize memo array with -1 to indicate unvisited states
        vector<int> memo(n, -1);

        // Start recursion from index 0
        return helper(arr, k, 0, memo);
    }
};

int main() {
    vector<int> arr = {1, 15, 7, 9, 2, 5, 10};
    int k = 3;

    Solution sol;
    cout << "Maximum sum after partitioning: " << sol.maxSumAfterPartitioning(arr, k) << "\n";

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(k^N)$
    * **Explanation:** At each index, we have $k$ choices (partition lengths). In the worst case, this leads to an exponential number of recursive calls.
* **Space Complexity:** $O(N)$
    * **Explanation:** The maximum depth of the recursion stack is $N$.

---

## Optimal Approach (Tabulation)

### Algorithm:

To optimize the solution by removing the $O(N)$ auxiliary recursion stack space, we convert the memoized logic into a bottom-up **Tabulation** approach.

1.  **Identify State:** The changing parameter is the `start index (i)`, which ranges from $0$ to $n$.
2.  **Initialize DP Table:** Create a 1D `dp` array of size $(n+1)$.
    * **Base Case:** Initialize `dp[n] = 0`, as no sum can be formed from an empty subarray at the end of the array.
3.  **Iterative Direction:** In memoization, we moved from $0$ to $n$. In tabulation, we iterate in the opposite direction, from **$n-1$ down to $0$**.
4.  **Partitioning Logic:** * For each index `i`, we try to form a subarray starting at `i` with length `len` ranging from $1$ to $k$.
    * Maintain a `maxElement` variable for the current subarray `arr[i...j]`.
    * The relation is: `dp[i] = max(dp[i], (len * maxElement) + dp[i + len])`.
5.  **Final Result:** The maximum sum for the entire array will be stored at `dp[0]`.


### Code (C++):
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the maximum sum after partitioning
    int maxSumAfterPartitioning(vector<int>& arr, int k) {
        int n = (int)arr.size();

        // DP array to store max sum from index i to end
        vector<int> dp(n + 1, 0); 

        // Iterate from right to left over the array
        for (int i = n - 1; i >= 0; i--) {
            int maxElem = 0;
            int maxSum = 0;

            // Check all partitions of length 1 to k starting at i
            for (int length = 1; length <= k && i + length <= n; length++) {
                // Update maximum element for current partition
                maxElem = max(maxElem, arr[i + length - 1]);

                // Calculate sum if partition ends here
                int currentSum = maxElem * length + dp[i + length];

                // Update maxSum if currentSum is greater
                maxSum = max(maxSum, currentSum);
            }

            // Store maximum sum for subarray starting at i
            dp[i] = maxSum;
        }

        // Return max sum achievable starting at index 0
        return dp[0];
    }
};

int main() {
    vector<int> arr = {1, 15, 7, 9, 2, 5, 10};
    int k = 3;

    Solution sol;
    cout << "Maximum sum after partitioning: " << sol.maxSumAfterPartitioning(arr, k) << "\n";

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(N \times k)$
    * **Explanation:** The algorithm uses an outer loop that iterates through each index of the array ($N$ times) and an inner loop that explores partition lengths up to $k$. For each of the $N$ states, we do a constant amount of work within the $k$-length loop, resulting in a total time complexity of $O(N \times k)$.
* **Space Complexity:** $O(N)$
    * **Explanation:** We utilize a 1D `dp` array of size $n+1$ to store the maximum sums for each starting index. By switching from recursion to tabulation, we have eliminated the $O(N)$ auxiliary recursion stack space, though the overall space remains linear.
