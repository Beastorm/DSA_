## Burst Balloons | Partition DP | DP 51

**Problem Statement:**   
You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array. You are asked to burst all the balloons.

If you burst the $i^{th}$ balloon, you will get $arr[i - 1] \times arr[i] \times arr[i + 1]$ coins. If $i - 1$ or $i + 1$ goes out of the array's bounds, then treat it as if there is a balloon with a 1 painted on it. Return the **maximum coins** you can collect by bursting the balloons wisely.

---

>### Examples:

### Example 1:
* **Input:** `N = 4`, `array[] = {3, 1, 5, 8}`
* **Output:** `167`
* **Explanation:** 1. Burst `1`: $3 \times 1 \times 5 = 15$ coins. Remaining: `{3, 5, 8}`
    2. Burst `5`: $3 \times 5 \times 8 = 120$ coins. Remaining: `{3, 8}`
    3. Burst `3`: $1 \times 3 \times 8 = 24$ coins. Remaining: `{8}`
    4. Burst `8`: $1 \times 8 \times 1 = 8$ coins. 
    * **Total:** $15 + 120 + 24 + 8 = 167$.

### Example 2:
* **Input:** `N = 2`, `array[] = {1, 5}`
* **Output:** `10`

---

## Recursive Approach

### Algorithm:

The order of bursting affects the total, and multiple sequences exist. To solve this using Partition DP, we must ensure subproblems are independent.

* **Reverse Thinking:** Instead of picking which balloon to burst **first**, pick which balloon to burst **last** in the current range $[i, j]$.
* **Independence:** If a balloon at index `k` is burst last in the range $[i, j]$, then the balloons at $i-1$ and $j+1$ are its immediate neighbors because all other balloons between $i$ and $j$ have already been burst.
* **Partitioning:** Choosing the last balloon `k` splits the problem into two independent subproblems:
    1. Maximum coins from range $[i, k-1]$.
    2. Maximum coins from range $[k+1, j]$.
* **Cost Calculation:** The coins gained from bursting balloon `k` last is calculated as:
    * $\text{coins} = (arr[i-1] \times arr[k] \times arr[j+1]) + f(i, k-1) + f(k+1, j)$.
* **Initial Setup:** Add a `1` at the beginning and the end of the array to handle boundary conditions easily.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;
class Solution{
// Recursive function to calculate the maximum coins obtained
int maxCoinsHelper(int i, int j, vector<int> &nums) {
    if (i > j) return 0;
    int maxCoins = INT_MIN;
    
    // Iterate through each possible balloon to burst last
    for (int k = i; k <= j; k++) {
        // Calculate the coins obtained by bursting the k-th balloon last
        int coins = nums[i - 1] * nums[k] * nums[j + 1];
        
        // Recursively calculate the maximum coins for the remaining balloons
        int remainingCoins = maxCoinsHelper(i, k - 1, nums) + maxCoinsHelper(k + 1, j, nums);
        
        // Update the maximum coins
        maxCoins = max(maxCoins, coins + remainingCoins);
    }
    
    return maxCoins;
}

// Function to calculate the maximum coins obtained
int maxCoins(vector<int> &nums) {
    int n = nums.size();
    
    // Add 1 to the beginning and end of the nums array
    nums.insert(nums.begin(), 1);
    nums.push_back(1);
    
    // Call the helper function to compute the maximum coins
    return maxCoinsHelper(1, n, nums);
}

int main() {
    vector<int> nums = {3, 1, 5, 8};
    int maxCoinsResult = maxCoins(nums);
    cout << "Maximum coins obtained: " << maxCoinsResult << "\n";
    
    return 0;
}
```

### Complexity Analysis

* **Time Complexity:** $O(2^n)$
    * **Explanation:** In a raw recursive approach, we try every possible balloon as the "last" one for every possible range, leading to exponential growth in the number of function calls.
* **Space Complexity:** $O(n)$
    * **Explanation:** This represents the maximum depth of the recursion stack, which is equal to the number of balloons.

---

## Memoization Approach

### Algorithm:

To optimize the recursive solution and handle the overlapping subproblems, we use a 2D array to cache results.

1.  **Initialize DP Table:** Create a 2D array `dp` of size $(n+2) \times (n+2)$, where $n$ is the number of balloons. We use $n+2$ to account for the added boundary balloons (the `1`s) at the start and end of the array.
2.  **State Definition:** `dp[i][j]` represents the maximum coins that can be collected by bursting all balloons in the range $[i, j]$.
3.  **Default Values:** Initialize all values in the `dp` table to `-1` to represent uncomputed states.
4.  **Check Before Compute:** Before solving for a range $[i, j]$, check if `dp[i][j]` is not `-1`. If it has a value, return it immediately.
5.  **Store After Compute:** If the result isn't cached, calculate it by iterating through all possible "last" balloons `k` in the range. Once the maximum value for the range is found, store it in `dp[i][j]` before returning.

### C++ Code:
``` cpp

#include <bits/stdc++.h>
using namespace std;
class Solution{
// Recursive function to calculate the maximum coins obtained
int maxCoinsHelper(int i, int j, vector<int> &nums, vector<vector<int>> &dp) {
    if (i > j) return 0;
    if (dp[i][j] != -1) return dp[i][j];
    int maxCoins = INT_MIN;
    
    // Iterate through each possible balloon to burst last
    for (int k = i; k <= j; k++) {
        // Calculate the coins obtained by bursting the k-th balloon last
        int coins = nums[i - 1] * nums[k] * nums[j + 1];
        
        // Recursively calculate the maximum coins for the remaining balloons
        int remainingCoins = maxCoinsHelper(i, k - 1, nums, dp) + maxCoinsHelper(k + 1, j, nums, dp);
        
        // Update the maximum coins
        maxCoins = max(maxCoins, coins + remainingCoins);
    }
    
    return dp[i][j] = maxCoins;
}

// Function to calculate the maximum coins obtained
int maxCoins(vector<int> &nums) {
    int n = nums.size();
    
    // Add 1 to the beginning and end of the nums array
    nums.insert(nums.begin(), 1);
    nums.push_back(1);
    
    // Create a DP array for memoization
    vector<vector<int>> dp(n + 2, vector<int>(n + 2, -1));
    
    // Call the helper function to compute the maximum coins
    return maxCoinsHelper(1, n, nums, dp);
}
```

### Complexity Analysis:

* **Time Complexity:** $O(n^3)$
    * **Explanation:** There are approximately $n^2$ unique states (ranges $[i, j]$) in the DP table. For each state, we iterate through the range to pick the "last" balloon, which takes $O(n)$ time.
* **Space Complexity:** $O(n^2) + O(n)$
    * **Explanation:** $O(n^2)$ space is required for the 2D DP table. $O(n)$ space is used by the auxiliary recursion stack.

---

## Tabulation Approach

### Algorithm:

1.  **Base Case Initialization:** Handle the scenario where the starting index crosses the ending index ($i > j$). In this case, no balloons can be burst, so the result is zero. By initializing the entire `dp` table with zeros, we handle this base case automatically.
2.  **Iterative Strategy (Bottom-Up):** To ensure smaller sub-problems are solved before larger ones, we move through the solution table using specific loop directions. The starting pointer $i$ moves from the end of the array towards the beginning, while the ending pointer $j$ moves from $i$ towards the end.
3.  **Core Decision Logic:** Reuse the partition DP logic within the nested loops. For every range $[i, j]$, iterate through each balloon $k$ as the potential **last** balloon to be burst. Calculate the coins collected and store the maximum in `dp[i][j]`.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;
class Solution{
// Function to calculate the maximum coins obtained
int maxCoins(vector<int> &nums) {
    int n = nums.size();
    
    // Add 1 to the beginning and end of the nums array
    nums.insert(nums.begin(), 1);
    nums.push_back(1);
    
    // Create a DP array for memoization
    vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));

    for (int i = n; i >= 1; i--) {
        for (int j = 1; j <= n; j++) {
            if (i > j) continue;
            int maxi = INT_MIN;
            
            // Iterate through each possible balloon to burst last
            for (int ind = i; ind <= j; ind++) {
                // Calculate the coins obtained by bursting the ind-th balloon last
                int coins = nums[i - 1] * nums[ind] * nums[j + 1];
                
                // Calculate the maximum coins for the remaining balloons
                int remainingCoins = dp[i][ind - 1] + dp[ind + 1][j];
                
                // Update the maximum coins
                maxi = max(maxi, coins + remainingCoins);
            }
            
            dp[i][j] = maxi;
        }
    }
    
    return dp[1][n];
}

int main() {
    vector<int> nums = {3, 1, 5, 8};
    int maxCoinsResult = maxCoins(nums);
    cout << "Maximum coins obtained: " << maxCoinsResult << "\n";
    
    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n^3)$
    * **Explanation:** There are a total of $O(n^2)$ states in the DP table (representing all possible ranges $[i, j]$). For each state, we run a partitioning loop that iterates roughly $n$ times to find the optimal last balloon. This results in a cubic time complexity.

* **Space Complexity:** $O(n^2)$
    * **Explanation:** We use a 2D `dp` array of size $(n+2) \times (n+2)$ to store the maximum coins for every sub-range. This eliminates the recursion stack used in the memoization approach.
