## Approach

### Algorithm:

* **Define a 2D array** `dp` where `dp[i][j]` represents the minimum cost of multiplying the chain of matrices from index $i$ to index $j$.
* **Initialize the diagonal elements** of the `dp` array to 0, as a single matrix requires no multiplication.
* **Iterate over the length** of the chain, starting from 2 up to the length of the matrix array.
* **Iterate over the possible starting indices** of the chain for each length.
* **Calculate the ending index** based on the current chain length.
* **Iterate over all possible split points** for each pair of starting and ending indices.
* **Calculate the cost** of multiplying the matrices at the current split point, which includes the cost of multiplying the left sub-chain, the right sub-chain, and the cost of multiplying the resulting two matrices.
* **Update the `dp` array** with the minimum cost found for each pair of starting and ending indices.
* The result is stored in `dp[1][n-1]`, representing the minimum cost of multiplying the entire chain of matrices.


### C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int matrixMultiplication(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n, vector<int>(n, INT_MAX));

        // A single matrix needs no multiplication cost
        for (int i = 1; i < n; ++i) {
            dp[i][i] = 0;
        }

        // Filling the dp array
        for (int length = 2; length < n; ++length) { // length of the chain
            for (int i = 1; i <= n - length; ++i) {
                int j = i + length - 1;
                for (int k = i; k < j; ++k) {
                    int cost = dp[i][k] + dp[k + 1][j] + nums[i - 1] * nums[k] * nums[j];
                    if (cost < dp[i][j]) {
                        dp[i][j] = cost;
                    }
                }
            }
        }

        // The result is in dp[1][n-1]
        return dp[1][n - 1];
    }
};

int main() {
    Solution sol;
    vector<int> nums = {10, 15, 20, 25};
    // Output should be 8000
    cout << sol.matrixMultiplication(nums) << endl; 
    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n^3)$
    * **Explanation:** Where $n$ is the number of matrices. This is because we use three nested loops: one for the chain length, one for the starting index, and one for the partition split point.

* **Space Complexity:** $O(n^2)$
    * **Explanation:** This is due to the 2D DP table used to store the minimum multiplication costs for all subproblems from index $i$ to $j$.
