## Evaluate Boolean Expression to True | Partition DP: DP 52

**Problem Statement:**   
Given an expression $A$ with operands (`T`, `F`) and operators (`|`, `&`, `^`), find the number of ways to parenthesize the expression so it evaluates to **True**.

Return the result modulo $10^9 + 7$.

---

>### Examples:

### Example 1:
* **Input:** `expression = "T|T&F"`
* **Output:** `1`
* **Explanation:** Only `(T) | (T & F)` results in True.

### Example 2:
* **Input:** `expression = "F|T^F"`
* **Output:** `2`
* **Explanation:** 1. `(F | T) ^ F` = `T ^ F` = `True`
    2. `F | (T ^ F)` = `F | T` = `True`

---

## Brute Force Approach

### Algorithm:

This problem follows the **Partition DP** pattern because the total number of ways depends on where we place the "last" operator to be evaluated.

1.  **Function Definition:** Define `f(i, j, isTrue)` as the number of ways to evaluate the expression from index $i$ to $j$ to get the result `isTrue`.
2.  **Base Cases:**
    * **If $i > j$:** Return 0.
    * **If $i == j$:** * If `isTrue == 1`, return 1 if `exp[i] == 'T'`, else 0.
        * If `isTrue == 0`, return 1 if `exp[i] == 'F'`, else 0.
3.  **Recursive Step:**
    * Iterate through all operators between $i$ and $j$ using a pointer `k` (indices $i+1, i+3, \dots, j-1$).
    * For each operator at `k`, calculate the following four values recursively:
        * `lT`: Ways to make left side **True**
        * `lF`: Ways to make left side **False**
        * `rT`: Ways to make right side **True**
        * `rF`: Ways to make right side **False**
4.  **Combining Results:**
    * **AND (&):** * To get **True**: `lT * rT`
        * To get **False**: `(lT*rF) + (lF*rT) + (lF*rF)`
    * **OR (|):** * To get **True**: `(lT*rT) + (lT*rF) + (lF*rT)`
        * To get **False**: `lF * rF`
    * **XOR (^):** * To get **True**: `(lT*rF) + (lF*rT)`
        * To get **False**: `(lT*rT) + (lF*rF)`

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
const int mod = 1000000007;

// Function to evaluate the number of ways to parenthesize the expression to get True or False
int f(int i, int j, int isTrue, string &exp) {
    // Base case 1: If i > j, it's an invalid expression, return 0.
    if (i > j) return 0;
    
    // Base case 2: If i and j are the same, evaluate the single character.
    if (i == j) {
        if (isTrue == 1) return exp[i] == 'T' ? 1 : 0;
        else return exp[i] == 'F' ? 1 : 0;
    }
    
    ll ways = 0;
    
    // Iterate through the expression to divide it into left and right subexpressions
    for (int ind = i + 1; ind <= j - 1; ind += 2) {
        // Recursively calculate the number of ways to make the left and right subexpressions true or false
        ll lT = f(i, ind - 1, 1, exp);  // Number of ways to make the left expression true.
        ll lF = f(i, ind - 1, 0, exp);  // Number of ways to make the left expression false.
        ll rT = f(ind + 1, j, 1, exp);  // Number of ways to make the right expression true.
        ll rF = f(ind + 1, j, 0, exp);  // Number of ways to make the right expression false.

        // Check the operator at the current index and update ways accordingly.
        if (exp[ind] == '&') {  // AND operator
            if (isTrue) ways = (ways + (lT * rT) % mod) % mod;
            else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;
        }
        else if (exp[ind] == '|') {  // OR operator
            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;
            else ways = (ways + (lF * rF) % mod) % mod;
        }
        else {  // XOR operator
            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;
            else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;
        }
    }
    return ways;  // Return the total number of ways to evaluate the expression
}

// Function to start evaluating the expression
int evaluateExp(string &exp) {
    int n = exp.size();
    return f(0, n - 1, 1, exp);  // Start evaluation with isTrue set to true.
}

int main() {
    // Example expression
    string exp = "F|T^F";
    
    // Evaluate the expression and find the number of ways to get the result as True
    int ways = evaluateExp(exp);
    
    // Output the result
    cout << "The total number of ways: " << ways << "\n";

    return 0;
}
```

### Complexity Analysis:

* **Time Complexity:** $O(3^N)$ 
    * **Explanation:** Without memoization, each subproblem splits into four recursive calls, leading to exponential growth.
* **Space Complexity:** $O(N)$
    * **Explanation:** This is the depth of the recursion stack.

---

## Better Approach (Memoization)

### Algorithm:

**Steps to memoize the recursive solution:**

1.  **Initialize DP Table:** Create a **3D DP array** of size `[n][n][2]`. The dimensions represent the starting index `i`, the ending index `j`, and the target boolean result `isTrue` (1 for True, 0 for False).
2.  **Set Default Values:** Initialize all states in the `dp` array to `-1`. This indicates that the sub-expression within range `[i, j]` for that specific boolean outcome has not been computed yet.
3.  **Check for Cached Results:** Before performing any recursive logic for a range, check if `dp[i][j][isTrue]` is not `-1`. If a value exists, return it immediately to avoid redundant calculations.
4.  **Compute and Store:** If the state is being visited for the first time, compute the result by iterating through all possible operators (partition points) between `i` and `j`. Once the total count is calculated, store it in `dp[i][j][isTrue]` before returning.


### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
const int mod = 1000000007;

// Function to evaluate the number of ways to parenthesize the expression
int f(int i, int j, int isTrue, string &exp, vector<vector<vector<ll>>> &dp) {
    // Base case 1: Invalid range
    if (i > j) return 0;
    
    // Base case 2: Single character (operand)
    if (i == j) {
        if (isTrue == 1) return exp[i] == 'T' ? 1 : 0;
        else return exp[i] == 'F' ? 1 : 0;
    }

    // Return cached result if available
    if (dp[i][j][isTrue] != -1) return dp[i][j][isTrue];
    
    ll ways = 0;
    
    // Iterate through operators at indices i+1, i+3, ..., j-1
    for (int ind = i + 1; ind <= j - 1; ind += 2) {
        // Recursive calls for left and right sub-parts
        ll lT = f(i, ind - 1, 1, exp, dp);
        ll lF = f(i, ind - 1, 0, exp, dp);
        ll rT = f(ind + 1, j, 1, exp, dp);
        ll rF = f(ind + 1, j, 0, exp, dp);

        // Logic for different Boolean operators
        if (exp[ind] == '&') {
            if (isTrue) ways = (ways + (lT * rT) % mod) % mod;
            else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;
        }
        else if (exp[ind] == '|') {
            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;
            else ways = (ways + (lF * rF) % mod) % mod;
        }
        else { // XOR operator (^)
            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;
            else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;
        }
    }
    
    return dp[i][j][isTrue] = ways;
}

int evaluateExp(string &exp) {
    int n = exp.size();
    // 3D DP table initialization: [n][n][2]
    vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(n, vector<ll>(2, -1)));
    return f(0, n - 1, 1, exp, dp);
}

int main() {
    string exp = "F|T^F";
    int ways = evaluateExp(exp);
    cout << "The total number of ways: " << ways << "\n";
    return 0;
}
```
### Complexity Analysis:
* **Time Complexity:** $O(N^3)$
    * **Explanation:** There are a total of $2 \times N^2$ states in the 3D DP table (for each $i$, $j$, and the boolean `isTrue`). For each state, we iterate through the partition points (operators) to split the expression, which takes $O(N)$ time.
* **Space Complexity:** $O(N^2)$
    * **Explanation:** The DP table requires $O(2 \times N^2)$ space to store the results of all subproblems. Additionally, the recursion stack can go up to $O(N)$ depth in the worst case.

---

### Optimal Approach (Tabulation)

### Algorithm:

**Steps to convert the memoized solution to a bottom-up approach:**

1.  **Base Case Initialization:** In the recursive solution, if $i > j$, we return 0. To handle this in tabulation, we initialize the entire 3D `dp` array of size `[n][n][2]` with 0.
2.  **Order of Iteration:** Since tabulation is a bottom-up approach, we must solve smaller subproblems before larger ones. 
    * The parameter `i` (starting index) will change from $n-1$ down to 0.
    * The parameter `j` (ending index) will change from 0 up to $n-1$.
    * The `isTrue` parameter will iterate from 0 to 1.
3.  **Recursive Logic Migration:** Copy the core recursive logic (iterating through partition points and combining results based on operators) inside the nested loops. Ensure that the results are pulled from the `dp` table rather than making recursive calls.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
const int mod = 1000000007;

// Function to evaluate the number of ways to parenthesize the expression to get True or False
int evaluateExp(string &exp) {
    int n = exp.size();
    
    // DP table to store the number of ways to evaluate the expression from i to j with isTrue (0 or 1)
    vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(n, vector<ll>(2, 0)));

    // Iterate through the string from right to left for bottom-up DP
    for (int i = n - 1; i >= 0; i--) {
        for (int j = 0; j <= n - 1; j++) {
            // Base case 1: If i > j, it's an invalid expression, so continue.
            if (i > j) continue;

            // Iterate through the possible values of isTrue (either 1 or 0)
            for (int isTrue = 0; isTrue <= 1; isTrue++) {
                // Base case 2: If i == j, evaluate the single character.
                if (i == j) {
                    if (isTrue == 1) dp[i][j][isTrue] = exp[i] == 'T';
                    else dp[i][j][isTrue] = exp[i] == 'F';
                    continue;
                }

                // Recurrence logic for other subexpressions
                ll ways = 0;
                for (int ind = i + 1; ind <= j - 1; ind += 2) {
                    // Number of ways to make the left and right subexpressions true or false
                    ll lT = dp[i][ind - 1][1];
                    ll lF = dp[i][ind - 1][0];
                    ll rT = dp[ind + 1][j][1];
                    ll rF = dp[ind + 1][j][0];

                    // Perform the operation based on the operator at the current index
                    if (exp[ind] == '&') {  // AND operator
                        if (isTrue) ways = (ways + (lT * rT) % mod) % mod;
                        else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;
                    }
                    else if (exp[ind] == '|') {  // OR operator
                        if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;
                        else ways = (ways + (lF * rF) % mod) % mod;
                    }
                    else {  // XOR operator
                        if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;
                        else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;
                    }
                }
                dp[i][j][isTrue] = ways;  // Store the result in the DP table
            }
        }
    }
    return dp[0][n - 1][1];  // Return the number of ways to evaluate the entire expression as true
}

int main() {
    string exp = "F|T^F";  // Example expression
    
    // Evaluate the expression and find the number of ways to get the result as True
    int ways = evaluateExp(exp);
    
    // Output the result
    cout << "The total number of ways: " << ways << "\n";

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(N^3)$
    * **Explanation:** There are a total of $2 \times N^2$ states in the DP table (one for each possible range $[i, j]$ and each boolean result, True or False). For each of these states, we execute a partitioning loop that runs approximately $N$ times, leading to an overall cubic time complexity.

* **Space Complexity:** $O(N^2)$
    * **Explanation:** We use a 3D DP array of size $N \times N \times 2$ to store the number of ways for each sub-expression. Since the boolean dimension is a constant (2), the space complexity is $O(N^2)$.
    
