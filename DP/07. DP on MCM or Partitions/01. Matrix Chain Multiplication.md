## Matrix Chain Multiplication | (DP-48)

**Problem Statement:**    
Given a chain of matrices $A_1, ..., A_n$ denoted by an array of size $n+1$, find the minimum number of operations to multiply these $n$ matrices.

---

>### Examples:

### Example 1:
**Input:** `arr = [40, 20, 30, 10, 30]`
**Output:** `26000`
**Explanation:** The best parenthesization is $((A_1 \times (A_2 \times A_3)) \times A_4)$.

### Example 2:
**Input:** `arr = [10, 20, 30, 40, 30]`
**Output:** `30000`
**Explanation:** Optimal parenthesization minimizes the total multiplication cost.

---

## Recursive Approach

### Algorithm:
**Pattern Identification:**
Whenever we need to find the answer to a large problem such that the problem can be broken into subproblems and the final answer varies due to the **order** in which the subproblems are solved, we can think in terms of **Partition DP**.

**Rules of Matrix Multiplication:**
1.  Two matrices $A_1$ and $A_2$ of dimensions $[p \times q]$ and $[r \times s]$ can only be multiplied if $q = r$.
2.  The total number of multiplications required to multiply $A_1$ and $A_2$ is: $p \times q \times s$.



**Rules to solve the problem of Partition DP:**
1.  **Start with the full array:** Represent the matrices with indexes $i$ and $j$. We need to find the minimum cost to multiply matrices from $i$ to $j$ ($f(i, j)$).
2.  **Check the base case:** If $i == j$, there is only one matrix, so return 0 (no multiplication needed).
3.  **Try all possible partitions:** For $k$ from $i$ to $j-1$, split the range into two parts: $f(i, k)$ and $f(k+1, j)$.
4.  **Calculate cost for each partition:** Add the cost of the two subproblems plus the cost of multiplying their resulting matrices: 
    * $\text{Cost} = f(i, k) + f(k+1, j) + (\text{arr}[i-1] \times \text{arr}[k] \times \text{arr}[j])$.
5.  **Choose the minimum:** Keep track of the minimum cost among all possible values of $k$.
6.  **Return the result:** After checking all partitions, return the minimum cost for the range $[i, j]$.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the minimum multiplication cost
    int matrixChainOrder(vector<int>& arr, int i, int j) {
        // Base case: if only one matrix is present, no multiplication needed
        if (i == j) return 0;

        // Initialize minimum cost as very large
        int minCost = INT_MAX;

        // Try all possible partitions
        for (int k = i; k < j; k++) {
            // Cost of multiplying matrices from i to k
            int cost1 = matrixChainOrder(arr, i, k);

            // Cost of multiplying matrices from k+1 to j
            int cost2 = matrixChainOrder(arr, k + 1, j);

            // Cost of multiplying the two resulting matrices
            int costMultiply = arr[i - 1] * arr[k] * arr[j];

            // Total cost for this partition
            int total = cost1 + cost2 + costMultiply;

            // Update minimum
            minCost = min(minCost, total);
        }

        return minCost;
    }
};

// Driver code
int main() {
    Solution sol;
    vector<int> arr = {40, 20, 30, 10, 30}; 
    int n = arr.size();

    cout << "Minimum number of multiplications is: "
         << sol.matrixChainOrder(arr, 1, n - 1) << endl;

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(2^n)$
    * **Explanation:** This is because we try every possible parenthesization, which leads to exponential recursion.
* **Space Complexity:** $O(n)$
    * **Explanation:** This comes from the recursion call stack depth in the worst case, which is proportional to the number of matrices.

---

## Memoization Approach

### Algorithm:

**Steps to memoize a recursive solution:**

As there are overlapping subproblems in the recursive tree, we can memoize the recursive code to reduce the time complexity.

1.  **Create a DP array:** Initialize a 2D array `dp` of size $[n][n]$. Since the parameters $i$ and $j$ can range from $1$ to $n-1$, an $n \times n$ size is sufficient.
2.  **Initialize:** Set all values in the `dp` array to $-1$.
3.  **Check for existing results:** Whenever the function is called with parameters $(i, j)$, first check if `dp[i][j] != -1`. If true, simply return the stored value.
4.  **Compute and Store:** If the result is not in the array, compute it using the recursive relation. Before returning the result, store it in `dp[i][j]` to avoid redundant calculations in the future.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Recursive function with memoization
    int solve(vector<int>& arr, int i, int j, vector<vector<int>>& dp) {
        // Base case: only one matrix, no multiplication
        if (i == j) return 0;

        // If already computed, return from dp
        if (dp[i][j] != -1) return dp[i][j];

        // Initialize min cost as very large
        int minCost = INT_MAX;

        // Try every partition
        for (int k = i; k < j; k++) {
            int cost1 = solve(arr, i, k, dp);
            int cost2 = solve(arr, k + 1, j, dp);
            int costMultiply = arr[i - 1] * arr[k] * arr[j];

            int total = cost1 + cost2 + costMultiply;

            minCost = min(minCost, total);
        }

        // Store and return result
        return dp[i][j] = minCost;
    }

    // Function to start the memoization approach
    int matrixChainOrder(vector<int>& arr) {
        int n = arr.size();
        vector<vector<int>> dp(n, vector<int>(n, -1));
        return solve(arr, 1, n - 1, dp);
    }
};

// Driver code
int main() {
    Solution sol;
    vector<int> arr = {40, 20, 30, 10, 30};
    cout << "Minimum number of multiplications is: "
         << sol.matrixChainOrder(arr) << endl;
    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(n^3)$
    * **Explanation:** There are $n^2$ states in the DP table, and for each state, we run a loop that takes $O(n)$ time.
* **Space Complexity:** $O(n^2) + O(n)$
    * **Explanation:** $O(n^2)$ is for the 2D DP table and $O(n)$ is for the auxiliary recursion stack space.

---

## Tabulation Approach:

### Algorithm:

**Steps to convert the recursive solution to tabulation:**

1.  **Initialize DP Table:** Create a 2D `dp` array of size $[n][n]$.
2.  **Base Case:** Fill the diagonal where $i == j$ with 0, as the cost of multiplying one matrix is zero.
3.  **Iterate through Lengths:** Use a loop to define the length of the matrix chain (starting from length 2 up to $n$).
4.  **Set Boundaries:** For each length, determine the starting index $i$ and the ending index $j$.
5.  **Find Optimal Partition:** For every range $[i, j]$, iterate with a variable $k$ from $i$ to $j-1$. Calculate the cost for each split and store the minimum in `dp[i][j]`.
6.  **Final Result:** The answer for the entire chain will be stored in `dp[1][n-1]`.


### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int matrixMultiplication(vector<int>& arr, int N) {
        // dp[i][j] stores the minimum multiplication cost for matrices i to j
        int dp[N][N];

        // Base case: multiplication cost for a single matrix is 0
        for (int i = 1; i < N; i++) {
            dp[i][i] = 0;
        }

        // l is the chain length
        for (int len = 2; len < N; len++) {
            for (int i = 1; i < N - len + 1; i++) {
                int j = i + len - 1;
                dp[i][j] = INT_MAX;

                // Try all possible partitions between i and j
                for (int k = i; k <= j - 1; k++) {
                    int cost = dp[i][k] + dp[k + 1][j] + (arr[i - 1] * arr[k] * arr[j]);
                    if (cost < dp[i][j]) {
                        dp[i][j] = cost;
                    }
                }
            }
        }

        return dp[1][N - 1];
    }
};

int main() {
    vector<int> arr = {10, 20, 30, 40, 30};
    int n = arr.size();
    Solution sol;
    cout << "Minimum number of multiplications is " << sol.matrixMultiplication(arr, n) << endl;
    return 0;
}
```
### Complexity Analysis:
* **Time Complexity:** $O(n^3)$
    * **Explanation:** There are three nested loops: one for the chain length, one for the starting index $i$, and one for the partition point $k$.
* **Space Complexity:** $O(n^2)$
    * **Explanation:** A 2D DP table of size $n \times n$ is used to store the results of subproblems.

---

