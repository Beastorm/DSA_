## Palindrome Partitioning - II | Front Partition : DP 53

**Problem Description:**   
Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return the **minimum cuts** needed for a palindrome partitioning of `s`.

---

>### Examples:

### Example 1:
* **Input:** `s = "bababcbadcede"`
* **Output:** `4`
* **Explanation:** One way to get the minimum cuts is: `bab | abcba | d | c | ede`. All these substrings are palindromes.

---

### Example 2:
* **Input:** `s = "aab"`
* **Output:** `1`
* **Explanation:** The partition `aa | b` results in all palindromic substrings with only 1 cut.


---

## Memoization Approach

### Algorithm:

The goal is to partition the string such that every segment is a palindrome while minimizing the total number of cuts. Since every single character is a palindrome, any string can be partitioned into $n$ palindromes using $n-1$ cuts. We use the **Front Partition** technique to optimize this.

**Steps to memoize the solution:**

1.  **Initialize DP Table:** Create a 1D array `dp` of size $n$, where $n$ is the length of the string. Initialize all values to `-1` to represent uncomputed states.
2.  **Front Partitioning:** Start from the current index $i$. Iterate through all possible ending positions $j$ (from $i$ to $n-1$).
3.  **Palindrome Check:** For each substring `s[i...j]`, check if it is a palindrome.
4.  **Recursive Transition:** If `s[i...j]` is a palindrome:
    * One cut is made.
    * The problem reduces to finding the minimum cuts for the remaining string starting at $j+1$.
    * The cost is $1 + f(j+1)$.
5.  **Store and Reuse:** Before computing `f(i)`, check if `dp[i]` is already calculated. If yes, return the stored value. Otherwise, store the minimum cuts found across all valid $j$ partitions into `dp[i]`.
6.  **Base Case:** When the index $i$ reaches the end of the string ($n$), return 0 as no more cuts are possible.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Check if substring s[start...end] is palindrome
    bool isPalindrome(const string& s, int start, int end) {
        while (start < end) {
            if (s[start] != s[end])
                return false;
            start++;
            end--;
        }
        return true;
    }

    // Recursive helper with memoization to find min cuts from index 'start'
    int minCutsHelper(const string& s, int start, vector<int>& memo) {
        int n = (int)s.size();

        // If reached end or substring is palindrome, no cut needed
        if (start == n || isPalindrome(s, start, n - 1))
            return 0;

        // Return stored result if already computed
        if (memo[start] != -1)
            return memo[start];

        int minCuts = INT_MAX;

        // Try all possible partitions
        for (int end = start; end < n; end++) {
            if (isPalindrome(s, start, end)) {
                // 1 cut plus cuts for the remaining substring
                int cuts = 1 + minCutsHelper(s, end + 1, memo);
                minCuts = min(minCuts, cuts);
            }
        }

        // Store and return minimum cuts needed from this start
        return memo[start] = minCuts;
    }

public:
    // Public function to get minimum cuts for palindrome partitioning
    int minCut(string s) {
        int n = (int)s.size();
        vector<int> memo(n, -1);
        return minCutsHelper(s, 0, memo);
    }
};

int main() {
    string s = "aab";

    Solution sol;
    cout << "Minimum cuts needed: " << sol.minCut(s) << "\n";

    return 0;
}
```
### Complexity Analysis:
* **Time Complexity:** $O(N^3)$
    * **Explanation:** There are $N$ states in the `dp` array (each index of the string). For each state, we run a partitioning loop that iterates up to $N$ times. Inside that loop, we perform an `isPalindrome` check which also takes $O(N)$ in the worst case. This results in $O(N \times N \times N) = O(N^3)$.
* **Space Complexity:** $O(N)$
    * **Explanation:** We use a 1D `dp` array of size $N$ to store the minimum cuts for each suffix. Additionally, the auxiliary recursion stack space can grow up to $O(N)$ in the case of a string where every character results in a new partition.

---

## Optimal Approach (Tabulation)

### Algorithm:

To optimize the solution and eliminate the auxiliary recursion stack space, we convert the memoized approach into a bottom-up **Tabulation** approach.

1.  **Identify State:** The changing parameter is the `start index (i)`, which ranges from $0$ to $n$.
2.  **Initialize DP Table:** Create a 1D `dp` array of size $(n+1)$. 
    * The base case `f(n) = 0` is represented by `dp[n] = 0`.
3.  **Iterative Direction:** In memoization, we moved from $0$ to $n$. In tabulation, we move in the opposite direction, from $n-1$ down to $0$.
4.  **Partitioning Logic:** * For each index `i`, run a loop `j` from $i$ to $n-1$.
    * If `s[i...j]` is a palindrome, calculate the cost: `cost = 1 + dp[j+1]`.
    * Keep track of the minimum cost for each `i` and store it in `dp[i]`.
5.  **Final Answer:** The value stored at `dp[0]` will be the minimum cuts plus one (due to the logical cut after the last palindrome). Subtract 1 from the final result.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Check if substring s[i...j] is palindrome
    bool isPalindrome(const string& s, int i, int j) {
        while (i < j) {
            if (s[i] != s[j])
                return false;
            i++;
            j--;
        }
        return true;
    }

public:
    // Tabulation approach to find minimum cuts for palindrome partitioning
    int minCut(string s) {
        int n = (int)s.size();
        // dp[i] = min cuts needed for substring s[i...end]
        vector<int> dp(n + 1, 0);  

        // Base case: no cuts needed beyond the last index
        dp[n] = -1;

        // Fill dp from end to start
        for (int i = n - 1; i >= 0; i--) {
            int minCuts = INT_MAX;

            // Check all substrings s[i...j]
            for (int j = i; j < n; j++) {
                if (isPalindrome(s, i, j)) {
                    // 1 cut plus cuts needed after j
                    minCuts = min(minCuts, 1 + dp[j + 1]);
                }
            }

            dp[i] = minCuts;
        }

        // dp[0] holds the min cuts needed for the full string
        return dp[0];
    }
};

int main() {
    string s = "aab";

    Solution sol;
    cout << "Minimum cuts needed: " << sol.minCut(s) << "\n";

    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(N^3)$
    * **Explanation:** We utilize two nested loops: an outer loop for the start index $i$ (running $N$ times) and an inner loop for the partition index $j$ (also running up to $N$ times). For every valid partition, the `isPalindrome` function performs a linear check of $O(N)$, leading to an overall complexity of $O(N \times N \times N) = O(N^3)$.
* **Space Complexity:** $O(N)$
    * **Explanation:** We maintain a 1D `dp` array of size $N+1$ to store the minimum cuts required for each suffix of the string. By using the tabulation approach, we have eliminated the $O(N)$ auxiliary recursion stack space.
