## Introduction to Dynamic Programming

### What is Dynamic Programming?
Dynamic Programming (DP) is a technique used to solve complex problems by breaking them down into simpler sub-problems. It involves storing the results of these sub-problems so that they can be reused later, avoiding redundant calculations.

---

### Two Common Approaches:

#### a. Memoization (Top-Down)
- Solves the problem from the **main problem down to the base cases**.
- Uses recursion and caches the results.
- If a sub-problem has already been solved, return the stored result.

#### b. Tabulation (Bottom-Up)
- Solves the problem from the **base cases up to the main problem**.
- Uses iteration (loops) and fills a table (array) with solutions.

![Visual representation of recursion levels showing base case (leaf nodes) and recursive steps.](https://static.takeuforward.org/content/-HktiNZO0)

> **Note:** The base case depends on the problem logic, not necessarily just smaller inputs.

---

## Fibonacci Numbers

The Fibonacci series is defined as:
`0, 1, 1, 2, 3, 5, 8, 13, 21, ...`

We need to find the **nth Fibonacci number** (0-based index).
- `F(0) = 0`
- `F(1) = 1`
- `F(n) = F(n-1) + F(n-2)` for `n > 1`

---

### Part 1: Memoization (Top-Down)

#### The Recursive Problem:
A simple recursive solution recalculates the same values multiple times.
For `n=5`, the recursion tree shows `overlapping sub-problems` (e.g., `F(3)` and `F(2)` are calculated multiple times). This leads to *exponential time complexity O(2^n)*.

#### Optimizing with Memoization:
We can store the results of sub-problems in an array (or a hash map) to reuse them. This reduces the time complexity to **O(n)**.

#### Steps to Memoize:
1. **Create a DP Array:** Initialize an array `dp[n+1]` with `-1` (indicating values are not yet computed).
2. **Check Before Computation:** Before performing recursion for `n`, check if `dp[n]` is already computed (i.e., not `-1`). If yes, return `dp[n]`.
3. **Store After Computation:** If not computed, perform the recursive step and **store** the result in `dp[n]` before returning it.

### C++ Code: 
```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate Fibonacci using memoization
    int fib(int n, vector<int>& dp) {
        // If base case return n
        if (n <= 1) return n;

        // If already computed, return stored value
        if (dp[n] != -1) return dp[n];

        // Otherwise compute and store
        dp[n] = fib(n - 1, dp) + fib(n - 2, dp);
        return dp[n];
    }
};

int main() {
    int n = 10;
    vector<int> dp(n + 1, -1);
    Solution sol;
    cout << sol.fib(n, dp);
    return 0;
}
```
### Complexity Analysis - Fibonacci (Memoization)

- **Time Complexity: O(N)**
    - **Each state `f(i)` is computed exactly once.**
    - If `f(i)` is called again, we return `dp[i]` in **O(1)**.
    - There are `N` unique subproblems.
    - Total time: `O(N)`.

- **Space Complexity: O(N)**
    - **DP Array:** `O(N)` space to store computed values.
    - **Recursion Stack:** `O(N)` depth in the worst case.
    - Total space: `O(N)`.
---

### Part 2: Tabulation:
Tabulation is a ‘bottom-up’ approach where we start from the base case and reach the final answer that we want. Tabulation helps in optimizing the solution by preventing additional stack space used during recursion.
Steps to convert the recursive solution to Tabulation one.

Declare a dp[] array of size n+1.
First, initialize the base condition values, i.e i=0 and i=1 of the dp array as 0 and 1, respectively.
Set an iterative loop that traverses the array( from index 2 to n) and for every index set its value as dp[i-1] + dp[i-2]. 

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate Fibonacci using tabulation
    int fib(int n) {
        // If n is 0 or 1, return n
        if (n <= 1) return n;

        // Create dp array
        vector<int> dp(n + 1, 0);

        // Initialize base cases
        dp[0] = 0;
        dp[1] = 1;

        // Fill dp array iteratively
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        // Return final answer
        return dp[n];
    }
};

int main() {
    int n = 10;
    Solution sol;
    cout << sol.fib(n);
    return 0;
}

```
### Complexity Analysis - Fibonacci (Tabulation)

- **Time Complexity: O(N)**
    - **Iterative approach:** We run a single loop from `2` to `N`.
    - Each iteration performs a constant number of operations (addition and assignment).
    - Total time: `O(N)`.

- **Space Complexity: O(N)**
    - **DP Array:** `O(N)` space is used to store the values `dp[0]` to `dp[n]`.
    - No recursion stack is used.
    - Total space: `O(N)`.

---

### Part 3: Space Optimization:
If we closely look at the relation,

``` dp[i] =  dp[i-1] + dp[i-2] ```

We see that for any i, we do need only the last two values in the array. So, is there a need to maintain a whole array for it? The answer is ‘No’. Let us call dp[i-1] as prev and dp[i-2] as prev2. Now, understand the following illustration.

![Fibonacci Series: A sequence where each number is the sum of the two preceding ones, usually starting with 0 and 1.](https://static.takeuforward.org/content/-3r5t408Z)

- Each iteration’s cur_i and prev become the next iteration’s prev and prev2, respectively.
- Therefore, after calculating cur_i, if we update prev and prev2 according to the next step, we will always get the answer. 
- After the iterative loop has ended, we can simply return prev as our answer.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int fib(int n) {
        // If n is 0 return 0
        if(n == 0) return 0;
        // If n is 1 return 1
        if(n == 1) return 1;

        // prev2 stores fib(n-2)
        int prev2 = 0;
        // prev stores fib(n-1)
        int prev = 1;
        // curr stores current fib
        int curr;

        // Loop from 2 to n
        for(int i = 2; i <= n; i++) {
            // Calculate current fib
            curr = prev + prev2;
            // Update prev2
            prev2 = prev;
            // Update prev
            prev = curr;
        }
        // Return final answer
        return prev;
    }
};

int main() {
    Solution s;
    int n = 10;
    cout << s.fib(n);
    return 0;
}

```
### Complexity Analysis - Fibonacci (Space Optimized)

- **Time Complexity: O(N)**
    - **Iterative approach:** We run a single loop from `2` to `N`.
    - Each iteration performs a constant number of operations (addition and variable updates).
    - Total time: `O(N)`.

- **Space Complexity: O(1)**
    - **No DP Array:** We only use three variables (`prev2`, `prev`, `curr`).
    - No recursion stack is used.
    - Total space: `O(1)` (Constant space).
