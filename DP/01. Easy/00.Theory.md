## Introduction to Dynamic Programming

### What is Dynamic Programming?
Dynamic Programming (DP) is a technique used to solve complex problems by breaking them down into simpler sub-problems. It involves storing the results of these sub-problems so that they can be reused later, avoiding redundant calculations.

---

### Two Common Approaches

### 1. Memoization (Top-Down)
- Solves the problem from the **main problem down to the base cases**.
- Uses recursion and caches the results.
- If a sub-problem has already been solved, return the stored result.

### 2. Tabulation (Bottom-Up)
- Solves the problem from the **base cases up to the main problem**.
- Uses iteration (loops) and fills a table (array) with solutions.

> **Note:** The base case depends on the problem logic, not necessarily just smaller inputs.

---

## Example: Fibonacci Numbers

The Fibonacci series is defined as:
`0, 1, 1, 2, 3, 5, 8, 13, 21, ...`

We need to find the **nth Fibonacci number** (0-based index).
- `F(0) = 0`
- `F(1) = 1`
- `F(n) = F(n-1) + F(n-2)` for `n > 1`

---

## Part 1: Memoization (Top-Down)

### The Recursive Problem
A simple recursive solution recalculates the same values multiple times.
For `n=5`, the recursion tree shows overlapping sub-problems (e.g., `F(3)` and `F(2)` are calculated multiple times). This leads to **exponential time complexity O(2^n)**.

### Optimizing with Memoization
We can store the results of sub-problems in an array (or hash map) to reuse them. This reduces the time complexity to **O(n)**.

### Steps to Memoize:
1. **Create a DP Array:** Initialize an array `dp[n+1]` with `-1` (indicating values are not yet computed).
2. **Check Before Computation:** Before performing recursion for `n`, check if `dp[n]` is already computed (i.e., not `-1`). If yes, return `dp[n]`.
3. **Store After Computation:** If not computed, perform the recursive step and **store** the result in `dp[n]` before returning it.

### Code Structure
```cpp
// Initialize dp array with -1
if (n <= 1) return n;
if (dp[n] != -1) return dp[n];

return dp[n] = f(n-1) + f(n-2);
```
