## Buy and Sell Stock – II | (DP-36)

**Problem Statement:**
We are given an array `Arr[]` of length `n`, where `Arr[i]` represents the price of a stock on the `i`-th day.

We are allowed to perform **multiple transactions** (buy and sell) with the following rules:

- We can **buy and sell the stock any number of times**.
- To **sell a stock**, we must have bought it on the **same or a previous day**.
- We **cannot buy again before selling** the previously bought stock.
- At any time, we can hold **at most one stock**.

Our task is to **maximize the total profit** by choosing the best sequence of buy and sell operations.

---

>### Example:

### Example 1:
**Input:**  
`prices = [7, 1, 5, 3, 6, 4]`

**Output:** `7`

**Explanation:**  
- Buy at price `1`, sell at `5` → profit = `4`  
- Buy at price `3`, sell at `6` → profit = `3`  
- Total profit = `4 + 3 = 7`

---

### Example 2:
**Input:**  
`prices = [1, 2, 3, 4, 5]`

**Output:** `4`

**Explanation:**  
Buy on day 1 and sell on day 5, or make a profit every day.  
Total profit = `(2-1) + (3-2) + (4-3) + (5-4) = 4`

---

### Example 3:
**Input:**  
`prices = [7, 6, 4, 3, 1]`

**Output:** `0`

**Explanation:**  
Prices keep decreasing, so no profitable transaction is possible.

---

## Approach - Recursive:

### Intuition:

Every day, we have **two choices** depending on whether we are currently holding a stock or not:

- **If we are allowed to buy (canBuy = 1):**
  - Buy the stock on this day.
  - Skip this day (do nothing).

- **If we are holding a stock (canBuy = 0):**
  - Sell the stock on this day.
  - Skip this day (do nothing).

We explore **all possible choices recursively** and take the maximum profit achievable.


### Recursive State Definition:

Let  
`f(ind, canBuy)` = maximum profit we can achieve starting from day `ind`.

- `ind` → current day index
- `canBuy` →  
  - `1` → we are allowed to buy  
  - `0` → we are holding a stock and must sell before buying again

### Base Case:

- If `ind == n` (we have processed all days), no profit can be made:
return 0

### Recursive Transitions:

#### Case 1: We can buy (`canBuy == 1`)
We have two options:
1. **Buy today**  
 Profit = `-prices[ind] + f(ind + 1, 0)`
2. **Skip today**  
 Profit = `f(ind + 1, 1)`

Take the maximum:
f(ind, 1) = max(
-prices[ind] + f(ind + 1, 0),
f(ind + 1, 1)
)

#### Case 2: We must sell (`canBuy == 0`)
We have two options:
1. **Sell today**  
   Profit = `prices[ind] + f(ind + 1, 1)`
2. **Skip today**  
   Profit = `f(ind + 1, 0)`

Take the maximum:
f(ind, 0) = max(
prices[ind] + f(ind + 1, 1),
f(ind + 1, 0)
)

### Final Answer:

We start from day `0` with permission to buy:
f(0, 1)

### C++ Code:
``` cpp

---

### Full Recursive Code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

int solve(int ind, int canBuy, vector<int>& prices, int n) {
    // Base case
    if (ind == n)
        return 0;

    int profit = 0;

    if (canBuy) {
        // Option 1: Buy
        int buy = -prices[ind] + solve(ind + 1, 0, prices, n);
        // Option 2: Skip
        int skip = solve(ind + 1, 1, prices, n);
        profit = max(buy, skip);
    } else {
        // Option 1: Sell
        int sell = prices[ind] + solve(ind + 1, 1, prices, n);
        // Option 2: Skip
        int skip = solve(ind + 1, 0, prices, n);
        profit = max(sell, skip);
    }

    return profit;
}

int maxProfit(vector<int>& prices) {
    int n = prices.size();
    return solve(0, 1, prices, n);
}
```
### Complexity Analysis:

### Time Complexity:
**O(2ⁿ)**

Each day, we make two recursive choices (buy/sell or skip).  
This results in an exponential number of recursive calls as all possible decision paths are explored.

### Space Complexity:
**O(n)**

The space is used by the recursion stack.  
In the worst case, the depth of recursion can go up to `n` (number of days).

---
## Approach - Memoization

### Intuition:
Every day, we have two choices: either do nothing or perform a buy/sell action to increase profit.  
Since we must explore all possible choices to get the maximum profit, we use recursion along with memoization to avoid repeated calculations.

### Representing the Problem:
- Think of the problem as making decisions for each day.
- Keep track of:
  - **Day index**
  - **Whether we are allowed to buy or must sell**
- The goal is to calculate the **maximum profit from the current day onward**.

### Try All Choices:

#### If we are allowed to buy:
- **Option 1:** Skip the day and move to the next day.
- **Option 2:** Buy the stock (profit decreases by the stock price) and move to the next day.

#### If we are holding a stock and can sell:
- **Option 1:** Skip the day and move to the next day.
- **Option 2:** Sell the stock (profit increases by the stock price) and move to the next day.


### Return the Maximum:
For each day, choose the option that results in the **maximum profit**.

### Base Case:
If we reach the end of the trading days, return `0` since no more profit can be made.


### Memoization:
- Create a DP table to store the results of already solved subproblems.
- Before computing the profit for a given day and state, check if it exists in the table.
- If it exists, return the stored value.
- Otherwise, compute it using recursion, store it in the table, and return it.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;
class StockProfit{
long getAns(long *Arr, int ind, int buy, int n, vector<vector<long>> &dp) {
    // Base case: When we reach the end of the array, there are no more decisions to make.
    if (ind == n) {
        return 0;
    }

    // If the result for this state has already been calculated, return it
    if (dp[ind][buy] != -1) {
        return dp[ind][buy];
    }

    long profit = 0;

    if (buy == 0) { // We can buy the stock
        profit = max(0 + getAns(Arr, ind + 1, 0, n, dp), -Arr[ind] + getAns(Arr, ind + 1, 1, n, dp));
    }

    if (buy == 1) { // We can sell the stock
        profit = max(0 + getAns(Arr, ind + 1, 1, n, dp), Arr[ind] + getAns(Arr, ind + 1, 0, n, dp));
    }

    // Store the calculated profit in the DP table and return it
    return dp[ind][buy] = profit;
}

long getMaximumProfit(long *Arr, int n) {
    // Create a DP table to memoize results
    vector<vector<long>> dp(n, vector<long>(2, -1));

    if (n == 0) {
        return 0;
    }

    long ans = getAns(Arr, 0, 0, n, dp);
    return ans;
}

int main() {
    int n = 6;
    long Arr[n] = {7, 1, 5, 3, 6, 4};
    return 0;
}
```
### Complexity Analysis:

### Time Complexity:
**O(N × 2)**  
There are `N` days and `2` possible states (can buy / can sell).  
Each state is computed only once due to memoization, so at most `N × 2` subproblems are solved.

### Space Complexity:
**O(N × 2) + O(N)**  
- `O(N × 2)` for the DP table storing results for each day and state.  
- `O(N)` for the recursion stack space in the worst case.

---
## Tabulation Approach
### Algorithm :

To convert the memoization approach into a tabulation approach, we use a DP table and fill it iteratively instead of using recursion.

- Create a DP table `dp` with rows representing days and two columns representing states:
  - `0` → not allowed to buy (must sell)
  - `1` → allowed to buy
- Initialize all values in the table to `0`.

### Base Case:
- On the last day (or beyond), no transactions are possible.
- Hence, profit is `0` for both buying and selling states.

### Iterative Computation:
- Use an outer loop to iterate from the second last day down to the first day.
- Use an inner loop to iterate over the two states (buy and sell).
- For each day and state, calculate the maximum profit using the same decision logic as memoization:
  - Either skip the day.
  - Or perform the buy/sell operation and move to the next day.

### Result:
- The final answer is stored at `dp[0][1]`, which represents the maximum profit starting from day `0` when buying is allowed.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;
class StockProfit {
long getMaximumProfit(long *Arr, int n) {
    // Create a DP table to memoize results
    vector<vector<long>> dp(n + 1, vector<long>(2, -1));

    // Base condition: When we have no stocks left, the profit is 0.
    dp[n][0] = dp[n][1] = 0;

    long profit;

    // Loop through the array in reverse order
    for (int ind = n - 1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            if (buy == 0) { // We can buy the stock
                profit = max(0 + dp[ind + 1][0], -Arr[ind] + dp[ind + 1][1]);
            }

            if (buy == 1) { // We can sell the stock
                profit = max(0 + dp[ind + 1][1], Arr[ind] + dp[ind + 1][0]);
            }

            dp[ind][buy] = profit;
        }
    }

    // The maximum profit is stored in dp[0][0] after all calculations
    return dp[0][0];
}

int main() {
    int n = 6;
    long Arr[n] = {7, 1, 5, 3, 6, 4};

    // Call the getMaximumProfit function and print the result
    cout << "The maximum profit that can be generated is " << getMaximumProfit(Arr, n);

    return 0;
}
```
### Complexity Analysis

- **Time Complexity:** `O(N * 2)`  
  There are two nested loops: one iterating over `N` days and the other over `2` states (buy/sell).

- **Space Complexity:** `O(N * 2)`  
  A DP table of size `N x 2` is used.  
  No recursion is involved, so **stack space is eliminated**.


---
## Approach - Space Optimized

### Algorithm:

- Observe that each DP state depends only on the **next day’s values**.
- Hence, we do not need the entire DP table.
- Use **two 1D arrays**:
  - `next` → represents profit values for the next day  
  - `cur` → represents profit values for the current day  

### Steps:
1. Initialize the `next` array with base condition values (profit = `0` when no days are left).
2. Iterate from the **last day to the first day**.
3. For each day, compute values for both states (buy and sell) using the `next` array.
4. Store the computed values in the `cur` array.
5. After processing for a day, assign `cur` to `next` for the next iteration.
6. The final answer is stored in `next[1]`, representing the maximum profit starting from day `0` when buying is allowed.

### C++ Code:
``` cpp 
#include <bits/stdc++.h>
using namespace std;
class StockProfit {
long getMaximumProfit(long *Arr, int n) {
    // Create two arrays to store the profits ahead of the current position (0 for not holding, 1 for holding)
    vector<long> ahead(2, 0);
    vector<long> cur(2, 0);

    // Base condition: When there are no stocks left, the profit is 0.
    ahead[0] = ahead[1] = 0;

    long profit;

    // Loop through the array in reverse order
    for (int ind = n - 1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            if (buy == 0) { // We can buy the stock
                profit = max(0 + ahead[0], -Arr[ind] + ahead[1]);
            }

            if (buy == 1) { // We can sell the stock
                profit = max(0 + ahead[1], Arr[ind] + ahead[0]);
            }
            cur[buy] = profit;
        }

        ahead = cur; // Update the "ahead" array with the current values
    }

    // The maximum profit is stored in cur[0] after all calculations
    return cur[0];
}

int main() {
    int n = 6;
    long Arr[n] = {7, 1, 5, 3, 6, 4};

    // Call the getMaximumProfit function and print the result
    cout << "The maximum profit that can be generated is " << getMaximumProfit(Arr, n);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N * 2)`  
  We iterate over all `N` days and for each day, process two states (buy and sell).

- **Space Complexity:** `O(1)`  
  Only two arrays of constant size `2` are used to store current and next day states.
