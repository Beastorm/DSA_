## Buy and Sell Stocks With Transaction Fees | (DP - 40)

**Problem Statement:**  
We are given an array `Arr[]` of length `n`, where `Arr[i]` represents the price of a stock on the `i-th` day. We are also given a transaction fee `fee`.

The following rules apply:

- We can buy and sell the stock **any number of times**.
- To sell a stock, we must have bought it on the same or any previous day.
- We **cannot buy a stock again before selling the previously bought stock**.
- After every **sell operation**, a transaction fee `fee` is charged.

The task is to **find the maximum profit** that can be achieved under these conditions.

---

>### Examples:
### Example 1:
**Input:** Array=[1, 3, 2, 8, 4, 9], N=6, Fee=2  
**Output:** Max Profit=8 (5(8-1-2)+3(9-4-2))
**Explanation:** Buy the stock on the 0th day for 1 and sell on the 3rd day for 8, incurring a fee of 2, then again buy stock at 4th day for 4 and sell the stock at 5th day at a price of 9, incurring a fee of 2.

### Key Points:
- Multiple transactions are allowed.
- A transaction consists of **one buy followed by one sell**.
- The transaction fee is applied **only when selling**.
- At most one stock can be held at any time.

---
## Approach - Recursive

### Idea:

Every day, we decide whether to **buy**, **sell**, or **skip**, based on whether we are currently holding a stock or not.

We use recursion to try all valid choices and return the **maximum profit** possible.


### State Definition

`f(ind, canBuy)`  
- `ind` ‚Üí current day index  
- `canBuy` ‚Üí  
  - `1` ‚Üí we are allowed to buy  
  - `0` ‚Üí we are holding a stock and can sell  


### Base Case

- If `ind == n` (no more days left), return `0`.

### Recursive Choices:

#### If we can buy (`canBuy == 1`)
- **Skip today** ‚Üí `f(ind + 1, 1)`
- **Buy today** ‚Üí `-Arr[ind] + f(ind + 1, 0)`

Take the maximum of both.

#### If we can sell (`canBuy == 0`)
- **Skip today** ‚Üí `f(ind + 1, 0)`
- **Sell today** ‚Üí `Arr[ind] - fee + f(ind + 1, 1)`

Take the maximum of both.

### Recursive Code (C++):

```cpp
int solve(int ind, int canBuy, vector<int>& prices, int fee) {
    if (ind == prices.size())
        return 0;

    if (canBuy) {
        int skip = solve(ind + 1, 1, prices, fee);
        int buy  = -prices[ind] + solve(ind + 1, 0, prices, fee);
        return max(skip, buy);
    } else {
        int skip = solve(ind + 1, 0, prices, fee);
        int sell = prices[ind] - fee + solve(ind + 1, 1, prices, fee);
        return max(skip, sell);
    }
}

int maxProfit(vector<int>& prices, int fee) {
    return solve(0, 1, prices, fee);
}
```
### Complexity Analysis:

### Time Complexity: **O(2‚Åø)**
- Each day, we have **two choices** (take action or skip).
- The recursion explores all possible combinations of buy/sell decisions.
- This results in an **exponential number of recursive calls**.

### Space Complexity: **O(n)**
- The maximum depth of the recursion stack is `n` (one call per day).
- No extra data structures are used apart from the recursion stack space.

---
## Approach - Memoization

### Algorithm:

Each day gives us two choices: **do nothing** or **take an action** (buy or sell) depending on what we did previously.  
Our goal is to explore all possible choices and return the **maximum profit**, but we optimize the recursive solution using **memoization**.

### State Representation:

We define our state using:
- `day` ‚Üí current index in the price array  
- `canBuy` ‚Üí  
  - `1` ‚Üí we are allowed to buy  
  - `0` ‚Üí we must sell before buying again  

`dp[day][canBuy]` stores the **maximum profit** achievable from `day` onward in that state.

### Choices at Each State:

#### üîπ If we are allowed to buy (`canBuy = 1`)

- **Skip** the day  
  ‚Üí profit = `solve(day + 1, 1)`
- **Buy** the stock  
  ‚Üí profit = `-price[day] + solve(day + 1, 0)`

Take the maximum of the two.

#### üîπ If we must sell (`canBuy = 0`)

- **Skip** the day  
  ‚Üí profit = `solve(day + 1, 0)`
- **Sell** the stock  
  ‚Üí profit = `price[day] - fee + solve(day + 1, 1)`

The transaction fee is deducted **only after selling**, since buying + selling completes one transaction.

Take the maximum of the two.


### Base Case:

- If `day == n` (all days processed)  
  ‚Üí return `0` (no more profit possible)


### Memoization:

- Before solving a state `(day, canBuy)`, check if it already exists in `dp`.
- If present, return the stored value.
- Otherwise, compute the answer, store it in `dp`, and return it.


### Key Idea:

Buying reduces profit, selling increases profit (minus fee).  
At every step, we choose the option that gives the **maximum future profit**.

---


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;
class Solution{
int getAns(vector<int> &Arr, int ind, int buy, int n, int fee, vector<vector<int>> &dp) {
    // Base case: If we've reached the end of the array, return 0 profit.
    if (ind == n) return 0;
    
    // Check if the result is already computed
    if (dp[ind][buy] != -1)
        return dp[ind][buy];
        
    int profit;
    
    if (buy == 0) { // We can buy the stock
        profit = max(0 + getAns(Arr, ind + 1, 0, n, fee, dp), -Arr[ind] + getAns(Arr, ind + 1, 1, n, fee, dp));
    }
    
    if (buy == 1) { // We can sell the stock
        profit = max(0 + getAns(Arr, ind + 1, 1, n, fee, dp), Arr[ind] - fee + getAns(Arr, ind + 1, 0, n, fee, dp));
    }
    
    // Store the computed profit in the DP array
    return dp[ind][buy] = profit;
}

int maximumProfit(int n, int fee, vector<int> &Arr) {
    vector<vector<int>> dp(n, vector<int>(2, -1));
    
    if (n == 0) return 0; // Edge case: No stocks to trade.
    
    int ans = getAns(Arr, 0, 0, n, fee, dp);
    return ans;
}

int main() {
    vector<int> prices = {1, 3, 2, 8, 4, 9};
    int n = prices.size();
    int fee = 2;
                                 
    cout << "The maximum profit that can be generated is " << maximumProfit(n, fee, prices) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*2). There are N*2 states; therefore, at max ‚ÄòN*2‚Äô new problems will be solved, and we are running a for loop for ‚ÄòN‚Äô times to calculate the total sum.

- **Space Complexity:** O(N*2) + O(N). We are using a recursion stack space(O(N)) and a 2D array O(N*2).

---

## Approach - Tabulation

### Algorithm:

In this approach, we replace recursion with a **bottom-up dynamic programming table**.  
Instead of solving smaller subproblems through recursive calls, we directly **fill a DP table** starting from the last day and moving backward.

### DP Table Setup:

- Create a 2D DP table `dp[n+1][2]`
  - `dp[day][1]` ‚Üí maximum profit starting from `day` when **buying is allowed**
  - `dp[day][0]` ‚Üí maximum profit starting from `day` when **selling is required**
- `n` is the total number of days.

### Base Case:

- When `day = n` (no days left):
  - No profit can be made.
  - So, initialize:
    ```
    dp[n][0] = dp[n][1] = 0
    ```

### Filling the Table:

- Iterate **backward** from `day = n-1` to `day = 0`
- For each day, calculate values for both states:

#### If buying is allowed (`canBuy = 1`)

- **Skip the day**
profit = dp[day + 1][1]

- **Buy the stock**
profit = -price[day] + dp[day + 1][0]

- Store the maximum of the two:
dp[day][1] = max(skip, buy)


#### If selling is required (`canBuy = 0`)

- **Skip the day**
profit = dp[day + 1][0]

- **Sell the stock** (transaction completes here, fee deducted)
profit = price[day] - fee + dp[day + 1][1]

- Store the maximum of the two:
dp[day][0] = max(skip, sell)

---

### Final Answer:

- The result is stored at: dp[0][1]
- This represents the **maximum profit starting from day 0 when buying is allowed**.

---

### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
class Solution{
int maximumProfit(int n, int fee, vector<int>& Arr) {
    if (n == 0) return 0; // Edge case: No stocks to trade.

    // Create a 2D DP array with dimensions (n+1) x 2, initialized to 0
    vector<vector<int>> dp(n + 1, vector<int>(2, 0));

    // Loop through the stock prices from the end to the beginning
    for (int ind = n - 1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            int profit;

            if (buy == 0) { // We can buy the stock
                profit = max(0 + dp[ind + 1][0], -Arr[ind] + dp[ind + 1][1]);
            }

            if (buy == 1) { // We can sell the stock
                profit = max(0 + dp[ind + 1][1], Arr[ind] - fee + dp[ind + 1][0]);
            }

            dp[ind][buy] = profit;
        }
    }

    return dp[0][0]; // Return the maximum profit for buying.
}

int main() {
    vector<int> prices = {1, 3, 2, 8, 4, 9};
    int n = prices.size();
    int fee = 2;

    cout << "The maximum profit that can be generated is " << maximumProfit(n, fee, prices) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*2). Two nested loops account for O(N*2) complexity.
- **Space Complexity:** O(N*2). We are using an external array of size ‚ÄòN*2‚Äô. Stack Space is eliminated.


---

## Approach - Space Optimized

### Algorithm:

To decide the best profit for any given day, we only need the results from the **next day**.  
So, instead of maintaining a full DP table, we can optimize space by keeping just **two values** that represent the next day‚Äôs outcomes.

### Key Observation:

- The state on `day` depends only on `day + 1`
- Hence, a full 2D table is unnecessary
- We only track:
  - `aheadBuy` ‚Üí profit when buying is allowed on the next day
  - `aheadSell` ‚Üí profit when selling is required on the next day

### Initialization:

- When no days are left, no profit can be made:
aheadBuy = 0
aheadSell = 0

### Iterative Update (Reverse Order)

- Traverse days from `n-1` down to `0`
- For each day, compute:

#### When buying is allowed:
- Skip the day:
skip = aheadBuy

- Buy the stock:
buy = -price[day] + aheadSell

- Best choice:
currBuy = max(skip, buy)

#### When selling is required
- Skip the day:
skip = aheadSell
- Sell the stock (fee applied):
sell = price[day] - fee + aheadBuy

- Best choice:
currSell = max(skip, sell)

### Move Forward:
- After computing current values:
aheadBuy = currBuy
aheadSell = currSell

---

### Final Answer:
- The maximum profit is stored in:
aheadBuy
- This represents the best profit starting from day 0 when buying is allowed.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;
class Solution{
int maximumProfit(int n, int fee, vector<int>& Arr) {
    if (n == 0) return 0; // Edge case: No stocks to trade.

    vector<long> ahead(2, 0); // To track maximum profit one step ahead
    vector<long> cur(2, 0);   // To track current maximum profit

    // Initialize both ahead[0] and ahead[1] to 0 as the base condition
    ahead[0] = ahead[1] = 0;

    long profit;

    for (int ind = n - 1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            if (buy == 0) { // We can buy the stock
                profit = max(0 + ahead[0], -Arr[ind] + ahead[1]);
            }

            if (buy == 1) { // We can sell the stock
                profit = max(0 + ahead[1], Arr[ind] - fee + ahead[0]);
            }
            cur[buy] = profit;
        }

        ahead = cur;
    }
    return cur[0]; // Return the maximum profit for buying.
}

int main() {
    vector<int> prices = {1, 3, 2, 8, 4, 9};
    int n = prices.size();
    int fee = 2;

    cout << "The maximum profit that can be generated is " << maximumProfit(n, fee, prices) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*2). Two nested loops account for O(N*2) complexity
- **Space Complexity:** O(1). We are using an external array of size ‚Äò2‚Äô.
