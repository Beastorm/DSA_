## Buy and Sell Stocks With Cooldown | (DP - 39)

**Problem Statement:**  
We are given an array `Arr[]` of length `n`, where `Arr[i]` represents the price of a stock on the `i-th` day.  
We need to find the **maximum profit** that can be achieved under the following rules:

### Rules:
- We can buy and sell the stock **any number of times**.
- To sell a stock, we must first buy it on the same day or on any previous day.
- We **cannot buy a stock again before selling** the previously bought stock.
- We **cannot sell before buying**.
- **Cooldown constraint:** After selling a stock, we **cannot buy on the very next day**.

---

>### Examples:

### Example 1:
**Input:**  
Arr = [4, 9, 0, 4, 10]
N = 5

**Output:** 11

**Explanation:**  
- Buy on day 0 at price 4, sell on day 1 at price 9 → profit = 5  
- Cooldown on day 2  
- Buy on day 3 at price 4, sell on day 4 at price 10 → profit = 6  

**Total Profit = 5 + 6 = 11**

---

## Recursive Approach

### Intuition:
On each day, we decide whether to **buy**, **sell**, or **skip** based on:
- the current day index
- whether we are allowed to buy (`canBuy = 1`) or we are holding a stock (`canBuy = 0`)

The **cooldown rule** applies after selling:
- if we sell on day `i`, the next valid decision day is `i + 2`

### Recursive State:
`solve(ind, canBuy)`

- `ind` → current day index  
- `canBuy` →  
  - `1` → we are allowed to buy  
  - `0` → we are holding a stock and must sell before buying again  


### Choices:
- If `canBuy == 1`:
  - Skip the day
  - Buy the stock
- If `canBuy == 0`:
  - Skip the day
  - Sell the stock (and jump to `ind + 2` due to cooldown)

### Base Case:
- If `ind >= n`, return `0` (no days left, no profit)

### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

int solve(int ind, int canBuy, vector<int>& prices) {
    int n = prices.size();

    // Base case
    if (ind >= n) return 0;

    int profit = 0;

    if (canBuy) {
        // Option 1: Skip
        int skip = solve(ind + 1, 1, prices);

        // Option 2: Buy
        int buy = -prices[ind] + solve(ind + 1, 0, prices);

        profit = max(skip, buy);
    } else {
        // Option 1: Skip
        int skip = solve(ind + 1, 0, prices);

        // Option 2: Sell (cooldown applies)
        int sell = prices[ind] + solve(ind + 2, 1, prices);

        profit = max(skip, sell);
    }

    return profit;
}

int maxProfit(vector<int>& prices) {
    return solve(0, 1, prices);
}
``` 
### Complexity Analysis:

### Time Complexity: **O(2ⁿ)**  
Every day, we have two choices (take an action or skip), and due to recursion without memoization, many subproblems are recomputed. This results in exponential time complexity.

### Space Complexity: **O(n)**  
The maximum depth of the recursion stack can go up to `n` (number of days), so the auxiliary space used is linear.

---

## Memoization Approach

### Algorithm / Intuition:

On each day, we decide whether to take an action (buy or sell) or skip the day.  
Since future profit depends on today’s decision, we explore all possibilities using recursion and optimize it using memoization.

### Approach:

- We process the stock prices **day by day**.
- We track two states:
  - **Day index**
  - **Buy state** (whether we are allowed to buy or must sell)

#### When buying is allowed:
- **Option 1:** Skip the day and move to the next day.
- **Option 2:** Buy the stock today (profit decreases by price) and move to the next day with selling allowed.

#### When selling is allowed:
- **Option 1:** Skip the day and keep holding the stock.
- **Option 2:** Sell the stock today (profit increases by price) and skip the **next day** due to the cooldown rule before buying again.

### Memoization:

- Use a DP table to store results for each `(day, buy)` state.
- Before computing a state, check if it is already stored:
  - If yes, return the stored value.
  - If no, compute the result recursively and store it for future use.

This avoids recomputation of overlapping subproblems and significantly improves performance.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;
class Solution{
int getAns(vector<int> Arr, int ind, int buy, int n, vector<vector<int>> &dp) {
    // Base case: If we've reached the end of the array, return 0 profit.
    if (ind >= n) return 0;
    
    // Check if the result is already computed
    if (dp[ind][buy] != -1)
        return dp[ind][buy];
        
    int profit;
    
    if (buy == 0) { // We can buy the stock
        profit = max(0 + getAns(Arr, ind + 1, 0, n, dp), -Arr[ind] + getAns(Arr, ind + 1, 1, n, dp));
    }
    
    if (buy == 1) { // We can sell the stock
        profit = max(0 + getAns(Arr, ind + 1, 1, n, dp), Arr[ind] + getAns(Arr, ind + 2, 0, n, dp));
    }
    
    // Store the result in the DP array and return
    return dp[ind][buy] = profit;
}

int stockProfit(vector<int> &Arr) {
    int n = Arr.size();
    vector<vector<int>> dp(n, vector<int>(2, -1));
    
    int ans = getAns(Arr, 0, 0, n, dp);
    return ans;
}

int main() {
    vector<int> prices {4, 9, 0, 4, 10};
                                 
    cout << "The maximum profit that can be generated is " << stockProfit(prices) << endl;
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(N*2). There are N*2 states; therefore at max ‘N*2’ new problems will be solved, and we are running a for loop for ‘N’ times to calculate the total sum.
- **Space Complexity:** O(N*2) + O(N). We are using a recursion stack space(O(N)) and a 2D array O(N*2).

---

## Tabulation Approach

### Algorithm:

To convert the memoization solution into a tabulation (bottom-up) approach, we replace recursion with iterative DP table filling.

- Create a **2D DP array** of size `(n + 1) × 2`, where:
  - `n` is the number of days
  - The second dimension represents the **buy/sell state**
- Initialize the **last row with 0**, because no profit can be made after all days are completed.

### Iterative Filling:

- Use **two nested loops**:
  - **Outer loop:** iterate from the last day to the first day.
  - **Inner loop:** iterate over both states (buy and sell).

- For each `(day, state)`:
  - Apply the same decision logic used in memoization:
    - Choose the maximum profit between skipping the day or performing the allowed action (buy or sell).
    - When selling, account for the **cooldown** by skipping the next day.

### Final Answer:

- The result is stored at `dp[0][1]`, which represents the **maximum profit starting from day 0 with the option to buy**.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;
class Solution{
int stockProfit(vector<int> &Arr) {
    int n = Arr.size();
    // Create a 2D DP array with dimensions (n+2) x 2, initialized to 0
    vector<vector<int>> dp(n + 2, vector<int>(2, 0));
    
    // Loop through the stock prices from the end to the beginning
    for (int ind = n - 1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            int profit;

            if (buy == 0) { // We can buy the stock
                profit = max(0 + dp[ind + 1][0], -Arr[ind] + dp[ind + 1][1]);
            }

            if (buy == 1) { // We can sell the stock
                profit = max(0 + dp[ind + 1][1], Arr[ind] + dp[ind + 2][0]);
            }

            // Store the computed profit in the DP array
            dp[ind][buy] = profit;
        }
    }

    return dp[0][0];
}

int main() {
    vector<int> prices {4, 9, 0, 4, 10};
                                 
    cout << "The maximum profit that can be generated is " << stockProfit(prices) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*2). Two nested loops account for O(N*2) complexity.
- **Space Complexity:** O(N*2). We are using an external array of size ‘N*2’. Stack Space is eliminated.

---
## Approach - Space Optimized
### Algorithm:

When we observe the transition, we notice that the decision for **today** depends only on the results of the **next one or two days** (because of the cooldown after selling).

So, instead of storing a full DP table, we can optimize space by keeping only a few variables.

- Assume that after the last day, **no profit can be made**.
- Traverse the days **from the last day to the first day**.
- For each day, calculate the best profit for:
  - **Buy state**
  - **Sell state**
- While calculating, use only the stored values of:
  - The **next day**
  - The **day after next** (needed due to cooldown).
- After computing today’s values, **shift the stored results** so they act as future values for the next iteration.

### Final Answer:
- After finishing the backward traversal, the stored value corresponding to **day 0 with buy allowed** gives the maximum profit.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;
class Solution{
int stockProfit(vector<int> &Arr) {
    int n = Arr.size();
    
    // Initialize three arrays to track the maximum profit for buying and selling
    vector<int> cur(2, 0);       // Current maximum profit
    vector<int> front1(2, 0);    // Maximum profit one step ahead
    vector<int> front2(2, 0);    // Maximum profit two steps ahead
    
    for (int ind = n - 1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            int profit;

            if (buy == 0) { // We can buy the stock
                profit = max(0 + front1[0], -Arr[ind] + front1[1]);
            }

            if (buy == 1) { // We can sell the stock
                profit = max(0 + front1[1], Arr[ind] + front2[0]);
            }
            
            cur[buy] = profit;
        }
        
        // Update the 'front1' and 'front2' arrays with current values
        front2 = front1;
        front1 = cur;
    }
    
    return cur[0]; // Return the maximum profit for buying.
}

int main() {
    vector<int> prices {4, 9, 0, 4, 10};
                                 
    cout << "The maximum profit that can be generated is " << stockProfit(prices) << endl;
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N*2). Two nested loops account for O(N*2) complexity
- **Space Complexity:** O(1). We are using three external arrays of size ‘2’.
