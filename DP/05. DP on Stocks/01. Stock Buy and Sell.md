## Stock Buy and Sell | (DP-35)

**Problem Statement:**
We are given an array `Arr[]` of length `n`, where `Arr[i]` represents the price of a stock on the `i-th` day.

The following rules apply:
1. We can **buy and sell the stock only once**.
2. We must **buy before selling** (i.e., the selling day must be the same or after the buying day).

Our task is to find the **maximum profit** that can be obtained from a single buy and sell operation.

---

>### Examples:

### Example 1:
**Input:**  
`prices = [7, 1, 5, 3, 6, 4]`

**Output:** `5`

**Explanation:**  
Buy on day 2 (price = `1`) and sell on day 5 (price = `6`).  
Profit = `6 - 1 = 5`.

---

### Example 2:
**Input:**  
`prices = [7, 6, 4, 3, 1]`

**Output:** `0`

**Explanation:**  
Prices keep decreasing, so no profitable transaction is possible.  
Hence, profit = `0`.

---


## Brute Force Approach

### Algorithm:
To calculate the maximum profit by buying and selling the stock once, we consider **all possible pairs of buy and sell days**.

1. Initialize a variable `maxProfit` with `0`.
2. Iterate over the array with index `i` from `0` to `n-2` (buying day).
3. For each `i`, iterate with index `j` from `i+1` to `n-1` (selling day).
4. Calculate  
   `profit = prices[j] - prices[i]`.
5. If `profit > maxProfit`, update `maxProfit`.
6. After checking all `(i, j)` pairs, return `maxProfit`.

This approach is straightforward but inefficient due to redundant comparisons.


### C++ Code:
``` 
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the maximum profit using brute force
    int maxProfit(vector<int>& prices) {
        // Variable to store the maximum profit
        int maxProfit = 0;

        // Iterate over all pairs (i, j) such that i < j
        for (int i = 0; i < prices.size(); i++) {
            for (int j = i + 1; j < prices.size(); j++) {
                // Calculate profit by buying on day i and selling on day j
                int profit = prices[j] - prices[i];

                // Update maxProfit if this profit is higher
                maxProfit = max(maxProfit, profit);
            }
        }

        // Return the maximum profit
        return maxProfit;
    }
};

// Driver code
int main() {
    Solution obj;
    vector<int> prices = {7, 1, 5, 3, 6, 4};

    cout << obj.maxProfit(prices) << endl;  // Output: 5

    return 0;
}
```

### Complexity Analysis:

### Time Complexity:
**O(n²)**  
We iterate over all possible pairs of days using two nested loops.  
For each day `i`, we check every future day `j`, resulting in  
`n(n − 1) / 2` comparisons, which is quadratic in nature.

### Space Complexity:
**O(1)**  
Only constant extra space is used (variables like `maxProfit` and `profit`).  
No additional data structures are required.

---

## Optimal Approach

### Algorithm:
- Traverse the stock prices array only once.
- Maintain a variable `minPrice` to store the lowest price seen so far.
- Maintain a variable `maxProfit` to store the maximum profit.
- For each day:
  - Update `minPrice` if the current price is lower.
  - Calculate the profit by selling on the current day:  
    `profit = currentPrice - minPrice`.
  - Update `maxProfit` if this profit is greater than the current maximum.
- After completing the traversal, return `maxProfit` as the final answer.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find maximum profit from one buy and one sell
    int maxProfit(vector<int>& prices) {
        // Initialize minimum price to a very large number
        int minPrice = INT_MAX;

        // Initialize max profit to 0
        int maxProfit = 0;

        // Traverse through each day's price
        for (int i = 0; i < prices.size(); i++) {
            // If the current price is less than the minimum seen so far, update minPrice
            if (prices[i] < minPrice)
                minPrice = prices[i];

            // Calculate profit if stock is sold today
            int profit = prices[i] - minPrice;

            // Update maxProfit if the profit today is better than before
            if (profit > maxProfit)
                maxProfit = profit;
        }

        // Return the best profit found
        return maxProfit;
    }
};

// Driver code
int main() {
    Solution obj;
    vector<int> prices = {7, 1, 5, 3, 6, 4};
    cout << "Maximum Profit: " << obj.maxProfit(prices) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(n)`  
  We iterate through the prices array only once.

- **Space Complexity:** `O(1)`  
  Only constant extra space is used for variables like `minPrice` and `maxProfit`.
