## Buy and Sell Stock – IV | (DP-38)

**Problem Statement:**   
We are given an array `Arr[]` of length `n`, where each element represents the price of a stock on a given day.

The following rules apply:
- We can buy and sell the stock **any number of times**.
- To sell a stock, we must first buy it on the same day or on a previous day.
- We cannot buy a new stock before selling the previously bought stock.
- At most **K transactions** are allowed.
  - One transaction = one **buy + one sell**.

Our task is to find the **maximum profit** that can be achieved under these constraints.

---

>### Examples:

### Example 1:
**Input:**
Arr = {3, 3, 5, 0, 0, 1, 4}
K = 2
**Output:**  6
**Explanation:**
- Buy on day 3 at price `0`, sell on day 5 at price `3` → profit = `3`
- Buy on day 6 at price `1`, sell on day 7 at price `4` → profit = `3`
- Total profit = `3 + 3 = 6`

---
## Approach - Recursive

### Intuition:
On each day, we have choices based on:
- **Day index**
- **Whether we are allowed to buy or must sell**
- **How many transactions are still allowed (K)**

We try **all possible valid choices** and take the maximum profit.

### State Definition:
`f(day, buy, cap)`  
- `day` → current day index  
- `buy` → `1` if we are allowed to buy, `0` if we must sell  
- `cap` → remaining transactions  

### Base Cases:
- If `day == n` → no days left → profit = `0`
- If `cap == 0` → no transactions left → profit = `0`

### Recursive Choices:
- **If we can buy (`buy == 1`)**
  - Skip the day → `f(day+1, 1, cap)`
  - Buy the stock → `-price[day] + f(day+1, 0, cap)`

- **If we must sell (`buy == 0`)**
  - Skip the day → `f(day+1, 0, cap)`
  - Sell the stock → `price[day] + f(day+1, 1, cap-1)`

Take the **maximum** of the two choices.

### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

int solve(int day, int buy, int cap, vector<int>& prices, int n) {
    // Base cases
    if (day == n || cap == 0)
        return 0;

    if (buy == 1) {
        return max(
            solve(day + 1, 1, cap, prices, n),              // skip
            -prices[day] + solve(day + 1, 0, cap, prices, n) // buy
        );
    } else {
        return max(
            solve(day + 1, 0, cap, prices, n),               // skip
            prices[day] + solve(day + 1, 1, cap - 1, prices, n) // sell
        );
    }
}

int maxProfit(int k, vector<int>& prices) {
    int n = prices.size();
    return solve(0, 1, k, prices, n);
}
```
### Complexity Analysis:

### Time Complexity: **O(2^N)** (Exponential)
- Each day, we try two choices (take action or skip).
- This branching continues recursively for all `N` days.
- Even though `K` limits transactions, recursion still explores an exponential number of paths.

### Space Complexity: **O(N)**
- Due to the recursion call stack.
- In the worst case, the recursion depth goes up to `N` days.
- No extra DP table is used in pure recursion.

---

## Approach - Memoization

### Intuition:
This problem is an extension of **Buy and Sell Stock III**, where instead of only 2 transactions, we are allowed **up to K transactions**.  
On each day, we decide whether to **take an action (buy/sell)** or **skip the day**.  
To get the maximum profit, we explore all possible choices using recursion and optimize it using memoization.

We define the state using three parameters:
- `day` → current day index
- `buy` → whether we are allowed to buy (`1`) or need to sell (`0`)
- `cap` → number of transactions remaining

### Choices:
- **If we can buy (`buy == 1`)**:
  - Skip the day → move to next day with same state
  - Buy the stock → profit decreases, move to next day with `buy = 0`

- **If we need to sell (`buy == 0`)**:
  - Skip the day → move to next day with same state
  - Sell the stock → profit increases, one transaction is completed (`cap - 1`), move to next day with `buy = 1`

We return the **maximum profit** from these choices.

### Base Cases:
- If `day == n` (all days are finished) → return `0`
- If `cap == 0` (no transactions left) → return `0`

### Memoization:
- Use a **3D DP table** `dp[day][buy][cap]` to store results of subproblems.
- Before computing a state, check if it is already stored in `dp`.
- If yes, return the stored value to avoid recomputation.
- Otherwise, compute the result, store it in `dp`, and return it.

This optimization reduces redundant recursive calls and makes the solution efficient.

### C++ Code:
``` cpp

#include <bits/stdc++.h>
using namespace std;
class StockBuySell{
int getAns(vector& Arr, int n, int ind, int buy, int cap, vector>>& dp) {
    // Base case
    if (ind == n || cap == 0) return 0;

    // Check if the result is already computed
    if (dp[ind][buy][cap] != -1)
        return dp[ind][buy][cap];

    int profit;

    if (buy == 0) { // We can buy the stock
        profit = max(0 + getAns(Arr, n, ind + 1, 0, cap, dp),
                     -Arr[ind] + getAns(Arr, n, ind + 1, 1, cap, dp));
    }

    if (buy == 1) { // We can sell the stock
        profit = max(0 + getAns(Arr, n, ind + 1, 1, cap, dp),
                     Arr[ind] + getAns(Arr, n, ind + 1, 0, cap - 1, dp));
    }

    // Store the result in the DP array and return
    return dp[ind][buy][cap] = profit;
}

int maximumProfit(vector& prices, int n, int k) {
    // Creating a 3D DP array of size [n][2][k+1]
    vector>> dp(n, vector>(2, vector(k + 1, -1)));

    return getAns(prices, n, 0, 0, k, dp);
}

int main() {
    vector prices = {3, 3, 5, 0, 0, 3, 1, 4};
    int n = prices.size();
    int k = 2;

    cout << "The maximum profit that can be generated is " << maximumProfit(prices, n, k) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*2*3) ,There are N*2*3 states therefore at max ‘N*2*3’ new problems will be solved.
- **Space Complexity:** O(N*2*3) + O(N), We are using a recursion stack space(O(N)) and a 3D array ( O(N*2*3)).

---

## Approach - Tabulation
### Algorithm:

We convert the memoization solution into a **bottom-up tabulation** method by creating a **3D DP table** to store results for all states.

---

### DP State:
`dp[day][buy][cap]` represents the **maximum profit** we can achieve starting from:
- `day` → current day index  
- `buy` → whether we are allowed to buy (`1`) or need to sell (`0`)  
- `cap` → number of transactions remaining  

---

### Base Cases:
- If all days are finished (`day == n`) → profit is `0`
- If no transactions are left (`cap == 0`) → profit is `0`

To handle these, we **initialize the entire DP table with 0**.

---

### Filling the DP Table:
- Iterate **days from last to first**.
- For each day, iterate over:
  - both states of `buy` (`0` and `1`)
  - all possible transaction counts from `1` to `K`
- For each state:
  - **If `buy == 1`**:
    - Skip the day
    - Buy the stock  
    Take the maximum of the two.
  - **If `buy == 0`**:
    - Skip the day
    - Sell the stock (reduces `cap` by 1)  
    Take the maximum of the two.
- Store the result in `dp[day][buy][cap]`.

---

### Final Answer:
The result is stored in:

dp[0][1][K]

This represents the maximum profit starting from **day 0**, when we are **allowed to buy**, with **K transactions available**.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;
class StockBuySell{
int maximumProfit(vector& Arr, int n, int k) {
    // Creating a 3D DP array of size [n+1][2][k+1] initialized to 0
    vector>> dp(n + 1,
                                    vector>(2, vector(k + 1, 0)));

    // Loop through the stock prices from the end to the beginning
    for (int ind = n - 1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            for (int cap = 1; cap <= k; cap++) {
                if (buy == 0) { // We can buy the stock
                    dp[ind][buy][cap] = max(0 + dp[ind + 1][0][cap],
                                -Arr[ind] + dp[ind + 1][1][cap]);
                }

                if (buy == 1) { // We can sell the stock
                    dp[ind][buy][cap] = max(0 + dp[ind + 1][1][cap],
                                Arr[ind] + dp[ind + 1][0][cap - 1]);
                }
            }
        }
    }

    return dp[0][0][k];
}

int main() {
    vector prices = {3, 3, 5, 0, 0, 3, 1, 4};
    int n = prices.size();
    int k = 2;

    cout << "The maximum profit that can be generated is " << maximumProfit(prices, n, k) << endl;
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N*2*3), There are three nested loops that account for O(N*2*3) complexity.
- **Space Complexity:** O(N*2*3), We are using an external array of size ‘N*2*3’. Stack Space is eliminated.

---
## Approach - Space Optimized
### Algorithm:

In the tabulation approach, each DP state depends **only on the next day’s values**. Therefore, we do **not** need to store the entire 3D DP table.

### Key Observation:
For any day:
- `dp[day][buy][cap]` depends only on `dp[day+1][...]`

So, we only need **two 2D tables**:
- `ahead` → represents DP values for the next day  
- `cur` → represents DP values for the current day  

Each table has dimensions `[2][K+1]`.

### Steps:

1. Initialize the `ahead` table with `0`  
   - This handles the base case: no profit after the last day.

2. Traverse days from **last to first**.

3. For each day:
   - Iterate over `buy = 0, 1`
   - Iterate over `cap = 1` to `K`
   - Compute `cur[buy][cap]` using values from `ahead`:
     - If `buy == 1` → choose between skipping or buying
     - If `buy == 0` → choose between skipping or selling

4. After finishing calculations for the current day:
   - Copy `cur` into `ahead` for the next iteration.

### Final Answer:
After processing all days, the result is stored in:



### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class StockBuySell{
int maximumProfit(vector& Arr, int n, int k) {
    // Creating a 3D DP array of size [n+1][2][k+1] initialized to 0
    vector>> dp(n + 1,
    vector>(2, vector(k + 1, 0)));

    // Loop through the stock prices from the end to the beginning
    for (int ind = n - 1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            for (int cap = 1; cap <= k; cap++) {
                if (buy == 0) { // We can buy the stock
                    dp[ind][buy][cap] = max(0 + dp[ind + 1][0][cap],
                                -Arr[ind] + dp[ind + 1][1][cap]);
                }

                if (buy == 1) { // We can sell the stock
                    dp[ind][buy][cap] = max(0 + dp[ind + 1][1][cap],
                                Arr[ind] + dp[ind + 1][0][cap - 1]);
                }
            }
        }
    }

    return dp[0][0][k];
}

int main() {
    vector prices = {3, 3, 5, 0, 0, 3, 1, 4};
    int n = prices.size();
    int k = 2;

    cout << "The maximum profit that can be generated is " << maximumProfit(prices, n, k) << endl;
    return 0;
}
```

### Complexity Analysis:
- **Time Complexity:** O(N*2*3), There are three nested loops that account for O(N*2*3) complexity
- **Space Complexity:** O(1), We are using two external arrays of size ‘2*3’.
