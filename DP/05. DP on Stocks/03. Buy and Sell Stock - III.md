## Buy and Sell Stock – III | (DP - 37)

**Problem Statement:**
We are given an array `Arr[]` of length `n`, where `Arr[i]` represents the price of a stock on the `i-th` day.

We must follow these rules:
- We can buy and sell the stock multiple times.
- A stock must be bought before it can be sold.
- After selling a stock, we are allowed to buy again.
- **At most 2 transactions** are allowed (each transaction = 1 buy + 1 sell).

Our task is to find the **maximum profit** that can be achieved under these constraints.

-
### Key Observations:
- Each transaction consists of one **buy** followed by one **sell**.
- Since only **2 transactions** are allowed, the total number of actions is limited.
- On each day, we can either:
  - Do nothing
  - Buy a stock
  - Sell a stock
- The decision depends on:
  - The current day
  - Whether we are allowed to buy or must sell
  - How many transactions are left

### State Representation (DP Idea):
A common DP state can be represented as:

`dp[day][buy][cap]`

Where:
- `day` → current day index
- `buy` → `1` if we are allowed to buy, `0` if we must sell
- `cap` → number of transactions remaining (max = 2)


### Goal:
Compute the maximum profit starting from day `0`, with:
- `buy = 1` (we can buy initially)
- `cap = 2` (two transactions allowed)


### Output:
Return the maximum profit that can be achieved following all rules.

---

>### Example:

### Example 1:
**Input:**  
`prices = [3,3,5,0,0,3,1,4]`

**Output:** `6`

**Explanation:**  
- Buy at price `0`, sell at `3` → profit = `3`
- Buy at price `1`, sell at `4` → profit = `3`
- Total profit = `6`


This problem is a classic extension of **Buy and Sell Stock I & II**, adding a **transaction limit**, which makes it a perfect candidate for **Dynamic Programming**.


---
## Approach - Recursive

### Intuition:
On each day, we have two possible states:
- **Buy allowed** → we can either buy or skip
- **Sell allowed** → we can either sell or skip  

Additionally, we are allowed **at most 2 transactions**.  
Each **sell** consumes one transaction.

We try **all possible choices recursively** and return the maximum profit.

---

### Recursive State:
`solve(day, buy, cap)`

Where:
- `day` → current index in prices array
- `buy` → `1` if we are allowed to buy, `0` if we must sell
- `cap` → remaining transactions (max = 2)

---

### Base Cases:
- If `day == n` → no more days left → return `0`
- If `cap == 0` → no transactions left → return `0`

---

### Choices:
#### If we are allowed to buy (`buy == 1`)
- **Skip** → move to next day
- **Buy** → subtract price and move to sell state

#### If we must sell (`buy == 0`)
- **Skip** → move to next day
- **Sell** → add price, reduce transaction count

---

### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

int solve(int day, int buy, int cap, vector<int>& prices) {
    // Base cases
    if (day == prices.size() || cap == 0)
        return 0;

    if (buy == 1) {
        // Option 1: Skip
        int skip = solve(day + 1, 1, cap, prices);

        // Option 2: Buy
        int take = -prices[day] + solve(day + 1, 0, cap, prices);

        return max(skip, take);
    } else {
        // Option 1: Skip
        int skip = solve(day + 1, 0, cap, prices);

        // Option 2: Sell
        int sell = prices[day] + solve(day + 1, 1, cap - 1, prices);

        return max(skip, sell);
    }
}

int maxProfit(vector<int>& prices) {
    return solve(0, 1, 2, prices);
}
```
### Complexity Analysis:

### Time Complexity: **O(2ⁿ)**  
Each day, we have two choices (take action or skip), and we explore all possible combinations recursively. Since there is **no memoization**, many subproblems are recomputed, leading to exponential time complexity.

### Space Complexity: **O(N)**  
The space is used only by the **recursion stack**, which can go as deep as `N` (number of days) in the worst case. No extra DP table is used.


---

## Approach - Memoization


### Intuition:
Every day, we decide whether to **trade or skip** based on:
- the current **day index**,
- whether we are allowed to **buy or must sell**,
- and how many **transactions are remaining**.

To maximize profit, we explore all valid choices and pick the one giving the highest profit.

### Decision Making:
- **If we can buy**:
  - Skip the day → move to next day.
  - Buy the stock → profit decreases by price, move to the next day.
- **If we must sell**:
  - Skip the day → move to next day.
  - Sell the stock → profit increases by price and one transaction is completed.


### Base Cases:
- If all days are processed → return `0`.
- If no transactions are left → return `0`.

### Memoization:
- Use a DP table to store results for each state:
  - `(day, buy/sell state, remaining transactions)`
- If a state is already computed, reuse the stored value instead of recalculating.


### C++ Code:
``` cpp

#include <bits/stdc++.h>
using namespace std;
class StockProfit{
int getAns(vector<int>& Arr, int n, int ind, int buy, int cap, vector<vector<vector<int>>>& dp) {
    // Base case: If we reach the end of the array or run out of allowed transactions, return 0.
    if (ind == n || cap == 0)
        return 0;

    // If the result is already calculated, return it.
    if (dp[ind][buy][cap] != -1)
        return dp[ind][buy][cap];

    int profit;

    if (buy == 0) { // We can buy the stock
        profit = max(0 + getAns(Arr, n, ind + 1, 0, cap, dp),
                     -Arr[ind] + getAns(Arr, n, ind + 1, 1, cap, dp));
    }

    if (buy == 1) { // We can sell the stock
        profit = max(0 + getAns(Arr, n, ind + 1, 1, cap, dp),
                     Arr[ind] + getAns(Arr, n, ind + 1, 0, cap - 1, dp));
    }

    // Store and return the calculated profit.
    return dp[ind][buy][cap] = profit;
}

int maxProfit(vector<int>& prices, int n) {
    // Creating a 3D DP array of size [n][2][3]
    vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(3, -1)));

    // Call the recursive function to calculate maximum profit
    return getAns(prices, n, 0, 0, 2, dp);
}

int main() {
    vector<int> prices = {3, 3, 5, 0, 0, 3, 1, 4};
    int n = prices.size();

    // Call the maxProfit function and print the result
    cout << "The maximum profit that can be generated is " << maxProfit(prices, n);

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(N*2*3) , There are N*2*3 states therefore at max ‘N*2*3’ new problems will be solved.

- **Space Complexity:** O(N*2*3) + O(N) , We are using a recursion stack space(O(N)) and a 3D array ( O(N*2*3)).

---
## Approach - Tabulation
### Algorithm:
We convert the memoization solution into a **bottom-up DP** approach by building a **3D DP table** for:
- day index
- buy/sell state
- remaining transactions

### Base Cases:
- If all days are completed → profit = `0`
- If no transactions are left → profit = `0`

To handle this, initialize the entire DP table with `0`.

### Filling the DP Table:
- Iterate from the **last day to the first day**
- For each day:
  - Try both states (**can buy / must sell**)
  - Try both actions:
    - Skip the day
    - Perform buy or sell
- Store the **maximum profit** of the choices in the DP table

### Final Answer:
The result is stored at:
dp[0][1][2]

which represents:
- Day `0`
- Buying is allowed
- `2` transactions remaining

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;
class StockProfit{
int maxProfit(vector<int>& Arr, int n) {
    // Creating a 3D DP array of size [n+1][2][3] initialized to 0
    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2, vector<int>(3, 0)));

    // Base case: dp array is already initialized to 0, covering the base case.

    for (int ind = n - 1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            for (int cap = 1; cap <= 2; cap++) {
                if (buy == 0) { // We can buy the stock
                    dp[ind][buy][cap] = max(0 + dp[ind + 1][0][cap],
                                           -Arr[ind] + dp[ind + 1][1][cap]);
                }

                if (buy == 1) { // We can sell the stock
                    dp[ind][buy][cap] = max(0 + dp[ind + 1][1][cap],
                                           Arr[ind] + dp[ind + 1][0][cap - 1]);
                }
            }
        }
    }

    // The result is stored in dp[0][0][2] which represents maximum profit after the final transaction.
    return dp[0][0][2];
}

int main() {
    vector<int> prices = {3, 3, 5, 0, 0, 3, 1, 4};
    int n = prices.size();

    // Call the maxProfit function and print the result
    cout << "The maximum profit that can be generated is " << maxProfit(prices, n);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*2*3) There are three nested loops that account for O(N*2*3) complexity.
- **Space Complexity:** O(N*2*3), We are using an external array of size ‘N*2*3’. Stack Space is eliminated.

---
## Approach - Space Optimized
### Algorithm:
Since each day’s DP values depend only on the **next day**, we can optimize space by avoiding the full 3D DP table.

### Space Optimization:
- Maintain two 2D tables:
  - **ahead** → stores DP values for the next day
  - **cur** → stores DP values for the current day
- Initialize **ahead** with `0`, as profit is `0` after the last day.
- For each day (iterate from last to first):
  - Compute all states using values from **ahead**
  - Store results in **cur**
  - Copy **cur** into **ahead** for the next iteration
- Repeat until day `0` is processed.


### Final Answer:
The result is stored in:
ahead[1][2]

which represents:
- Buying allowed
- `2` transactions remaining

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;
class StockProfit{
int maxProfit(vector<int>& Arr, int n) {
    // Create two 2D arrays to store the profit information, one for the current state and one for the next state.
    vector<vector<int>> ahead(2, vector<int>(3, 0));
    vector<vector<int>> cur(2, vector<int>(3, 0));

    for (int ind = n - 1; ind >= 0; ind--) {
        for (int buy = 0; buy <= 1; buy++) {
            for (int cap = 1; cap <= 2; cap++) {
                if (buy == 0) { // We can buy the stock
                    cur[buy][cap] = max(0 + ahead[0][cap], 
                                        -Arr[ind] + ahead[1][cap]);
                }

                if (buy == 1) { // We can sell the stock
                    cur[buy][cap] = max(0 + ahead[1][cap],
                                        Arr[ind] + ahead[0][cap - 1]);
                }
            }
        }
        // Update the ahead state with the current state for the next iteration.
        ahead = cur;
    }

    return ahead[0][2];
}

int main() {
    vector<int> prices = {3, 3, 5, 0, 0, 3, 1, 4};
    int n = prices.size();

    // Call the maxProfit function and print the result
    cout << "The maximum profit that can be generated is " << maxProfit(prices, n);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*2*3). Three nested loops account for O(N*2*3) complexity
- **Space Complexity:** O(1). We are using two external arrays of size ‘2*3’.

