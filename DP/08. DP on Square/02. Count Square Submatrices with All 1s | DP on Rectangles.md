## Count Square Submatrices with All 1s | DP on Rectangles : DP 56

**Problem Statement:**   
Given an $n \times m$ matrix of ones and zeros, return how many square submatrices have all ones.

---

>### Examples:

### Example 1:
* **Input:** ```
    matrix = [[0,1,1,1],
              [1,1,1,1],
              [0,1,1,1]]
    ```
* **Output:** `15`
* **Explanation:** * Squares of size 1: 10
    * Squares of size 2: 4
    * Squares of size 3: 1
    * Total = $10 + 4 + 1 = 15$.

### Example 2:
* **Input:**
    ```
    matrix = [[1,0,1],
              [1,1,0],
              [1,1,0]]
    ```
* **Output:** `7`

---

## Approach

### Algorithm:

Instead of brute-forcing every possible square, we use Dynamic Programming to count squares ending at each cell $(i, j)$.

1.  **Define DP State:** `dp[i][j]` represents the size of the largest square submatrix whose bottom-right corner is the cell $(i, j)$.
2.  **Base Case (Initialization):**
    * The first row and first column of the `dp` table are the same as the input matrix. A cell in the first row/column can at most be a square of size 1.
3.  **Transitions:**
    * If `matrix[i][j] == 0`, then `dp[i][j] = 0`.
    * If `matrix[i][j] == 1`, then:
        $$dp[i][j] = 1 + \min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])$$
    * **Logic:** To form a square of size $k$ at $(i, j)$, there must be squares of at least size $k-1$ to its top, left, and top-left diagonal.
4.  **Final Result:** The total number of square submatrices is the **sum of all values** in the `dp` table. This is because if the largest square ending at $(i, j)$ has side $k$, it automatically includes $k$ squares (of sizes $1 \times 1, 2 \times 2, \dots, k \times k$).



### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int countSquares(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        
        // DP table initialization
        vector<vector<int>> dp(n, vector<int>(m, 0));
        
        // Base cases: Fill first row and first column
        for (int i = 0; i < n; i++) dp[i][0] = matrix[i][0];
        for (int j = 0; j < m; j++) dp[0][j] = matrix[0][j];
        
        // Fill the rest of the DP table
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (matrix[i][j] == 0) {
                    dp[i][j] = 0;
                } else {
                    dp[i][j] = 1 + min({dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]});
                }
            }
        }
        
        // Sum all values in the DP table
        int totalSquares = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                totalSquares += dp[i][j];
            }
        }
        
        return totalSquares;
    }
};

int main() {
    vector<vector<int>> matrix = {{0, 1, 1, 1}, {1, 1, 1, 1}, {0, 1, 1, 1}};
    Solution sol;
    cout << "Total square submatrices: " << sol.countSquares(matrix) << endl;
    return 0;
}
```
### Complexity Analysis:

* **Time Complexity:** $O(N \times M)$
    * **Explanation:** We iterate through the $N \times M$ matrix to fill the DP table. For each cell $(i, j)$, we perform a constant time $O(1)$ operation to find the minimum of three neighbors. A second pass (or simultaneous sum) to aggregate the total squares also takes $O(N \times M)$.

* **Space Complexity:** $O(N \times M)$
    * **Explanation:** We maintain a 2D DP table of size $N \times M$ to store the largest square size ending at each cell. 

> **Note:** The space complexity can be optimized to $O(M)$ by observing that to calculate the current row, we only need the values from the previous row and the previous cell in the current row.
