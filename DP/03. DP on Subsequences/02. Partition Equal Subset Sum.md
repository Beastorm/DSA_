## Partition Equal Subset Sum

**Problem Description:**   
Given an array `arr` of `n` integers, determine whether it can be partitioned into *two subsets* such that the *sum of elements in both subsets is equal*.

Return `true` if such a partition exists, otherwise return `false`.

**Key Insight:**  
- Let the total sum of the array be `S`
- For two subsets to have equal sum, S must be even
- The problem reduces to checking:

> Is there a subset with sum = `S / 2` ?   
This is exactly the **Subset Sum (DP-14)** problem.

---

>### Examples:

### Example 1:
**Input:** nums = [2, 3, 3, 3, 4, 5]
**Output:** True

**Explanation**
- Total sum = 20
- Target subset sum = 10
- One possible partition: `{2, 3, 5}` and `{3, 3, 4}`

---

### Example 2:
**Input:** nums = [1, 2, 3, 5]
**Output:** False

**Explanation**
- Total sum = 11 (odd)
- Cannot be divided into two equal subsets

---

### Relation to Previous Problem:
- Direct application of **Subset Sum Equal to Target**
- Uses the same DP logic (recursive, memoization, tabulation, or space-optimized)
---

## Approach - Recursive:

### Intuition:
- If we split the array into two subsets with **equal sum**, then:
sum(subset1) = sum(subset2)

- This means the **total sum of the array must be even**
- So the problem reduces to:

> Can we find a subset with sum = (total sum / 2)?

This is exactly the **Subset Sum** problem.

### Algorithm:

1. **Compute total sum** of the array
2. If total sum is **odd**, return `false`
3. Set `target = totalSum / 2`
4. Use recursion to check if any subset sums to `target`

### Recursive Logic:
At each index, we have two choices:
- **Pick** the current element → reduce target
- **Not pick** the current element → target remains same

### Base Cases:
- If `target == 0` → subset found → return `true`
- If `index == 0` → return `arr[0] == target`


### Final Answer:
- If a subset with sum `target` exists → return `true`
- Else → return `false`

### Key Insight:
- Problem transforms into **Subset Sum**
- Uses **pick / not pick** recursion
- Can be optimized using **DP**

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function to check subset sum
bool subsetSum(int ind, int target, vector<int>& arr) {
    // Base cases
    if (target == 0) 
        return true;

    if (ind == 0) 
        return arr[0] == target;

    // Not take the current element
    bool notTake = subsetSum(ind - 1, target, arr);

    // Take current element (if possible)
    bool take = false;
    if (arr[ind] <= target) {
        take = subsetSum(ind - 1, target - arr[ind], arr);
    }

    return take || notTake;
}

// Driver function
bool canPartition(vector<int>& arr) {
    int totalSum = accumulate(arr.begin(), arr.end(), 0);

    // If the total sum is odd, partition is not possible
    if (totalSum % 2 != 0)
        return false;

    int target = totalSum / 2;
    return subsetSum(arr.size() - 1, target, arr);
}

int main() {
    vector<int> nums1 = {2, 3, 3, 3, 4, 5};
    vector<int> nums2 = {1, 2, 3, 5};

    cout << (canPartition(nums1) ? "True" : "False") << endl;
    cout << (canPartition(nums2) ? "True" : "False") << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(2^N)**  
  - Each element has two choices: pick or not pick  
  - All possible subsets are explored in the worst case  

- **Space Complexity:** **O(N)**  
  - Maximum recursion depth is `N`  
  - No extra data structures are used  

### Note:
- This is the **pure recursive approach**
- Using **memoization or DP**, time complexity can be reduced to **O(N × (Sum/2))**


---

## Memoization Approach

### Core Idea:
To partition the array into two subsets with equal sum, we only need to check whether **one subset** exists with sum equal to **half of the total array sum**.

### Algorithm:

1. **Calculate Total Sum:**
   - Compute the sum of all elements in the array
   - If the sum is **odd**, return `false` (equal partition not possible)

2. **Define Target:**
   - Set:
     ```
     target = totalSum / 2
     ```

3. **Recursive Function:**
   - Define:
     ```
     f(index, remainingSum)
     ```
     which returns `true` if a subset from `index` to the end can form `remainingSum`

4. **Base Cases:**
   - If `remainingSum == 0` → return `true`
   - If `index < 0` or `remainingSum < 0` → return `false`

5. **Choices at Each Step:**
   - **Include** current element:
     ```
     f(index-1, remainingSum - arr[index])
     ```
   - **Exclude** current element:
     ```
     f(index-1, remainingSum)
     ```

6. **Memoization:**
   - Use a 2D DP table `dp[index][remainingSum]`
   - If a state is already computed, return it directly
   - Store the result before returning

7. **Initial Call:**
   - f(n-1, target)

### Key Insight:
- This problem is a **direct application of Subset Sum**
- Memoization avoids repeated calculations
- Time complexity reduces significantly compared to pure recursion

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to check if it's possible to partition the array into two subsets with equal sum
bool subsetSumUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
    // Base case: If the target sum is 0, we found a valid partition
    if (target == 0)
        return true;

    // Base case: If we have considered all elements and the target is still not 0, return false
    if (ind == 0)
        return arr[0] == target;

    // If the result for this state is already calculated, return it
    if (dp[ind][target] != -1)
        return dp[ind][target];

    // Recursive cases
    // 1. Exclude the current element
    bool notTaken = subsetSumUtil(ind - 1, target, arr, dp);

    // 2. Include the current element if it doesn't exceed the target
    bool taken = false;
    if (arr[ind] <= target)
        taken = subsetSumUtil(ind - 1, target - arr[ind], arr, dp);

    // Store the result in the DP table and return
    return dp[ind][target] = notTaken || taken;
}

// Function to check if the array can be partitioned into two equal subsets
bool canPartition(int n, vector<int>& arr) {
    int totSum = 0;

    // Calculate the total sum of the array
    for (int i = 0; i < n; i++) {
        totSum += arr[i];
    }

    // If the total sum is odd, it cannot be partitioned into two equal subsets
    if (totSum % 2 == 1)
        return false;
    else {
        int k = totSum / 2;

        // Create a DP table with dimensions n x k+1 and initialize with -1
        vector<vector<int>> dp(n, vector<int>(k + 1, -1));

        // Call the subsetSumUtil function to check if it's possible to partition
        return subsetSumUtil(n - 1, k, arr, dp);
    }
}

int main() {
    vector<int> arr = {2, 3, 3, 3, 4, 5};
    int n = arr.size();

    if (canPartition(n, arr))
        cout << "The Array can be partitioned into two equal subsets";
    else
        cout << "The Array cannot be partitioned into two equal subsets";

    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** **O(N × K)**  
  - Each DP state is defined by `(index, remainingSum)`
  - There are at most `N × K` unique states  
  - Each state is computed only once due to memoization  

- **Space Complexity:** **O(N × K) + O(N)**  
  - `O(N × K)` for the memoization table  
  - `O(N)` for the recursion stack space  
  
**Where:**
  - `N` = number of elements in the array  
  - `K` = target sum (`totalSum / 2`)


---


## Tabulation Approach

### Algorithm:

1. **Reduce to Subset Sum:**
   - Compute the total sum of the array
   - If the sum is **odd**, return `false`
   - Set:
     ```
     target = totalSum / 2
     ```

2. **DP Table Setup:**
   - Create a 2D boolean DP table:
     ```
     dp[n][target + 1]
     ```
   - Initialize all values to `false`

3. **Base Case Initialization:**
   - Set the first column to `true`:
     ```
     dp[i][0] = true   for all i
     ```
     (Target sum `0` is always achievable)
   - For the first row:
     ```
     if arr[0] ≤ target:
         dp[0][arr[0]] = true
     ```

4. **Fill the DP Table:**
   - Iterate `i` from `1` to `n-1`
   - Iterate `t` from `1` to `target`
   - Apply pick / not-pick logic:
     ```
     notPick = dp[i-1][t]
     pick = (arr[i] ≤ t) ? dp[i-1][t - arr[i]] : false
     dp[i][t] = pick || notPick
     ```

5. **Final Answer:**
   - The result is stored at:
     ```
     dp[n-1][target]
     ```

---

### Key Insight:
- Eliminates recursion and stack space
- Uses bottom-up DP
- Same logic as memoization, but iterative and efficient


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Determines if the given array can be split into two subsets
    // whose sums are equal using a tabulation DP approach
    bool canPartition(int n, vector<int>& arr) {
        
        // Step 1: Calculate the total sum
        int totalSum = 0;
        for (int i = 0; i < n; i++) {
            totalSum += arr[i];
        }

        // Step 2: If the total sum is odd, the partition is impossible
        if (totalSum % 2 != 0) {
            return false;
        }

        // Step 3: Determine the target sum for each subset
        int targetSum = totalSum / 2;

        // Step 4: Create DP table and initialize
        vector<vector<bool>> dp(n, vector<bool>(targetSum + 1, false));

        // Step 5: Base case: sum 0 is always possible
        for (int i = 0; i < n; i++) {
            dp[i][0] = true;
        }

        // Step 6: Initialize first row
        if (arr[0] <= targetSum) {
            dp[0][arr[0]] = true;
        }

        // Step 7: Fill DP table
        for (int index = 1; index < n; index++) {
            for (int target = 1; target <= targetSum; target++) {
                bool notTaken = dp[index - 1][target];
                bool taken = false;
                if (arr[index] <= target) {
                    taken = dp[index - 1][target - arr[index]];
                }
                dp[index][target] = notTaken || taken;
            }
        }

        // Step 8: Return result
        return dp[n - 1][targetSum];
    }
};

int main() {
    vector<int> arr = {2, 3, 3, 3, 4, 5};
    int n = arr.size();
    Solution solver;

    if (solver.canPartition(n, arr)) {
        cout << "The array can be partitioned into two equal subsets";
    } else {
        cout << "The array cannot be partitioned into two equal subsets";
    }
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** **O(N × K)**  
  - The DP table has `N × K` states  
  - Each state is computed once using constant-time transitions  
  
  Where:
  - `N` = number of elements in the array  
  - `K` = target sum (`totalSum / 2`)

- **Space Complexity:** **O(N × K)**  
  - A 2D DP array of size `N × K` is used  
  - No recursion stack is required

---

## Space Optimization

### Algorithm:
- Relation:  dp[ind][target] = dp[ind-1][target] || dp[ind-1][target - arr[ind]]
- Observation: To compute a cell, only the previous row is needed.

**Steps:**
- Maintain **two 1D arrays**: `prev` (previous row) and `curr` (current row).
- Initialize `prev[0] = true` (sum `0` is always possible).
- For each element in the array:
  - Fill `curr` using values from `prev`.
  - After processing, assign `prev = curr`.
- The final answer is `prev[target]`.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to check if it's possible to partition the array into two subsets with equal sum
bool canPartition(int n, vector<int>& arr) {
    int totSum = 0;

    // Calculate the total sum of the array
    for (int i = 0; i < n; i++) {
        totSum += arr[i];
    }

    // If the total sum is odd, it cannot be partitioned into two equal subsets
    if (totSum % 2 == 1)
        return false;
    else {
        int k = totSum / 2;

        // Create a vector to represent the previous row of the DP table
        vector<bool> prev(k + 1, false);

        // Base case: If the target sum is 0, it can be achieved by not selecting any elements
        prev[0] = true;

        // Initialize the first row based on the first element of the array
        if (arr[0] <= k)
            prev[arr[0]] = true;

        // Fill in the DP table using a bottom-up approach
        for (int ind = 1; ind < n; ind++) {
            // Create a vector to represent the current row of the DP table
            vector<bool> cur(k + 1, false);
            cur[0] = true;

            for (int target = 1; target <= k; target++) {
                // Exclude the current element
                bool notTaken = prev[target];

                // Include the current element if it doesn't exceed the target
                bool taken = false;
                if (arr[ind] <= target)
                    taken = prev[target - arr[ind]];

                // Update the current row of the DP table
                cur[target] = notTaken || taken;
            }

            // Set the current row as the previous row for the next iteration
            prev = cur;
        }

        // The final result is in the last cell of the previous row of the DP table
        return prev[k];
    }
}

int main() {
    vector<int> arr = {2, 3, 3, 3, 4, 5};
    int n = arr.size();

    if (canPartition(n, arr))
        cout << "The Array can be partitioned into two equal subsets";
    else
        cout << "The Array cannot be partitioned into two equal subsets";

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N*K)` — there are `N*K` states, where `N` is the array length and `K` is the target sum (half of total array sum).  
- **Space Complexity:** `O(K)` — we use two 1D arrays of size `K+1` for previous and current row.
