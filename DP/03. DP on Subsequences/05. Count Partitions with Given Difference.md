## Count Partitions with Given Difference

**Problem Statement:**   
Given an array with **N** positive integers and an integer **D**, count the number of ways to partition the array into two subsets **S1** and **S2** such that:

- `S1 - S2 = D`
- `S1 â‰¥ S2`

---

>### Examples:

#### Example 1
**Input:** `arr = [1, 1, 2, 3]`, `diff = 1`  

**Output:** `3`  

**Explanation:**  
Valid partitions are:
- `[1, 2]` and `[1, 3]`
- `[1, 3]` and `[1, 2]`
- `[1, 1, 2]` and `[3]`

---

#### Example 2:
**Input:** `arr = [1, 2, 3, 4]`, `diff = 2`  

**Output:**  `2`  

**Explanation:**  
Valid partitions are:
- `[1, 3]` and `[2, 4]`
- `[1, 2, 3]` and `[4]`

---

## Approach - Recursive 

### Intuition:
We are given the difference between two subsets:
- `S1 - S2 = D`
- `S1 + S2 = totalSum`

By solving these two equations, we get:   
S1 = (totalSum + D) / 2

So instead of forming two subsets directly, the problem becomes:   
ðŸ‘‰ **Count the number of subsets whose sum is equal to `(totalSum + D) / 2`.**   

If `(totalSum + D)` is odd or `totalSum < D`, it is impossible to form such partitions.   
This is now a **subset sum counting problem**.   


### Algorithm:

1. Compute `totalSum` of the array.
2. If `totalSum < D` or `(totalSum + D)` is odd, return `0`.
3. Set `target = (totalSum + D) / 2`.
4. Use recursion to count subsets with sum = `target`:
   - At each index, either **pick** or **not pick** the element.
5. Base cases:
   - If `target == 0`, return `1`.
   - If `index == 0`, return `1` if `arr[0] == target`, else `0`.
6. Return the sum of both choices (pick + not pick).

This counts all valid partitions satisfying the given difference.


### C++ Code:
``` cpp

#include <bits/stdc++.h>
using namespace std;

int countSubsets(int ind, int target, vector<int>& arr) {
    // Base cases
    if (target == 0)
        return 1;
    if (ind == 0)
        return (arr[0] == target);

    // Not take the current element
    int notPick = countSubsets(ind - 1, target, arr);

    // Take current element
    int pick = 0;
    if (arr[ind] <= target)
        pick = countSubsets(ind - 1, target - arr[ind], arr);

    return pick + notPick;
}

int countPartitions(vector<int>& arr, int D) {
    int totalSum = accumulate(arr.begin(), arr.end(), 0);

    // Invalid cases
    if (totalSum < D || (totalSum + D) % 2 != 0)
        return 0;

    int target = (totalSum + D) / 2;
    return countSubsets(arr.size() - 1, target, arr);
}

int main() {
    vector<int> arr = {1, 1, 2, 3};
    int diff = 1;

    cout << countPartitions(arr, diff);
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**   O(2^N)  
  - Each element has two choices (pick or not pick), leading to an exponential number of recursive calls.

- **Space Complexity:**  O(N)  
  - Due to the recursion stack depth, which can go up to `N` in the worst case.

---
## Approach - Memoization

### Intuition:
- At each index, we either **pick** or **not pick** the current element.
- We recursively explore both choices.
- Many subproblems repeat â†’ use **memoization** to store results.
- Each state is defined by `(index, remainingSum)`.

### Algorithm:
1. Compute `totalSum` of the array.
2. If `(totalSum + D)` is odd â†’ return `0` (no valid partition).
3. Set `target = (totalSum + D) / 2`.
4. Define a recursive function `f(ind, target)`:
   - If `target == 0` â†’ return `1`
   - If `ind == 0`:
     - Return `1` if `arr[0] == target`, else `0`
   - If already computed, return stored value.
5. Choices:
   - **Not pick** current element â†’ `f(ind-1, target)`
   - **Pick** current element (if `arr[ind] <= target`) â†’ `f(ind-1, target-arr[ind])`
6. Store and return the sum of both choices.
7. Final answer is `f(n-1, target)`.

### Why Memoization Works?
- Avoids recomputation of overlapping subproblems
- Reduces exponential recursion to polynomial time


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive + Memoization function
int countSubsets(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
    // Base cases
    if (target == 0) return 1;
    if (ind == 0) {
        return (arr[0] == target);
    }

    if (dp[ind][target] != -1)
        return dp[ind][target];

    // Not take current element
    int notTake = countSubsets(ind - 1, target, arr, dp);

    // Take current element (if possible)
    int take = 0;
    if (arr[ind] <= target) {
        take = countSubsets(ind - 1, target - arr[ind], arr, dp);
    }

    return dp[ind][target] = take + notTake;
}

// Main function
int countPartitions(int n, int d, vector<int>& arr) {
    int totalSum = 0;
    for (int x : arr) totalSum += x;

    // (S1 + S2 + D) must be even
    if ((totalSum + d) % 2 != 0) return 0;

    int target = (totalSum + d) / 2;

    vector<vector<int>> dp(n, vector<int>(target + 1, -1));

    return countSubsets(n - 1, target, arr, dp);
}

// Driver code
int main() {
    vector<int> arr = {1, 1, 2, 3};
    int diff = 1;
    int n = arr.size();

    cout << "Number of partitions: "
         << countPartitions(n, diff, arr) << endl;

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** `O(N * K)`  
  - Each state `(index, target)` is computed once, where  
    `N` = number of elements and  `K = (totalSum + D) / 2`.

- **Space Complexity:** `O(N * K) + O(N)`  
  - `O(N * K)` for the memoization DP table  
  - `O(N)` for the recursion stack in the worst case

---

## Tabulation Approach (Bottom-Up DP)

### Intuition:
We want to split the array into two partitions such that the **difference of their sums = d**.

Let:
- Sum of first partition = `S1`
- Sum of second partition = `S2`

Given:
- `S1 - S2 = d`
- `S1 + S2 = totalSum`

Adding both:
2 * S1 = d + totalSum
S1 = (d + totalSum) / 2

So the problem reduces to:

ðŸ‘‰ **Count the number of subsets with sum = target**,  
where  
target = (d + totalSum) / 2

### Validity Checks
Before applying DP:
- If `(d + totalSum)` is **odd** â†’ no valid partition
- If `d > totalSum` â†’ no valid partition


### Algorithm (Tabulation):
1. Compute the `totalSum` of the array
2. Check validity conditions
3. Set `target = (d + totalSum) / 2`
4. Create a DP table:
dp[i][j] = number of ways to form sum j using first i elements

6. Initialization:
- `dp[0][0] = 1` (empty subset forms sum 0)
- `dp[0][j] = 0` for `j > 0`
6. Transition:
```
if arr[i-1] <= j:
dp[i][j] = dp[i-1][j] + dp[i-1][j - arr[i-1]]
else:
dp[i][j] = dp[i-1][j]
```
7. Answer is `dp[n][target]`

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to count partitions with given difference
    int countPartitions(vector<int>& arr, int d) {
        // Calculate total sum of array
        int totalSum = accumulate(arr.begin(), arr.end(), 0);

        // Check if solution is possible
        if ((totalSum + d) % 2 != 0 || d > totalSum) return 0;

        // Calculate target sum
        int K = (totalSum + d) / 2;

        // Create dp array of size K+1
        vector<int> dp(K + 1, 0);

        // Base case: empty set makes sum 0
        dp[0] = 1;

        // If first element <= K, mark it
        if (arr[0] <= K) dp[arr[0]] += 1;

        // Process remaining elements
        for (int i = 1; i < arr.size(); i++) {
            vector<int> curr(K + 1, 0);
            curr[0] = 1;

            for (int t = 0; t <= K; t++) {
                int notTake = dp[t];
                int take = 0;
                if (arr[i] <= t) {
                    take = dp[t - arr[i]];
                }
                curr[t] = take + notTake;
            }
            dp = curr;
        }
        return dp[K];
    }
};

int main() {
    Solution sol;
    vector<int> arr = {1, 2, 3, 4};
    int d = 1;
    cout << sol.countPartitions(arr, d) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N * K)`  
   - Each DP state defined by `(index, target)` is computed exactly once.

- **Space Complexity:** `O(K)`  
   - Only a 1D DP array of size `K + 1` is used to store intermediate results.

---

## Space Optimized Solution (1D DP)

### Intuition:
From the partition equations:
- `S1 - S2 = d`
- `S1 + S2 = totalSum`

We get:
S1 = (d + totalSum) / 2

So the problem reduces to **counting subsets with sum = target**, where:
target = (d + totalSum) / 2

Instead of using a 2D DP table, we observe:
- `dp[i][t]` depends only on `dp[i-1][t]` and `dp[i-1][t - arr[i]]`
- Hence, we can compress DP into **one dimension**

### Algorithm:
1. Compute `totalSum`
2. If `totalSum + d` is odd or `d > totalSum`, return `0`
3. Set `target = (totalSum + d) / 2`
4. Create a DP array `dp[0â€¦target]`, initialize:
   - `dp[0] = 1` (empty subset)
5. Traverse elements one by one:
   - For each element `num`, update DP **backwards**:
     ```
     for t from target down to num:
         dp[t] += dp[t - num]
     ```
6. `dp[target]` gives the number of valid partitions

Backward traversal ensures we donâ€™t reuse the same element multiple times.


### Code (C++)
``` cpp
#include <bits/stdc++.h>
using namespace std;

int countPartitions(int n, int d, vector<int>& arr) {
    int totalSum = 0;
    for (int x : arr) totalSum += x;

    // Invalid cases
    if (d > totalSum || (totalSum + d) % 2 != 0)
        return 0;

    int target = (totalSum + d) / 2;

    // 1D DP array
    vector<int> dp(target + 1, 0);
    dp[0] = 1;  // Empty subset

    for (int num : arr) {
        // Traverse backwards to avoid overwriting
        for (int t = target; t >= num; t--) {
            dp[t] += dp[t - num];
        }
    }

    return dp[target];
}

int main() {
    int n, d;
    cin >> n >> d;

    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    cout << countPartitions(n, d, arr) << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N Ã— K)`  
  We process all `N` elements, and for each element, we iterate through all target sums from `0` to `K`.

- **Space Complexity:** `O(K)`  
  A single 1D DP array of size `K + 1` is used to store the number of ways to achieve each sum.

**Where:**
- `N` is the number of elements in the array  
- `K` is the target sum calculated as `(totalSum + D) / 2`


