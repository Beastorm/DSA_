## Assign Cookies

**Problem Statement:**  
Consider a scenario where a teacher wants to distribute cookies to students, with each student receiving at most one cookie.  

- The `student` array represents the minimum cookie size required by each student.  
- The `cookie` array represents the sizes of available cookies.  

A cookie can be assigned to a student if:
cookie[j] ≥ student[i]

The goal is to **maximize the number of students who receive a cookie**.

---

>### Examples:

### Example 1:
**Input:**  
Student = [1, 2, 3]
Cookie = [1, 1]

**Output:** 1
**Explanation:**  
Only one cookie of size `1` can satisfy the student with the requirement `1`.

---

### Example 2:
**Input:**  
Student = [1, 2]
Cookie = [1, 2, 3]

**Output:** 2
**Explanation:**  
- Cookie `1` satisfies student `1`  
- Cookie `2` satisfies student `2`  

So, `2` students receive cookies.


---

## Assign Cookies – Recursive Solution

### Intuition:
We want to maximize the number of students who can get cookies.  
At each step, we have a choice:

1. Assign a cookie to the current student if it satisfies their requirement.
2. Skip the current cookie or student if it doesn’t fit.  

We can try all possibilities recursively to find the maximum number of satisfied students.

### Recursive Approach:

1. Sort both `students` and `cookies` arrays in **ascending order**.
2. Define a recursive function: f(i, j)

- `i` → index of current student  
- `j` → index of current cookie  

3. **Base cases:**
- If `i == n` (all students considered) → return `0`
- If `j == m` (all cookies considered) → return `0`

4. **Choices at each step:**
- If `cookie[j] >= student[i]` → assign it: 1 + f(i + 1, j + 1)
- Else → skip current cookie: f(i, j + 1)

5. Return the **maximum** of the above two options.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function to assign cookies
int maxStudents(vector<int>& students, vector<int>& cookies, int i, int j) {
    int n = students.size();
    int m = cookies.size();

    // Base case: all students or cookies considered
    if (i == n || j == m) return 0;

    if (cookies[j] >= students[i]) {
        // Assign cookie or skip it
        return max(1 + maxStudents(students, cookies, i + 1, j + 1),
                   maxStudents(students, cookies, i, j + 1));
    } else {
        // Skip this cookie
        return maxStudents(students, cookies, i, j + 1);
    }
}

int main() {
    vector<int> students = {1, 2, 3};
    vector<int> cookies = {1, 1};

    // Sort both arrays
    sort(students.begin(), students.end());
    sort(cookies.begin(), cookies.end());

    int result = maxStudents(students, cookies, 0, 0);

    cout << "Maximum number of students who can get cookies: " << result << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(2^min(N, M))  
  - In the worst case, for each student and cookie, we have two choices: assign or skip. So the recursion explores all combinations of assignments.  
  - Here, N is the number of students and M is the number of cookies.  

- **Space Complexity:** O(N + M)  
  - The recursion stack can go up to the depth of min(N, M), depending on how many students/cookies are considered.  

> Note: This recursive solution is exponential and not efficient for large inputs. Sorting doesn’t reduce the recursion branches but ensures correct assignment order if used in a greedy/DP approach.


---

## Memoization Approach

### Algorithm: 
We use recursion to try all ways of assigning cookies to children. At each step:  

- If the current cookie can satisfy the current student, we try both:  
  1. Assign the cookie and move to the next student and next cookie.  
  2. Skip the cookie and try the next cookie for the same student.  
  - Take the maximum of these two choices.  

- If the cookie cannot satisfy the student, skip it and move to the next cookie.  

- Store results in a 2D `dp[student][cookie]` array to avoid recalculating the same subproblems.  

### Steps:
1. Sort both `student` and `cookie` arrays in ascending order.  
2. Start from the first student and first cookie.  
3. At each step, check if the current cookie can satisfy the current student.  
4. Use the stored DP results whenever the same student-cookie pair is encountered.  
5. Repeat until all students or all cookies are considered.  

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the maximum number of content students
    int findContentChildren(vector<int>& student, vector<int>& cookie) {
        // Sort both arrays to apply the greedy strategy
        sort(student.begin(), student.end());
        sort(cookie.begin(), cookie.end());

        // Initialize DP table with -1
        vector<vector<int>> memo(student.size(), vector<int>(cookie.size(), -1));

        // Start recursion from index 0 for both arrays
        return helper(0, 0, student, cookie, memo);
    }

private:
    // Recursive helper function with memoization
    int helper(int studentIndex, int cookieIndex, vector<int>& student, vector<int>& cookie, vector<vector<int>>& memo) {
        // Base case: if we reach the end of either list
        if (studentIndex >= student.size() || cookieIndex >= cookie.size())
            return 0;

        // Return memoized result if already computed
        if (memo[studentIndex][cookieIndex] != -1)
            return memo[studentIndex][cookieIndex];

        int result = 0;

        // If the cookie satisfies the student's greed
        if (cookie[cookieIndex] >= student[studentIndex]) {
            // Option 1: assign this cookie and move to the next student and cookie
            result = max(result, 1 + helper(studentIndex + 1, cookieIndex + 1, student, cookie, memo));
        }

        // Option 2: skip this cookie and try the next one for the same student
        result = max(result, helper(studentIndex, cookieIndex + 1, student, cookie, memo));

        // Store the result in the memo table
        return memo[studentIndex][cookieIndex] = result;
    }
};

int main() {
    vector<int> student = {1, 2, 3};
    vector<int> cookie = {1, 1};

    // Create Solution object
    Solution solver;

    // Get the number of content students and print it
    int result = solver.findContentChildren(student, cookie);
    cout << "Maximum number of content students: " << result << endl;

    return 0;
}
```

### Complexity Analysis:  

- **Time Complexity:** O(n * m), every pair of student and cookie is checked exactly once.  
- **Space Complexity:** O(n * m) + O(n + m), a 2D memoization table is used to store results of subproblems and an additional O(n + m) stack space is used for recursion.  

---

## Approach - Tabulation

### Algorithm: 
- Sort both `student` and `cookie` arrays in ascending order.  
- Create a 2D table `dp[n+1][m+1]` where `dp[i][j]` represents the maximum number of students that can be satisfied using students from `i` onward and cookies from `j` onward.  
- Fill the table from the end (bottom-right) to the beginning:  
  - If the current cookie `cookie[j]` can satisfy the current student `student[i]`, take the maximum of:  
    - Assign the cookie: `1 + dp[i+1][j+1]`  
    - Skip the cookie: `dp[i][j+1]`  
  - If the cookie cannot satisfy the student, skip the cookie: `dp[i][j] = dp[i][j+1]`  
- The answer will be in `dp[0][0]`, representing the maximum number of students satisfied starting from the first student and first cookie.  

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the maximum number of content students using tabulation
    int findContentChildren(vector<int>& student, vector<int>& cookie) {
        int n = student.size();
        int m = cookie.size();

        // Sort both arrays to prepare for DP
        sort(student.begin(), student.end());
        sort(cookie.begin(), cookie.end());

        // Create a 2D DP table
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

        // Fill DP table from bottom up
        for (int i = n - 1; i >= 0; --i) {
            for (int j = m - 1; j >= 0; --j) {
                // Skip current cookie
                int skip = dp[i][j + 1];

                // Take the current cookie if it satisfies the student's greed
                int take = 0;
                if (cookie[j] >= student[i]) {
                    take = 1 + dp[i + 1][j + 1];
                }

                // Take the best of both choices
                dp[i][j] = max(skip, take);
            }
        }

        return dp[0][0];
    }
};

int main() {
    vector<int> student = {1, 2};
    vector<int> cookie = {1, 2, 3};

    // Create Solution object
    Solution solver;

    // Get the number of content students and print it
    int result = solver.findContentChildren(student, cookie);
    cout << "Maximum number of content students: " << result << endl;

    return 0;
}
```

### Complexity Analysis:   
- **Time Complexity:** O(n * m), every pair of student and cookie is checked exactly once.  
- **Space Complexity:** O(n * m), a 2D table is used to store results of subproblems.

---

## Optimal Approach
### Algorithm:
The goal is to satisfy as many children as possible, giving the smallest sufficient cookie to the least greedy child so that bigger cookies remain for greedier children.

1. Sort the `student` (greed) and `cookie` arrays in increasing order.  
2. Initialize two pointers, one for students (`i`) and one for cookies (`j`).  
3. Traverse both arrays:
   - If `cookie[j] >= student[i]`, assign the cookie to the child, increment both `i` and `j`.  
   - If `cookie[j] < student[i]`, increment `j` to try the next bigger cookie.  
4. Count the number of children satisfied (`i`) and return it.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the maximum number of content students
    int findContentChildren(vector<int>& student, vector<int>& cookie) {
        // Sort both arrays to apply the greedy strategy
        sort(student.begin(), student.end());
        sort(cookie.begin(), cookie.end());

        int studentIndex = 0; 
        int cookieIndex = 0;  

        // Try to assign cookies until any one list is fully processed
        while (studentIndex < student.size() && cookieIndex < cookie.size()) {
            // If the cookie satisfies the student's greed
            if (cookie[cookieIndex] >= student[studentIndex]) {
                studentIndex++; 
            }
            // Move to next cookie in both cases
            cookieIndex++; 
        }

        // Number of students satisfied is equal to studentIndex
        return studentIndex;
    }
};

int main() {
    vector<int> student = {1, 2, 3};
    vector<int> cookie = {1, 1};

    // Create Solution object
    Solution solver;

    // Get the number of content students and print it
    int result = solver.findContentChildren(student, cookie);
    cout << "Maximum number of content students: " << result << endl;

    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(n * log n + m * log m), due to sorting both arrays in increasing order.  
- **Space Complexity:** O(1), no extra space is used.
