## Partition Set Into 2 Subsets With Minimum Absolute Sum Difference

**Problem Description:**   
Given an array of `n` integers, partition the array into two subsets such that the *absolute difference between the sums of the two subsets is minimized*.

---

>### Examples:

### Example 1:
**Input:**  `nums = [1, 2, 3, 4]`  

**Output:**  `0`  

**Explanation:**  
The array can be partitioned into `[1, 4]` and `[2, 3]`.  
Both subsets have a sum `5`, so the absolute difference is `0`.

---
### Example 2:

**Input:**  `nums = [8, 6, 5]`  

**Output:**  `3`  

**Explanation:**  
One possible partition is `[8]` and `[6, 5]`.  
Subset sums are `8` and `11`, so the absolute difference is `|8 − 11| = 3`.

---

## Approach - Recursive
### 1. The Intuition: "The Tug-of-War"

Imagine you have a set of numbers (weights). You want to split them into two teams (Subsets) so that the total weight of Team 1 ($S_1$) is as close as possible to the total weight of Team 2 ($S_2$).

* **The Total Sum:** If you know the sum of all numbers is `totSum`, then $S_2$ is automatically `totSum - S_1$.
* **The Goal:** Minimize the difference: $|S_1 - S_2|$ which is the same as $|S_1 - (totSum - S_1)|$.
* **The Strategy:** For every single number, you ask: **"Should I put this in my subset?"**
    1. **Choice A (Take):** Subtract the value from your target and move to the next number.
    2. **Choice B (Not Take):** Keep the target the same and move to the next number.
---

### 2. The Algorithm (Step-by-Step)

1. **Calculate Total Sum:** Find the `totSum` of all elements in the array.
2. **Recursive Function `f(index, target)`:**
   - **Base Case 1:** If `target == 0`, we found a subset! Return `true`.
   - **Base Case 2:** If we are at the first index (`index == 0`), return `true` only if `arr[0] == target`.
   - **Recursive Step:**
     - Check `notTaken`: Call `f(index - 1, target)`.
     - Check `taken`: If `arr[index] <= target`, call `f(index - 1, target - arr[index])`.
     - Return `true` if either path works.
3. **The Loop:** - Since we need the minimum difference, check every possible sum `i` from `0` to `totSum`.
   - If `f(n-1, i)` is `true`, calculate the difference $|i - (totSum - i)|$.
4. **Update Minimum:** Keep track of the smallest difference found during the loop.
---

### C++ Code:

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <cmath>

using namespace std;

bool canFormSum(int ind, int target, vector<int>& arr) {
    if (target == 0) return true;
    if (ind == 0) return (arr[0] == target);

    bool notTaken = canFormSum(ind - 1, target, arr);
    
    bool taken = false;
    if (arr[ind] <= target) {
        taken = canFormSum(ind - 1, target - arr[ind], arr);
    }

    return taken || notTaken;
}

int minSubsetSumDifference(vector<int>& arr) {
    int n = arr.size();
    int totSum = accumulate(arr.begin(), arr.end(), 0);
    int mini = 1e9;

    for (int i = 0; i <= totSum; i++) {
        if (canFormSum(n - 1, i, arr)) {
            int diff = abs(i - (totSum - i));
            mini = min(mini, diff);
        }
    }
    return mini;
}
```

### Complexity Analysis:

- **Time Complexity:**  O(2ⁿ)  
  - Each element has two choices (go to subset 1 or subset 2), resulting in `2ⁿ` possible combinations.

- **Space Complexity:**  O(N)  
  - The recursion stack can go as deep as `N` (number of elements).

---

## Approach - Memoization  
### Algorithm:

This problem is a variation of **Subset Sum**. Instead of checking whether a subset with a fixed target exists, we want to **minimize the absolute difference** between sums of two subsets.

Key observations:
- If the total sum of the array is `S`
- And one subset has sum `s`
- Then the other subset has sum `S - s`
- The difference is `|S - 2*s|`

So, we only need to track **one subset sum**.

#### Steps:
- Compute the **total sum** of the array.
- Use a recursive function with parameters `(index, currentSum)`.
- At each index, we have two choices:
  - Include the current element in the subset.
  - Exclude the current element.
- Use a DP table `dp[index][currentSum]` to memoize results and avoid recomputation.
- After all states are computed, check all possible subset sums `s` from `0` to `totalSum`.
- For each valid sum, compute `|totalSum - 2*s|`.
- Return the **minimum absolute difference** found.


### C++ Code:
``` cpp

#include <bits/stdc++.h>
using namespace std;

// Function to solve the subset sum problem with memoization
bool subsetSumUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
    // Base case: If the target sum is 0, return true
    if (target == 0)
        return dp[ind][target] = true;

    // Base case: If we have considered all elements and the target is still not 0, return false
    if (ind == 0)
        return dp[ind][target] = (arr[0] == target);

    // If the result for this state is already calculated, return it
    if (dp[ind][target] != -1)
        return dp[ind][target];

    // Recursive cases
    // 1. Exclude the current element
    bool notTaken = subsetSumUtil(ind - 1, target, arr, dp);

    // 2. Include the current element if it doesn't exceed the target
    bool taken = false;
    if (arr[ind] <= target)
        taken = subsetSumUtil(ind - 1, target - arr[ind], arr, dp);

    // Store the result in the DP table and return
    return dp[ind][target] = notTaken || taken;
}

// Function to find the minimum absolute difference between two subset sums
int minSubsetSumDifference(vector<int>& arr, int n) {
    int totSum = 0;

    // Calculate the total sum of the array
    for (int i = 0; i < n; i++) {
        totSum += arr[i];
    }

    // Initialize a DP table to store the results of the subset sum problem
    vector<vector<int>> dp(n, vector<int>(totSum + 1, -1));

    // Calculate the subset sum for each possible sum from 0 to the total sum
    for (int i = 0; i <= totSum; i++) {
        bool dummy = subsetSumUtil(n - 1, i, arr, dp);
    }

    int mini = 1e9;
    for (int i = 0; i <= totSum; i++) {
        if (dp[n - 1][i] == true) {
            int diff = abs(i - (totSum - i));
            mini = min(mini, diff);
        }
    }
    return mini;
}

int main() {
    vector<int> arr = {1, 2, 3, 4};
    int n = arr.size();

    cout << "The minimum absolute difference is: " << minSubsetSumDifference(arr, n);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N*K)`  
  -  There are `N*K` possible states, where `N` is the number of elements in the array and `K` is the total sum of all elements. Each state is computed only once due to memoization.

- **Space Complexity:** `O(N*K) + O(N)`  
  - `O(N*K)` is used for the DP memoization table.  
  - `O(N)` additional space is used by the recursion stack in the worst case.

---

## Approach - Tabulation  
### Algorithm:

To avoid the extra recursive stack space used in the memoization approach, we convert the solution into a **tabulation (bottom-up DP)** approach.

1. Create a 2D DP table `dp[n][totalSum + 1]`, initialized to `false`,  
   where `dp[i][s]` indicates whether a subset with sum `s` is possible using elements up to index `i`.

2. Initialize the first column (`dp[i][0] = true` for all `i`), since a subset sum of `0` is always achievable.

3. Initialize the first row:  
   If `arr[0] <= totalSum`, set `dp[0][arr[0]] = true`.

4. Fill the DP table using nested loops:
   - For each element index `i` from `1` to `n-1`
   - For each possible sum `s` from `1` to `totalSum`
   - Set  
     `dp[i][s] = dp[i-1][s] || dp[i-1][s - arr[i]]` (if `arr[i] <= s`)

5. After filling the table, iterate over all possible subset sums in the last row.
   For each valid sum `s`, compute the absolute difference:  
   `|totalSum - 2*s|`

6. Return the minimum absolute difference found.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the minimum absolute difference between two subset sums
    int minSubsetSumDifference(vector<int>& arr, int n) {
        int totSum = 0;

        // Calculate the total sum of the array
        for (int i = 0; i < n; i++) {
            totSum += arr[i];
        }

        // Initialize a DP table to store the results of the subset sum problem
        vector<vector<bool>> dp(n, vector<bool>(totSum + 1, false));

        // Base case: If no elements are selected (sum is 0), it's a valid subset
        for (int i = 0; i < n; i++) {
            dp[i][0] = true;
        }

        // Initialize the first row based on the first element of the array
        if (arr[0] <= totSum)
            dp[0][arr[0]] = true;

        // Fill in the DP table using a bottom-up approach
        for (int ind = 1; ind < n; ind++) {
            for (int target = 1; target <= totSum; target++) {
                // Exclude the current element
                bool notTaken = dp[ind - 1][target];

                // Include the current element if it doesn't exceed the target
                bool taken = false;
                if (arr[ind] <= target)
                    taken = dp[ind - 1][target - arr[ind]];

                dp[ind][target] = notTaken || taken;
            }
        }

        int mini = 1e9;
        for (int i = 0; i <= totSum; i++) {
            if (dp[n - 1][i] == true) {
                // Calculate the absolute difference between two subset sums
                int diff = abs(i - (totSum - i));
                mini = min(mini, diff);
            }
        }
        return mini;
    }
};

int main() {
    vector<int> arr = {1, 2, 3, 4};
    int n = arr.size();

    Solution sol;
    cout << "The minimum absolute difference is: " << sol.minSubsetSumDifference(arr, n);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N*K)`  
  - There are `N*K` DP states, where `N` is the number of elements in the array and `K` is the total sum of the array. Each state is computed once.

- **Space Complexity:** `O(N*K)`  
  - A 2D DP array of size `N x K` is used to store whether a subset sum is achievable.

---

## Space Optimization

### Algorithm:

From the DP relation:

dp[ind][target] = dp[ind-1][target] || dp[ind-1][target - arr[ind]]

We observe that to compute the current row (`ind`), we only need values from the previous row (`ind-1`). Therefore, storing the entire 2D DP table is unnecessary.

### Optimized Approach:

- Use two 1D arrays:
  - `prev` → represents `dp[ind-1][*]`
  - `cur` → represents `dp[ind][*]`
- Initialize `prev[0] = true`, since a subset sum of `0` is always achievable.
- For each element in the array:
  - Set `cur[0] = true`
  - For each possible target sum:
    - Set `cur[target] = prev[target] || prev[target - arr[ind]]` (if valid)
- After processing each element, assign `prev = cur`
- The final answer will be stored in `prev[target]`

This reduces memory usage while preserving correctness.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the minimum absolute difference between two subset sums
    int minSubsetSumDifference(vector<int>& arr, int n) {
        int totSum = 0;

        // Calculate the total sum of the array
        for (int i = 0; i < n; i++) {
            totSum += arr[i];
        }

        // Initialize a boolean vector 'prev' to represent the previous row of the DP table
        vector<bool> prev(totSum + 1, false);

        // Base case: If no elements are selected (sum is 0), it's a valid subset
        prev[0] = true;

        // Initialize the first row based on the first element of the array
        if (arr[0] <= totSum)
            prev[arr[0]] = true;

        // Fill in the DP table using a bottom-up approach
        for (int ind = 1; ind < n; ind++) {
            // Create a boolean vector 'cur' to represent the current row of the DP table
            vector<bool> cur(totSum + 1, false);
            cur[0] = true;

            for (int target = 1; target <= totSum; target++) {
                // Exclude the current element
                bool notTaken = prev[target];

                // Include the current element if it doesn't exceed the target
                bool taken = false;
                if (arr[ind] <= target)
                    taken = prev[target - arr[ind]];

                // Mark current target as achievable if either excluding or including the current element works
                cur[target] = notTaken || taken;
            }

            // Set 'cur' as the 'prev' for the next iteration
            prev = cur;
        }

        int mini = INT_MAX;
        for (int i = 0; i <= totSum; i++) {
            if (prev[i]) {
                // Calculate the absolute difference between two subset sums
                int diff = abs(i - (totSum - i));
                mini = min(mini, diff);
            }
        }
        return mini;
    }
};

int main() {
    vector<int> arr = {1, 2, 3, 4};
    int n = arr.size();

    Solution sol;
    cout << "The minimum absolute difference is: " << sol.minSubsetSumDifference(arr, n) << "\n";

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N × K)**  
  - There are `N` elements, and for each element, we iterate over all possible sums from `0` to `K`.

- **Space Complexity:** **O(K)**  
  - Only two 1D arrays (`prev` and `cur`) of size `K + 1` are used to store the previous and current DP states.

