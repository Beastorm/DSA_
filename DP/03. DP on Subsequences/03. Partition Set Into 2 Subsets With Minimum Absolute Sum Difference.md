## Partition Set Into 2 Subsets With Minimum Absolute Sum Difference

**Problem Description:**   
Given an array of `n` integers, partition the array into two subsets such that the *absolute difference between the sums of the two subsets is minimized*.

---

>### Examples:

### Example 1:
**Input:**  `nums = [1, 2, 3, 4]`  

**Output:**  `0`  

**Explanation:**  
The array can be partitioned into `[1, 4]` and `[2, 3]`.  
Both subsets have a sum `5`, so the absolute difference is `0`.

---
### Example 2:

**Input:**  `nums = [8, 6, 5]`  

**Output:**  `3`  

**Explanation:**  
One possible partition is `[8]` and `[6, 5]`.  
Subset sums are `8` and `11`, so the absolute difference is `|8 − 11| = 3`.

---

## Approach - Recursive
### Intuition:

We want to split the array into two subsets such that the **absolute difference of their sums is minimum**.

For every element, we have **two choices**:
- Put it in the first subset
- Put it in the second subset

By exploring all possible ways of distributing elements between the two subsets and calculating the difference of their sums at the end, we can find the minimum possible difference.

### Algorithm:

1. Start from index `0` with two running sums: `sum1 = 0` and `sum2 = 0`.
2. For each element at index `i`, recursively try:
   - Adding it to `sum1`
   - Adding it to `sum2`
3. When all elements are processed, compute `abs(sum1 - sum2)`.
4. Return the minimum difference obtained from all recursive paths.



### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

/*
 Recursive idea:
 At each index, we have two choices:
 1) Put the current element in subset1
 2) Put the current element in subset2

 We track the running sums of both subsets and
 minimize |sum1 - sum2| at the end.
*/

int solve(int idx, int sum1, int sum2, vector<int>& arr) {
    // Base case: all elements considered
    if (idx == arr.size()) {
        return abs(sum1 - sum2);
    }

    // Choice 1: put arr[idx] in subset1
    int diff1 = solve(idx + 1, sum1 + arr[idx], sum2, arr);

    // Choice 2: put arr[idx] in subset2
    int diff2 = solve(idx + 1, sum1, sum2 + arr[idx], arr);

    // Return minimum difference
    return min(diff1, diff2);
}

int minSubsetSumDifference(vector<int>& arr) {
    return solve(0, 0, 0, arr);
}

int main() {
    vector<int> arr1 = {1, 2, 3, 4};
    vector<int> arr2 = {8, 6, 5};

    cout << minSubsetSumDifference(arr1) << endl; // Output: 0
    cout << minSubsetSumDifference(arr2) << endl; // Output: 3

    return 0;
}

```

### Complexity Analysis:

- **Time Complexity:**  O(2ⁿ)  
  - Each element has two choices (go to subset 1 or subset 2), resulting in `2ⁿ` possible combinations.

- **Space Complexity:**  O(N)  
  - The recursion stack can go as deep as `N` (number of elements).

---

## Approach - Memoization  
### Algorithm:

This problem is a variation of **Subset Sum**. Instead of checking whether a subset with a fixed target exists, we want to **minimize the absolute difference** between sums of two subsets.

Key observations:
- If the total sum of the array is `S`
- And one subset has sum `s`
- Then the other subset has sum `S - s`
- The difference is `|S - 2*s|`

So, we only need to track **one subset sum**.

#### Steps:
- Compute the **total sum** of the array.
- Use a recursive function with parameters `(index, currentSum)`.
- At each index, we have two choices:
  - Include the current element in the subset.
  - Exclude the current element.
- Use a DP table `dp[index][currentSum]` to memoize results and avoid recomputation.
- After all states are computed, check all possible subset sums `s` from `0` to `totalSum`.
- For each valid sum, compute `|totalSum - 2*s|`.
- Return the **minimum absolute difference** found.


### C++ Code:
``` cpp

#include <bits/stdc++.h>
using namespace std;

// Function to solve the subset sum problem with memoization
bool subsetSumUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
    // Base case: If the target sum is 0, return true
    if (target == 0)
        return dp[ind][target] = true;

    // Base case: If we have considered all elements and the target is still not 0, return false
    if (ind == 0)
        return dp[ind][target] = (arr[0] == target);

    // If the result for this state is already calculated, return it
    if (dp[ind][target] != -1)
        return dp[ind][target];

    // Recursive cases
    // 1. Exclude the current element
    bool notTaken = subsetSumUtil(ind - 1, target, arr, dp);

    // 2. Include the current element if it doesn't exceed the target
    bool taken = false;
    if (arr[ind] <= target)
        taken = subsetSumUtil(ind - 1, target - arr[ind], arr, dp);

    // Store the result in the DP table and return
    return dp[ind][target] = notTaken || taken;
}

// Function to find the minimum absolute difference between two subset sums
int minSubsetSumDifference(vector<int>& arr, int n) {
    int totSum = 0;

    // Calculate the total sum of the array
    for (int i = 0; i < n; i++) {
        totSum += arr[i];
    }

    // Initialize a DP table to store the results of the subset sum problem
    vector<vector<int>> dp(n, vector<int>(totSum + 1, -1));

    // Calculate the subset sum for each possible sum from 0 to the total sum
    for (int i = 0; i <= totSum; i++) {
        bool dummy = subsetSumUtil(n - 1, i, arr, dp);
    }

    int mini = 1e9;
    for (int i = 0; i <= totSum; i++) {
        if (dp[n - 1][i] == true) {
            int diff = abs(i - (totSum - i));
            mini = min(mini, diff);
        }
    }
    return mini;
}

int main() {
    vector<int> arr = {1, 2, 3, 4};
    int n = arr.size();

    cout << "The minimum absolute difference is: " << minSubsetSumDifference(arr, n);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N*K)`  
  -  There are `N*K` possible states, where `N` is the number of elements in the array and `K` is the total sum of all elements. Each state is computed only once due to memoization.

- **Space Complexity:** `O(N*K) + O(N)`  
  - `O(N*K)` is used for the DP memoization table.  
  - `O(N)` additional space is used by the recursion stack in the worst case.

---

## Approach - Tabulation  
### Algorithm:

To avoid the extra recursive stack space used in the memoization approach, we convert the solution into a **tabulation (bottom-up DP)** approach.

1. Create a 2D DP table `dp[n][totalSum + 1]`, initialized to `false`,  
   where `dp[i][s]` indicates whether a subset with sum `s` is possible using elements up to index `i`.

2. Initialize the first column (`dp[i][0] = true` for all `i`), since a subset sum of `0` is always achievable.

3. Initialize the first row:  
   If `arr[0] <= totalSum`, set `dp[0][arr[0]] = true`.

4. Fill the DP table using nested loops:
   - For each element index `i` from `1` to `n-1`
   - For each possible sum `s` from `1` to `totalSum`
   - Set  
     `dp[i][s] = dp[i-1][s] || dp[i-1][s - arr[i]]` (if `arr[i] <= s`)

5. After filling the table, iterate over all possible subset sums in the last row.
   For each valid sum `s`, compute the absolute difference:  
   `|totalSum - 2*s|`

6. Return the minimum absolute difference found.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the minimum absolute difference between two subset sums
    int minSubsetSumDifference(vector<int>& arr, int n) {
        int totSum = 0;

        // Calculate the total sum of the array
        for (int i = 0; i < n; i++) {
            totSum += arr[i];
        }

        // Initialize a DP table to store the results of the subset sum problem
        vector<vector<bool>> dp(n, vector<bool>(totSum + 1, false));

        // Base case: If no elements are selected (sum is 0), it's a valid subset
        for (int i = 0; i < n; i++) {
            dp[i][0] = true;
        }

        // Initialize the first row based on the first element of the array
        if (arr[0] <= totSum)
            dp[0][arr[0]] = true;

        // Fill in the DP table using a bottom-up approach
        for (int ind = 1; ind < n; ind++) {
            for (int target = 1; target <= totSum; target++) {
                // Exclude the current element
                bool notTaken = dp[ind - 1][target];

                // Include the current element if it doesn't exceed the target
                bool taken = false;
                if (arr[ind] <= target)
                    taken = dp[ind - 1][target - arr[ind]];

                dp[ind][target] = notTaken || taken;
            }
        }

        int mini = 1e9;
        for (int i = 0; i <= totSum; i++) {
            if (dp[n - 1][i] == true) {
                // Calculate the absolute difference between two subset sums
                int diff = abs(i - (totSum - i));
                mini = min(mini, diff);
            }
        }
        return mini;
    }
};

int main() {
    vector<int> arr = {1, 2, 3, 4};
    int n = arr.size();

    Solution sol;
    cout << "The minimum absolute difference is: " << sol.minSubsetSumDifference(arr, n);

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N*K)`  
  - There are `N*K` DP states, where `N` is the number of elements in the array and `K` is the total sum of the array. Each state is computed once.

- **Space Complexity:** `O(N*K)`  
  - A 2D DP array of size `N x K` is used to store whether a subset sum is achievable.

---

## Space Optimization

### Algorithm:

From the DP relation:

dp[ind][target] = dp[ind-1][target] || dp[ind-1][target - arr[ind]]

We observe that to compute the current row (`ind`), we only need values from the previous row (`ind-1`). Therefore, storing the entire 2D DP table is unnecessary.

### Optimized Approach:

- Use two 1D arrays:
  - `prev` → represents `dp[ind-1][*]`
  - `cur` → represents `dp[ind][*]`
- Initialize `prev[0] = true`, since a subset sum of `0` is always achievable.
- For each element in the array:
  - Set `cur[0] = true`
  - For each possible target sum:
    - Set `cur[target] = prev[target] || prev[target - arr[ind]]` (if valid)
- After processing each element, assign `prev = cur`
- The final answer will be stored in `prev[target]`

This reduces memory usage while preserving correctness.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the minimum absolute difference between two subset sums
    int minSubsetSumDifference(vector<int>& arr, int n) {
        int totSum = 0;

        // Calculate the total sum of the array
        for (int i = 0; i < n; i++) {
            totSum += arr[i];
        }

        // Initialize a boolean vector 'prev' to represent the previous row of the DP table
        vector<bool> prev(totSum + 1, false);

        // Base case: If no elements are selected (sum is 0), it's a valid subset
        prev[0] = true;

        // Initialize the first row based on the first element of the array
        if (arr[0] <= totSum)
            prev[arr[0]] = true;

        // Fill in the DP table using a bottom-up approach
        for (int ind = 1; ind < n; ind++) {
            // Create a boolean vector 'cur' to represent the current row of the DP table
            vector<bool> cur(totSum + 1, false);
            cur[0] = true;

            for (int target = 1; target <= totSum; target++) {
                // Exclude the current element
                bool notTaken = prev[target];

                // Include the current element if it doesn't exceed the target
                bool taken = false;
                if (arr[ind] <= target)
                    taken = prev[target - arr[ind]];

                // Mark current target as achievable if either excluding or including the current element works
                cur[target] = notTaken || taken;
            }

            // Set 'cur' as the 'prev' for the next iteration
            prev = cur;
        }

        int mini = INT_MAX;
        for (int i = 0; i <= totSum; i++) {
            if (prev[i]) {
                // Calculate the absolute difference between two subset sums
                int diff = abs(i - (totSum - i));
                mini = min(mini, diff);
            }
        }
        return mini;
    }
};

int main() {
    vector<int> arr = {1, 2, 3, 4};
    int n = arr.size();

    Solution sol;
    cout << "The minimum absolute difference is: " << sol.minSubsetSumDifference(arr, n) << "\n";

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N × K)**  
  - There are `N` elements, and for each element, we iterate over all possible sums from `0` to `K`.

- **Space Complexity:** **O(K)**  
  - Only two 1D arrays (`prev` and `cur`) of size `K + 1` are used to store the previous and current DP states.

