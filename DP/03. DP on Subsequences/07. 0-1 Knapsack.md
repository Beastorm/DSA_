## 0/1 Knapsack Problem

**Problem Statement:**    
Given `N` items, each with a weight `wt[i]` and value `val[i]`, and a knapsack with capacity `W`, determine the maximum total value that can be put in the knapsack. Each item can be chosen **at most once**.

>### Examples:

### Example 1:
**Input:** `wt = [1, 2, 3]`, `val = [10, 20, 30]`, `W = 5`  
**Output:** `50`  
**Explanation:** Pick items 2 and 3 (weights 2 + 3 = 5), total value = 20 + 30 = 50.  

### Example 2:
**Input:** `wt = [3, 2, 2]`, `val = [60, 100, 120]`, `W = 5`  
**Output:** `220`  
**Explanation:** Pick items 2 and 3 (weights 2 + 2 = 4 ≤ 5), total value = 100 + 120 = 220.

---
## Approach - Recursive

### Intuition:
We need to maximize the total value in the knapsack without exceeding its weight limit. For each item, we have two choices: include it (if it fits) or exclude it. By exploring all combinations recursively, we find the maximum possible value.

### Algorithm: 
1. Define a recursive function `knapsack(index, W)` which returns the maximum value using items `0..index` within capacity `W`.  
2. **Base Case:** If `index == 0`, return `val[0]` if `wt[0] <= W`, else return `0`.  
3. **Recursive Case:**  
   - **Exclude** the current item: `notTaken = knapsack(index-1, W)`  
   - **Include** the current item (if it fits): `taken = val[index] + knapsack(index-1, W - wt[index])`  
4. Return `max(taken, notTaken)`  
5. Call `knapsack(N-1, W)` to get the final answer.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function for 0/1 Knapsack
int knapsack(int index, int W, vector<int>& wt, vector<int>& val) {
    // Base case: only first item
    if (index == 0) {
        if (wt[0] <= W) return val[0];
        else return 0;
    }

    // Case 1: Do not take the current item
    int notTaken = knapsack(index - 1, W, wt, val);

    // Case 2: Take current item (if it fits)
    int taken = INT_MIN;
    if (wt[index] <= W)
        taken = val[index] + knapsack(index - 1, W - wt[index], wt, val);

    return max(taken, notTaken);
}

int main() {
    // Example input
    vector<int> wt = {1, 3, 4, 5};
    vector<int> val = {1, 4, 5, 7};
    int W = 7; // Max capacity of knapsack

    int N = wt.size();

    int maxValue = knapsack(N - 1, W, wt, val);
    cout << "Maximum value in Knapsack = " << maxValue << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(2^N)  
  - For each item, we have two choices: include or exclude.  
  - With N items, there are at most 2^N recursive calls.

- **Space Complexity:** O(N)  
  - The recursion stack can go as deep as N in the worst case.

---

## Memoization Approach

### Algorithm:
1. Define a recursive function `knapsack(ind, W)` that returns the maximum value achievable using items `0..ind` with remaining weight `W`.  
2. **Base case:** If `ind == 0`, return `val[0]` if `wt[0] <= W`, else `0`.  
3. **Recursive case:**  
   - **Exclude current item:** `notTake = knapsack(ind-1, W)`  
   - **Include current item (if weight allows):** `take = val[ind] + knapsack(ind-1, W - wt[ind])`  
   - Return `max(take, notTake)`  
4. Create a DP table `dp[N][W+1]` initialized with `-1`.  
5. Before computing a state, check if it is already calculated (`dp[ind][W] != -1`) and reuse the value.  
6. Call the function with `knapsack(N-1, W)` to get the answer.  

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive + Memoization function
int knapsackUtil(int ind, int W, vector<int>& wt, vector<int>& val, vector<vector<int>>& dp) {
    // Base case
    if (ind == 0) {
        if (wt[0] <= W) return val[0];
        else return 0;
    }

    // Check if already computed
    if (dp[ind][W] != -1) return dp[ind][W];

    // Exclude current item
    int notTake = knapsackUtil(ind - 1, W, wt, val, dp);

    // Include current item if possible
    int take = INT_MIN;
    if (wt[ind] <= W) take = val[ind] + knapsackUtil(ind - 1, W - wt[ind], wt, val, dp);

    // Store and return the result
    return dp[ind][W] = max(take, notTake);
}

// Main knapsack function
int knapsack(int N, int W, vector<int>& wt, vector<int>& val) {
    vector<vector<int>> dp(N, vector<int>(W + 1, -1));
    return knapsackUtil(N - 1, W, wt, val, dp);
}

int main() {
    int N = 4;
    int W = 7;
    vector<int> wt = {1, 3, 4, 5};
    vector<int> val = {1, 4, 5, 7};

    cout << "Maximum value in Knapsack = " << knapsack(N, W, wt, val) << endl;
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N * W) → Each state `(ind, W)` is computed once.  
- **Space Complexity:** O(N * W) + O(N) → DP table + recursion stack.

---

## Approach - Tabulation

### Algorithm:

1. **Problem Idea:**  
   We are given `N` items with weights `wt[i]` and values `val[i]`, and a knapsack with capacity `W`. The goal is to maximize total value without exceeding the weight.

2. **Define DP Table:**  
   Create a 2D table `dp[N][W+1]` where `dp[i][w]` represents the maximum value achievable using the first `i` items and a knapsack capacity `w`.

3. **Base Case:**  
   - For the first item (index 0), if `wt[0] <= w`, then `dp[0][w] = val[0]`.  
   - Otherwise, `dp[0][w] = 0`.

4. **Fill DP Table:**  
   - Loop over items `ind = 1` to `N-1`.  
   - For each item, loop over weights `w = 0` to `W`.  
   - Two choices:
     - **Not take** current item: `notTake = dp[ind-1][w]`  
     - **Take** current item (if it fits): `take = val[ind] + dp[ind-1][w - wt[ind]]`  
   - Set `dp[ind][w] = max(take, notTake)`

5. **Answer:**  
   `dp[N-1][W]` contains the maximum value for `N` items and knapsack capacity `W`.



### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Tabulation approach for 0/1 Knapsack
int knapsack(int N, int W, vector<int>& wt, vector<int>& val) {
    vector<vector<int>> dp(N, vector<int>(W + 1, 0));

    // Base case: first item
    for (int w = wt[0]; w <= W; w++) {
        dp[0][w] = val[0];
    }

    // Fill the dp table
    for (int ind = 1; ind < N; ind++) {
        for (int w = 0; w <= W; w++) {
            int notTake = dp[ind - 1][w];
            int take = INT_MIN;
            if (wt[ind] <= w) take = val[ind] + dp[ind - 1][w - wt[ind]];
            dp[ind][w] = max(take, notTake);
        }
    }

    return dp[N - 1][W];
}

int main() {
    int N = 4;
    int W = 7;
    vector<int> wt = {1, 3, 4, 5};
    vector<int> val = {1, 4, 5, 7};

    cout << "Maximum value in Knapsack = " << knapsack(N, W, wt, val) << endl;
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(N * W)  
  - There are N items, and for each item, we iterate over W capacities, filling the DP table.

- **Space Complexity:** O(N * W)  
  - A 2D DP table of size N × (W + 1) is used.


---

## Approach - Space Optimized 

### Algorithm: 
Instead of using a full 2D DP table, we notice that the value of `dp[i][w]` only depends on the previous row `dp[i-1][...]`. Hence, we can maintain just a single 1D array of size `W + 1` and update it in reverse to avoid overwriting needed values.  

**Steps:**
1. Initialize a 1D array `dp[0..W]` with zeros.  
2. Iterate through each item:  
   - For weight `w` from W down to `weight[i]`:  
     - Update `dp[w] = max(dp[w], value[i] + dp[w - weight[i]])`  
       (This represents taking or not taking the current item).  
3. After processing all items, `dp[W]` contains the maximum value achievable.  

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to solve 0/1 Knapsack using space optimized DP
int knapsackSpaceOptimized(vector<int>& weight, vector<int>& value, int n, int W) {
    vector<int> dp(W + 1, 0);

    // Iterate over each item
    for (int i = 0; i < n; i++) {
        // Traverse weights in reverse to avoid overwriting previous results
        for (int w = W; w >= weight[i]; w--) {
            dp[w] = max(dp[w], value[i] + dp[w - weight[i]]);
        }
    }

    return dp[W];
}

int main() {
    int n = 4; // number of items
    vector<int> weight = {2, 1, 3, 2};
    vector<int> value  = {12, 10, 20, 15};
    int W = 5; // maximum weight of knapsack

    cout << "Maximum value in Knapsack = " << knapsackSpaceOptimized(weight, value, n, W) << endl;

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** `O(N * W)`  
   - We iterate through all `N` items and for each item, we traverse the weights from `W` down to the item's weight. So, total operations = `N * W`.

- **Space Complexity:** `O(W)`  
   - We only store a 1D array of size `W + 1` instead of a full 2D DP table. No recursion stack is used.
