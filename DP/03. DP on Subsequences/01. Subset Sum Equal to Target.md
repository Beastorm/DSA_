## Subset Sum Equal to Target

**Problem Statement:**   
We are given an array **arr** of `N` positive integers.  
We need to determine whether there exists a **subset** whose sum is exactly equal to `K`.

A **subset (or subsequence)** can be **contiguous or non-contiguous**, but the **order of elements must remain the same** as in the original array.

---

>### Examples:

### Example 1:
**Input:**  
- `N = 4`  
- `arr = [4, 3, 5, 2]`  
- `K = 6`

**Output:**  
- `true`

**Explanation:**  
One valid subset is `[4, 2]`, which sums to `6`.

---

### Example 2:
**Input:**  
- `N = 3`  
- `arr = [1, 2, 5]`  
- `K = 4`

**Output:**  
- `false`

**Explanation:**  
All possible subsets and their sums:
- `[1] → 1`
- `[2] → 2`
- `[5] → 5`
- `[1,2] → 3`
- `[1,5] → 6`
- `[2,5] → 7`
- `[1,2,5] → 8`

None of them equals `4`, so the answer is `false`.

---

### Key Insight:
- The problem is about **choosing or not choosing** each element.
- We stop as soon as we find **any one subset** whose sum equals `K`.
- This problem is a classic **Dynamic Programming** problem.

---

## Approach - Recursive

### Intuition:
- For each element in the array, you have **two choices**:
  1. **Pick** the element → reduce the target by the element's value
  2. **Do not pick** the element → keep the target unchanged
- Explore all possible combinations recursively.
- If **any subset adds up to the target**, return `true`.
- **Base cases:**
  - Target becomes `0` → subset found
  - Only one element left → check if it equals the target

### Algorithm:

1. **Define the recursive function:**

`f(index, target)`

Returns `true` if a subset of elements `0..index` sums to `target`.

2. **Base Cases:**
- `target == 0` → return `true`
- `index == 0` → return `arr[0] == target`

3. **Recursive Steps:**
- **Not pick** current element:
  ```
  notPick = f(index-1, target)
  ```
- **Pick:** current element (if <= target):
  ```
  pick = f(index-1, target - arr[index])
  ```

4. **Return Result:**
```f(index, target) = pick || notPick```

5. **Initial Call:**
```f(N-1, K)```


---

### Key Insight:
- Each element gives **two possibilities** → forms a **binary recursion tree**.
- The problem exhibits **overlapping subproblems**, so it can be optimized using **memoization or DP**.


### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function to check subset sum
bool subsetSum(int index, int target, vector<int>& arr) {
    // Base case: target 0 can always be achieved (empty subset)
    if (target == 0)
        return true;

    // Base case: first element
    if (index == 0)
        return arr[0] == target;

    // Option 1: do not pick the current element
    bool notPick = subsetSum(index - 1, target, arr);

    // Option 2: pick current element (if <= target)
    bool pick = false;
    if (arr[index] <= target)
        pick = subsetSum(index - 1, target - arr[index], arr);

    // Return true if either choice works
    return pick || notPick;
}

int main() {
    int N, K;
    cout << "Enter number of elements: ";
    cin >> N;

    vector<int> ARR(N);
    cout << "Enter array elements: ";
    for (int i = 0; i < N; i++)
        cin >> ARR[i];

    cout << "Enter target sum K: ";
    cin >> K;

    if (subsetSum(N - 1, K, ARR))
        cout << "true\n";
    else
        cout << "false\n";

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(2^N)**  
  - For each of the `N` elements, we have **2 choices**: pick or not pick  
  - Hence, the recursion explores all **2^N possible subsets**  

- **Space Complexity:** **O(N)**  
  - The recursion stack goes as deep as the number of elements in the array  

> Note: This is the **pure recursive solution**.  
> Using **memoization**, the time complexity can be reduced to **O(N × K)** and space complexity to **O(N × K + N)** (for DP table + recursion stack).

---

## Approach - Memoization 

### Why a Greedy Solution Doesn’t Work?
A greedy approach does not apply here because we are **not optimizing** (min/max).  
We simply need to check the **existence** of at least one subset whose sum equals the target.  
Hence, we must explore **all possible subsequences** using recursion.

### Problem Representation:
We express the problem using:
- **Index (`ind`)** → current position in the array
- **Target (`target`)** → remaining sum to be formed

Let:  
`f(ind, target)`
return `true` if a subset from index `0` to `ind` can form `target`.

Initial call:
`f(n-1, K)`

### Base Cases:
1. **`target == 0`**  
   → A valid subset is found  
   → return `true`

2. **`ind == 0`**  
   → Only one element left  
   → return `arr[0] == target`

### Recursive Choices (Pick / Not Pick):

At every index, we have two options:

1. **Do not pick the current element**   
notTaken = f(ind-1, target)

2. **Pick the current element**   
(only if `arr[ind] <= target`)  
`taken = f(ind-1, target - arr[ind])`  

### Transition:
Since we only need **one valid subset**, return:  
`f(ind, target) = taken || notTaken`

### Why Memoization?
The recursion tree contains **overlapping subproblems**.  
To avoid recomputation, we store results.

### Memoization Steps:
1. Create a DP table: `dp[n][k+1]`

- `n` → number of elements  
- `k` → target sum  

2. Initialize all values to `-1`.

3. Before computing `f(ind, target)`:
- If `dp[ind][target] != -1`, return it.

4. After computing the result: `dp[ind][target] = result`

---

### Key Insight:
- This is a **decision problem** (true / false)
- Uses **pick / non-pick recursion**
- Memoization reduces time complexity from **O(2ⁿ)** to **O(N × K)**

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Recursive helper function to check if a subset sum equals target
    bool subsetSumUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
        // Base case: target achieved
        if (target == 0) return true;

        // Base case: at the first index, check if it equals the target
        if (ind == 0) return arr[0] == target;

        // Check memoization table
        if (dp[ind][target] != -1) return dp[ind][target];

        // Choice 1: do not take the current element
        bool notTaken = subsetSumUtil(ind - 1, target, arr, dp);

        // Choice 2: take the current element if possible
        bool taken = false;
        if (arr[ind] <= target) {
            taken = subsetSumUtil(ind - 1, target - arr[ind], arr, dp);
        }

        // Store result in DP table
        return dp[ind][target] = notTaken || taken;
    }

    // Main function to check if a subset with sum = k exists
    bool subsetSumToK(int n, int k, vector<int>& arr) {
        vector<vector<int>> dp(n, vector<int>(k + 1, -1));
        return subsetSumUtil(n - 1, k, arr, dp);
    }
};

// Driver code
int main() {
    vector<int> arr = {1, 2, 3, 4};
    int k = 4;
    int n = arr.size();

    Solution sol;
    if (sol.subsetSumToK(n, k, arr))
        cout << "Subset with the given target found";
    else
        cout << "Subset with the given target not found";

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(N × K)**  
  - The DP state is defined by `(index, target)`
  - There are at most `N × K` unique states
  - Each state is computed only once due to memoization

- **Space Complexity:** **O(N × K) + O(N)**  
  - `O(N × K)` for the DP table
  - `O(N)` for the recursion stack (maximum depth equals array size)

---

## Approach - Tabulation

### Algorithm:

### Step 1: DP Table Definition
- Create a 2D DP array:
dp[n][k+1]

- `dp[i][t] = true` means a subset from index `0` to `i` can form sum `t.`
- Initialize all values to `false`

### Step 2: Base Case Initialization

1. **Target = 0**
 - A sum of `0` is always possible by choosing an empty subset
dp[i][0] = true for all i from 0 to n-1

2. **First Element Handling**
- Only the first element is considered
- If `arr[0] ≤ k`, then:
dp[0][arr[0]] = true

### Step 3: Fill the DP Table
- Traverse from index `1` to `n-1`
- For each possible target `t` from `1` to `k`:

- **Not Take**
 ```
 notTake = dp[i-1][t]
 ```

- **Take** (only if `arr[i] ≤ t`)
 ```
 take = dp[i-1][t - arr[i]]
 ```

- **Transition**
 ```
 dp[i][t] = take || notTake
 ```

### Step 4: Final Answer
- The required result is stored at:
dp[n-1][k]

---

### Key Insight:
- Tabulation removes recursion and stack overhead
- Uses bottom-up DP based on pick / non-pick logic
- Efficient and easy to visualize using a DP table

---

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to check if there is a subset of 'arr' with a sum equal to 'k'
    bool subsetSumToK(int n, int k, vector<int> &arr) {
        // Initialize a 2D DP array with dimensions (n x k+1) to store subproblem results
        vector<vector<bool>> dp(n, vector<bool>(k + 1, false));

        // Base case: If the target sum is 0, we can always achieve it by taking no elements
        for (int i = 0; i < n; i++) {
            dp[i][0] = true;
        }

        // Base case: If the first element of 'arr' is less than or equal to 'k', set dp[0][arr[0]] to true
        if (arr[0] <= k) {
            dp[0][arr[0]] = true;
        }

        // Fill the DP array iteratively
        for (int ind = 1; ind < n; ind++) {
            for (int target = 1; target <= k; target++) {
                // If we don't take the current element, the result is the same as the previous row
                bool notTaken = dp[ind - 1][target];

                // If we take the current element, subtract its value from the target and check the previous row
                bool taken = false;
                if (arr[ind] <= target) {
                    taken = dp[ind - 1][target - arr[ind]];
                }

                // Store the result in the DP array for the current subproblem
                dp[ind][target] = notTaken || taken;
            }
        }

        // The final result is stored in dp[n-1][k]
        return dp[n - 1][k];
    }
};

// Driver code
int main() {
    vector<int> arr = {1, 2, 3, 4};
    int k = 4;
    int n = arr.size();

    Solution sol;
    if (sol.subsetSumToK(n, k, arr))
        cout << "Subset with the given target found";
    else
        cout << "Subset with the given target not found";

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** **O(N × K)**  
  - Two nested loops are used:
    - One over the array elements (`N`)
    - One over the target values (`K`)

- **Space Complexity:** **O(N × K)**  
  - A 2D DP table of size `N × K` is used
  - No recursion, so **stack space is eliminated**

---

## Approach - Space Optimization 

### Algorithm:  
#### Key Observation:
*The DP transition is:*   
`dp[ind][target] = dp[ind-1][target] || dp[ind-1][target - arr[ind]]`

To compute the current row, we only need values from the **previous row**.

### Space Optimization Idea:
- Instead of a full 2D DP table, use **two 1D arrays**:
  - `prev` → represents `dp[ind-1][*]`
  - `cur` → represents `dp[ind][*]`

### Steps:

1. **Initialization**
   - Create a 1D array `prev` of size `K+1`, initialize all values to `false`
   - Set:
     ```
     prev[0] = true
     ```
   - If `arr[0] ≤ K`, then:
     ```
     prev[arr[0]] = true
     ```

2. **Iterate Over Elements**
   - For each index `ind` from `1` to `n-1`:
     - Create a new array `cur` of size `K+1`
     - Set base condition:
       ```
       cur[0] = true
       ```

3. **Fill Current Row**
   - For each `target` from `1` to `K`:
     - **Not Take**
       ```
       notTake = prev[target]
       ```
     - **Take** (only if `arr[ind] ≤ target`)
       ```
       take = prev[target - arr[ind]]
       ```
     - **Transition**
       ```
       cur[target] = take || notTake
       ```

4. **Update**
   - Assign:
     ```
     prev = cur
     ```

### Final Answer: 
`prev[K]`


---

### Key Insight:
- Only the previous row is required at any step
- Space reduces from **O(N×K)** to **O(K)**
- Time complexity remains unchanged

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to check if there is a subset of 'arr' with sum equal to 'k' using space optimization
    bool subsetSumToK(int n, int k, vector<int> &arr) {
        // Initialize a vector 'prev' to represent the previous row of the DP table
        vector<bool> prev(k + 1, false);

        // Base case: sum 0 can always be formed by empty subset
        prev[0] = true;

        // Base case: if first element <= k, mark true
        if (arr[0] <= k) {
            prev[arr[0]] = true;
        }

        // Iterate over all elements from second to last
        for (int ind = 1; ind < n; ind++) {
            vector<bool> cur(k + 1, false);
            cur[0] = true; // sum 0 is always possible

            for (int target = 1; target <= k; target++) {
                bool notTaken = prev[target]; // skip current element
                bool taken = false;

                if (arr[ind] <= target) {
                    taken = prev[target - arr[ind]]; // take current element
                }

                cur[target] = notTaken || taken; // store result for current target
            }

            prev = cur; // move to next iteration
        }

        // Final answer: Can we form sum k using all elements?
        return prev[k];
    }
};

// Driver code
int main() {
    vector<int> arr = {1, 2, 3, 4};
    int k = 4;
    int n = arr.size();

    Solution sol;
    if (sol.subsetSumToK(n, k, arr))
        cout << "Subset with the given target found";
    else
        cout << "Subset with the given target not found";

    return 0;
}
```

### Complexity Analysis:
- **Time Complexity:** **O(N × K)**  
  - One loop over the elements (`N`)
  - One loop over the target values (`K`)
  - Initialization loops are linear and do not change overall complexity

- **Space Complexity:** **O(K)**  
  - A single 1D array of size `K + 1` is used to store DP states
  - No recursion stack is used

