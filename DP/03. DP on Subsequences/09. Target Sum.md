## Target Sum (DP - 21)

**Problem Statement:**    
We are given an array `ARR` of size `N` and an integer `Target`.  
Our task is to build an expression by placing either a `'+'` or `'-'` sign in front of each element of the array such that the final expression evaluates to `Target`.

We need to **count the number of different ways** to assign signs to all elements so that the resulting sum equals `Target`.

---

>### Examples

### Example 1:
**Input:** nums = [1, 1, 1, 1, 1], target = 3   
**Output:** 5   
**Explanation:**   
There are 5 ways to assign signs:
```
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```
---

### Example 2:
**Input:** nums = [1], target = 1   
**Output:** 1   
**Explanation:**  
Only one valid assignment exists: +1 = 1

---
## Approach - Recursive

### Target Sum | Recursive Approach (Reducing Index)

#### Intuition
Instead of building a sum up from zero, we start with the `target` and work backward. Each number can either **bring us closer** to zero (if we subtract it) or **push us further** (if we add it). By starting from the last index and moving toward the first, we check every combination of signs to see which ones result in a perfect balance of $0$.

---

#### Algorithm

1.  **Function Definition:** `solve(ind, target)` calculates the number of ways to reach a target of $0$ using elements from index `0` to `ind`.
2.  **Base Case:** * If `ind < 0`: Return `1` if `target == 0` (all numbers assigned signs correctly), otherwise return `0`.
3.  **Recursive Steps:**
    * **Plus Path:** Assume the current number has a `+` sign: `solve(ind - 1, target - nums[ind])`.
    * **Minus Path:** Assume the current number has a `-` sign: `solve(ind - 1, target + nums[ind])`.
4.  **Result:** The total ways at index `ind` is the **sum** of these two choices.

---

#### Code (C++)

```cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function reducing index from n-1 to 0
int solve(int ind, int target, vector<int>& nums) {
    // Base Case: When no more elements are left to process
    if (ind < 0) {
        return target == 0 ? 1 : 0;
    }

    // Try assigning '+' to the current number
    int plus = solve(ind - 1, target - nums[ind], nums);
    
    // Try assigning '-' to the current number
    int minus = solve(ind - 1, target + nums[ind], nums);

    // Return total ways found from both branches
    return plus + minus;
}

int findTargetSumWays(vector<int>& nums, int target) {
    // Start from the last index
    return solve(nums.size() - 1, target, nums);
}
```
### Complexity Analysis:

- **Time Complexity:** O(2^N)
  - Every element has two choices (+ or -)

- **Space Complexity:** O(N)
  - Due to the recursion stack depth

---

## Memoization Approach

### Algorithm:

The first approach that comes to our mind is to generate all subsequences and try both options of placing `'-'` and `'+'` signs and count the expression if it evaluates to the answer. This surely gives the answer, but we can optimize it using a familiar DP concept.

We use the idea from **Count Partitions with Given Difference (DP – 18)**.

### Key Insight:

If we assign `+` and `-` signs to array elements, the expression can be split into two parts:

- `S1`: sum of elements with `+`
- `S2`: sum of elements with `-`

From the problem:
S1 - S2 = target ...(i)
S1 + S2 = totalSum ...(ii)

Solving (i) and (ii):
S2 = (totalSum - target) / 2

So, the problem reduces to:

> **Count the number of subsets with sum = (totalSum - target) / 2**

This is the classic **Count Subsets with Sum K** problem.

### Edge Cases:

- If `totalSum < target`, return `0`
- If `(totalSum - target)` is odd, return `0`
- The array may contain `0`, which must be handled carefully

### Recursive Definition:

Let `f(ind, target)` be the number of subsets using elements from index `0` to `ind` that sum to `target`.

### Base Cases:

- If `target == 0`, return `1`
- If `ind == 0`:
  - Return `1` if `arr[0] == target`
  - Else return `0`

### Choices at Each Index:

- **Not Pick** current element  
f(ind - 1, target)

- **Pick** current element (only if `arr[ind] <= target`)  
f(ind - 1, target - arr[ind])

### Transition:

f(ind, target) = notPick + pick

### Memoization Steps:

- Create a DP table `dp[n][k+1]` initialized with `-1`
- Before solving `f(ind, target)`, check if `dp[ind][target] != -1`
- Store the computed result in `dp[ind][target]`

This avoids recomputation of overlapping subproblems and significantly improves performance.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to count number of ways to assign '+' or '-' to reach target
    int findTargetSumWays(vector<int>& nums, int target) {
        // Calculate the total sum of the array
        int totalSum = accumulate(nums.begin(), nums.end(), 0);

        // If target is not achievable (because of sum or parity), return 0
        if ((totalSum - target) < 0 || (totalSum - target) % 2 != 0) 
            return 0;

        // Our problem reduces to subset sum with sum = (totalSum - target) / 2
        int subsetSum = (totalSum - target) / 2;

        // Initialize memo table with -1
        vector<vector<int>> dp(nums.size(), vector<int>(subsetSum + 1, -1));

        // Call recursive function with memoization
        return countSubsets(nums, nums.size() - 1, subsetSum, dp);
    }

private:
    // Recursive function with memoization
    int countSubsets(vector<int>& nums, int ind, int target, vector<vector<int>>& dp) {
        // Base case: when we are at index 0
        if (ind == 0) {
            // Two scenarios:
            if (target == 0 && nums[0] == 0) return 2; // {pick or not pick 0}
            if (target == 0 || target == nums[0]) return 1; // Either pick or skip
            return 0; // Otherwise no valid way
        }

        // Return if already computed
        if (dp[ind][target] != -1) return dp[ind][target];

        // Exclude current element
        int notPick = countSubsets(nums, ind - 1, target, dp);

        // Include current element if it is <= target
        int pick = 0;
        if (nums[ind] <= target)
            pick = countSubsets(nums, ind - 1, target - nums[ind], dp);

        // Store and return result
        return dp[ind][target] = pick + notPick;
    }
};

// Driver code
int main() {
    Solution sol;
    vector<int> nums = {1,1,1,1,1};
    int target = 3;
    cout << sol.findTargetSumWays(nums, target) << endl; // Output: 5
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*K),There are N*K states therefore at max ‘N*K’ new problems will be solved.
- **Space Complexity:** O(N*K) + O(N),We are using a recursion stack space(O(N)) and a 2D array ( O(N*K)).


---

## Tabulation Approach

### Algorithm:

To convert the **memoization approach** into a **tabulation (bottom-up DP)** approach, we create a DP table with the same dimensions as used in memoization and fill it iteratively.

Let:
- `n` = size of the array  
- `k` = required subset sum = `(totalSum - target) / 2`  
- `dp[i][j]` = number of ways to form sum `j` using elements from index `0` to `i`

Initialize the DP table with `0`.

### Step 1: Initialize Base Conditions:

#### 1. Target = 0
If the target is `0`, there is **exactly 1 way** to form it (by choosing no elements), regardless of how many elements we consider.

So, for all `i`:
dp[i][0] = 1

This initializes the first column of the DP table.

#### 2. First Element (i = 0)
When only the first element is considered:

We can form arr[0] only if arr[0] <= k

Hence:
if (arr[0] <= k)
    dp[0][arr[0]] = 1
This represents picking the first element to achieve the target arr[0].

### Step 2: Fill the DP Table
Use two nested loops:

Outer loop for array index i from 1 to n-1

Inner loop for target sum j from 0 to k

For each cell dp[i][j], we have two choices:

*1.* Not Pick the current element
notPick = dp[i-1][j]

*2.* Pick the current element (only if arr[i] <= j)
pick = dp[i-1][j - arr[i]]

**Transition Formula**
dp[i][j] = notPick + pick
This mirrors the recursive logic but uses already-computed DP values instead of recursive calls.

### Step 3: Final Answer
The answer will be stored in: dp[n-1][k]
This represents the total number of subsets using all elements that sum up to k, which directly gives the number of ways to assign + and - signs to reach the target.

**Summary:**
- Convert recursion → iteration
- Initialize base cases carefully
- Use DP transitions instead of recursive calls
- The final result is obtained from the last DP cell
This tabulation approach eliminates recursion overhead and efficiently solves the problem.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find number of ways to assign + or - to reach the target
    int findTargetSumWays(vector<int>& nums, int target) {
        int n = nums.size();

        // First calculate the total sum of all numbers
        int totalSum = accumulate(nums.begin(), nums.end(), 0);

        // If (target + totalSum) is odd or target > totalSum, no valid partition exists
        if ((totalSum + target) % 2 != 0 || abs(target) > totalSum) return 0;

        // We now need to count subsets with sum = (target + totalSum) / 2
        int newTarget = (totalSum + target) / 2;

        // Create DP table: dp[i][j] = number of ways to make sum j using first i numbers
        vector<vector<int>> dp(n + 1, vector<int>(newTarget + 1, 0));

        // Base case: One way to form sum 0 (by taking no elements)
        for (int i = 0; i <= n; i++) dp[i][0] = 1;

        // Fill DP table iteratively
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= newTarget; j++) {
                // Exclude current element
                dp[i][j] = dp[i - 1][j];

                // Include current element if it does not exceed current target j
                if (nums[i - 1] <= j) {
                    dp[i][j] += dp[i - 1][j - nums[i - 1]];
                }
            }
        }

        return dp[n][newTarget];
    }
};

// Driver code
int main() {
    Solution sol;
    vector<int> nums = {1, 1, 1, 1, 1};
    int target = 3;
    cout << sol.findTargetSumWays(nums, target) << endl; // Output: 5
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*K),There are two nested loops
- **Space Complexity:** O(N*K), We are using an external array of size ‘N*K’. Stack Space is eliminated.

---

## Space Optimization Approach

### Algorithm:

If we closely observe the DP relation:

dp[ind][target] = dp[ind-1][target] + dp[ind-1][target - arr[ind]]

To compute the current DP state, we only need values from the **previous row**. Hence, storing the entire 2D DP table is unnecessary. We can **optimize space** by using a **1D DP array**.

### Key Idea:

- Use a single array `dp[]` where  
  `dp[j]` = number of ways to form sum `j`
- Update the array **from right to left** to avoid overwriting values needed for the current iteration


### Step-by-Step Procedure:

1. **Calculate the total sum of the array**
totalSum = sum(arr)

2. **Invalid cases**
- If `(totalSum + target)` is odd → return `0`
- If `|target| > totalSum` → return `0`

3. **Transform the problem**
Convert it into a subset sum problem:
newTarget = (totalSum + target) / 2

4. **Initialize DP array**
- Create a 1D array `dp` of size `(newTarget + 1)`
- Initialize all values to `0`
- Base condition:
  ```
  dp[0] = 1
  ```

5. **Iterate through the array**
For each element `num` in `arr`:
for j from newTarget down to num:
dp[j] = dp[j] + dp[j - num]

6. **Final Answer:** dp[newTarget]

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to count the number of ways to assign signs to reach the target
    int findTargetSumWays(vector<int>& nums, int target) {
        // Step 1: calculate the total sum of the array
        int total = accumulate(nums.begin(), nums.end(), 0);

        // Step 2: check feasibility
        if ((total + target) % 2 != 0 || abs(target) > total) return 0;

        // Step 3: new target for subset sum problem
        int newTarget = (total + target) / 2;

        // Step 4: initialize dp array of size newTarget + 1 with 0
        vector<int> dp(newTarget + 1, 0);

        // Step 5: base case: one way to form sum 0 (by choosing nothing)
        dp[0] = 1;

        // Step 6: iterate over each number
        for (int num : nums) {
            // Step 7: update dp array from right to left
            for (int j = newTarget; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }

        // Step 8: final answer
        return dp[newTarget];
    }
};

// Driver code
int main() {
    Solution sol;
    vector<int> nums = {1,1,1,1,1};
    int target = 3;
    cout << sol.findTargetSumWays(nums, target) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N * T)`
- **Space Complexity:** `O(T)`
