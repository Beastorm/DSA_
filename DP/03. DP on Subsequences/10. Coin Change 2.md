## Coin Change 2

**Problem Statement:**   
We are given an array Arr with N distinct coins and a target. We have an infinite supply of each coin denomination. We need to find the number of ways we can sum up the coin values to give us the target.

---

>### Examples:

### Example 1:
**Input:** coins = [2, 4,10], amount = 10
**Output:** 4
**Explanation:** The four combinations are:
10 = 10
10 = 4 + 4 + 2
10 = 4 + 2 + 2 + 2
10 = 2 + 2 + 2 + 2 + 2

---

### Example 2:
**Input:** coins = [5], amount = 5
**Output:** 1
**Explanation:** There is one combination: 5 = 5.

---

## Approach - Recursive

We can solve the problem recursively by trying each coin at every step and reducing the remaining amount. At each step, we choose the coin and recursively solve for the reduced amount. We take the minimum among all possibilities.

### Steps:

1. Base Case:  
   - If `amount == 0`, return 0 (no more coins needed).  
   - If `amount < 0`, return a large value (invalid path).  

2. Recursive Case:  
   - For each coin, recursively compute the minimum coins required for `amount - coin`.  
   - Take the minimum among all choices and add 1 (for the current coin used).  

3. Return the minimum number of coins needed.

### Recursive Formula:

minCoins(amount) = 1 + min(minCoins(amount - coin) for coin in coins)

### Note:
- This recursive solution explores all possible combinations of coins.  
- It has **exponential time complexity** due to overlapping subproblems.

### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function to find minimum coins
int minCoinsRecursive(vector<int>& coins, int amount) {
    // Base Case: amount is 0, no coins needed
    if (amount == 0) return 0;
    
    // Initialize answer to a large number
    int ans = INT_MAX;
    
    // Try all coins
    for (int coin : coins) {
        if (amount - coin >= 0) {
            int subRes = minCoinsRecursive(coins, amount - coin);
            if (subRes != INT_MAX) {
                ans = min(ans, 1 + subRes);
            }
        }
    }
    
    return ans;
}

int main() {
    vector<int> coins = {1, 2, 5};
    int amount = 11;
    
    int res = minCoinsRecursive(coins, amount);
    if (res == INT_MAX)
        cout << -1 << endl;  // Not possible
    else
        cout << res << endl; // Minimum coins
    
    return 0;
}
```
### Complexity Analysis:

**Time Complexity:** O(S^n)  
  - Here, `S` is the `amount` and `n` is the number of coin denominations.  
  - This is because for each amount, we try all `n` coins, and the recursion explores all possible combinations.  
  - Exponential in nature, very inefficient for large `amount`.

**Space Complexity:** O(S)  
  - Due to the recursion stack, the maximum depth of recursion is `amount`.  
  - No extra DP/memoization table is used in the pure recursive approach.

---

## Approach - Memoization

### Algorithm & Why Greedy Fails

**Why Greedy Doesn’t Work:**  
- Greedy fails because picking the locally largest coin may not lead to the minimum total coins.  
- Example: `coins = [1, 5, 6, 9]`, `amount = 11`.  
  - Greedy picks `9 + 1 + 1 = 3 coins`  
  - Optimal solution is `5 + 6 = 2 coins`.

**Recursive Approach (Pick/Not Pick):**  
1. For each coin at index `i`, we have two choices:  
   - **Not Pick:** Skip the coin, move to the next index.  
   - **Pick:** Use the coin, reduce the target by the coin value, and count 1 coin.  
2. Recursively do this for all coins.  
3. Return the minimum number of coins between pick and not pick.  
4. To avoid recomputation of overlapping subproblems, store results in a **memo table** (`dp[index][target]`) and check it before computing.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class to implement memoization approach
class Solution {
public:
    // Function to find the minimum coins
    int coinChange(vector<int>& coins, int amount) {
        // Creating dp array initialized with -2 
        // (-2 means not calculated yet)
        vector<int> dp(amount + 1, -2);

        // Calling helper function
        return helper(coins, amount, dp);
    }

private:
    // Helper recursive function
    int helper(vector<int>& coins, int rem, vector<int>& dp) {
        // If the remaining amount is zero
        if (rem == 0) return 0;

        // If the remaining amount is negative
        if (rem < 0) return -1;

        // If already computed
        if (dp[rem] != -2) return dp[rem];

        // Initialize minimum with a large value
        int mini = INT_MAX;

        // Try every coin
        for (int coin : coins) {
            // Recursive call
            int res = helper(coins, rem - coin, dp);

            // If the result is valid
            if (res >= 0 && res < mini)
                mini = 1 + res;
        }

        // Store result in dp
        dp[rem] = (mini == INT_MAX) ? -1 : mini;
        return dp[rem];
    }
};

// Driver function
int main() {
    vector<int> coins = {1, 2, 5};
    int amount = 11;

    Solution obj;
    cout << obj.coinChange(coins, amount) << endl;
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N * T), where N is the number of coin types and T is the target amount. Each state `(index, target)` is computed at most once.  
- **Space Complexity:** O(N * T) + O(N), for the memoization table and recursion stack.

---

## Tabulation Approach

### Algorithm:
1. To avoid extra recursion stack space, convert the memoization solution into a tabulation solution.
2. Create a 2D DP table where rows represent coin types and columns represent target amounts.
3. Initialize the first row based on whether each target can be formed using only the first coin type repeatedly:
   - If the target is divisible by the first coin, store the number of coins used.
   - Otherwise, mark it as not possible (e.g., a large number or infinity).
4. Iterate row by row for each coin type:
   - For each target amount, compute the result using two cases:
     1. **Exclude** the current coin → use the value from the previous row for the same target.
     2. **Include** the current coin → reduce the target and use the value from the same row (since unlimited coins are allowed).
   - Take the minimum of the two options.
5. The answer is found in the last row and last column of the table.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Solution class to implement tabulation approach
class Solution {
public:
    // Function to find the minimum coins
    int coinChange(vector<int>& coins, int amount) {
        // Creating dp array of size amount+1
        vector<int> dp(amount + 1, INT_MAX);

        // Base case: dp[0] = 0
        dp[0] = 0;

        // Loop through all amounts from 1 to the amount
        for (int i = 1; i <= amount; i++) {
            // Try each coin
            for (int coin : coins) {
                // If the coin can be used
                if (i - coin >= 0 && dp[i - coin] != INT_MAX) {
                    // Update dp[i] with minimum coins
                    dp[i] = min(dp[i], 1 + dp[i - coin]);
                }
            }
        }

        // If dp[amount] is still infinity, return -1
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};

// Driver function
int main() {
    vector<int> coins = {1, 2, 5};
    int amount = 11;

    Solution obj;
    cout << obj.coinChange(coins, amount) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N * T), where N is the number of coin types, and T is the target amount. Each state is computed once.  
- **Space Complexity:** O(N * T), for storing the 2D DP table.

---

## Space Optimization Approach

### Algorithm:

If we closely look at the relation:
dp[ind][target] = dp[ind-1][target] + dp[ind-1][target-arr[ind]]

We see that to calculate the value of a cell of the DP array, we need only the previous row values.  
So, we don’t need to store the entire 2D table and can use space optimization.

**Note:**  
We first need to initialize the first row as we did in the tabulation approach.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class containing the solution method
class Solution {
public:

    // Function to compute the minimum elements to reach the target sum
    int minimumElements(vector<int>& arr, int T) {
        int n = arr.size();

        // Create two vectors for previous and current rows
        vector<int> prev(T + 1, 0);
        vector<int> cur(T + 1, 0);

        // Initialize base case for the first row
        for (int i = 0; i <= T; i++) {
            if (i % arr[0] == 0)
                prev[i] = i / arr[0];
            // Very large value if not possible
            else
                prev[i] = 1e9; 
        }

        // Fill table using bottom-up approach
        for (int ind = 1; ind < n; ind++) {
            for (int target = 0; target <= T; target++) {

                // Option 1: Do not take the current element
                int notTake = prev[target];

                // Option 2: Take the current element if possible
                int take = 1e9;
                if (arr[ind] <= target)
                    take = 1 + cur[target - arr[ind]];

                // Store minimum of take and notTake
                cur[target] = min(notTake, take);
            }

            // Update previous row with current row values
            prev = cur;
        }

        // Retrieve answer from the last row
        int ans = prev[T];

        // Return -1 if target cannot be formed
        if (ans >= 1e9)
            return -1;

        // Return the minimum number of elements required
        return ans;
    }
};

// Main function to test the solution
int main() {

    // Input array
    vector<int> arr = {1, 2, 3};

    // Target sum
    int T = 7;

    // Create object of Solution class
    Solution sol;

    // Call function to get result
    int result = sol.minimumElements(arr, T);

    // Output the result
    cout << "The minimum number of coins required to form the target sum is "
         << result << endl;

    // Return 0 to indicate successful execution
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N * T), since there are N rows and T target values, and each state is computed once.  
- **Space Complexity:** O(T), as we store only one row (or two rows) instead of the entire 2D DP table.
