## Unbounded Knapsack (DP-23)

**Problem Statement:**   
A thief wants to rob a store. He is carrying a bag of capacity `W`. The store has `n` items of infinite supply. Its weight is given by the `wt` array and its value by the `val` array. He can either include an item in his knapsack or exclude it, but can’t partially have it as a fraction. We need to find the maximum value of items that the thief can steal. He can take a single item any number of times he wants and put it in his knapsack.

---

>### Examples:

### Example 1:
**Input:** n = 3, W = 8, wt = [2, 4, 6], val = [5, 11, 13]   
**Output:** 22   
**Explanation:** We can take an item with a weight of 2 (value 5) four times to fill a capacity of 8, total value = 5 × 4 = 20.   
But a better choice: take item with weight 2 (value 5) twice and item with weight 4 (value 11) once → total weight = 2 + 2 + 4 = 8, total value = 5 + 5 + 11 = 21.
Even better: take two items with weight 4 (value 11 each), total value = 22, which is maximum.

---

### Example 2:
**Input:** n = 2, W = 3, wt = [2, 1], val = [4, 2]   
**Output:** 6   
**Explanation:** We can take an item with a weight of 1 (value 2) three times, total value = 6.
Taking weight 2 (value 4) plus weight 1 (value 2) also gives 6. No combination yields more than 6.

---

## Approach Recursive

### Intuition:

At every index, we have **two choices**:

1. **Exclude the current item**
   - Move to the previous index
2. **Include the current item**
   - Since items are unlimited, we **stay at the same index**
   - Reduce the remaining capacity

We take the **maximum value** of both choices.

### Recursive Relation:

Let `f(ind, W)` be the **maximum value** using items `0..ind` with capacity `W`.

- **Base Case**
  - If `ind == 0`  
    We can take item `0` as many times as possible:
    ```
    f(0, W) = (W / wt[0]) * val[0]
    ```

- **Recursive Case**
notTake = f(ind - 1, W)

take = val[ind] + f(ind, W - wt[ind]) (only if wt[ind] <= W)

`f(ind, W) = max(take, notTake)`


### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

int unboundedKnapsack(int ind, int W, vector<int>& wt, vector<int>& val) {
  // Base case
  if (ind == 0) {
      return (W / wt[0]) * val[0];
  }

  // Option 1: Do not take the current item
  int notTake = unboundedKnapsack(ind - 1, W, wt, val);

  // Option 2: Take current item (can take again)
  int take = 0;
  if (wt[ind] <= W) {
      take = val[ind] + unboundedKnapsack(ind, W - wt[ind], wt, val);
  }

  return max(take, notTake);
}

int main() {
  int n = 3, W = 8;
  vector<int> wt = {2, 4, 6};
  vector<int> val = {5, 11, 13};

  cout << unboundedKnapsack(n - 1, W, wt, val);
  return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** Exponential (≈ 2^N)
- **Space Complexity:** O(W) recursion stack (worst case)

---

## Memoization Approach

### Why Greedy Does Not Work?

A greedy solution fails in this problem because there is **no uniform pattern** in the data.  
Choosing a locally optimal item (based on value or weight ratio) may lead to a **suboptimal overall result**.

Hence, we must explore **all possible combinations** using recursion and optimize it using **Dynamic Programming**.

### Step 1: Express the Problem in Terms of Indices

We are given:
- `n` items
- `wt[]` → weights of items
- `val[]` → values of items
- `W` → capacity of the knapsack

Define a function: f(ind, W)

It represents the **maximum value** we can obtain using items from index `0` to `ind` with remaining capacity `W`.

Initially, we want to compute: f(n-1, W)

### Step 2: Define the Base Case

If `ind == 0`, we only have the **first item** available.

Since this is an **unbounded knapsack**, we can take this item **any number of times** as long as weight allows.

f(0, W) = (W / wt[0]) * val[0]

This ensures maximum value while respecting the capacity.

---

### Step 3: Try All Possible Choices (Pick / Non-Pick)

At any index `ind`, we have **two choices**:

### 1️⃣ Exclude the Current Item (Not Pick)

- Do not include the current item
- Capacity remains the same
- Move to the previous index

notTake = f(ind - 1, W)

### 2️⃣ Include the Current Item (Pick)

- Include the current item only if `wt[ind] <= W`
- Add its value
- Reduce capacity
- Stay at the same index (unlimited supply)

take = val[ind] + f(ind, W - wt[ind])

## Step 4: Take the Maximum

Since we want to **maximize value**, we take:

f(ind, W) = max(take, notTake)

## Step 5: Memoization (Optimizing the Recursive Solution)

### Why Memoization?

The recursion tree contains **overlapping subproblems**.  
To avoid recomputation, we store results.

### DP Table:
- Create a DP array: dp[n][W+1]
- Initialize all values to `-1`

### Memoization Rule:

Before computing `f(ind, W)`:
If dp[ind][W] != -1
return dp[ind][W]

Otherwise:
- Compute using recursion
- Store the result in `dp[ind][W]`
- Return the stored value

### Final Memoized Recurrence

```
f(ind, W) = max(f(ind - 1, W),val[ind]
+ 
f(ind, W - wt[ind]) if wt[ind] <= W)
```

### Key Insight:

- **Unlimited supply** → stay on the same index when picking
- **Memoization** reduces exponential recursion to polynomial time

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Utility function for solving the unbounded knapsack problem using recursion + memoization
    int knapsackUtil(vector<int>& wt, vector<int>& val, int ind, int W, vector<vector<int>>& dp) {
        // Base case: if we're at the first item
        if (ind == 0) {
            // Calculate and return the maximum value for the given weight limit
            return (W / wt[0]) * val[0];
        }

        // If the result for this index and weight limit is already calculated, return it
        if (dp[ind][W] != -1)
            return dp[ind][W];

        // Calculate the maximum value without taking the current item
        int notTaken = knapsackUtil(wt, val, ind - 1, W, dp);

        // Initialize 'taken' with a very small value
        int taken = INT_MIN;

        // If current item can fit in the remaining capacity
        if (wt[ind] <= W)
            taken = val[ind] + knapsackUtil(wt, val, ind, W - wt[ind], dp);

        // Store and return the maximum of taking or not taking the current item
        return dp[ind][W] = max(notTaken, taken);
    }

    // Main function to call the utility function and set up DP table
    int unboundedKnapsack(int n, int W, vector<int>& val, vector<int>& wt) {
        // Create a DP table initialized with -1
        vector<vector<int>> dp(n, vector<int>(W + 1, -1));

        // Call the recursive function and return the answer
        return knapsackUtil(wt, val, n - 1, W, dp);
    }
};

// Driver code
int main() {
    // Initialize item weights
    vector<int> wt = {2, 4, 6};

    // Initialize item values
    vector<int> val = {5, 11, 13};

    // Weight capacity of the knapsack
    int W = 10;

    // Number of items
    int n = wt.size();

    // Create Solution object
    Solution obj;

    // Output the result
    cout << "The Maximum value of items the thief can steal is " 
         << obj.unboundedKnapsack(n, W, val, wt) << endl;

    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N*W), There are N*W states,s therefore at max ‘N*W’ new problems will be solved.
- **Space Complexity:** O(N*W) + O(N). We are using a recursion stack space(O(N)) and a 2D array ( O(N*W)).

---

## Tabulation Approach

### Algorithm:

To convert the **memoization approach** into a **tabulation approach**, we create a DP table and fill it iteratively instead of using recursion.

### Step 1: Create the DP Table

- Create a 2D DP array: dp[n][W + 1]

- Initialize all values to `0`

Here:
- `dp[ind][cap]` represents the **maximum value** achievable using items from `0` to `ind` with capacity `cap`.


### Step 2: Initialize Base Case (First Row)

When `ind == 0`, only the **first item** is available.

Since it is an **unbounded knapsack**, we can take the first item multiple times.

For every capacity `cap` from `0` to `W`:
dp[0][cap] = (cap / wt[0]) * val[0]

This fills the first row of the DP table.

### Step 3: Fill the DP Table

Now, iterate over the remaining items and capacities.

- `ind` varies from `1` to `n - 1`
- `cap` varies from `0` to `W`

For each cell `dp[ind][cap]`, we compute two choices:

#### 1️⃣ Not Take the Current Item

notTake = dp[ind - 1][cap]

#### 2️⃣ Take the Current Item (if possible)

If `wt[ind] <= cap`:

take = val[ind] + dp[ind][cap - wt[ind]]

Else:

take = 0

#### 3️⃣ Store the Maximum

dp[ind][cap] = max(take, notTake)

### Step 4: Final Answer:

After filling the entire DP table, the answer is stored at: dp[n - 1][W]

### Key Observations:
- Staying on the **same index while picking** enables unlimited usage of items.
- Tabulation removes recursion stack overhead.
- Time complexity remains optimal.


### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to solve the unbounded knapsack problem using tabulation
    int unboundedKnapsack(int n, int W, vector<int>& val, vector<int>& wt) {
        // Create a DP table where dp[i][j] represents max value using first i items and capacity j
        vector<vector<int>> dp(n, vector<int>(W + 1, 0));

        // Base condition: fill first row considering infinite supply of first item
        for (int i = wt[0]; i <= W; i++) {
            dp[0][i] = (i / wt[0]) * val[0];
        }

        // Loop through all items starting from the second
        for (int ind = 1; ind < n; ind++) {
            // Loop through all capacities from 0 to W
            for (int cap = 0; cap <= W; cap++) {
                // Case 1: Not taking the current item
                int notTaken = dp[ind - 1][cap];

                // Case 2: Taking the current item (if it fits)
                int taken = INT_MIN;
                if (wt[ind] <= cap)
                    taken = val[ind] + dp[ind][cap - wt[ind]];

                // Store the best of both choices
                dp[ind][cap] = max(notTaken, taken);
            }
        }

        // Return the maximum value possible for n items and capacity W
        return dp[n - 1][W];
    }
};

// Driver code
int main() {
    // Item weights
    vector<int> wt = {2, 4, 6};

    // Item values
    vector<int> val = {5, 11, 13};

    // Knapsack capacity
    int W = 10;

    // Number of items
    int n = wt.size();

    // Create object
    Solution obj;

    // Output result
    cout << "The Maximum value of items the thief can steal is "
         << obj.unboundedKnapsack(n, W, val, wt) << endl;

    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N*W),There are two nested loops
- **Space Complexity:** O(N*W), We are using an external array of size ‘N*W’. Stack Space is eliminated.

---

## Approach - Space Optimization

### Key DP Relation:

From the tabulation approach, we have the recurrence:
```
dp[ind][cap] = max(
dp[ind - 1][cap],
val[ind] + dp[ind][cap - wt[ind]]
)
```
### Observation:

To compute `dp[ind][cap]`, we need:

- `dp[ind - 1][cap]` → value from the **previous row**
- `dp[ind][cap - wt[ind]]` → value from the **current row**

So, at any point:
- We **do not need the entire DP table**
- We only need:
  - One value from the previous row
  - One value from the current row

This allows us to **optimize space**.

---

### Space Optimization Idea:
Instead of maintaining a 2D DP array, we use a **single 1D array**: dp[cap]


Where:
- `dp[cap]` represents the maximum value achievable for capacity `cap`
- The same array is reused for all items

### Why One Row Works (Important Insight):

When iterating capacity from `0 → W`:

- `dp[cap]` (before update) behaves like `dp[ind - 1][cap]`
- `dp[cap - wt[ind]]` (already updated) behaves like `dp[ind][cap - wt[ind]]`

So, the required values are **already available** inside the same array.

This works **only because it is an Unbounded Knapsack**, where we are allowed to stay on the same index after taking an item.


### Algorithm Steps:

#### Step 1: Initialize DP Array

- Create a 1D DP array of size `W + 1`
- Initialize all values to `0`

dp[0…W] = 0


#### Step 2: Process Each Item

For each item index `ind` from `0` to `n - 1`:

- Traverse capacity from `wt[ind]` to `W` (left to right)

#### Step 3: Update DP State

For each capacity `cap`:

dp[cap] = max(
dp[cap],
val[ind] + dp[cap - wt[ind]]
)

Explanation:
- `dp[cap]` → previous value (acts as `dp[ind - 1][cap]`)
- `val[ind] + dp[cap - wt[ind]]` → taking the current item again

#### Step 4: Final Answer:

After processing all items: dp[W]
contains the **maximum value** achievable with capacity `W`.

### Why This Optimization Works

- We reuse the same row as both:
  - previous row (`dp[ind - 1][cap]`)
  - current row (`dp[ind][cap - wt[ind]]`)
- No overwriting issue because:
  - capacities are processed **left to right**
  - Unlimited item usage is allowed


### Final Takeaway:
- Unbounded Knapsack allows **forward iteration**
- One DP array is sufficient
- Clean, efficient, and optimal

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to solve the unbounded knapsack problem using space-optimized DP
    int unboundedKnapsack(int n, int W, vector<int>& val, vector<int>& wt) {
        // Create a 1D DP array where cur[cap] stores max value for given capacity
        vector<int> cur(W + 1, 0);

        // Base condition: fill values for first item
        for (int i = wt[0]; i <= W; i++) {
            cur[i] = (i / wt[0]) * val[0];
        }

        // Iterate through remaining items
        for (int ind = 1; ind < n; ind++) {
            for (int cap = 0; cap <= W; cap++) {
                // Option 1: Do not take the current item
                int notTaken = cur[cap];

                // Option 2: Take current item (if it fits)
                int taken = INT_MIN;
                if (wt[ind] <= cap) {
                    taken = val[ind] + cur[cap - wt[ind]];
                }

                // Store the better option
                cur[cap] = max(notTaken, taken);
            }
        }

        // Return max value for capacity W
        return cur[W];
    }
};

int main() {
    vector<int> wt = {2, 4, 6}; // Weights of items
    vector<int> val = {5, 11, 13}; // Values of items
    int W = 10; // Capacity of knapsack
    int n = wt.size(); // Number of items

    Solution obj; // Create Solution object
    cout << "The Maximum value of items the thief can steal is "
         << obj.unboundedKnapsack(n, W, val, wt) << endl;

    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** `O(n × W)`
- **Space Complexity:** `O(W)`



