## Count Subsets with Sum K

**Problem Statement:**   
Given an array `arr` of `n` integers and an integer `K`, count the number of subsets whose sum is exactly equal to `K`.

A **subset** can be contiguous or non-contiguous, but elements must follow the original order.

---

>### Examples:

### Example 1:
- **Input:** `arr = [1, 2, 2, 3]`, `K = 3`
- **Output:** `3`
- **Explanation:** Valid subsets are `[1,2]`, `[1,2]`, and `[3]`.

---

### Example 2:
- **Input:** `arr = [1, 2, 3, 4, 5]`, `K = 5`
- **Output:** `3`
- **Explanation:** Valid subsets are `[5]`, `[2,3]`, and `[1,4]`.

---

## Approach - Recursive

### Intuition:
For every element in the array, we have **two choices**:
- **Include** it in the subset
- **Exclude** it from the subset

We explore **all possible subsets** using recursion.  
Whenever the remaining sum becomes **0**, we have found **one valid subset**.

Since we need the **count** of such subsets (not just true/false), we **add** the results from both choices.

---

### Algorithm:

1. Start from the last index with the target sum `K`.
2. At each index:
   - **Not Pick** the element → move to previous index with same target.
   - **Pick** the element (only if ≤ target) → reduce target and move to previous index.
3. If `target == 0`, return `1` (one valid subset found).
4. If index becomes `< 0`, return `0` (no valid subset).
5. Return the **sum of counts** from pick and not-pick cases.

### Recursive Relation:

f(ind, target) = f(ind-1, target) + f(ind-1, target - arr[ind]) if arr[ind] ≤ target

### Final Answer:
Call the function as: f(n-1, K)

This gives the **total number of subsets** with sum equal to `K`.

### C++ Code:
``` cpp

#include <bits/stdc++.h>
using namespace std;

int countSubsets(int ind, int target, vector<int>& arr) {
    // Base cases
    if (target == 0)
        return 1;
    if (ind < 0)
        return 0;

    // Not pick current element
    int notPick = countSubsets(ind - 1, target, arr);

    // Pick current element
    int pick = 0;
    if (arr[ind] <= target)
        pick = countSubsets(ind - 1, target - arr[ind], arr);

    return pick + notPick;
}

int main() {
    vector<int> arr = {1, 2, 2, 3};
    int K = 3;
    int n = arr.size();

    cout << countSubsets(n - 1, K, arr);
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** **O(2ⁿ)**  
  - At each element, we branch into two choices (pick / not pick), leading to an exponential number of recursive calls.

- **Space Complexity:** **O(N)**  
  - Maximum depth of the recursion stack is `N`, where `N` is the number of elements in the array.

---

## Memoization Approach

### Algorithm:

The problem of counting subsets with a given sum **K** can be modeled as a choice at each index:
- **Include** the current element → reduce the target by its value
- **Exclude** the current element → keep the target unchanged

This leads to a recursive solution, but many subproblems repeat (same `index` and `target`).  
To avoid recomputation, we use **memoization**, storing results for each state `(index, target)`.

### Steps:

- Define a recursive function `f(index, target)` that returns the number of subsets.
- **Base Cases**:
  - If `target == 0`, return `1` (one valid subset found).
  - If `index == 0`, return `1` if `arr[0] == target`, else return `0`.
- If the result for `(index, target)` is already stored in `dp`, return it.
- Compute:
  - `notPick = f(index - 1, target)`
  - `pick = f(index - 1, target - arr[index])` (only if `arr[index] <= target`)
- Total ways = `pick + notPick`
- Store the result in `dp[index][target]` and return it.

Memoization ensures each state is solved only once, reducing the exponential complexity to polynomial.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to count subsets that sum up to target
    int countSubsets(vector<int>& nums, int target) {
        // Initialize dp table with -1 (uncomputed states)
        vector<vector<int>> dp(nums.size(), vector<int>(target + 1, -1));
        return solve(nums.size() - 1, target, nums, dp);
    }

private:
    // Recursive helper with memoization
    int solve(int index, int target, vector<int>& nums, vector<vector<int>>& dp) {
        // Base case: if target is 0, we found a valid subset
        if (target == 0) return 1;

        // Base case: if we are at index 0, check if nums[0] equals target
        if (index == 0) return (nums[0] == target ? 1 : 0);

        // If already computed, return from dp
        if (dp[index][target] != -1) return dp[index][target];

        // Case 1: Exclude current element
        int notTake = solve(index - 1, target, nums, dp);

        // Case 2: Include current element (if it is not greater than target)
        int take = 0;
        if (nums[index] <= target) {
            take = solve(index - 1, target - nums[index], nums, dp);
        }

        // Store result in dp and return
        return dp[index][target] = take + notTake;
    }
};

int main() {
    vector<int> nums = {1, 2, 3, 3};
    int target = 6;
    Solution obj;
    cout << obj.countSubsets(nums, target) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N * K)`  
  - Each state defined by `(index, target)` is computed only once.
  
- **Space Complexity:** `O(N * K)`  
  - Extra space is used for the DP table, along with recursion stack space.

---

## Tabulation

### Algorithm: 

The problem of counting subsets with a given sum `K` can be solved using tabulation by building the solution bottom-up. We construct a DP table where each entry `dp[i][t]` represents the number of subsets that can be formed using the first `i` elements to achieve sum `t`.  

### Steps:  

1. Create a 2D `dp` table where `dp[i][t]` = number of subsets using first `i` elements to make sum `t`.  
2. Initialize `dp[0][0] = 1` because with zero elements, only the empty subset forms sum 0.  
3. If the first element `arr[0] <= K`, set `dp[0][arr[0]] = 1` because a single element can form that sum.  
4. Iterate over all elements from index `1` to `n-1`.  
5. For each element, iterate over all target sums from `0` to `K`.  
6. For `dp[i][t]`, first take the value from `dp[i-1][t]` (excluding the current element).  
7. If `arr[i] <= t`, also add `dp[i-1][t - arr[i]]` (including the current element).  
8. At the end, `dp[n-1][K]` will hold the total number of subsets with sum equal to `K`.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int countSubsets(vector<int>& arr, int K) {
        // Get number of elements
        int n = arr.size();

        // Create dp table with dimensions n x (K+1)
        vector<vector<int>> dp(n, vector<int>(K + 1, 0));

        // Base case: one subset (empty set) makes sum 0
        dp[0][0] = 1;

        // If first element is <= K, mark dp[0][arr[0]] as 1
        if (arr[0] <= K) dp[0][arr[0]] = 1;

        // Fill the table
        for (int i = 1; i < n; i++) {
            for (int target = 0; target <= K; target++) {
                // Exclude current element
                int notTake = dp[i - 1][target];

                // Include current element if possible
                int take = 0;
                if (arr[i] <= target) take = dp[i - 1][target - arr[i]];

                // Total ways
                dp[i][target] = notTake + take;
            }
        }

        // Final answer
        return dp[n - 1][K];
    }
};

int main() {
    Solution obj;
    vector<int> arr = {1, 2, 3, 3};
    int K = 6;
    cout << obj.countSubsets(arr, K) << endl;
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N * K), each state defined by index and target is computed once.  
- **Space Complexity:** O(N * K), extra space is used for the DP table.

---
## Space Optimization

### Algorithm:

The problem of counting subsets with a given sum K can also be solved with space optimization. Instead of storing results for all `n` rows, we notice that `dp[i][t]` only depends on the previous row. Thus, instead of storing the entire table, we can only store a single 1D array representing the previous row.

### Steps:

1. Create a 1D `dp` array of size `(K + 1)`, where `dp[t]` represents the number of subsets that sum to `t`.
2. Initialize `dp[0] = 1` because there’s always one subset (empty set) with sum `0`.
3. If the first element is less than or equal to `K`, set `dp[arr[0]] = 1`.
4. Iterate through the array from index `1` to `n-1`.
5. For each element, traverse target sums **backwards** from `K` down to `arr[i]`.
6. Update `dp[t]` by adding `dp[t - arr[i]]`, meaning we include the current element.
7. Backward traversal ensures we don’t overwrite values that are yet to be used.
8. At the end, `dp[K]` will hold the total number of subsets that sum to `K`.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int countSubsets(vector<int>& arr, int K) {
        // Create a dp array of size K+1 initialized to 0
        vector<int> dp(K + 1, 0);

        // Base case: One subset (empty set) makes sum 0
        dp[0] = 1;

        // If first element <= K, mark it as a subset
        if (arr[0] <= K) dp[arr[0]] += 1;

        // Loop through elements starting from index 1
        for (int i = 1; i < arr.size(); i++) {
            // Create a temporary dp array for current element
            vector<int> curr(K + 1, 0);

            // Empty set always makes sum 0
            curr[0] = 1;

            // Iterate over all possible targets
            for (int t = 0; t <= K; t++) {
                // Exclude current element
                int notTake = dp[t];

                // Include current element if possible
                int take = 0;
                if (arr[i] <= t) {
                    take = dp[t - arr[i]];
                }

                // Total ways = include + exclude
                curr[t] = take + notTake;
            }

            // Update dp for next iteration
            dp = curr;
        }

        // Return answer for sum K
        return dp[K];
    }
};

int main() {
    Solution sol;
    vector<int> arr = {1, 2, 3};
    int K = 4;
    cout << sol.countSubsets(arr, K) << endl; 
    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** O(N * K), each state defined by index and target is computed once.  
- **Space Complexity:** O(K), extra space is used for storing the dp array.



