## Rod Cutting Problem | (DP - 24)

**Problem Statement:**    
Given a rod of length N inches and an array price[] where price[i] denotes the value of a piece of rod of length i inches (1-based indexing). Determine the maximum value obtainable by cutting up the rod and selling the pieces. Make any number of cuts, or none at all, and sell the resulting pieces.

>### Examples:

### Example 1:
**Input:** price = [1, 6, 8, 9, 10, 19, 7, 20], N = 8
**Output:** 25
**Explanation:** Cut the rod into lengths of 2 and 6 for a total price of 6 + 19= 25.

---

### Example 2:
**Input:** price = [1, 5, 8, 9], N = 4
**Output:** 10
**Explanation:** Cut the rod into lengths of 2 and 2 for a total price of 5 + 5 = 10.

---
## Approach - Recursive

### Intuition:

The Rod Cutting problem is a classic **optimization problem** where we are allowed to cut a rod into smaller pieces and sell them to maximize profit.

Key observations:
- Each rod length can be used **multiple times** ‚Üí this is an **Unbounded Knapsack** problem.
- For every possible rod length, we have **two choices**:
  1. **Do not cut** using this length ‚Üí move to smaller lengths.
  2. **Cut** using this length ‚Üí reduce remaining rod length and stay on the same index.

The goal is to explore all valid ways of cutting the rod and pick the one that gives the **maximum total value**.

---

### Problem Re-statement (Recursive View):

Given:
- `price[i]` ‚Üí value of rod piece of length `i + 1`
- Rod length `N`

We define:
> `f(ind, N)` = maximum value obtainable using rod lengths `1` to `ind + 1` for a rod of length `N`.


###  Base Case:

- When `ind == 0` (only rod of length `1` is available):
  - We can cut the rod into `N` pieces of length `1`
  - Total value = `N √ó price[0]`


### Recursive Choices:

At any index `ind`, we have two options:

#### 1Ô∏è‚É£ Not Take the Current Rod Length
- Skip the current rod length
- Move to smaller rod sizes
notTake = f(ind - 1, N)


### 2Ô∏è‚É£ Take the Current Rod Length
- Use the rod of length `ind + 1`
- Reduce remaining rod length
- Stay at the same index (unbounded usage)

take = price[ind] + f(ind, N - (ind + 1))


‚ö†Ô∏è Only allowed if `(ind + 1) ‚â§ N`

### Final Answer:

At each step, we choose the better of the two:
f(ind, N) = max(take, notTake)

The final result is:
f(n - 1, N)

### Why Recursion Works Here

- Explores **all possible cutting combinations**
- Guarantees the **maximum profit**
- Directly models decision-making at each rod length

### Note:
This recursive solution is **educational** and helps build intuition.  
For large inputs, it should be optimized using:
- Memoization
- Tabulation
- 1D Space Optimization

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function
int solve(int ind, int N, vector<int>& price) {
    // Base case: only rod of length 1 available
    if (ind == 0) {
        return N * price[0];
    }

    // Option 1: Do not cut using the current rod length
    int notTake = solve(ind - 1, N, price);

    // Option 2: Cut using current rod length (unbounded)
    int take = INT_MIN;
    int rodLength = ind + 1;

    if (rodLength <= N) {
        take = price[ind] + solve(ind, N - rodLength, price);
    }

    return max(take, notTake);
}

// Driver function
int cutRod(vector<int>& price, int N) {
    int n = price.size();
    return solve(n - 1, N, price);
}

int main() {
    vector<int> price = {1, 6, 8, 9, 10, 19, 7, 20};
    int N = 8;

    cout << "Maximum Obtainable Value: " << cutRod(price, N) << endl;

    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** O(2^N)
  - The recursive solution tries **all possible cuts** of the rod.
  - (Exponential because every length has cut / no-cut choices)

- **Space Complexity:** O(N)
  - Only the **recursion stack** is used.  

---

## Approach - Memoization

### Why Greedy Doesn‚Äôt Work?
A greedy approach fails because **locally optimal choices don‚Äôt guarantee a global optimum**.  
Choosing an item with the highest value or best value/weight ratio may block better combinations later.

Hence, we explore **all possible combinations** using recursion and optimize it with **memoization**.

### Recursive + Memoization Strategy

#### 1Ô∏è‚É£ Express the Problem in Terms of Indexes
- We are given:
  - `wt[]` ‚Üí weights of items  
  - `val[]` ‚Üí values of items  
  - `W` ‚Üí knapsack capacity  
  - `n` ‚Üí number of items  

Define the function: f(ind, W)
It represents the **maximum value** we can obtain using items from index `0` to `ind` with capacity `W`.
Initial call: f(n-1, W)

#### 2Ô∏è‚É£ Base Case
If `ind == 0`, only the first item is available.

Since this is **unbounded knapsack**, we can take item `0` multiple times:

f(0, W) = (W / wt[0]) * val[0]

#### 3Ô∏è‚É£ Try All Possible Choices

At index `ind`, we have **two choices**:

#### Not Take (Exclude current item)
- Capacity remains the same
notTake = f(ind - 1, W)

#### ‚úÖ Take (Include current item)
- Allowed only if `wt[ind] <= W`
- Since items are unlimited, we stay on the same index
take = val[ind] + f(ind, W - wt[ind])

### 4Ô∏è‚É£ Return the Best Option
f(ind, W) = max(take, notTake)

### Why Memoization?
The recursion tree has **overlapping subproblems**.  
To avoid recomputation, we store results.

### Steps:
- Create a DP table: dp[n][W+1]

- Initialize all values to `-1`
- Before computing `f(ind, W)`:
  - If `dp[ind][W] != -1`, return it
- Otherwise:
  - Compute using recursion
  - Store the result in `dp[ind][W]`

### ‚úÖ Final Result
Memoization reduces time complexity dramatically and converts an exponential solution into a **polynomial-time DP solution**.
Answer = dp[n-1][W]

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
  public:
    // Function to compute the maximum price obtainable by cutting the rod
    int rodCutting(vector<int> price, int n) {

        // Initialize a DP table where dp[i][j] stores the max price 
        // using first i rod lengths to make total rod length j
        vector<vector<int>> dp(n, vector<int>(n + 1, 0));

        // Fill the base case: only using the first rod length (length = 1)
        for(int length = 0; length <= n; length++) {
            // We can use the rod of length 1 (index 0) multiple times
            dp[0][length] = length * price[0];
        }

        // Iterate through each rod piece starting from index 1
        for(int i = 1; i < n; i++) {
            for(int length = 0; length <= n; length++) {

                // Option 1: Do not cut with this rod (copy from above)
                int notTake = dp[i - 1][length];

                // Option 2: Cut with current rod length (reuse allowed)
                int take = INT_MIN;
                int rodLength = i + 1;

                // Check if this rod fits in the current length
                if(rodLength <= length) {
                    take = price[i] + dp[i][length - rodLength];
                }

                // Store the best value in the DP table
                dp[i][length] = max(take, notTake);
            }
        }

        // Return the answer from the last row and column (full rod length)
        return dp[n - 1][n];
    }
};

// Driver code
int main() {
    // Length of the rod
    int n = 8;

    // Price list where price[i] is the value of rod of length i+1
    vector<int> price = {1, 5, 8, 9, 10, 17, 17, 20};

    // Create object of Solution class
    Solution obj;

    // Call rodCutting function and print the result
    int maxValue = obj.rodCutting(price, n);
    cout << "The maximum obtainable value is: " << maxValue << endl;

    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(n √ó n). Each subproblem (i, length) is computed once.
- **Space Complexity:** O(n √ó n),We use a 2D DP table for memoization.


---


## Tabulation Approach 
This problem is a **classic Unbounded Knapsack** variant.

### Key Insight:
- Each rod piece length `i` (1-based) has:
  - **length = i**
  - **value = price[i-1]**
- You can cut the rod **any number of times** ‚Üí items are **unlimited**
- Goal: **maximize total price** for rod length `N`

### DP Definition
Let  
dp[ind][len]

= **maximum value obtainable** using rod lengths `1..(ind+1)` to achieve total length `len`

**Where:**
- `ind` ‚Üí index in `price[]` (0-based)
- `len` ‚Üí current rod length (0 to N)

DP table size: dp[n][N + 1]

### Base Case Initialization:

### First Row (`ind == 0`)
Only rod length **1** is available.

So for every length `len`:
dp[0][len] = len * price[0]

Because we can cut length-1 pieces unlimited times.

### Transition (Tabulation):

For each index `ind = 1 .. n-1`  
For each rod length `len = 0 .. N`

### Not Take
Do not cut using the current rod length:
notTake = dp[ind - 1][len]


### ‚úÖ Take (Unbounded)
If `(ind + 1) <= len`, we can take the current piece again:
take = price[ind] + dp[ind][len - (ind + 1)]

### Best Choice
dp[ind][len] = max(take, notTake)

### üéØ Final Answer
dp[n - 1][N]

### üíª C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int cutRod(vector<int>& price, int N) {
    int n = price.size();
    vector<vector<int>> dp(n, vector<int>(N + 1, 0));

    // Base case: only length 1 available
    for (int len = 0; len <= N; len++) {
        dp[0][len] = len * price[0];
    }

    // Fill DP table
    for (int ind = 1; ind < n; ind++) {
        for (int len = 0; len <= N; len++) {
            int notTake = dp[ind - 1][len];
            int take = 0;
            int rodLength = ind + 1;

            if (rodLength <= len) {
                take = price[ind] + dp[ind][len - rodLength];
            }

            dp[ind][len] = max(take, notTake);
        }
    }

    return dp[n - 1][N];
}

int main() {
    vector<int> price = {1, 6, 8, 9, 10, 19, 7, 20};
    int N = 8;
    cout << cutRod(price, N);
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N¬≤)
- **Space Complexity:** O(N¬≤)

---

## Space Optimized Approach
The **Rod Cutting problem** is an **Unbounded Knapsack** problem, which means:
- Each rod length can be used **multiple times**
- We can optimize space using **1D DP**

### Key Observation:

From tabulation:
```
dp[ind][len] = max(
dp[ind-1][len], // not take
price[ind] + dp[ind][len-(ind+1)] // take (same index)
)
```
**Notice:**
- `dp[ind][len]` depends on:
  - **previous row** ‚Üí `dp[ind-1][len]`
  - **same row** ‚Üí `dp[ind][len-(ind+1)]`

So, we **do not need a full 2D table**.
A **single 1D array** is enough.


### 1D DP Definition:
dp[len] = maximum value obtainable for rod length = len
DP size: dp[N + 1]

### Initialization:

When only the rod of length `1` is available: dp[len] = len * price[0]

### Transition (Unbounded Knapsack):
For each rod length `ind = 1 .. n-1`  
For each `len = 0 .. N`:

- **Not take** ‚Üí dp[len] (already present)
- **Take** ‚Üí price[ind] + dp[len - (ind + 1)]

dp[len] = max(dp[len], price[ind] + dp[len - rodLength])


‚ö†Ô∏è Loop `len` **from left to right** (0 ‚Üí N)  
This allows reuse of the same item multiple times.


### üéØ Final Answer: dp[N]

### üíª C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int cutRod(vector<int>& price, int N) {
    int n = price.size();
    vector<int> dp(N + 1, 0);

    // Base case: only length 1 rod
    for (int len = 0; len <= N; len++) {
        dp[len] = len * price[0];
    }

    // Process remaining rod lengths
    for (int ind = 1; ind < n; ind++) {
        int rodLength = ind + 1;
        for (int len = rodLength; len <= N; len++) {
            dp[len] = max(dp[len], price[ind] + dp[len - rodLength]);
        }
    }

    return dp[N];
}

int main() {
    vector<int> price = {1, 6, 8, 9, 10, 19, 7, 20};
    int N = 8;
    cout << cutRod(price, N);
    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** O(N¬≤)
- **Space Complexity:** O(N)

