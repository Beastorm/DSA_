## Minimum Insertions to Make String Palindrome | (DP-29)

**Problem Statement:**   
Given a string `s`, find the **minimum number of insertions** required to make the string a **palindrome**.

- A **palindrome** reads the same forward and backward.
- You may insert characters at **any position** in the string.

**Pre-requisites:**
- Longest Common Subsequence (LCS)
- Longest Palindromic Subsequence (LPS)

---

>### Examples:

### Example 1:
**Input:** `s = "abcaa"`  
**Output:** `2`  
**Explanation:**  
Insert `"c"` and `"b"` to form `"abcacba"`, which is a palindrome.

---

### Example 2:
**Input:** `s = "ba"`   
**Output:** `1`   
**Explanation:**   
Insert `"a"` at the beginning to form `"aba"`, which is a palindrome.

---

## Tabulation Approach

### Algorithm:

We need to find the **minimum number of insertions** required to make a string a palindrome.  
To understand this, let us first ignore the *minimum* condition and think about how we can make **any** string a palindrome.

The simplest way is to append the **reverse of the string** to the end of the original string.  
This will always form a palindrome.

In this case, the number of inserted characters equals **n** (the length of the string).  
This represents the **maximum** number of insertions required.

To **minimize insertions**, we should avoid inserting characters that already contribute to a palindromic structure.

For example, in a string like `"abcaa"`, substrings such as `"aaa"`, `"aba"`, or `"aca"` are already palindromic components.  
We can keep any one of them intact (they all have the same maximum length).

The remaining characters (such as `'b'` and `'c'`) break the palindrome.  
By inserting these characters in **reverse order**, we can make the whole string palindromic.

### Key Insight:

To minimize insertions, we must **maximize the part of the string that is already palindromic**.

That is exactly the **Longest Palindromic Subsequence (LPS)**.

### Formula:

\[
\text{Minimum Insertions} = n - \text{Length of Longest Palindromic Subsequence}
\]

where `n` is the length of the string.

### Final Note:

So, the problem reduces to:
1. Compute the **Longest Palindromic Subsequence (LPS)** of the string.
2. Subtract its length from the total string length.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Define a class named Solution
class Solution {
public:

    // Function to calculate Longest Common Subsequence
    int lcs(string s1, string s2) {
        
        // Get sizes of both strings
        int n = s1.size();
        int m = s2.size();

        // Create a dp table of size (n+1) x (m+1)
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));

        // Initialize first row as 0
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }

        // Initialize first column as 0
        for (int i = 0; i <= m; i++) {
            dp[0][i] = 0;
        }

        // Fill dp table using bottom-up approach
        for (int ind1 = 1; ind1 <= n; ind1++) {
            for (int ind2 = 1; ind2 <= m; ind2++) {

                // If characters match, add 1 to the previous diagonal
                if (s1[ind1 - 1] == s2[ind2 - 1])
                    dp[ind1][ind2] = 
                        1 + dp[ind1 - 1][ind2 - 1];

                // Else take max from top or left
                else
                    dp[ind1][ind2] = 
                        max(dp[ind1 - 1][ind2], 
                            dp[ind1][ind2 - 1]);
            }
        }

        // Return bottom-right value
        return dp[n][m];
    }

    // Function to find the length of the longest palindromic subsequence
    int longestPalindromeSubsequence(string s) {
        
        // Reverse the string
        string t = s;
        reverse(s.begin(), s.end());

        // LCS of s and its reverse is the LPS
        return lcs(s, t);
    }

    // Function to find min insertions to make the string a palindrome
    int minInsertion(string s) {
        
        // Get length of input string
        int n = s.size();

        // Get length of longest palindromic subsequence
        int k = longestPalindromeSubsequence(s);

        // Return total - palindromic length
        return n - k;
    }
};

// Main function
int main() {
    
    // Create object of Solution class
    Solution obj;

    // Input string
    string s = "abcaa";

    // Call minInsertion and print the result
    cout << "The Minimum insertions required to make the string a palindrome: " << obj.minInsertion(s);

    return 0;
}
```
### Complexity Analysis:
- **Time Complexity:** $O(N*N)$, we fill the entire DP array of size N*N one by one.
- **Space Complexity:** $O(N*N)$, additional space used to store DP array.

---


## Space Optimized Approach

### Algorithm:

If we observe the DP relation, we notice that at any step, we are only using **two rows** of the DP table:
- `dp[ind-1][ ]` (previous row)
- `dp[ind][ ]` (current row)

Hence, maintaining the entire **2D DP array** is unnecessary.

### Optimization Idea:

We can reduce the space complexity by using **two 1D arrays**:

- `prev` → represents `dp[ind-1][ ]`
- `cur`  → represents `dp[ind][ ]`

### Steps:

1. Initialize two arrays `prev` and `cur`.
2. Replace all occurrences of `dp[ind-1]` with `prev`.
3. Replace all occurrences of `dp[ind]` with `cur`.
4. Compute values for `cur` using values from `prev`.
5. After finishing each inner loop, update:
prev = cur


So the current row becomes the previous row for the next iteration.

This way, we achieve the same result as the tabulation approach while using significantly less space.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {

public:

    // Function to compute LCS using 2-row DP
    int lcs(string s1, string s2) {

        // Get sizes
        int n = s1.size();
        int m = s2.size();

        // Initialize prev and cur rows
        vector<int> prev(m + 1, 0), cur(m + 1, 0);

        // Fill rows
        for (int ind1 = 1; ind1 <= n; ind1++) {
            for (int ind2 = 1; ind2 <= m; ind2++) {

                // If characters match
                if (s1[ind1 - 1] == s2[ind2 - 1])
                    cur[ind2] = 1 + prev[ind2 - 1];

                // Else take max from prev row or left
                else
                    cur[ind2] = max(prev[ind2], cur[ind2 - 1]);
            }

            // Move cur to prev
            prev = cur;
        }

        // Return result
        return prev[m];
    }

    // Function to compute LPS
    int longestPalindromeSubsequence(string s) {
        string t = s;
        reverse(t.begin(), t.end());
        return lcs(s, t);
    }

    // Function to compute min insertions
    int minInsertion(string s) {
        int n = s.size();
        int k = longestPalindromeSubsequence(s);
        return n - k;
    }
};

int main() {
    Solution sol;
    string s = "abcaa";
    cout << "The Minimum insertions required to make the string a palindrome: "
         << sol.minInsertion(s) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N * N)`  
  We fill the entire DP table of size `N × N`.

- **Space Complexity:** `O(N)`  
  We use only two 1D arrays of size `N + 1` to store the current and previous rows.
