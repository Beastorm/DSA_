## Longest Palindromic Subsequence | (DP-28)

**Problem Statement:**   
Given a string `s`, find the **length of the longest palindromic subsequence** in the string.

- A **palindrome** is a sequence that reads the same forward and backward.
- A **subsequence** is a sequence that can be obtained by deleting zero or more characters from the original string without changing the order of the remaining characters.

---

### Examples:

### Example 1:
**Input:** `s = "eeeme"`   
**Output:** `4`

**Explanation:**  
The longest palindromic subsequence is `"eeee"`, which has a length of `4`.

---

### Example 2:
**Input:** `s = "annb"`   
**Output:** `2`

**Explanation:**  
The longest palindromic subsequence is `"nn"`, which has a length of `2`.

---
## Approach - Recursive

### Idea:
We define a recursive function `f(i, j)` that returns the **length of the longest palindromic subsequence** in the substring `s[i...j]`.

### Recursive Logic:
- If `i > j` → no characters left → return `0`
- If `i == j` → single character → return `1`
- If `s[i] == s[j]` → both characters can be part of palindrome  
  `2 + f(i+1, j-1)`
- Else → skip one character and take the maximum  
  `max(f(i+1, j), f(i, j-1))`

### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

int lps(int i, int j, string &s) {
    // Base cases
    if (i > j) return 0;
    if (i == j) return 1;

    // If characters match
    if (s[i] == s[j]) {
        return 2 + lps(i + 1, j - 1, s);
    }

    // If characters do not match
    return max(
        lps(i + 1, j, s),
        lps(i, j - 1, s)
    );
}

int main() {
    string s;
    cin >> s;

    int n = s.length();
    cout << lps(0, n - 1, s) << endl;

    return 0;
}
```
### Complexity Analysis:

### Time Complexity:
**O(2ⁿ)**  
At each step, the recursion branches into two calls (`f(i+1, j)` and `f(i, j-1)`), leading to an exponential number of overlapping subproblems.

### Space Complexity:
**O(n)**  
The maximum depth of the recursion stack is `n` (length of the string), as the recursive calls reduce the range `[i, j]` by one character at a time.

---

## Approach - Memoization: 

### Intuition:
The recursive solution has **overlapping subproblems**, where the same `(i, j)` range is solved multiple times.  
To optimize this, we **store results** of subproblems in a 2D DP table so that each state is computed only once.

### State Definition:
`dp[i][j]` → Length of the **longest palindromic subsequence** in the substring `s[i...j]`

### Base Cases:
- If `i > j` → return `0`
- If `i == j` → return `1` (a single character is a palindrome)

### Transition:
```
- If `s[i] == s[j]`  
dp[i][j] = 2 + solve(i+1, j-1)
- Else  
dp[i][j] = max(solve(i+1, j), solve(i, j-1))
```

### Memoization Steps:
1. Create a 2D array `dp[n][n]` initialized with `-1`
2. Before computing a state `(i, j)`, check if `dp[i][j] != -1`
3. Store the computed result in `dp[i][j]`
4. Return `dp[0][n-1]` as the final answer

### C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int solve(int i, int j, string &s, vector<vector<int>> &dp) {
  if (i > j) return 0;
  if (i == j) return 1;

  if (dp[i][j] != -1)
      return dp[i][j];

  if (s[i] == s[j]) {
      dp[i][j] = 2 + solve(i + 1, j - 1, s, dp);
  } else {
      dp[i][j] = max(
          solve(i + 1, j, s, dp),
          solve(i, j - 1, s, dp)
      );
  }

  return dp[i][j];
}

int longestPalindromicSubsequence(string s) {
  int n = s.size();
  vector<vector<int>> dp(n, vector<int>(n, -1));
  return solve(0, n - 1, s, dp);
}

int main() {
  string s = "eeeme";
  cout << longestPalindromicSubsequence(s);
  return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(n²)`  
  Each state `(i, j)` is computed only once, and there are `n × n` possible states.

- **Space Complexity:** `O(n²) + O(n)`  
  - `O(n²)` for the 2D DP table  
  - `O(n)` for the recursion call stack in the worst case

---

## Approach - Tabulation
### Algorithm:

- We are given a string `s` and need to find the length of its **longest palindromic subsequence**.
- First, make a copy of the string `s` and store it in another string `t`.
- Reverse the original string `s` to obtain `s'`.
- The problem now reduces to finding the **Longest Common Subsequence (LCS)** between the string `t` and its reverse `s'`.
- Use **dynamic programming** to compute the LCS of the two strings.
- Since a palindrome reads the same forwards and backwards, the LCS between `s` and `reverse(s)` will represent the **longest palindromic subsequence**.
- The value stored in the last cell of the DP table gives the **length of the longest palindromic subsequence**.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution{
private:
    /* Function to calculate the length of 
    the Longest Palindromic Subsequence*/
    int func(string s1, string s2) {
        int n = s1.size();
        int m = s2.size();

        // Declare a 2D DP array to store the length of the LCS
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));

        // Initialize first row and first column to 0
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }
        for (int i = 0; i <= m; i++) {
            dp[0][i] = 0;
        }

        // Fill in the DP array
        for (int ind1 = 1; ind1 <= n; ind1++) {
            for (int ind2 = 1; ind2 <= m; ind2++) {
                if (s1[ind1 - 1] == s2[ind2 - 1])
                    dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];
                else
                    dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);
            }
        }
        // The value at dp[n][m] contains length of the LCS
        return dp[n][m];
    }
public:
    /* Function to calculate the length of 
    the Longest Palindromic Subsequence*/
    int longestPalinSubseq(string s){
        // Store a reversed copy of the string
        string t = s;
        reverse(s.begin(), s.end());

        /* Call the LCS function to find the 
        length of the Longest Common Subsequence*/
        return lcs(s, t);
    }
};
int main() {
    string s = "bbabcbcab";
    
    //Create an instance of the Solution class
    Solution sol;
    
    // Print the result
    cout << "The Length of Longest Palindromic Subsequence is " << sol.longestPalinSubseq(s);
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** `O(N * M)`  
  Where `N` is the length of the string and `M` is the length of its reverse.  
  This is because we fill a 2D DP table of size `N × M`.

- **Space Complexity:** `O(N * M)`  
  Additional space is used for the DP table that stores the lengths of the longest common subsequences.

---

## Approach - Space Optimized

- In the tabulation approach, we observe that only two rows are required at any time:  
  `dp[ind-1][ ]` (previous row) and `dp[ind][ ]` (current row).
- Hence, instead of maintaining the entire 2D DP table, we can optimize space by using two 1D arrays:
  - `prev` → represents `dp[ind-1][ ]`
  - `cur` → represents `dp[ind][ ]`

### Steps:
1. Initialize two arrays `prev` and `cur` of size `n + 1`, where `n` is the length of the string.
2. Replace `dp[ind-1]` with `prev` and `dp[ind]` with `cur` from the tabulation logic.
3. Compute values for `cur[ind]` using values from `prev` and `cur`, following the same DP relation.
4. After completing the inner loop for a given index, assign `prev = cur` so the current row becomes the previous row for the next iteration.
5. After finishing all iterations, `prev[n]` contains the final result.

This approach significantly reduces space usage while preserving the same time complexity.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution{
private:
    /* Function to calculate the length of 
    the Longest Palindromic Subsequence*/
    int lcs(string s1, string s2) {
        int n = s1.size();
        int m = s2.size();

        /* Create two arrays to store the 
        previous and current rows of DP values*/
        vector<int> prev(m + 1, 0), cur(m + 1, 0);

        /* Base Case is covered as we have
        initialized the prev and cur to 0.*/

        for (int ind1 = 1; ind1 <= n; ind1++) {
            for (int ind2 = 1; ind2 <= m; ind2++) {
                if (s1[ind1 - 1] == s2[ind2 - 1])
                    cur[ind2] = 1 + prev[ind2 - 1];
                else
                    cur[ind2] = max(prev[ind2], cur[ind2 - 1]);
            }
            // Update the prev array with current values
            prev = cur;
        }
        // The value at prev[m] contains length of LCS
        return prev[m];
    }
public:
    /* Function to calculate the length of 
    the Longest Palindromic Subsequence*/
    int longestPalinSubseq(string s){
        // Store a reversed copy of the string
        string t = s;
        reverse(s.begin(), s.end());

        /* Call the LCS function to find the 
        length of the Longest Common Subsequence*/
        return lcs(s, t);
    }
};
int main() {
    string s = "bbabcbcab";
    
    //Create an instance of the Solution class
    Solution sol;
    
    // Print the result
    cout << "The Length of Longest Palindromic Subsequence is " << sol.longestPalinSubseq(s);
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N * M)`  
  We compute the DP values for all pairs of indices from the string and its reverse.

- **Space Complexity:** `O(M)`  
  Only two arrays of size `M + 1` are used to store the current and previous DP rows.
