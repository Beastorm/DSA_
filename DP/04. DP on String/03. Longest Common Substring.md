## Longest Common Substring | (DP - 27)

**Problem Statement:**   
Given two strings **str1** and **str2**, find the **length of their longest common substring**.

A **substring** is a contiguous sequence of characters within a string.

---

>### Examples:

### Example 1: 
**Input:**  
`str1 = "abcde"`  
`str2 = "abfce"`  

**Output:** `2`  

**Explanation:**  
The longest common substring is `"ab"`.

---
### Example 2:  
**Input:**  
`str1 = "abcdxyz"`  
`str2 = "xyzabcd"`  

**Output:**  `4`  

**Explanation:**  
The longest common substring is `"abcd"`.

---
## Approach - Recursive 
### Intuition:

- A **substring must be contiguous**, meaning characters must match **continuously** in both strings.
- While comparing two strings:
  - If characters **match**, we can **extend** the current substring.
  - If characters **don’t match**, the substring **breaks**, and the length resets to `0`.
- The longest common substring **can end at any position**, so we must explore **all index combinations**.
- We track:
  - `count` → current length of the ongoing matching substring
  - maximum value found during recursion

###  Algorithm Steps (Recursive):

1. **Define a recursive function**  
   `solve(i, j, count)` where:
   - `i` → current index in `str1`
   - `j` → current index in `str2`
   - `count` → length of the current matching substring

2. **Base Case**
   - If `i == 0` or `j == 0`, return `count`

3. **If characters match**
   - If `str1[i-1] == str2[j-1]`
   - Extend the substring:
     - `solve(i-1, j-1, count + 1)`

4. **If characters don’t match**
   - Reset the substring length to `0`
   - Explore other possibilities:
     - `solve(i-1, j, 0)`
     - `solve(i, j-1, 0)`

5. **Return the maximum**
   - Take the maximum of:
     - the current matching length
     - the results from other recursive calls

6. **Final Answer**
   - The maximum value obtained during recursion is the **length of the Longest Common Substring**


### Key Difference from LCS:

- In **Longest Common Subsequence**, mismatches are allowed.
- In **Longest Common Substring**, mismatches **break continuity**, so the count resets to `0`.



### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Recursive function
int solve(int i, int j, int count, string &s1, string &s2) {
    // Base case
    if (i == 0 || j == 0)
        return count;

    int curCount = count;

    // If characters match, extend substring
    if (s1[i - 1] == s2[j - 1]) {
        curCount = solve(i - 1, j - 1, count + 1, s1, s2);
    }

    // Explore other possibilities (reset count)
    int left = solve(i - 1, j, 0, s1, s2);
    int right = solve(i, j - 1, 0, s1, s2);

    return max(curCount, max(left, right));
}

// Driver function
int longestCommonSubstring(string s1, string s2) {
    return solve(s1.length(), s2.length(), 0, s1, s2);
}

int main() {
    string str1 = "abcde";
    string str2 = "abfce";

    cout << "Length of Longest Common Substring: "
         << longestCommonSubstring(str1, str2) << endl;

    return 0;
}

```
### Complexity Analysis:

**Time Complexity:**
- **O(3^(n+m))** (Exponential)
- At each recursive call, we may branch into **three recursive calls**:
  - Match case: `solve(i-1, j-1)`
  - Skip from first string: `solve(i-1, j)`
  - Skip from second string: `solve(i, j-1)`
- Due to **no memoization**, many overlapping subproblems are recomputed.

**Space Complexity:**
- **O(n + m)**
- This is due to the **maximum depth of the recursion stack**, which in the worst case can go up to `n + m`.

> ⚠️ This recursive approach is **not efficient** for large inputs.  
> Using **DP (tabulation or space-optimized DP)** reduces time complexity to **O(n × m)**.


---

## Approach - Memoization
### Intuition:
For **Longest Common Substring**, characters must be **contiguous**.  
So at any indices `(i, j)`:

- If `str1[i] == str2[j]` → we can **extend** the substring ending at `(i-1, j-1)`
- If they don’t match → the substring **breaks**, length becomes `0`

We define a recursive function that returns the **length of the longest common substring ending exactly at `(i, j)`**.  
A global variable `ans` keeps track of the maximum length found.

Since many `(i, j)` states repeat, we **memoize** them using a 2D DP array.

### Recursive Relation:
```
f(i, j):
if i < 0 or j < 0 → return 0

if str1[i] == str2[j]:
return 1 + f(i-1, j-1)
else:
return 0
```

### Memoization Strategy:
- `dp[i][j]` stores the result of `f(i, j)`
- If `dp[i][j] != -1`, return it directly
- Update `ans` whenever a longer substring is found


### C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int ans = 0;

int solve(int i, int j, string &s1, string &s2, vector<vector<int>> &dp) {
    if (i < 0 || j < 0)
        return 0;

    if (dp[i][j] != -1)
        return dp[i][j];

    if (s1[i] == s2[j]) {
        dp[i][j] = 1 + solve(i - 1, j - 1, s1, s2, dp);
        ans = max(ans, dp[i][j]);
    } else {
        dp[i][j] = 0;
    }

    return dp[i][j];
}

int longestCommonSubstring(string s1, string s2) {
    int n = s1.size(), m = s2.size();
    vector<vector<int>> dp(n, vector<int>(m, -1));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            solve(i, j, s1, s2, dp);
        }
    }

    return ans;
}

int main() {
    string s1 = "abcdxyz";
    string s2 = "xyzabcd";
    cout << longestCommonSubstring(s1, s2);
    return 0;
}
```
### Complexity Analysis:

### Time Complexity:
**O(n × m)**  
Each pair of indices `(i, j)` is computed at most once due to memoization.  
There are `n × m` such states.

### Space Complexity:
**O(n × m) + O(n + m)**  
- `O(n × m)` for the DP table  
- `O(n + m)` for the recursion stack in the worst case

---
## Tabulation Approach

### Algorithm:

- Declare a DP array `dp` of size `(n+1) x (m+1)`, where:
  - `n` = length of string `S1`
  - `m` = length of string `S2`
- Here, `dp[i][j]` represents the length of the **longest common substring ending at** `S1[i-1]` and `S2[j-1]`.

---

### DP Transitions:

- If `S1[i-1] != S2[j-1]`:
  - The characters do not match, so the substring continuity breaks.
  - Set  
    ```
    dp[i][j] = 0
    ```

- If `S1[i-1] == S2[j-1]`:
  - The characters match, so we can extend the previous substring.
  - Set  
    ```
    dp[i][j] = 1 + dp[i-1][j-1]
    ```

### Important Observation:

- The answer is **not necessarily stored at `dp[n][m]`**.
- This is because the longest common substring may end at **any position** in the table.
- Therefore, we must keep track of the **maximum value** found in the entire `dp` table.


### ✅ Final Answer:

- The **maximum value** in the DP table represents the **length of the longest common substring**.

This approach efficiently checks all character pairs and maintains substring continuity using dynamic programming.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    /* Function to find the length of 
    the Longest Common Substring (LCS) */
    int longestCommonSubstr(string str1, string str2) {
        int n = str1.size();
        int m = str2.size();
    
        // Initialize a 2D DP table with dimensions
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

        // Initialize the answer variable
        int ans = 0;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                // Characters match, increment substring length
                if (str1[i - 1] == str2[j - 1]) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                    
                    /* Update the maximum substring 
                    length found so far */
                    ans = max(ans, dp[i][j]);
                } else {
                    /* Characters don't match, 
                    substring length becomes 0 */
                    dp[i][j] = 0;
                }
            }
        }
        // Return the length of the Longest Common Substring
        return ans;
    }
};

int main() {
    string s1 = "abcjklp";
    string s2 = "acjkp";

    // Create an instance of the Solution class
    Solution sol;
    
    // Print the result
    cout << "The Length of Longest Common Substring is " << sol.longestCommonSubstr(s1, s2) << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:**  **O(n × m)**  
  - We fill a 2D DP table of size `(n+1) × (m+1)`, where `n` and `m` are the lengths of `str1` and `str2`.

- **Space Complexity:**  **O(n × m)**  
  - A 2D DP table is used to store intermediate results for all pairs of indices.

---

## Space Optimized Approach

### Algorithm:

- If we observe the relation in the tabulation approach, we use `dp[i-1][j-1]` to calculate the present cell.  
  This means we are only using the **previous row** (`dp[ind1-1][ ]`) to compute the current row.

- Since only the previous row is required, there is no need to maintain the entire 2D DP array.  
  Instead, we use two 1D arrays:
  - `prev` → represents `dp[ind1-1][ ]`
  - `cur` → represents `dp[ind1][ ]`

- After declaring `prev` and `cur`, replace:
  - `dp[ind1-1]` with `prev`
  - `dp[ind1]` with `cur`
  in the tabulation logic.

- Using the same logic as the tabulation approach:
  - If characters match, update `cur[j] = 1 + prev[j-1]`
  - Otherwise, set `cur[j] = 0`
  - Keep track of the maximum value encountered in a variable `ans`.

- After the inner loop completes, assign `prev = cur` so that the current row becomes the previous row for the next iteration.

- At the end of execution, return `ans`, which stores the maximum length of the **longest common substring**.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    /* Function to find the length of 
    the Longest Common Substring (LCS) */
    int longestCommonSubstr(string str1, string str2) {
        int n = str1.size();
        int m = str2.size();
    
        /* Initialize two vectors to store 
        previous and current row values*/
        vector<int> prev(m+1, 0);
        vector<int> cur(m+1, 0);  
        
        /* Initialize the answer variable to
        store the maximum LCS length found*/
        int ans = 0; 
    
        // Loop through both strings
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                // Characters match, increment substring length
                if(str1[i-1] == str2[j-1]){
                    int val = 1 + prev[j-1]; 
                    cur[j] = val; 
                    
                    /* Update the maximum substring
                    length found so far*/
                    ans = max(ans, val); 
                }
                else{
                    /* Characters don't match,
                    substring length becomes 0*/
                    cur[j] = 0; 
                }
                
            }
            /* Update the previous row with 
            the values of the current row*/
            prev = cur; 
        }
        // Return the length of the Longest Common Substring
        return ans;
    }
};

int main() {
    string s1 = "abcjklp";
    string s2 = "acjkp";

    // Create an instance of the Solution class
    Solution sol;
    
    // Print the result
    cout << "The Length of Longest Common Substring is " << sol.longestCommonSubstr(s1, s2) << endl;

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** `O(n * m)`  
  - We iterate through both strings and compute DP values for all character pairs.

- **Space Complexity:** `O(m)`  
  - Only two arrays of size `m + 1` are used to store the current and previous rows.
