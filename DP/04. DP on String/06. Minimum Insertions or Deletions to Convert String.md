## Minimum Insertions/Deletions to Convert String | (DP-30)

**Problem Statement:**  
Given two strings `str1` and `str2`, you are allowed to perform the following operations on `str1`:

1. **Delete** any number of characters from `str1`
2. **Insert** any number of characters into `str1`

Return the **minimum number of operations** required to convert `str1` into `str2`.


**Pre-requisite:**
- Longest Common Subsequence (LCS)

---

>### Examples:

### Example 1:
**Input:**  
`str1 = "kitten"`, `str2 = "sitting"`

**Output:** `5`

**Explanation:**  
- Delete `'k'`, insert `'s'` → `"sitten"`  
- Delete `'e'`, insert `'i'` → `"sittin"`  
- Insert `'g'` → `"sitting"`  

Total operations = `5`

---

### Example 2:
**Input:**  
`str1 = "flaw"`, `str2 = "lawn"`

**Output:** `2`

**Explanation:**  
- Delete `'f'` → `"law"`  
- Insert `'n'` → `"lawn"`  

Total operations = `2`

---

## Tabulation Approach

### Algorithm:

To find the minimum number of operations required to convert `str1` into `str2`, let us first think about the **maximum** number of operations needed.

- The simplest way is to **delete all characters of `str1`** and then **insert all characters of `str2`**.  
  This would take `n + m` operations, where:
  - `n` = length of `str1`
  - `m` = length of `str2`

### Minimizing the Operations:

To reduce the number of operations:
- We try to **keep characters that are common to both strings and appear in the same order**.
- These characters form the **Longest Common Subsequence (LCS)**.
- All characters of `str1` that are **not part of the LCS** must be deleted.
- All characters of `str2` that are **not part of the LCS** must be inserted.

### Key Insight:

If:
- `k` = length of the Longest Common Subsequence (LCS)

Then:
- Deletions required = `n - k`
- Insertions required = `m - k`

### Final Formula:
Minimum Operations = (n - k) + (m - k)
Where:
- `n` = length of `str1`
- `m` = length of `str2`
- `k` = length of LCS between `str1` and `str2`


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find minimum insertions/deletions
    int minOperations(string s1, string s2) {
        // Get lengths of both strings
        int n = s1.length();
        int m = s2.length();

        // Create DP table of size (n+1) x (m+1)
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

        // Fill the table using a bottom-up approach
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                // If characters match, extend LCS
                if (s1[i - 1] == s2[j - 1])
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                else
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }

        // Get LCS length
        int lcs = dp[n][m];

        // Return total operations = deletions + insertions
        return (n - lcs) + (m - lcs);
    }
};

int main() {
    Solution sol;
    string s1 = "heap", s2 = "pea";

    // Call function and print result
    cout << "Minimum operations: " << sol.minOperations(s1, s2) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N * M)`  
  We fill the entire DP table of size `N × M`, where `N` and `M` are the lengths of `str1` and `str2`.

- **Space Complexity:** `O(N * M)`  
  Additional space is used to store the DP table.

---

## Approach - Space Optimized

### Algorithm:

- Observe that in the DP solution, each state depends only on two rows:  
  `dp[ind-1][ ]` (previous row) and `dp[ind][ ]` (current row).
- Hence, we do not need to store the entire 2D DP table.
- Use two 1D arrays:
  - `prev` → represents `dp[ind-1]`
  - `cur` → represents `dp[ind]`
- Replace all references of `dp[ind-1]` with `prev` and `dp[ind]` with `cur`.
- After completing the inner loop for one index, update:
  - `prev = cur`
- Continue this process until all rows are processed.
- The final answer will be stored in the last updated `prev` array.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class containing the solution
class Solution {
public:
    // Function to calculate minimum operations
    int minOperations(string s1, string s2) {
        // Get the lengths of both strings
        int n = s1.size(), m = s2.size();

        // Create two 1D DP arrays
        vector<int> prev(m + 1, 0), cur(m + 1, 0);

        // Iterate through each character of s1
        for (int i = 1; i <= n; i++) {

            // Iterate through each character of s2
            for (int j = 1; j <= m; j++) {

                // If characters match, increment LCS length
                if (s1[i - 1] == s2[j - 1])
                    cur[j] = 1 + prev[j - 1];

                // Else, take max from left or top
                else
                    cur[j] = max(prev[j], cur[j - 1]);
            }

            // Update prev row to current
            prev = cur;
        }

        // Calculate total operations
        int lcs = prev[m];
        return (n - lcs) + (m - lcs);
    }
};

// Main function
int main() {
    // Input strings
    string s1 = "heap", s2 = "pea";

    // Create object of Solution
    Solution obj;

    // Call function and print result
    cout << obj.minOperations(s1, s2) << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** `O(N * M)`  
  We iterate through all pairs of characters from both strings and compute each DP state once.

- **Space Complexity:** `O(M)`  
  We use only two 1D arrays of size `M + 1` to store the current and previous rows of the DP table.

