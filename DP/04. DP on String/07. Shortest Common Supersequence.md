## Shortest Common Supersequence | (DP - 31)

**Problem Statement:**   
We are given two strings, `S1` and `S2`.  
We need to return their **shortest common supersequence (SCS)**.

A **supersequence** is a string that contains both `S1` and `S2` as subsequences.

---

>### Examples:

### Example 1:
**Input:**  
`str1 = "mno"`, `str2 = "nop"`

**Output:** `"mnop"`

**Explanation:**  
The shortest common supersequence is `"mnop"`.  
It contains `"mno"` as its first three characters and `"nop"` as its last three.

---

### Example 2:
**Input:**  
`str1 = "dynamic"`, `str2 = "program"`

**Output:** `"dynprogramic"`

**Explanation:**  
The shortest common supersequence is `"dynprogramic"`.  
It includes all characters from both `"dynamic"` and `"program"` with minimal overlap.  
- `"dynamic"` appears as `"dyn...amic"`  
- `"program"` appears as `"...program..."`


---
## Approach

### Algorithm

**Pre-requisite:**  
- Longest Common Subsequence (LCS)  
- Print Longest Common Subsequence  

---
## Approach
### Intuition:

If we ignore the **shortest** condition, a simple way to form a supersequence is to concatenate the two strings (`S1 + S2`).  
This always works, but it is the **worst case**, giving a length of `n + m`, where `n` and `m` are the lengths of `S1` and `S2`.

To make the supersequence **shorter**, we should avoid repeating characters that are:
- common in both strings, and
- appear in the **same order**

These characters form the **Longest Common Subsequence (LCS)**.

In an optimal solution:
- Characters of the LCS are written **only once**
- Non-LCS characters from both strings are placed **around** the LCS characters while maintaining order


### Length of Shortest Common Supersequence:

Let:
- `n` = length of `S1`
- `m` = length of `S2`
- `k` = length of LCS of `S1` and `S2`

Then,

Length of SCS = n + m - k

### Constructing the Shortest Common Supersequence:

Instead of only finding the length, we construct the **actual SCS string** using the **LCS DP table**.

The LCS DP recurrence relations are:
```
- If `S1[i-1] == S2[j-1]`  
dp[i][j] = 1 + dp[i-1][j-1]

- If `S1[i-1] != S2[j-1]`  
dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```
### Backtracking to Build the SCS String:

```
1. Start from `dp[n][m]` with `i = n`, `j = m`
2. While `i > 0` and `j > 0`:
 - If `S1[i-1] == S2[j-1]`  
   - This character is part of LCS  
   - Add it **once** to the answer  
   - Move diagonally: `i--`, `j--`
 - Else:
   - If `dp[i-1][j] > dp[i][j-1]`  
     - Add `S1[i-1]` to answer  
     - Move up: `i--`
   - Else  
     - Add `S2[j-1]` to answer  
     - Move left: `j--`
3. If `i > 0`, add remaining characters of `S1`
4. If `j > 0`, add remaining characters of `S2`
5. Reverse the constructed string to get the final answer

```
### Key Idea Recap:

- LCS characters → added **once**
- Non-LCS characters → added separately
- Order is preserved
- Final string is the **Shortest Common Supersequence**

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to return the shortest common supersequence of two strings
    string shortestSupersequence(string s1, string s2) {

        // Get the lengths of the two strings
        int n = s1.size();
        int m = s2.size();

        // Create a 2D DP table to store lengths of LCS
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

        // Initialize base cases: when either string is empty
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }
        for (int i = 0; i <= m; i++) {
            dp[0][i] = 0;
        }

        // Fill the DP table using bottom-up approach
        for (int ind1 = 1; ind1 <= n; ind1++) {
            for (int ind2 = 1; ind2 <= m; ind2++) {

                // If characters match, take diagonal + 1
                if (s1[ind1 - 1] == s2[ind2 - 1])
                    dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];

                // Otherwise, take max from left or top
                else
                    dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);
            }
        }

        // Start from bottom-right of the DP table to build the supersequence
        int i = n;
        int j = m;
        string ans = "";

        // Traverse the table in reverse to find the supersequence
        while (i > 0 && j > 0) {

            // If characters are equal, include it once
            if (s1[i - 1] == s2[j - 1]) {
                ans += s1[i - 1];
                i--;
                j--;
            }

            // Move in the direction of greater value
            else if (dp[i - 1][j] > dp[i][j - 1]) {
                ans += s1[i - 1];
                i--;
            } else {
                ans += s2[j - 1];
                j--;
            }
        }

        // If any characters are left in s1, add them
        while (i > 0) {
            ans += s1[i - 1];
            i--;
        }

        // If any characters are left in s2, add them
        while (j > 0) {
            ans += s2[j - 1];
            j--;
        }

        // Since we added characters in reverse order, reverse the result
        reverse(ans.begin(), ans.end());

        // Return the final shortest supersequence
        return ans;
    }
};

// Driver code
int main() {

    // Define input strings
    string s1 = "brute";
    string s2 = "groot";

    // Create object of Solution class
    Solution obj;

    // Call the function and print the result
    cout << "The Shortest Common Supersequence is " << obj.shortestSupersequence(s1, s2);

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(n * m), Filling the DP table takes O(n * m), and backtracking adds O(n + m), which is negligible compared to the main DP.

- **Space Complexity:** O(n * m),A 2D DP array of size (n+1) × (m+1) is used.
