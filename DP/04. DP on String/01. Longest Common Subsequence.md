## Longest Common Subsequence | (DP - 25)

**Problem Statement:**   
Given two strings `str1` and `str2`, find the **length of their longest common subsequence (LCS)**.

A **subsequence** is a sequence that appears in the same relative order but **not necessarily contiguous**.  
A **common subsequence** is a subsequence that is present in **both strings**.

---

>### Examples:

### Example 1:
**Input:**   
str1 = "bdefg"  
str2 = "bfg"     
**Output:** 3   
**Explanation:** The longest common subsequence is `"bfg"`, which has length `3`.

---

### Example 2
**Input:**   
str1 = "mnop"  
str2 = "mnq"

**Output:** 2   
**Explanation:**  
The longest common subsequence is `"mn"`, which has length `2`.

---

## Approach - Recursive

### Intuition:
At any position `(i, j)` in the two strings:
- If `str1[i] == str2[j]`, then this character **must be part of LCS**, so we add `1` and move both pointers.
- If they are **not equal**, we have two choices:
  - Skip the current character of `str1`
  - Skip the current character of `str2`  
  We take the **maximum** of both choices.


###  Recursive Function Definition:
Let  
`f(i, j)` = length of LCS considering `str1[0..i]` and `str2[0..j]`

### Base Case:
- If `i < 0` or `j < 0` → return `0`

### Recursive Relation:
- If `str1[i] == str2[j]`  
f(i, j) = 1 + f(i-1, j-1)

- Else  
f(i, j) = max(f(i-1, j), f(i, j-1))



### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

int lcs(int i, int j, string &s1, string &s2) {
  // Base case
  if (i < 0 || j < 0)
      return 0;

  // If characters match
  if (s1[i] == s2[j])
      return 1 + lcs(i - 1, j - 1, s1, s2);

  // If characters do not match
  return max(
      lcs(i - 1, j, s1, s2),
      lcs(i, j - 1, s1, s2)
  );
}

int main() {
  string str1 = "bdefg";
  string str2 = "bfg";

  int n = str1.size();
  int m = str2.size();

  cout << lcs(n - 1, m - 1, str1, str2);
  return 0;
}
```
### Complexity Analysis:
- **Time Complexity:**  `O(2^(N+M))`  
  - Each character comparison branches into two recursive calls in the worst case.

- **Space Complexity:** `O(N + M)`  
  - Due to the recursion stack depth (maximum depth equals the sum of the lengths of both strings).

---

## Memoization Approach

### Algorithm:
- Create a 2D DP array `dp[n][m]`, where  
  `n = length of S1` and `m = length of S2`.
- The two changing parameters are `ind1` and `ind2`, so a 2D table is required.
- Initialize all values of `dp` with `-1` to mark unsolved subproblems.

### Handling Overlapping Subproblems:
- Before computing any state `(ind1, ind2)`, check:
  - If `dp[ind1][ind2] != -1`, return the stored value directly.
- This avoids recomputation and speeds up the solution.

### Storing Subproblem Results:
- If `dp[ind1][ind2] == -1`, compute the result using recursion.
- Store the computed value in `dp[ind1][ind2]` before returning it.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution{
private:
    /* Function to find the length of the
    Longest Common Subsequence (LCS)*/
    int func(string& s1, string& s2, int ind1, int ind2, vector<vector<int>>& dp) {
        // Base case
        if (ind1 < 0 || ind2 < 0)
            return 0;

        /* If the result for this pair of indices
        is already calculated, return it*/
        if (dp[ind1][ind2] != -1)
            return dp[ind1][ind2];

        /* If the characters at the current 
        indices match, increment the LCS length*/
        if (s1[ind1] == s2[ind2])
            return dp[ind1][ind2] = 1 + func(s1, s2, ind1 - 1, ind2 - 1, dp);
        else
            return dp[ind1][ind2] = max(func(s1, s2, ind1, ind2 - 1, dp), func(s1, s2, ind1 - 1, ind2, dp));
    }
public:
    /* Function to calculate the length
    of the Longest Common Subsequence*/
    int lcs(string str1, string str2) {
        int n = str1.size();
        int m = str2.size();

        vector<vector<int>> dp(n, vector<int>(m, -1));
        //Return the result
        return func(str1, str2, n - 1, m - 1, dp);
    }
};
int main() {
    string s1 = "acd";
    string s2 = "ced";
    
    //Create an instance of the Solution class
    Solution sol;
    
    // Call the function to find and output
    cout << "The Length of Longest Common Subsequence is " << sol.lcs(s1, s2) << endl;

    return 0; 
}
```
### Complexity Analysis:

- **Time Complexity:** `O(n * m)`  
  - Each state `(ind1, ind2)` is computed once using the 2D DP table.

- **Space Complexity:** `O(n * m) + O(n + m)`  
  - `O(n * m)` for the DP table  
  - `O(n + m)` for the recursion stack in the worst case

---

## Tabulation Approach (Bottom-Up DP)

### Algorithm:

- **DP Array Declaration**
  - Create a 2D DP array `dp` of size `(n+1) x (m+1)`
  - Here, `n = length of S1` and `m = length of S2`

- **Index Shifting (Handling Base Case)**
  - In recursion, base case is when `ind1 < 0` or `ind2 < 0`
  - Since negative indices are not allowed in DP, shift indices by `+1`
  - New base case becomes:
    - If `ind1 == 0` or `ind2 == 0` → `dp[ind1][ind2] = 0`
  - Initialize:
    - First row (`dp[0][*]`) = 0
    - First column (`dp[*][0]`) = 0

- **Iterative Computation**
  - Use two nested loops:
    - `ind1` from `1` to `n`
    - `ind2` from `1` to `m`
  - Transition:
    - If `S1[ind1-1] == S2[ind2-1]`  
      `dp[ind1][ind2] = 1 + dp[ind1-1][ind2-1]`
    - Else  
      `dp[ind1][ind2] = max(dp[ind1-1][ind2], dp[ind1][ind2-1])`

- **Final Answer**
  - The result is stored in `dp[n][m]`
  - This represents the length of the **Longest Common Subsequence**


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution{
public:
    /* Function to calculate the length
    of the Longest Common Subsequence*/
    int lcs(string str1, string str2) {
        int n = str1.size();
        int m = str2.size();
        
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1)); 

        // Initialize the base cases
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }
        for (int i = 0; i <= m; i++) {
            dp[0][i] = 0;
        }

        // Fill in the DP table to calculate the length of LCS
        for (int ind1 = 1; ind1 <= n; ind1++) {
            for (int ind2 = 1; ind2 <= m; ind2++) {
                
                // Characters match, increment LCS length
                if (str1[ind1 - 1] == str2[ind2 - 1])
                    dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1]; 
                /* Characters don't match, consider
                the maximum from left or above*/    
                else
                    dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]); 
            }
        }
        // Return the length of the Longest Common Subsequence
        return dp[n][m]; 
    }
};
int main() {
    string s1 = "acd";
    string s2 = "ced";
    
    //Create an instance of the Solution class
    Solution sol;
    
    // Call the function to find and output
    cout << "The Length of Longest Common Subsequence is " << sol.lcs(s1, s2) << endl;

    return 0; 
}
```
### Complexity Analysis:

- **Time Complexity:** **O(n × m)**  
  - We fill a 2D DP table of size `(n+1) × (m+1)`, and each cell is computed in constant time.

- **Space Complexity:** **O(n × m)**  
  - A 2D DP array is used to store results for all pairs of indices from both strings.

---

### Space Optimized Approach

### Algorithm:

- From the tabulation relation, we only use:
  - `dp[ind1 - 1][ind2]` (previous row)
  - `dp[ind1][ind2 - 1]` (current row)
- Hence, we do **not** need the full 2D DP array.

### Optimization Idea:

- Use **two 1D arrays**:
  - `prev` → represents `dp[ind1 - 1][ ]`
  - `cur` → represents `dp[ind1][ ]`

### Steps:

1. Initialize two arrays `prev` and `cur` of size `(m + 1)` with `0`.
2. Traverse `ind1` from `1` to `n`.
3. For each `ind1`, iterate `ind2` from `1` to `m`.
4. Compute `cur[ind2]` using the same recurrence relation as tabulation.
5. After completing the inner loop, assign `prev = cur`.
6. After all iterations, `prev[m]` contains the final LCS length.

### Final Answer:

- Return `prev[m]`, which holds the result after the last iteration.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution{
public:
    /* Function to calculate the length
    of the Longest Common Subsequence*/
    int lcs(string str1, string str2) {
        int n = str1.size();
        int m = str2.size();
        
        /* Initialize two vectors to store the
        current and previous rows of the DP table*/
        vector<int> prev(m + 1, 0), cur(m + 1, 0);

        /* Base case is covered as we have initialized
        the prev and cur vectors to 0.*/

        for (int ind1 = 1; ind1 <= n; ind1++) {
            for (int ind2 = 1; ind2 <= m; ind2++) {
                
                // Characters match, increment LCS length
                if (str1[ind1 - 1] == str2[ind2 - 1])
                    cur[ind2] = 1 + prev[ind2 - 1]; 
                else
                    cur[ind2] = max(prev[ind2], cur[ind2 - 1]);
            }
            // Update the previous row with the current row
            prev = cur; 
        }
        // Return the length of the Longest Common Subsequence
        return prev[m]; 
    }
};
int main() {
    string s1 = "acd";
    string s2 = "ced";
    
    //Create an instance of the Solution class
    Solution sol;
    
    // Call the function to find and output
    cout << "The Length of Longest Common Subsequence is " << sol.lcs(s1, s2) << endl;

    return 0; 
}
```
### Complexity Analysis:

- **Time Complexity:** `O(n * m)`  
  - We still compute all combinations of indices from both strings.

- **Space Complexity:** `O(m)`  
  - Only two arrays of size `(m + 1)` are used to store the current and previous rows.

