## Longest Increasing Subsequence | Binary Search | (DP-43)

**Problem Statement:** 
Given an integer array `nums`, return the length of the longest strictly increasing subsequence.
A subsequence is a sequence derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, `[3, 6, 2, 7]` is a subsequence of `[0, 3, 1, 6, 2, 2, 7]`.
The task is to find the length of the longest subsequence in which every element is greater than the previous one.

**Note:** In this article, we will solve the problem of the longest-increasing subsequence using binary search.

---

### Examples:

## Example 1:
* **Input:** `nums = [10, 9, 2, 5, 3, 7, 101, 18]`
* **Output:** `4`
* **Explanation:** The longest increasing subsequence is `[2, 3, 7, 101]`, and its length is 4.

## Example 2:
* **Input:** `nums = [0, 1, 0, 3, 2, 3]`
* **Output:** `4`
* **Explanation:** The longest increasing subsequence is `[0, 1, 2, 3]`, and its length is 4.

---

## Approach
### Algorithm:
1.  **Initialize:** Create an empty list (or dynamic array) `temp`.
2.  **Iterate:** Loop through each element `x` in the input array `nums`.
3.  **Compare and Replace:**
    * If `temp` is empty or the current element `x` is greater than the last element in `temp`, append `x` to `temp`.
    * Otherwise, find the smallest element in `temp` that is greater than or equal to `x` using **Binary Search** (`lower_bound` in C++). Replace that element with `x`.
4.  **Result:** The size of the `temp` array will be the length of the Longest Increasing Subsequence.

---

### Code (C++):

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int longestIncreasingSubsequence(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;

        vector<int> temp;
        temp.push_back(nums[0]);

        for (int i = 1; i < n; i++) {
            if (nums[i] > temp.back()) {
                // If the current element is greater than the last element in temp, append it
                temp.push_back(nums[i]);
            } else {
                // Find the first element >= nums[i] using binary search
                int ind = lower_bound(temp.begin(), temp.end(), nums[i]) - temp.begin();
                temp[ind] = nums[i];
            }
        }

        return temp.size();
    }
};

int main() {
    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};
    Solution sol;
    cout << "Length of LIS: " << sol.longestIncreasingSubsequence(nums) << endl;
    return 0;
}
```
### Complexity Analysis:
* **Time Complexity:** $O(n \log n)$
    * **Explanation:** We traverse the array once ($n$ iterations). In each iteration, we perform a binary search on the temp array, which takes $O(\log n)$ time.
* **Space Complexity:** $O(n)$
    * **Explanation:** In the worst case (the input array is sorted), the temp array will store all $n$ elements.
