# String Problems using recursion

---

## 1. Check Palindrome

``` cpp
#include <iostream>
#include <string>
using namespace std;

bool checkpal(const string& str, int start, int end) {
    // base condition
    if (start >= end) return true;

    // not matched
    if (str[start] != str[end]) return false;

    // matched -> check inside
    return checkpal(str, start + 1, end - 1);
}

int main() {
    // Example driver like the screenshot
    string str = "naman";

    cout << checkpal(str, 0, (int)str.size() - 1) << "\n"; // prints 1 for true, 0 for false
    return 0;
}
```

``` text
Recursive call tree for: checkpal("naman", 0, 4)

                 checkpal(0,4)
                (n == n) ✓
                      |
                      v
                 checkpal(1,3)
                (a == a) ✓
                      |
                      v
                 checkpal(2,2)
              (start >= end) ✓
                      |
                      v
                   true


Return back:
checkpal(2,2) -> true
checkpal(1,3) -> true
checkpal(0,4) -> true

```

### Complexity Analysis (Recursive Palindrome Check)

Let `n = str.length`.

**Time Complexity:**  
Each recursive call compares one pair of characters: `str[start]` and `str[end]`,
then moves inward (`start+1`, `end-1`).

- Number of calls is about `n/2` in the worst case (when all pairs match).
- Work per call is `O(1)`.

So, **Time = O(n)**.

**Space Complexity:** 
Extra space comes from the recursion call stack.

- Depth of recursion is about `n/2` in the worst case.
- Each call uses constant space.

So, **Space = O(n)** (stack space).

---
## 2. Count Vowels

``` cpp
#include <iostream>
#include <string>
using namespace std;

bool isVowel(char c) {
    return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';
}

// Recursive count of vowels from index 0..index
int countVowels(const string& str, int index) {
    if (index == -1) return 0;

    if (isVowel(str[index])) {
        return 1 + countVowels(str, index - 1);
    } else {
        return countVowels(str, index - 1);
    }
}

int main() {
    // Driver example
    string str;
    cin >> str; // lowercase string as in image logic

    cout << countVowels(str, (int)str.size() - 1) << "\n";
    return 0;
}
```
``` text
## Recursive Call Diagram (Example)

For `str = "naman"` and the call `countVowels(str, 4)`:

```text
countVowels(str, 4)   -> 'n' (not vowel)
|
v
countVowels(str, 3)   -> 'a' (vowel) => 1 + countVowels(str, 2)
|
v
countVowels(str, 2)   -> 'm' (not vowel)
|
v
countVowels(str, 1)   -> 'a' (vowel) => 1 + countVowels(str, 0)
|
v
countVowels(str, 0)   -> 'n' (not vowel)
|
v
countVowels(str, -1)  -> base case => 0

Return Flow::
countVowels(-1) = 0
countVowels(0)  = 0
countVowels(1)  = 1 + 0 = 1
countVowels(2)  = 1
countVowels(3)  = 1 + 1 = 2
countVowels(4)  = 2
```

### Complexity Analysis (Recursive Vowel Count)

Let `n = str.length`.

**Time Complexity:**  
The function makes exactly one recursive call for each index from `n-1` down to `0`.

- Number of calls: `n + 1` (including the base case at `index = -1`)
- Work per call: `O(1)` (one vowel check + constant operations)

**Time = O(n)**

**Space Complexity:**  
Extra space is due to the recursion call stack.

- Maximum recursion depth: `n + 1`

**Space = O(n)** (stack space)

---

## 3. Reverse String

``` cpp
#include <iostream>
#include <string>
using namespace std;

void rev(string &str, int start, int end) {
    if (start >= end) return;

    char c = str[start];
    str[start] = str[end];
    str[end] = c;

    rev(str, start + 1, end - 1);
}

int main() {
    string str = "rohit";   // driver example like the image
    rev(str, 0, (int)str.size() - 1);
    cout << str << "\n";    // outputs: tihor
    return 0;
}
```

``` text
Recursive Call Tree (Reverse String)

Example: `str = "rohit"`  
Call: `rev(str, 0, 4)`

```text
rev(str, 0, 4)   // swap str[0] <-> str[4]  (r <-> t)  -> "tohir"
|
v
rev(str, 1, 3)   // swap str[1] <-> str[3]  (o <-> i)  -> "tihor"
|
v
rev(str, 2, 2)   // start >= end (base case), stop


Return Flow::
rev(2,2) returns
rev(1,3) returns
rev(0,4) returns
Final string: "tihor"
```

### Complexity Analysis (Recursive String Reverse)

Let `n = str.length`.

**Time Complexity:**  
Each recursive call swaps one pair of characters and moves inward:
- `(start, end)` becomes `(start+1, end-1)`
- Number of calls is about `n/2`
- Work per call is `O(1)` (one swap)

**Time = O(n)**

**Space Complexity:**  
Extra space comes from the recursion call stack:
- Recursion depth is about `n/2`

**Space = O(n)** (stack space)

---

## 4. Convert Lowercase to Uppercase

``` cpp
#include <iostream>
#include <string>
using namespace std;

// Convert a lowercase string to uppercase using recursion.
// Works correctly if the string contains only 'a' to 'z' (as shown in the image).
void lowerToUpper(string &str, int index) {
    // Base case: processed all characters (index moved before 0)
    if (index == -1) return;

    // Convert current character to uppercase using ASCII math:
    // 'a'..'z'  ->  'A'..'Z'
    // conversion to int happens automatically during arithmetic (called “integer promotion”).
    str[index] = char('A' + (str[index] - 'a'));

    // Recurse for the previous character
    lowerToUpper(str, index - 1);
}

int main() {
    // Driver example like the screenshot
    string str = "rohit";

    // Convert entire string to uppercase
    lowerToUpper(str, (int)str.size() - 1);

    // Output: ROHIT
    cout << str << "\n";
    return 0;
}
```

```text
Example: `str = "rohit"`  
Call: `lowerToUpper(str, 4)`  (last index)

lowerToUpper(str, 4)   // convert str[4] = 't' -> 'T'
|
v
lowerToUpper(str, 3)   // convert str[3] = 'i' -> 'I'
|
v
lowerToUpper(str, 2)   // convert str[2] = 'h' -> 'H'
|
v
lowerToUpper(str, 1)   // convert str[1] = 'o' -> 'O'
|
v
lowerToUpper(str, 0)   // convert str[0] = 'r' -> 'R'
|
v
lowerToUpper(str, -1)  // base case (stop)


Return Flow::
lowerToUpper(-1) returns
lowerToUpper(0)  returns
lowerToUpper(1)  returns
lowerToUpper(2)  returns
lowerToUpper(3)  returns
lowerToUpper(4)  returns

Final string: "ROHIT"

```

### Complexity Analysis (Recursive lowerToUpper)

Let `n = str.length`.

**Time Complexity:**  
The function processes exactly one character per recursive call.
- Number of calls: `n + 1` (including the base call at `index = -1`)
- Work per call: `O(1)` (a constant-time conversion)

**Time = O(n)**

**Space Complexity:**  
Extra space comes from the recursion call stack.
- Maximum recursion depth: `n + 1`

**Space = O(n)** (stack space)
