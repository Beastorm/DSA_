## C-String in C++: All related basics (explained)

### 1) What is a C-string?
A **C-string** is a `char` array that ends with a **null character** `'\0'`.  
That final `'\0'` marks the end of the string.  

### 2) Char array vs C-string

**Char array (may NOT be a string)**

In C++, a character array is distinct from a C-string. A C-string **must** be null-terminated.

```cpp
char a[3] = {'a', 'b', 'c'};  // no '\0'
```


**The Problem:**  
Because there is no null terminator `(\0)`, functions that rely on it will fail or cause undefined behavior.

``` cpp
std::cout << a;    // ❌ Undefined Behavior (prints garbage until it finds a 0 in memory)
strlen(a);         // ❌ Undefined Behavior (buffer overflow read)
```


**The Valid C-string:** 
To contain the string `"abc"`, the array must be at least size 4 to hold the terminator.

``` cpp
char b[4] = {'a', 'b', 'c', '\0'}; // ✅ Valid C-string
// OR
char c[] = "abc";                  // ✅ Valid (compiler adds '\0' automatically)

```


**Memory Layout Comparison:**  
```
// Char Array (Not a string):
Index: [0]   [1]   [2]
      ┌─────┬─────┬─────┐
      │ 'a' │ 'b' │ 'c' │ ... (unknown next byte)
      └─────┴─────┴─────┘


// C-string (Valid):
Index: [0]   [1]   [2]   [3]
      ┌─────┬─────┬─────┬─────┐
      │ 'a' │ 'b' │ 'c' │ \0  │
      └─────┴─────┴─────┴─────┘
```

**C-string (must have '\0'):**
``` cpp
char a[4] = {'a','b','c','\0'};
```

### 3) Input with C-strings

**Read one word (stops at space):**  
The extraction operator `>>` stops reading at the first whitespace (space, tab, or newline).

```cpp
char s[100];
cin >> s;
```

**Example:**  

*   **Input:** `Hello World`
*   **Result:** `s` contains `"Hello"`
*   *(Note: "World" remains in the input buffer)*

**Read full line (includes spaces):**  
The `cin.getline()` function reads input until it encounters a newline character or reaches the specified buffer size.

``` C++

char s[100];
cin.getline(s, 100); // 2nd argument is buffer size
```
**Example:**

**Input:** `Hello World`
**Result:** `s` contains `"Hello World"`
>(Note: Automatically handles the null terminator and prevents buffer overflow)

### 4) Length of a C-string
Use strlen() from <cstring>:

``` C++

#include <cstring>
char s[] = "hello";
cout << strlen(s);   // 5
```
> Important: strlen() works only if '\0' is present.

### 5) Copying C-strings
**Use strcpy():**

``` C++

#include <cstring>
char src[] = "hello";
char dest[20];

strcpy(dest, src);   // dest = "hello"
```

**Safer version (limits copy):**

``` C++

strncpy(dest, src, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0';
```

### 6) Comparing C-strings
**You cannot do == directly like std::string. Use strcmp():**
```
C++
#include <cstring>
cout << strcmp("abc", "abc"); // 0 (equal)
cout << strcmp("abc", "abd"); // negative
cout << strcmp("abe", "abd"); // positive
```

### 7) Concatenation (joining)
**Use strcat() (destination must have enough space):**

``` C++

#include <cstring>
char a[50] = "hello";
char b[] = "world";

strcat(a, " ");
strcat(a, b);     // a = "hello world"
```

### 8) Converting between C-string and std::string
**C-string → std::string**

```C++

char s[] = "hello";
string str = s;
std::string → C-string
```
```C++

string str = "hello";
const char* cstr = str.c_str(); // read-only pointer
```

### 9) Common pitfalls
**a) Missing null terminator**
```C++

char a[3] = {'a','b','c'};
cout << a;  // undefined behavior (may print garbage)
```
**b) Buffer overflow**
```C++

char a[5] = "hello"; // needs 6 bytes including '\0' -> overflow
```
Correct:

```C++
char a[6] = "hello";
```
**c) Using sizeof vs strlen**
>`sizeof(a)` gives total array size in bytes  
>`strlen(a)` gives length until '\0'

### 10) When to use C-strings vs std::string

>Prefer std::string in modern C++ (safer, easier).
>Use C-strings when:
 >* working with C libraries
 >* very low-level memory handling is needed
 >* egacy code requires it

---

### `std::string` Constructors (Different Forms)

> Header: `#include <string>` (or `#include <bits/stdc++.h>`)

---

**1) Default constructor (empty string)**
```cpp
string s;          // ""
string s2 = "";    // ""
```

**2) From C-string (null-terminated char array)**
```C++
string s = "hello";
const char* c = "world";
string s2(c);      // "world"
```

**3) From C-string with length (first n characters)**

```C++

const char* c = "abcdef";
string s(c, 3);    // "abc"
```

**4) Fill constructor (repeat a character count times)**
```C++

string s(5, 'a');  // "aaaaa"
string t(1, 'x');  // "x"
```

**5) Copy constructor (copy another string)**
```C++
string a = "coder";
string b(a);       // "coder"
```

**6) Substring constructor (part of another string)**
```C++

string s = "abcdef";
string sub(s, 2);      // from index 2 to end -> "cdef"
string sub2(s, 1, 3);  // from index 1, length 3 -> "bcd"
```

**7) From iterators (range constructor)**
``` C++

string s = "abcdef";
string part(s.begin() + 1, s.begin() + 4); // "bcd"
```

**8) From initializer list**
```C++
string s({'a', 'b', 'c'}); // "abc"
```

**9) Move constructor (avoids copying)**
```C++

string a = "hello";
string b(std::move(a)); // b="hello", a becomes empty/unspecified
```

**Quick Notes
>string(count, ch) is useful for building repeated characters.
>string(ptr, n) is useful when you have a char* buffer with known length (may not contain '\0').
>string(str, pos, len) extracts a substring without calling substr().





