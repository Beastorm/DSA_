# Factorials of Large Numbers

**Problem Statemwnt:**  
Given an integer `n`, compute `n!` (factorial of `n`) and return the result as a **list of integers**, where each integer is a **digit** of `n!` in order from most significant to least significant.

 **Definition**  
`n! = 1 × 2 × 3 × ... × n`

### Examples
- Input: `n = 5`  
  Output: `[1, 2, 0]`  
  Explanation: `5! = 120`

- Input: `n = 10`  
  Output: `[3, 6, 2, 8, 8, 0, 0]`  
  Explanation: `10! = 3628800`

- Input: `n = 1`  
  Output: `[1]`  
  Explanation: `1! = 1`

### Constraints
- `1 ≤ n ≤ 10^3`

---

> Notes
> - The factorial grows very quickly, so the result may not fit in standard integer types.
> - The output must be represented as digits (not as a built-in big integer).

### Intuition
`n!` becomes very large, so it cannot fit in normal integer types.  
We store the factorial as a list of digits and multiply it step-by-step (like manual multiplication).  
A `carry` is used to handle values greater than 9.

Digits are stored in **reverse order** (least significant digit first) to make multiplication and carry handling easy.

### Algorithm Steps
1. Initialize `ans = [1]` to represent the current value of factorial (starting from `1`).
2. While `n > 1`:
   - Set `carry = 0`.
   - For each digit `ans[i]`:
     - Compute `res = ans[i] * n + carry`.
     - Update digit: `ans[i] = res % 10`.
     - Update carry: `carry = res / 10`.
   - After all digits are processed, while `carry > 0`:
     - Append `carry % 10` to `ans`.
     - Set `carry = carry / 10`.
   - Decrement `n` by 1.
3. Reverse `ans` (because digits are currently stored in reverse order).
4. Return/print `ans` as the digits of `n!` from most significant to least.


``` cpp
#include <bits/stdc++.h>
using namespace std;

// Returns digits of n! as a vector<int> in normal order (most significant to least).
vector<int> factorialDigits(int n) {
    // store digits in reverse order (least significant first)
    vector<int> ans;
    ans.push_back(1);

    while (n > 1) {
        int carry = 0;
        int sz = (int)ans.size();

        for (int i = 0; i < sz; i++) {
            int res = ans[i] * n + carry;
            ans[i] = res % 10;
            carry = res / 10;
        }

        while (carry) {
            ans.push_back(carry % 10);
            carry /= 10;
        }

        n--;
    }

    reverse(ans.begin(), ans.end());
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    vector<int> digits = factorialDigits(n);

    // Print as list like [1, 2, 0]
    cout << "[";
    for (int i = 0; i < (int)digits.size(); i++) {
        cout << digits[i];
        if (i + 1 < (int)digits.size()) cout << ", ";
    }
    cout << "]\n";

    return 0;
}
```
### Complexity Analysis

Let `D` be the number of digits in `n!`.

**Time Complexity:**  
For each multiplier from `2` to `n`, we multiply across all current digits.
So the total work is roughly:

- `O(D2 + D3 + ... + Dn)` where `Dx` is digits in `x!`
- This is commonly written as **O(n · D)** (since digit count grows and is at most `D`)

So, **Time = O(n · D)**.

(Using Stirling approximation, `D = Θ(n log n)`, so time is about `O(n^2 log n)`.)

**Space Complexity:**  
- The vector `ans` stores all digits of `n!`: **O(D)**
- Extra variables like `carry` take **O(1)**.

So, **Space = O(D)**.
