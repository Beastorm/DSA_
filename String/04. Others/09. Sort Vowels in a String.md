# Sort Vowels in a String

**Problem Statement:**  
Given a 0-indexed string `s`, permute it into a new string `t` such that:

- **Consonants stay fixed:** if `s[i]` is a consonant, then `t[i] = s[i]`.
- **Vowels are sorted by ASCII:** for any vowel indices `i < j`, `t[i]` must have ASCII value `<= t[j]`.

Vowels are: `a, e, i, o, u` in both lowercase and uppercase.

Return `t`.

>Notes
>- ASCII sorting means all uppercase vowels come before lowercase vowels (since `'A' < 'a'`).
>- If there are no vowels, the string remains unchanged.

### Examples
- Input: `lEetcOde`  
  Output: `lEOtcede`
- Input: `lYmpH`  
  Output: `lYmpH`

### Constraints
- `1 <= s.length <= 10^5`
- `s` contains only English letters (uppercase and lowercase).

---
### Intuition
Consonants are **fixed** (they must stay at the same indices). Only vowels are allowed to move, and after moving them they must appear from left to right in **nondecreasing ASCII order**.  
So we keep the string “skeleton” of consonants, and refill the vowel positions with the vowels arranged in ASCII order.

### Algorithm Steps
1. Create two frequency arrays:
   - `upper[26]` for counts of `'A'..'Z'`
   - `lower[26]` for counts of `'a'..'z'`

2. Scan the string `s`:
   - If `s[i]` is a lowercase vowel (`a,e,i,o,u`):
     - increment `lower[s[i]-'a']`
     - set `s[i] = '#'` (mark this position as a vowel slot)
   - Else if `s[i]` is an uppercase vowel (`A,E,I,O,U`):
     - increment `upper[s[i]-'A']`
     - set `s[i] = '#'`
   - Else (consonant): leave it unchanged.

3. Build a string `vowelsSorted` in ASCII order:
   - For `i = 0..25`, append character `'A'+i` exactly `upper[i]` times
   - For `i = 0..25`, append character `'a'+i` exactly `lower[i]` times  
   This produces vowels in sorted ASCII order without calling `sort()`.

4. Scan `s` again and refill:
   - Maintain an index `j = 0`
   - If `s[i] == '#'`, replace it with `vowelsSorted[j]` and increment `j`
   - Consonants remain as they are.

5. Return the modified string.

``` cpp
#include <bits/stdc++.h>
using namespace std;

static inline bool isLowerVowel(char c) {
    return c=='a' || c=='e' || c=='i' || c=='o' || c=='u';
}
static inline bool isUpperVowel(char c) {
    return c=='A' || c=='E' || c=='I' || c=='O' || c=='U';
}
static inline bool isVowel(char c) {
    return isLowerVowel(c) || isUpperVowel(c);
}

string sortVowels(string s) {
    vector<int> lower(26, 0), upper(26, 0);

    // Count vowels and mark their positions with '#'
    for (int i = 0; i < (int)s.size(); i++) {
        if (isLowerVowel(s[i])) {
            lower[s[i] - 'a']++;
            s[i] = '#';
        } else if (isUpperVowel(s[i])) {
            upper[s[i] - 'A']++;
            s[i] = '#';
        }
    }

    // Create sorted vowel string in ASCII order: 'A'..'Z' then 'a'..'z'
    string vowels;
    vowels.reserve(s.size());

    for (int i = 0; i < 26; i++) {
        char c = char('A' + i);
        while (upper[i] > 0) {
            vowels.push_back(c);
            upper[i]--;
        }
    }
    for (int i = 0; i < 26; i++) {
        char c = char('a' + i);
        while (lower[i] > 0) {
            vowels.push_back(c);
            lower[i]--;
        }
    }

    // Put vowels back into marked positions
    int second = 0;
    for (int first = 0; first < (int)s.size(); first++) {
        if (s[first] == '#') {
            s[first] = vowels[second];
            second++;
        }
    }

    return s;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // Driver:
    // Input: a single string (letters only), e.g. lEetcOde
    // Output: transformed string
    string s;
    cin >> s;

    cout << sortVowels(s) << "\n";
    return 0;
}
```
### Complexity Analysis

Let `n = s.length`.

### Time Complexity
- First pass over the string to count vowels and mark positions: **O(n)**
- Building the sorted vowel sequence using two loops over 26 letters each: **O(26 + 26) = O(1)**
- Second pass to place vowels back into `#` positions: **O(n)**

Total time: **O(n)**

### Space Complexity
- Frequency arrays `upper[26]` and `lower[26]`: **O(1)**
- Extra string `vowelsSorted` storing all vowels (worst case all characters are vowels): **O(n)**
- Output is stored in the same string `s` (modified in-place), but the auxiliary vowel storage dominates.

Total extra space: **O(n)** (auxiliary), **O(1)** excluding the vowel buffer.
