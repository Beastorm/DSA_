## Smallest Distinct Window

**Problem:**  
Given a string `str`, find the **length of the smallest substring** that contains **all distinct characters** present in `str` **at least once**.

---

>### Examples:
- Input: `aabcbcdbca`  
  Output: `4`  
  Explanation: `"dbca"` contains all distinct characters of the string.

- Input: `aaab`  
  Output: `2`  
  Explanation: `"ab"`.

- Input: `geeksforgeeks`  
  Output: `7`  
  Explanation: `"eksforg"` or `"ksforge"`.

---

### Constraints:
- `1 ≤ str.size() ≤ 10^5`
- `str` contains only lowercase English letters.

---

## Brute Force Solution

### Intuition:
Try every possible substring and check whether it contains **all distinct characters** that appear in the full string.  
Pick the smallest length among the valid substrings.

### Algorithm Steps:
1. Compute the set of distinct characters in the whole string `str`.
   - Let `need` = number of distinct characters.
2. Initialize `ans = +infinity`.
3. For every start index `i` from `0` to `n-1`:
   - For every end index `j` from `i` to `n-1`:
     1. Check if substring `str[i..j]` contains all `need` distinct characters:
        - Create an empty boolean/frequency array `seen[26]`.
        - Scan `k` from `i` to `j` and mark characters in `seen`.
        - Count how many distinct characters are marked; if it equals `need`, the substring is valid.
     2. If valid, update `ans = min(ans, j - i + 1)`.
4. Return `ans`.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// O(n^3) brute force: check every substring and verify it contains all distinct chars of str.
int smallestDistinctWindowN3(const string& str) {
    int n = (int)str.size();
    if (n == 0) return 0;

    // Distinct characters in whole string
    vector<bool> present(26, false);
    int need = 0;
    for (char ch : str) {
        int idx = ch - 'a';
        if (!present[idx]) {
            present[idx] = true;
            need++;
        }
    }

    int ans = INT_MAX;

    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            vector<bool> seen(26, false);
            int have = 0;

            for (int k = i; k <= j; k++) {
                int idx = str[k] - 'a';
                if (!seen[idx]) {
                    seen[idx] = true;
                    have++;
                }
            }

            if (have == need) {
                ans = min(ans, j - i + 1);
            }
        }
    }

    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string str;
    cin >> str;              // lowercase letters, no spaces as per constraints

    cout << smallestDistinctWindowN3(str) << "\n";
    return 0;
}
```

### Complexity Analysis:
- There are `O(n^2)` substrings `(i, j)`.
- For each substring, the check scans up to `O(n)` characters `(k loop)`.
- Total time: `O(n^3)`.
- Extra space: `O(1)` (only 26 letters).

---

## Better Approach

### Intuition: 
We need the smallest substring that contains **all distinct characters** of the full string.

Fix a starting index `i` and try to extend the substring to the right (`j = i, i+1, ...`).
While extending, keep track of:
- `freq[ch]`: how many times each character appears in the current substring `str[i..j]`
- `have`: how many **distinct** characters are currently present (frequency > 0)

As soon as `have` becomes equal to `need` (total distinct characters in the whole string), we know:
- `str[i..j]` is a valid window
- and it is the **smallest valid window starting at `i`**, because `j` is the first position where the window becomes valid.
So we update the answer and stop expanding for this `i`.

### Algorithm Steps:
1. Compute `need`:
   - Count how many distinct characters exist in the entire string `str`.
2. Initialize `ans = +infinity`.
3. For each start index `i` from `0` to `n-1`:
   - Create `freq[26] = 0` and set `have = 0`.
   - For each end index `j` from `i` to `n-1`:
     1. Add `str[j]` to the current window:
        - `freq[str[j]]++`
        - If `freq[str[j]]` becomes `1`, increment `have`.
     2. If `have == need`:
        - Update `ans = min(ans, j - i + 1)`
        - `break` (this is the minimal valid window for this `i`)
4. Return `ans`.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// O(n^2): for each start i, expand j and maintain a distinct count for str[i..j]
int smallestDistinctWindowN2(const string& str) {
    int n = (int)str.size();
    if (n == 0) return 0;

    // Count distinct chars in whole string
    vector<bool> present(26, false);
    int need = 0;
    for (char ch : str) {
        int idx = ch - 'a';
        if (!present[idx]) {
            present[idx] = true;
            need++;
        }
    }

    int ans = INT_MAX;

    for (int i = 0; i < n; i++) {
        vector<int> freq(26, 0);
        int have = 0;

        for (int j = i; j < n; j++) {
            int idx = str[j] - 'a';
            freq[idx]++;
            if (freq[idx] == 1) have++;

            if (have == need) {          // first time reaching all distinct for this i is minimal for this i
                ans = min(ans, j - i + 1);
                break;
            }
        }
    }

    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string str;
    cin >> str;

    cout << smallestDistinctWindowN2(str) << "\n";
    return 0;
}
```
### Complexity Analysis:

Let `n = str.length`.

- **Time Complexity:**  
  - Computing `need` (distinct characters in the whole string): `O(n)`
  - Outer loop over start index `i`: runs `n` times.
  - Inner loop over end index `j`: in the worst case, can scan up to `n - i` characters.
  
  Total inner iterations across all `i`:
  `(n) + (n-1) + ... + 1 = n(n+1)/2 = O(n^2)`
  
  So overall:
  
  *Time = O(n^2)*

- **Space Complexity:**  
  - `present[26]` and `freq[26]` arrays are fixed size (only lowercase letters).
  
  *Space = O(1)* (constant extra space)

---

## Optimized Approach(sliding window):
### Intuition:
We want the smallest substring that contains **every distinct character** present in the whole string.

Use a **sliding window** `[first, second)`:
- `second` expands the window to the right until the window becomes **valid** (contains all distinct characters).
- Then `first` shrinks the window from the left as much as possible while keeping it **valid**.
- Track the minimum window length during shrinking.

To know when the window is valid, we use:
- `diff` = how many distinct characters are still **missing** from the current window.
- `count[ch]` = frequency of character `ch` inside the current window.

When `diff == 0`, the window contains all distinct characters.

### Algorithm Steps:
1. **Count distinct characters in the whole string**
   - Use `count[256]` once to compute:
     - `diff = number of distinct characters in str`.
2. **Reset** `count[256]` to `0` for window frequencies.
3. Initialize:
   - `first = 0`, `second = 0`
   - `len = n` (answer)
4. While `second < n`:
   1. **Expand window** until it becomes valid:
      - While `second < n` and `diff > 0`:
        - If `count[str[second]] == 0`, then this distinct character is newly included → `diff--`
        - Increment `count[str[second]]`
        - `second++`
   2. **Shrink window** while it stays valid:
      - While `diff == 0`:
        - Update `len = min(len, second - first)`
        - Decrease `count[str[first]]`
        - If `count[str[first]]` becomes `0`, we lost a needed distinct character → `diff++`.
        - `first++`
5. Return `len`.

### Key Point:
- `second` only moves forward, and `first` only moves forward.
- Every character enters the window once and leaves once, making it efficient.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Sliding-window solution like in the screenshot (count[256], first/second, diff)
int smallestDistinctWindow(const string& str) {
    int n = (int)str.size();
    if (n == 0) return 0;

    vector<int> count(256, 0);

    // diff = number of distinct characters in the whole string
    int diff = 0;
    for (int i = 0; i < n; i++) {
        unsigned char c = (unsigned char)str[i];
        if (count[c] == 0) diff++;
        count[c]++;
    }

    // reset counts for window usage
    fill(count.begin(), count.end(), 0);

    int first = 0, second = 0;
    int len = n;

    while (second < n) {
        // expand until window contains all distinct chars (diff becomes 0)
        while (second < n && diff > 0) {
            unsigned char c = (unsigned char)str[second];
            if (count[c] == 0) diff--;
            count[c]++;
            second++;
        }

        // shrink from left while window remains valid (diff == 0)
        while (diff == 0) {
            len = min(len, second - first);

            unsigned char c = (unsigned char)str[first];
            count[c]--;
            if (count[c] == 0) diff++; // lost one distinct char
            first++;
        }
    }

    return len;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string str;
    cin >> str; // lowercase letters as per constraints

    cout << smallestDistinctWindow(str) << "\n";
    return 0;
}
```
### Complexity Analysis:

Let `n = str.length`.

- **Time Complexity:**  
  - First pass to count total distinct characters: `O(n)`
  - Sliding window:
    - `second` moves from `0` to `n` at most once → `O(n)`
    - `first` moves from `0` to `n` at most once → `O(n)`
  - Each character is processed a constant number of times (added/removed once).
  
  Total time: `O(n)`

- **Space Complexity:**  
  - `count[256]` (or equivalent) is a fixed-size frequency array.
  
  Total extra space: `O(1)` (constant)
