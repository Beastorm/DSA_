## C-String in C++: All related basics (explained)

### 1) What is a C-string?
A **C-string** is a `char` array that ends with a **null character** `'\0'`.  
That final `'\0'` marks the end of the string.  

### 2) Char array vs C-string

**Char array (may NOT be a string)**

In C++, a character array is distinct from a C-string. A C-string **must** be null-terminated.

```cpp
char a[3] = {'a', 'b', 'c'};  // no '\0'
```


**The Problem:**  
Because there is no null terminator `(\0)`, functions that rely on it will fail or cause undefined behavior.

``` cpp
std::cout << a;    // ❌ Undefined Behavior (prints garbage until it finds a 0 in memory)
strlen(a);         // ❌ Undefined Behavior (buffer overflow read)
```


**The Valid C-string:** 
To contain the string `"abc"`, the array must be at least size 4 to hold the terminator.

``` cpp
char b[4] = {'a', 'b', 'c', '\0'}; // ✅ Valid C-string
// OR
char c[] = "abc";                  // ✅ Valid (compiler adds '\0' automatically)

```


**Memory Layout Comparison:**  
```
// Char Array (Not a string):
Index: [0]   [1]   [2]
      ┌─────┬─────┬─────┐
      │ 'a' │ 'b' │ 'c' │ ... (unknown next byte)
      └─────┴─────┴─────┘


// C-string (Valid):
Index: [0]   [1]   [2]   [3]
      ┌─────┬─────┬─────┬─────┐
      │ 'a' │ 'b' │ 'c' │ \0  │
      └─────┴─────┴─────┴─────┘
```

**C-string (must have '\0'):**
``` cpp
char a[4] = {'a','b','c','\0'};
```

### 3) Input with C-strings

**Read one word (stops at space):**  
The extraction operator `>>` stops reading at the first whitespace (space, tab, or newline).

```cpp
char s[100];
cin >> s;
```

**Example:**  

*   **Input:** `Hello World`
*   **Result:** `s` contains `"Hello"`
*   *(Note: "World" remains in the input buffer)*

**Read full line (includes spaces):**  
The `cin.getline()` function reads input until it encounters a newline character or reaches the specified buffer size.

``` C++

char s[100];
cin.getline(s, 100); // 2nd argument is buffer size
```
**Example:**

**Input:** `Hello World`
**Result:** `s` contains `"Hello World"`
>(Note: Automatically handles the null terminator and prevents buffer overflow)

### 4) Length of a C-string
Use strlen() from <cstring>:

``` C++

#include <cstring>
char s[] = "hello";
cout << strlen(s);   // 5
```
> Important: strlen() works only if '\0' is present.

### 5) Copying C-strings
**Use strcpy():**

``` C++

#include <cstring>
char src[] = "hello";
char dest[20];

strcpy(dest, src);   // dest = "hello"
```

**Safer version (limits copy):**

``` C++

strncpy(dest, src, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0';
```

### 6) Comparing C-strings
**You cannot do == directly like std::string. Use strcmp():**
```
C++
#include <cstring>
cout << strcmp("abc", "abc"); // 0 (equal)
cout << strcmp("abc", "abd"); // negative
cout << strcmp("abe", "abd"); // positive
```

### 7) Concatenation (joining)
**Use strcat() (destination must have enough space):**

``` C++

#include <cstring>
char a[50] = "hello";
char b[] = "world";

strcat(a, " ");
strcat(a, b);     // a = "hello world"
```

### 8) Converting between C-string and std::string
**C-string → std::string**

```C++

char s[] = "hello";
string str = s;
std::string → C-string
```
```C++

string str = "hello";
const char* cstr = str.c_str(); // read-only pointer
```

### 9) Common pitfalls
**a) Missing null terminator**
```C++

char a[3] = {'a','b','c'};
cout << a;  // undefined behavior (may print garbage)
```
**b) Buffer overflow**
```C++

char a[5] = "hello"; // needs 6 bytes including '\0' -> overflow
```
Correct:

```C++
char a[6] = "hello";
```
**c) Using sizeof vs strlen**
>`sizeof(a)` gives total array size in bytes  
>`strlen(a)` gives length until '\0'

### 10) When to use C-strings vs std::string

>Prefer std::string in modern C++ (safer, easier).
>Use C-strings when:
 >* working with C libraries
 >* very low-level memory handling is needed
 >* egacy code requires it

---

### `std::string` Constructors (Different Forms)

> Header: `#include <string>` (or `#include <bits/stdc++.h>`)

---

**1) Default constructor (empty string)**
```cpp
string s;          // ""
string s2 = "";    // ""
```

**2) From C-string (null-terminated char array)**
```C++
string s = "hello";
const char* c = "world";
string s2(c);      // "world"
```

**3) From C-string with length (first n characters)**

```C++

const char* c = "abcdef";
string s(c, 3);    // "abc"
```

**4) Fill constructor (repeat a character count times)**
```C++

string s(5, 'a');  // "aaaaa"
string t(1, 'x');  // "x"
```

**5) Copy constructor (copy another string)**
```C++
string a = "coder";
string b(a);       // "coder"
```

**6) Substring constructor (part of another string)**
```C++

string s = "abcdef";
string sub(s, 2);      // from index 2 to end -> "cdef"
string sub2(s, 1, 3);  // from index 1, length 3 -> "bcd"
```

**7) From iterators (range constructor)**
``` C++

string s = "abcdef";
string part(s.begin() + 1, s.begin() + 4); // "bcd"
```

**8) From initializer list**
```C++
string s({'a', 'b', 'c'}); // "abc"
```

**9) Move constructor (avoids copying)**
```C++

string a = "hello";
string b(std::move(a)); // b="hello", a becomes empty/unspecified
```

**Quick Notes
>string(count, ch) is useful for building repeated characters.
>string(ptr, n) is useful when you have a char* buffer with known length (may not contain '\0').
>string(str, pos, len) extracts a substring without calling substr().

---

## `std::string` Functions Grouped by Category

### 1) Size and Capacity
| Name | Main overloads / signature | Example |
|---|---|---|
| `size()` / `length()` | `size_t size() const` | `s.size()` |
| `empty()` | `bool empty() const` | `s.empty()` |
| `clear()` | `void clear()` | `s.clear()` |

---

### 2) Element Access
| Name | Main overloads / signature | Example |
|---|---|---|
| `operator[]` | `char& operator[](size_t)` / `const char& operator[](size_t) const` | `s[i]` |
| `at()` | `char& at(size_t)` / `const char& at(size_t) const` | `s.at(i)` |
| `front()` | `char& front()` / `const char& front() const` | `s.front()` |
| `back()` | `char& back()` / `const char& back() const` | `s.back()` |

---

### 3) Modifiers
| Name | Main overloads (common) | Example |
|---|---|---|
| `push_back()` | `void push_back(char)` | `s.push_back('!')` |
| `pop_back()` | `void pop_back()` | `s.pop_back()` |
| `operator+=` | `+= string` / `+= const char*` / `+= char` | `s += "hi"` |
| `append()` | `append(string)` / `append(string,pos,len)` / `append(const char*)` / `append(count,char)` / `append(It,It)` | `s.append(3,'x')` |
| `insert()` | `insert(pos,string)` / `insert(pos,string,subpos,sublen)` / `insert(pos,const char*)` / `insert(pos,count,char)` / iterator inserts | `s.insert(2,"XYZ")` |
| `erase()` | `erase(pos,len)` / `erase(it)` / `erase(first,last)` | `s.erase(3,2)` |
| `replace()` | `replace(pos,len,string)` / `replace(pos,len,const char*)` / `replace(pos,len,count,char)` / iterator replaces | `s.replace(0,2,"Hi")` |
| `swap()` | `swap(string&)` | `s.swap(t)` |

---

### 4) Substrings
| Name | Signature / overloads | Example |
|---|---|---|
| `substr()` | `string substr(size_t pos=0, size_t len=npos) const` | `s.substr(2)` / `s.substr(2,3)` |

---

### 5) Searching
| Name | Main overloads (common) | Example |
|---|---|---|
| `find()` | `find(string,pos)` / `find(const char*,pos,count)` / `find(const char*,pos)` / `find(char,pos)` | `s.find("ab")` |
| `rfind()` | `rfind(string,pos)` / `rfind(const char*,pos,count)` / `rfind(const char*,pos)` / `rfind(char,pos)` | `s.rfind("ab")` |
| `find_first_of()` | `... (string / const char* / char, pos...)` | `s.find_first_of("aeiou")` |
| `find_last_of()` | `... (string / const char* / char, pos...)` | `s.find_last_of("0123")` |
| `find_first_not_of()` | `... (string / const char* / char, pos...)` | `s.find_first_not_of(" ")` |
| `find_last_not_of()` | `... (string / const char* / char, pos...)` | `s.find_last_not_of(" ")` |

---

### 6) Comparing
| Name | Main overloads (common) | Example |
|---|---|---|
| `compare()` | `compare(string)` / `compare(pos,len,string)` / `compare(pos,len,string,subpos,sublen)` / `compare(const char*)` / `compare(pos,len,const char*)` / `compare(pos,len,const char*,count)` | `s.compare(t)` |

---

### 7) C-style / Buffer Access
| Name | Signature | Example |
|---|---|---|
| `c_str()` | `const char* c_str() const` | `s.c_str()` |
| `data()` | `const char* data() const` / (C++17+) `char* data()` | `s.data()` |
| `copy()` | `size_t copy(char* dest, size_t count, size_t pos=0) const` | `s.copy(buf, 5, 0)` |

---

## Operators Grouped by Category

### A) Concatenation
| Operator | Meaning | Example |
|---|---|---|
| `+` | create new concatenated string | `c = a + b` |
| `+=` | append into same string | `a += b` |

### B) Comparison
| Operator | Meaning | Example |
|---|---|---|
| `== != < > <= >=` | lexicographic comparison | `a < b` |

### C) I/O
| Operator | Meaning | Example |
|---|---|---|
| `<<` | output | `cout << s` |
| `>>` | input (word) | `cin >> s` |


## Common overloaded operators for `std::string`

| Operator | Meaning | Example |
|---|---|---|
| `+` | Concatenate | `string x = a + b;` |
| `+=` | Append | `a += b;` |
| `== != < > <= >=` | Lexicographic comparison | `if (a < b) ...` |
| `<< >>` | Stream output/input | `cout << s; cin >> s;` |

> Note: Overload lists above are the most common ones; `std::string` has additional iterator and `std::string_view`-related overloads depending on the C++ standard/library.


