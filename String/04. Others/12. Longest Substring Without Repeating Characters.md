## Longest Substring Without Repeating Characters

**Problem:**  
Given a string `s`, return the **length** of the longest **substring** (contiguous part) that contains **no repeated characters**.

---

>### Examples:
- Input: `s = "abcabcbb"`  
  Output: `3`  
  Explanation: `"abc"` has length `3` (also `"bca"`, `"cab"`).

- Input: `s = "bbbbb"`  
  Output: `1`  
  Explanation: `"b"` has length `1`.

- Input: `s = "pwwkew"`  
  Output: `3`  
  Explanation: `"wke"` has length `3` (`"pwke"` is not a substring).

---

### Constraints:
- `0 <= s.length <= 5 * 10^4`
- `s` can include English letters, digits, symbols, and spaces.

---

## Bruteforce Approach:

### Intuition:
The longest substring without repeating characters must be one of the many substrings of `s`.
So we can:
- generate **every possible substring** `s[i..j]`
- check if that substring has **all unique characters**
- keep the maximum length among the valid ones

This is brute force because we do a full uniqueness check for each substring.

### Algorithm Steps:
1. Initialize `best = 0`.
2. For every start index `i` from `0` to `n-1`:
   - For every end index `j` from `i` to `n-1`:
     1. Check if substring `s[i..j]` has all unique characters:
        - Create a `seen` array/set (empty).
        - Scan `k` from `i` to `j`:
          - If `s[k]` is already marked in `seen`, then the substring is invalid (has duplicates).
          - Otherwise, mark it as seen.
     2. If the substring is valid, update:
        - `best = max(best, j - i + 1)`
3. Return `best`.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Check if s[l..r] has all unique characters (O(length))
static bool allUnique(const string& s, int l, int r) {
    // ASCII size 256 works for typical inputs (digits/symbols/spaces included)
    vector<bool> seen(256, false);

    for (int i = l; i <= r; i++) {
        unsigned char c = (unsigned char)s[i];
        if (seen[c]) return false;
        seen[c] = true;
    }
    return true;
}

// O(n^3): enumerate all substrings O(n^2), and check uniqueness O(n)
int lengthOfLongestSubstringN3(const string& s) {
    int n = (int)s.size();
    int best = 0;

    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            if (allUnique(s, i, j)) {
                best = max(best, j - i + 1);
            }
        }
    }
    return best;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s); // supports spaces

    cout << lengthOfLongestSubstringN3(s) << "\n";
    return 0;
}
```
### Complexity Analysis:

Let `n = s.length`.

- **Time Complexity:**
  - We enumerate all substrings using two loops `(i, j)`.
    - Number of substrings = `n + (n-1) + ... + 1 = n(n+1)/2 = O(n^2)`.
  - For each substring `s[i..j]`, we check uniqueness by scanning from `i` to `j`,
    which in the worst case takes `O(j - i + 1) = O(n)` time.
  
    So total time = `O(n^2) * O(n) = O(n^3)`.

- **Space Complexity:**
  - The uniqueness check uses a `seen` structure (like a boolean array of size 256 for ASCII).
  - That size is constant with respect to `n`.
  
    So extra space = **O(1)** (constant).

---

## Better Approach :

### Intuition:
For each starting index `i`, try to extend the substring to the right (`j = i..n-1`).
Keep a `seen` set of characters already in the current substring.
The moment you see a repeated character, you cannot extend further for that `i`, so you stop early.

This avoids re-checking the whole substring again and again (which caused the O(n^3)).

### Algorithm Steps:
1. Initialize `best = 0`.
2. For each start index `i` from `0` to `n-1`:
   - Create an empty set `seen`.
   - For each end index `j` from `i` to `n-1`:
     - If `s[j]` is already in `seen`, break (stop expanding this substring).
     - Otherwise insert `s[j]` into `seen`.
     - Update `best = max(best, j - i + 1)`.
3. Return `best`.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// O(n^2) approach: for each start i, extend j until a duplicate appears.
int lengthOfLongestSubstringN2(const string& s) {
    int n = (int)s.size();
    int best = 0;

    for (int i = 0; i < n; i++) {
        // Use fixed-size array for ASCII characters (fast, avoids hashing).
        vector<bool> seen(256, false);

        for (int j = i; j < n; j++) {
            unsigned char c = (unsigned char)s[j];
            if (seen[c]) break;      // duplicate found
            seen[c] = true;
            best = max(best, j - i + 1);
        }
    }
    return best;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s); // supports spaces too

    cout << lengthOfLongestSubstringN2(s) << "\n";
    return 0;
}
```

### Complexity Analysis:

Let `n = s.length`.

- **Time Complexity:**  
  - Outer loop chooses start index `i` from `0` to `n-1` → runs `n` times.
  - Inner loop extends end index `j` from `i` onward until a duplicate appears.
    - In the worst case (all characters are unique), it runs `(n - i)` times for each `i`.
  
  Total iterations:
  `(n) + (n-1) + ... + 1 = n(n+1)/2 = O(n^2)`
  
  Each inner step does `O(1)` work (array check/set), so:
  Time = O(n^2)

- **Space Complexity:**  
  - `seen[256]` (or a boolean array for the character set) is constant size.
  Space = O(1)** (constant extra space)

---

## Optimized Approach(Sliding Window)

### Intuition: 
We want the longest **contiguous** part of the string with **no repeating characters**.

Maintain a moving window `[first .. second]` such that:
- the window always contains **unique** characters only.

As we expand the window by moving `second` to the right:
- if `s[second]` is **not** already in the window, we can safely include it.
- if `s[second]` **is** already in the window, the window becomes invalid (has a duplicate), so we move `first` rightward to remove characters until the duplicate is gone.

A boolean array `count[256]` tells whether a character is currently inside the window.

### Algorithm Steps:
1. Initialize:
   - `count[256] = false`
   - `first = 0`, `second = 0`
   - `bestLen = 0`
2. While `second < n`:
   1. Let `c = s[second]`.
   2. If `c` is already in the window (`count[c] == true`):
      - While `count[c]` is still true:
        - remove `s[first]` from the window: `count[s[first]] = false`
        - increment `first`
      (this shrinks the window until the duplicate `c` is removed)
   3. Add `c` to the window: `count[c] = true`.
   4. Update answer: `bestLen = max(bestLen, second - first + 1)`.
   5. Move the right end forward: `second++`.
3. Return `bestLen`.

### Why does it work?
- The window is always kept valid (all unique).
- `second` only moves forward, and `first` only moves forward, so every character is added/removed at most once.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Sliding window using count[256]
int lengthOfLongestSubstring(const string& s) {
    vector<bool> count(256, false);

    int first = 0, second = 0;
    int bestLen = 0;

    while (second < (int)s.size()) {
        unsigned char c = (unsigned char)s[second];

        // If current char already in window, shrink from left until it's removed
        while (count[c]) {
            unsigned char leftChar = (unsigned char)s[first];
            count[leftChar] = false;
            first++;
        }

        // Add current char to window
        count[c] = true;

        // Update answer
        bestLen = max(bestLen, second - first + 1);

        second++;
    }

    return bestLen;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s); // supports spaces/symbols as per constraints

    cout << lengthOfLongestSubstring(s) << "\n";
    return 0;
}
```
### Complexity Analysis:

Let `n = s.length`.

- **Time Complexity:**  
  - The pointer `second` moves from `0` to `n-1` → at most `n` steps.
  - The pointer `first` also only moves forward and never goes back → at most `n` steps total.
  - Each character is inserted into the window once and removed at most once.
  
  So total operations are proportional to `2n`.
  `Time = O(n)`

- **Space Complexity:**  
  - `count[256]` is a fixed-size boolean array (for possible character values).
    `Space = O(1)` (constant extra space)
