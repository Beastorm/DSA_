## Longest Palindrome

**Problem Statement:**     
Given a string `s` consisting of lowercase or uppercase letters, return the **length of the longest palindrome** that can be built using those letters.

Letters are **case-sensitive**. For example, `"Aa"` is **not** considered a palindrome.

---

>### Examples:

### Example 1:
**Input:** `s = "abccccdd"`  
**Output:** `7`  

**Explanation:**  
One of the longest palindromes that can be built is `"dccaccd"`, whose length is `7`.

### Example 2:
**Input:** `s = "a"`  
**Output:** `1`  

**Explanation:**  
The longest palindrome that can be built is `"a"`, whose length is `1`.

---

### Constraints:
- `1 <= s.length <= 2000`
- `s` consists of lowercase and/or uppercase English letters only

### Intuition:

A palindrome is symmetric:

- Characters on the **left** must match characters on the **right**.
- So we can use characters in **pairs** (2 at a time).

For each character:
- If its frequency is even, we can use **all** of it in pairs.
- If its frequency is odd, we can use **frequency - 1** in pairs, and **1** character is left over.

In a palindrome, we can place **at most one** leftover (odd-frequency) character in the **middle**.

So:
- add up all usable pairs (`even parts`)
- if any odd exists, add `1` for the center


### Algorithm:

1. Create two frequency arrays of size `26`:
   - `lower[26]` for `'a'` to `'z'`
   - `upper[26]` for `'A'` to `'Z'` (case-sensitive)
2. Traverse the string and count the frequency of each character in the correct array.
3. Initialize:
   - `count = 0` (stores total length formed using pairs)
   - `odd = false` (tracks if any character has an odd frequency)
4. For each letter index `0..25`:
   - Add the largest even part of its frequency to `count`:
     - if frequency is even → add full frequency
     - if frequency is odd → add `frequency - 1` and set `odd = true`
   - Do this for both lowercase and uppercase arrays.
5. If `odd` is true, add `1` to `count` (one odd-frequency character can be placed in the center).
6. Return `count`.

### C++ Code:  
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Return the length of the longest palindrome that can be built
    int longestPalindrome(string s) {
        vector<int> lower(26, 0), upper(26, 0);

        // Count frequencies of lowercase and uppercase separately (case-sensitive)
        for (char ch : s) {
            if (ch >= 'a' && ch <= 'z') lower[ch - 'a']++;
            else if (ch >= 'A' && ch <= 'Z') upper[ch - 'A']++;
        }

        int count = 0;     // total length we can form using pairs
        bool odd = false;  // whether any character has odd frequency

        // Add the maximum even contribution from each character
        for (int i = 0; i < 26; i++) {
            // lowercase
            if (lower[i] % 2 == 0) count += lower[i];
            else {
                count += lower[i] - 1;  // use the even part
                odd = true;             // one leftover can be center
            }

            // uppercase
            if (upper[i] % 2 == 0) count += upper[i];
            else {
                count += upper[i] - 1;
                odd = true;
            }
        }

        // If any odd frequency exists, we can place one odd char in the center
        return count + (odd ? 1 : 0);
    }
};

int main() {
    Solution sol;

    // Example 1
    string s1 = "abccccdd";
    cout << "Input: " << s1 << "\n";
    cout << "Output: " << sol.longestPalindrome(s1) << "\n\n"; // 7

    // Example 2
    string s2 = "a";
    cout << "Input: " << s2 << "\n";
    cout << "Output: " << sol.longestPalindrome(s2) << "\n";   // 1

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity: `O(n)`**  
   We traverse the string once to count frequencies (`O(n)`) and then scan 26 lowercase + 26 uppercase counts (`O(1)`).
- **Space Complexity: `O(1)`**  
   We use two fixed-size arrays of length `26`, so extra space is constant.
