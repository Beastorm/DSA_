## üìù Shortest Palindrome 

**Problem Statement:**  
Minimum Characters to Add at the Front to Make a String a Palindrome
Given a string `s`, find the **minimum number of characters** to be added at the **front** to make the string a **palindrome**.

**Point:** A palindrome is a string that reads the same forward and backward.

---

>### üí° Examples:

### Example 1:
**Input:** `s = "abc"`  
**Output:** `2`  
**Explanation:** Add `'b'` and `'c'` at the front to make it a palindrome: `"cbabc"`.

### Example 2:
**Input:** `s = "aacecaaaa"`  
**Output:** `2`  
**Explanation:** Add `2` `'a'` characters at the front to make it a palindrome: `"aaaacecaaaa"`.

### Constraints:
- `1 ‚â§ s.size() ‚â§ 10^6`
- `s` consists of lowercase English alphabets

---

## üê¢ Brute Force Approach

### Idea:
- We want to make the string a palindrome by adding characters **only in front**.
- If the **prefix** `s[0..i]` is already a palindrome, then the remaining part `s[i+1..n-1]` is the only part that ‚Äúbreaks‚Äù the palindrome.
- So we can fix it by adding **reverse(suffix)** in front, where:
  - `suffix = s[i+1..n-1]`
- To add the **fewest** characters, we should choose the **longest palindromic prefix** (largest `i`).

### Algorithm:
1. Let `n = s.length()`.
2. For `i` from `n-1` down to `0`:
   - Check if the prefix `s[0..i]` is a palindrome.
   - If yes, then the answer is `n - (i + 1)` (characters after `i` must be added in reverse).
3. If no prefix matches (won‚Äôt happen for non-empty strings because a single character is always a palindrome), return `n - 1`.

### C++ Code:
```cpp
#include <bits/stdc++.h>
using namespace std;

bool isPalindrome(const string &s, int l, int r) {
    while (l < r) {
        if (s[l] != s[r]) return false;
        l++;
        r--;
    }
    return true;
}

int minCharsToAddFrontBrute(const string &s) {
    int n = (int)s.size();
    if (n == 0) return 0;

    // Find the longest palindromic prefix
    for (int i = n - 1; i >= 0; i--) {
        if (isPalindrome(s, 0, i)) {
            return n - (i + 1);
        }
    }
}

int main() {
    string s = "abc";
    cout << minCharsToAddFrontBrute(s) << "\n"; // 2
    return 0;
}
```
### üìä Complexity Analysis:

- **Time Complexity: `O(n^2)`**  
  - We may check up to `n` prefixes, and each palindrome check can take `O(n)` time.

- **Space Complexity: `O(1)`**  
  - Only constant extra space is used.

---

## üß† Using KMP Algorithm

### Intuition:

- We can add characters **only at the front**, so we want to keep as much of the beginning as possible.
- Let `L` be the length of the **longest palindromic prefix** of `str`.
- Then only the remaining part needs fixing, so the minimum characters to add is:  
  `answer = n - L`.

**How the code finds `L` quickly:**
- Build: `combined = str + '$' + reverse(str)`
- Compute KMP **LPS** array for `combined`
- The last value `lps.back()` gives `L` (longest palindromic prefix length)
- Return `n - lps.back()`
---
### Algorithm Steps:

1. Create `rev` as the reverse of the string `s`.
2. Build a new string:  
   `temp = s + "$" + rev`  
   (`$` is a separator that does not appear in `s`.)
3. Compute the **LPS array** for `temp` (KMP preprocessing).
4. Let `L = lps[last]` (last value of LPS).  
   This gives the length of the **longest palindromic prefix** of `s`.
5. Minimum characters to add at the front = `s.length() - L`.
6. Return the result.


### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Return the minimum number of characters to add at the front to make the string a palindrome
    int minChar(string str) {
        // Make a reversed copy
        string rev = str;
        reverse(rev.begin(), rev.end());

        int originalSize = (int)str.size();

        // Build combined string: str + '$' + reverse(str)
        // '$' is a separator that never appears in lowercase strings
        str += '$';
        str += rev;

        // Build LPS array for combined string (KMP preprocessing)
        int n = (int)str.size();
        vector<int> lps(n, 0);

        int pre = 0;   // length of current matching prefix
        int suf = 1;   // current index we are computing lps for

        while (suf < n) {
            // Match
            if (str[pre] == str[suf]) {
                lps[suf] = pre + 1;
                pre++;
                suf++;
            }
            // Not matched
            else {
                if (pre == 0) {
                    lps[suf] = 0;
                    suf++;
                } else {
                    pre = lps[pre - 1]; // fallback
                }
            }
        }

        // lps[n-1] gives the length of the longest prefix of the original string
        // which is also a suffix of reverse string => longest palindromic prefix
        return originalSize - lps[n - 1];
    }
};

int main() {
    Solution sol;

    string s1 = "abc";
    cout << "Input: " << s1 << "\n";
    cout << "Min chars to add at front: " << sol.minChar(s1) << "\n\n"; // 2

    string s2 = "aacecaaaa";
    cout << "Input: " << s2 << "\n";
    cout << "Min chars to add at front: " << sol.minChar(s2) << "\n";   // 2

    return 0;
}
```
### üìä Complexity Analysis:

- **Time Complexity: `O(n)`**  
  - Reversing the string takes `O(n)`.  
  - Building the combined string takes `O(n)`.  
  - Computing the LPS array takes `O(n)`.  
  Overall, the time complexity is `O(n)`.

- **Space Complexity: `O(n)`**  
  - We store the reversed string and the combined string (`O(n)`), and the LPS array (`O(n)`).
