# ðŸ“ Circular Pattern Matching Problem

**Problem Statement**
Given two strings:
- `text`
- `pattern`

Assume `text` is **circular** (after the last character, it continues again from the first).  
Find all starting indices (0-based) where `pattern` matches in this circular text.

A match is allowed to **wrap around** the end of `text`.

---

## Key Idea
A circular match can be checked by doubling the text:

`doubleText = text + text`

Now, any wrap-around match in the circular string becomes a normal substring match inside `doubleText`.

We only consider starting indices `0` to `n-1` (original text length), because circular starts repeat after that.

### ðŸ’¡ Example
**Input:**  
`text = "abcde"`  
`pattern = "deab"`

**Explanation:**  
In circular form: `abcdeabcde...`  
Starting at index `3`: `"deab"` matches (`d e` then wraps to `a b`).

**Output:** `[3]`

> **Note: Relation to Rotation Check Problem**  
> Yes, circular pattern matching is basically the same idea as the **rotated string** check.  
>  
> Both use the trick:  
> - Build `text + text`  
> - Search the `pattern` inside it  
>  
> **Difference:**  
> - **Rotation problem:** usually requires `|s| == |goal|` and returns `true/false`.  
> - **Circular pattern matching:** the pattern can be shorter, and we often return **all starting indices** (typically only in the range `0` to `|text|-1`) where the pattern matches, including wrap-around matches.

---

## ðŸ§  KMP Approach
1. If `pattern.length() > text.length()`, no match is possible â†’ return `[]`.
2. Create `doubleText = text + text`.
3. Search for `pattern` in `doubleText` using any string matching algorithm (KMP / Z / naive).
4. Collect matches whose start index `< n`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// KMP helper: build LPS array for pattern
static vector<int> buildLPS(const string& pat) {
    int m = (int)pat.size();
    vector<int> lps(m, 0);

    int len = 0; // length of current longest prefix-suffix
    for (int i = 1; i < m; ) {
        if (pat[i] == pat[len]) {
            lps[i] = ++len;
            i++;
        } else {
            if (len != 0) len = lps[len - 1];
            else lps[i++] = 0;
        }
    }
    return lps;
}

// Circular pattern matching: return all 0-based start indices in [0..n-1]
vector<int> circularMatches(const string& text, const string& pattern) {
    int n = (int)text.size();
    int m = (int)pattern.size();
    vector<int> ans;

    if (m == 0) return ans;      // define empty pattern -> no indices (can adjust)
    if (n == 0) return ans;
    if (m > n) return ans;       // cannot fit within one full cycle

    string doubled = text + text; // makes wrap-around matches contiguous
    vector<int> lps = buildLPS(pattern);

    int i = 0; // index in doubled
    int j = 0; // index in pattern

    while (i < (int)doubled.size()) {
        if (doubled[i] == pattern[j]) {
            i++;
            j++;
            if (j == m) {
                int start = i - m; // match start in doubled

                // accept only starts within original text range
                if (start < n) ans.push_back(start);

                j = lps[j - 1]; // continue searching
            }
        } else {
            if (j == 0) i++;
            else j = lps[j - 1];
        }
    }

    return ans;
}

int main() {
    string text = "xyzabxyzabxyz";
    string pattern = "xyz";

    vector<int> idx = circularMatches(text, pattern);

    cout << "Matches at indices: [";
    for (int i = 0; i < (int)idx.size(); i++) {
        cout << idx[i] << (i + 1 == (int)idx.size() ? "" : ", ");
    }
    cout << "]\n";

    return 0;
}
```
### ðŸ“Š Complexity Analysis

Let:
- `n = text.length()`
- `m = pattern.length()`

**Time Complexity: `O(n + m)`**  
- Building the LPS array takes `O(m)`.  
- KMP search runs on `text + text` (length `2n`), which is `O(2n) = O(n)`.  
So total time is `O(n + m)`.

**Space Complexity: `O(n + m)`**  
- We store `text + text` which takes `O(n)`.  
- The LPS array takes `O(m)`.  
So total space is `O(n + m)` (excluding the output indices).
