# ğŸ“ String Matching

**Problem Statement:**  
String matching means finding whether a **pattern (pat)** appears inside a **text (txt)** as a **continuous substring**.
Usually, we return the **0-based index of the first occurrence** of the pattern in the text, or `-1` if it does not exist.

ğŸ’¡ **Example:**  
Text = `"hello"`, Pattern = `"ll"` â†’ output = `2` (because `"ll"` starts at index `2`).

## ğŸ¢ Bruteforce
### Algorithm Steps

1. Let `n = txt.length()` and `m = pat.length()`.
2. If `pat` is empty, return `0`.
3. For each index `i` from `0` to `n - m`:
   - Set `first = i` (pointer in `txt`) and `second = 0` (pointer in `pat`).
   - While `second < m`:
     - If `txt[first] != pat[second]`, stop (mismatch).
     - Otherwise, increment both pointers.
   - If `second == m`, it means the whole `pat` matched â†’ return `i`.
4. If no match is found after the loop, return `-1`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

/*
Brute Force implementation of substring search (like strStr):
Return the first index where `pat` occurs in `txt`,
or -1 if it does not occur.
*/

class Solution {
public:
    int strStr(string txt, string pat) {
        int n = (int)txt.size();
        int m = (int)pat.size();

        // Edge case: empty pat is found at index 0
        if (m == 0) return 0;

        // If the pattern is longer than the text, it can't match
        if (m > n) return -1;

        // Try matching pat starting at every possible position
        for (int i = 0; i <= n - m; i++) {
            int first = i;   // pointer in txt
            int second = 0;  // pointer in pat

            // Compare characters one by one
            while (second < m) {
                if (txt[first] != pat[second]) {
                    break; // mismatch
                }
                first++;
                second++;
            }

            // If we matched all characters of pat
            if (second == m) {
                return first - second; // starting index of match
            }
        }

        return -1; // no match found
    }
};

int main() {
    Solution sol;

    string txt = "hello";
    string pat = "ll";

    int idx = sol.strStr(txt, pat);

    cout << "txt: " << txt << "\n";
    cout << "pat: " << pat << "\n";
    cout << "first occurrence index: " << idx << "\n"; // expected: 2

    return 0;
}
```
### ğŸ“Š Complexity Analysis

**Time Complexity: `O(n * m)`**  
- Outer loop tries all start positions: `n - m + 1` â‰ˆ `O(n)`
- Inner loop can compare up to `m` characters each time: `O(m)`
  So total time = `O(n) * O(m) = O(n * m)`

**Space Complexity: `O(1)`**  
Only constant extra space is used.

---

## ğŸ§  KMP String Matching Algorithm

### Algorithm 

1. If `pat` is empty, return `0`.
2. Build the **LPS array** for `pat`:
   - `lps[i]` = length of the longest proper prefix of `pat[0..i]` that is also a suffix.
3. Use two pointers:
   - `first` for `txt`
   - `second` for `pat`
4. While `first < txt.length()`:
   - If `txt[first] == pat[second]`:
     - increment both pointers
     - if `second == pat.length()`, a full match is found â†’ return `first - second`
   - Else (mismatch):
     - if `second == 0`, move `first++`
     - otherwise set `second = lps[second - 1]` (jump using LPS)
5. If the loop ends without a full match, return `-1`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// KMP-based string matching (strStr): find first occurrence of pat in txt
class Solution {
private:
    // Build LPS (Longest Prefix Suffix) array for pattern
    vector<int> buildLPS(const string& pat) {
        int m = (int)pat.size();
        vector<int> lps(m, 0);

        int pre = 0;   // length of the current longest prefix-suffix
        int suf = 1;   // current index being processed

        while (suf < m) {
            if (pat[pre] == pat[suf]) {
                lps[suf] = pre + 1;
                pre++;
                suf++;
            } else {
                if (pre == 0) {
                    lps[suf] = 0;
                    suf++;
                } else {
                    pre = lps[pre - 1]; // fallback
                }
            }
        }
        return lps;
    }

public:
    int strStr(string txt, string pat) {
        int n = (int)txt.size();
        int m = (int)pat.size();

        // Edge case: empty pattern
        if (m == 0) return 0;
        if (m > n) return -1;

        vector<int> lps = buildLPS(pat);

        int first = 0;   // pointer for txt
        int second = 0;  // pointer for pat

        while (first < n) {
            if (txt[first] == pat[second]) {
                first++;
                second++;

                // Full pattern matched
                if (second == m) {
                    return first - second; // starting index
                }
            } else {
                if (second == 0) {
                    first++; // move in txt if no partial match
                } else {
                    second = lps[second - 1]; // jump using lps
                }
            }
        }

        return -1;
    }
};

int main() {
    Solution sol;

    string txt = "ababcabcabababd";
    string pat = "ababd";

    int idx = sol.strStr(txt, pat);

    cout << "txt: " << txt << "\n";
    cout << "pat: " << pat << "\n";
    cout << "first occurrence index: " << idx << "\n"; // expected: 10

    return 0;
}
```
### ğŸ“Š Complexity Analysis (KMP)

**Time Complexity: `O(n + m)`**  
- Building the LPS array takes `O(m)` where `m` is the length of `pat`.  
- Searching through `txt` takes `O(n)` where `n` is the length of `txt`, because pointers only move forward with efficient jumps using LPS.

**Space Complexity: `O(m)`**  
We store the LPS array of size `m`.
