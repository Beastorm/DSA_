## ðŸ“ Repeated String Match

**Problem Statement:**  
Given two strings `a` and `b`, return the **minimum number of times** you should repeat string `a` so that string `b` becomes a **substring** of the repeated string.

If it is impossible for `b` to be a substring of repeated `a`, return `-1`.

> **Note:**  
> `"abc"` repeated `0` times is `""`, repeated `1` time is `"abc"`, and repeated `2` times is `"abcabc"`.

---

>### ðŸ’¡ Examples:

### Example 1:
**Input:** `a = "abcd"`, `b = "cdabcdab"`  
**Output:** `3`  

**Explanation:**  
Repeat `a` three times: `"abcdabcdabcd"`.  
Now `b = "cdabcdab"` is a substring of it.

### Example 2:
**Input:** `a = "a"`, `b = "aa"`  
**Output:** `2`

### Constraints
- `1 <= a.length, b.length <= 10^4`
- `a` and `b` consist of lowercase English letters
  
---

## ðŸ§  KMP Approach

### Algorithm Steps (Repeated String Match using KMP):

1. If `a == b`, return `1`.
2. Initialize:
   - `temp = a`
   - `repeat = 1`
3. Repeat `a` until `temp.length() >= b.length()`:
   - `temp += a`
   - `repeat++`
4. Check if `b` is a substring of `temp` using KMP:
   - If yes, return `repeat`.
5. If not found, check in `temp + a` (one extra repeat to handle overlap cases):
   - If yes, return `repeat + 1`.
6. If still not found, return `-1`.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Build LPS array for KMP
    vector<int> buildLPS(const string& pat) {
        int m = (int)pat.size();
        vector<int> lps(m, 0);

        int pre = 0;   // length of current longest prefix-suffix
        int suf = 1;   // current index

        while (suf < m) {
            if (pat[pre] == pat[suf]) {
                lps[suf] = pre + 1;
                pre++;
                suf++;
            } else {
                if (pre == 0) {
                    lps[suf] = 0;
                    suf++;
                } else {
                    pre = lps[pre - 1];
                }
            }
        }
        return lps;
    }

    // KMP match: returns true if pat is a substring of txt
    bool KMP_MATCH(const string& txt, const string& pat) {
        int n = (int)txt.size();
        int m = (int)pat.size();
        if (m == 0) return true;
        if (m > n) return false;

        vector<int> lps = buildLPS(pat);

        int first = 0; // txt pointer
        int second = 0; // pat pointer

        while (first < n) {
            if (txt[first] == pat[second]) {
                first++;
                second++;
                if (second == m) return true; // found match
            } else {
                if (second == 0) first++;
                else second = lps[second - 1];
            }
        }
        return false;
    }

public:
    int repeatedStringMatch(string a, string b) {
        // If a equals b, only 1 repeat needed
        if (a == b) return 1;

        int repeat = 1;
        string temp = a;

        // Keep repeating until temp length >= b length
        while ((int)temp.size() < (int)b.size()) {
            temp += a;
            repeat++;
        }

        // Check if b is a substring of temp
        if (KMP_MATCH(temp, b)) return repeat;

        // Sometimes need one extra repeat to cover the overlap case
        if (KMP_MATCH(temp + a, b)) return repeat + 1;

        return -1;
    }
};

int main() {
    Solution sol;

    // Example 1
    string a1 = "abcd", b1 = "cdabcdab";
    cout << "a = " << a1 << ", b = " << b1 << "\n";
    cout << "Minimum repeats: " << sol.repeatedStringMatch(a1, b1) << "\n\n"; // 3

    // Example 2
    string a2 = "a", b2 = "aa";
    cout << "a = " << a2 << ", b = " << b2 << "\n";
    cout << "Minimum repeats: " << sol.repeatedStringMatch(a2, b2) << "\n";   // 2

    return 0;
}
```
### ðŸ“Š Complexity Analysis:

Let:
- `n = a.length()`
- `m = b.length()`

- **Time Complexity: `O(m + n * r)`** (commonly written as `O(n * r + m)`)  
  - Building the LPS array for `b` takes `O(m)`.  
  - Let `r = ceil(m / n)`. We build `temp` with about `r` repeats, so `temp` length is `O(n * r)` (â‰ˆ `O(m)`).  
  - KMP search runs in linear time in the text length, so checking `temp` and `temp + a` costs `O(n * r)` each (overall still linear).

    Overall, the time is **linear in the size of the built repeated string**, i.e., approximately `O(m + n)` in practice.

- **Space Complexity: `O(m + n * r)`**  
  - `O(m)` for the LPS array.  
  - `O(n * r)` to store `temp` (and `temp + a` during the extra check).
