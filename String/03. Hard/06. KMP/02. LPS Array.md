## üìù LPS Array (Longest Prefix Suffix Array)

### What is the LPS array?
For a pattern string `pat`, the **LPS array** (`lps[i]`) stores:

> the length of the **longest proper prefix** of `pat[0..i]` that is also a **suffix** of `pat[0..i]`.

- **Prefix:** starts at index `0`
- **Suffix:** ends at index `i`
- **Proper:** not equal to the whole substring

### Why is it useful?
The LPS array is used in **KMP (Knuth‚ÄìMorris‚ÄìPratt)** string matching to avoid re-checking characters after a mismatch, making the algorithm efficient.

---

>### üí° Example:
`pat = "ababaca"`

`lps = [0, 0, 1, 2, 3, 0, 1]`.

**Meaning:**  
- `lps[0] = 0` ‚Üí `"a"` has no proper prefix=suffix
- `lps[3] = 2` ‚Üí `"abab"` has `"ab"` as both prefix and suffix
- `lps[4] = 3` ‚Üí `"ababa"` has `"aba"` as both prefix and suffix


---

## Approach

### Intuition:
The core logic revolves around avoiding unnecessary work. If we are matching a long prefix and suddenly find a mismatch, we usually don't need to start over completely from the beginning.

*   **Two Pointers:** We use `pre` (tracking the prefix) and `suf` (scanning the string). We are essentially comparing the string against itself.
*   **The Fallback Trick:** If `s[pre]` and `s[suf]` do **not** match, but `pre` is already greater than 0, it means we have matched a prefix *up until now*. Instead of resetting `pre` to 0, we check `lpsArr[pre - 1]`.
    *   This effectively asks: *"Okay, this long prefix didn't fit, but is there a shorter prefix inside the part we just matched that might fit?"*
    *   This keeps the time complexity linear $O(N)$.

### Algorithm Steps:
1.  **Initialize:**
    *   Create an array `lpsArr` initialized to 0.
    *   Set `pre = 0` (Start of the string/prefix).
    *   Set `suf = 1` (We start comparing the second character against the first).

2.  **Loop while `suf < n`:**

    *   **Case 1: Characters Match (`s[pre] == s[suf]`)**
        *   We can extend the current prefix length.
        *   Store the new length: `lpsArr[suf] = pre + 1`.
        *   Move both pointers forward (`pre++`, `suf++`).

    *   **Case 2: Mismatch (`s[pre] != s[suf]`)**
        *   **If `pre > 0`:** We have a partial match history. Do **not** move `suf`. Update `pre` to `lpsArr[pre - 1]` to try a shorter prefix.
        *   **If `pre == 0`:** No prefix matches here. Set `lpsArr[suf] = 0` and move `suf` forward.

3.  **Return:**
    *   The value at `lpsArr[n-1]` represents the LPS length for the entire string.
    

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Returns the length of the Longest Proper Prefix which is also a Suffix (LPS) for the whole string
    int lps(string s) {
        int n = (int)s.size();
        if (n == 0) return 0;

        vector<int> lpsArr(n, 0);

        int pre = 0;  // length/index of current matched prefix
        int suf = 1;  // current index to compute lpsArr[suf]

        while (suf < n) {
            // Match case: extend the current prefix-suffix match
            if (s[pre] == s[suf]) {
                lpsArr[suf] = pre + 1;
                pre++;
                suf++;
            }
            // Not match case
            else {
                // If no prefix to fall back to
                if (pre == 0) {
                    lpsArr[suf] = 0;
                    suf++;
                } 
                // Fall back to the previous best prefix length
                else {
                    pre = lpsArr[pre - 1];
                }
            }
        }

        // lpsArr[n-1] is the answer for the entire string
        return lpsArr[n - 1];
    }
};

int main() {
    Solution sol;

    string s = "ababa";
    cout << "String: " << s << "\n";
    cout << "LPS length (for whole string): " << sol.lps(s) << "\n"; // expected 3

    return 0;
}
```
## Complexity Analysis:

Let `n = s.length`.

Important: Unlike many sorting algorithms, the LPS computation is **always linear**.
Best / average / worst cases all have **O(n)** time, but the *number of fallbacks* differs.

---

### Why always O(n)?
- `suf` starts at `1` and only increases up to `n-1` ‚Üí at most `n-1` increments.
- When mismatch happens and `pre > 0`, we do `pre = lpsArr[pre-1]`:
  - `pre` strictly decreases.
- `pre` can increase at most `n-1` times (only on matches).
- So total decreases (fallbacks) across the whole run are also bounded by `O(n)`.

Therefore, total operations are linear: **O(n)**.

---

### Best Case Example:
**Example:** `s = "aaaaaa"`

What happens:
- Almost every comparison matches (`s[pre] == s[suf]`).
- `pre++` and `suf++` each step, with **no fallbacks**.

Work:
- `suf` moves from `1` to `n-1` once.

**Time:** `O(n)`  
**Behavior:** minimal branching, mostly straight matches.

---

### Average Case Example:
**Example:** `s = "abacabad"` (mixed repetitions)

What happens:
- Some matches and some mismatches.
- Occasional fallbacks, but not too many.

Still:
- `suf` moves forward `O(n)` times.
- Total fallbacks remain `O(n)`.

**Time:** `O(n)`  
**Behavior:** mix of match + mismatch, but still linear overall.

---

### Worst Case Example (many fallbacks):
**Example:** `s = "aaaaabaaaaa"` or classic: `s = "ababababx"`

What happens:
- Long partial matches build up `pre`.
- Then a mismatch causes multiple fallbacks (`pre` jumps back using `lpsArr`).
- This ‚Äúfallback chain‚Äù can happen multiple times.

Even then:
- Every fallback reduces `pre`, and total fallback reductions across the whole algorithm are bounded by how much `pre` can increase (‚â§ `n`).

**Time:** `O(n)`  
**Behavior:** maximum number of fallback operations, but still linear.

---

### Space Complexity: O(n) in all cases:
- `lpsArr` of size `n` ‚Üí `O(n)`
- extra variables ‚Üí `O(1)`

**Space:** `O(n)`

---

### Summary Table

| Case    | Example String     | Time | Why |
|---------|---------------------|------|-----|
| Best    | `"aaaaaa"`          | O(n) | mostly matches, no fallbacks |
| Average | `"abacabad"`        | O(n) | some matches, some fallbacks |
| Worst   | `"ababababx"`       | O(n) | many fallbacks, but bounded overall |
