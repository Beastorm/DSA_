# üìù LPS Array (Longest Prefix Suffix Array)

### What is the LPS array?
For a pattern string `pat`, the **LPS array** (`lps[i]`) stores:

> the length of the **longest proper prefix** of `pat[0..i]` that is also a **suffix** of `pat[0..i]`.

- **Prefix:** starts at index `0`
- **Suffix:** ends at index `i`
- **Proper:** not equal to the whole substring

### Why is it useful?
The LPS array is used in **KMP (Knuth‚ÄìMorris‚ÄìPratt)** string matching to avoid re-checking characters after a mismatch, making the algorithm efficient.

### üí° Example
`pat = "ababaca"`

`lps = [0, 0, 1, 2, 3, 0, 1]`

Meaning:
- `lps[0] = 0` ‚Üí `"a"` has no proper prefix=suffix
- `lps[3] = 2` ‚Üí `"abab"` has `"ab"` as both prefix and suffix
- `lps[4] = 3` ‚Üí `"ababa"` has `"aba"` as both prefix and suffix

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Returns the length of the Longest Proper Prefix which is also a Suffix (LPS) for the whole string
    int lps(string s) {
        int n = (int)s.size();
        if (n == 0) return 0;

        vector<int> lpsArr(n, 0);

        int pre = 0;  // length/index of current matched prefix
        int suf = 1;  // current index to compute lpsArr[suf]

        while (suf < n) {
            // Match case: extend the current prefix-suffix match
            if (s[pre] == s[suf]) {
                lpsArr[suf] = pre + 1;
                pre++;
                suf++;
            }
            // Not match case
            else {
                // If no prefix to fall back to
                if (pre == 0) {
                    lpsArr[suf] = 0;
                    suf++;
                } 
                // Fall back to the previous best prefix length
                else {
                    pre = lpsArr[pre - 1];
                }
            }
        }

        // lpsArr[n-1] is the answer for the entire string
        return lpsArr[n - 1];
    }
};

int main() {
    Solution sol;

    string s = "ababa";
    cout << "String: " << s << "\n";
    cout << "LPS length (for whole string): " << sol.lps(s) << "\n"; // expected 3

    return 0;
}
```
## Complexity Analysis (with examples for best/average/worst) ‚Äî KMP LPS

Let `n = s.length`.

Important: Unlike many sorting algorithms, the LPS computation is **always linear**.
Best / average / worst cases all have **O(n)** time, but the *number of fallbacks* differs.

---

### Why always O(n) (quick derivation)
- `suf` starts at `1` and only increases up to `n-1` ‚Üí at most `n-1` increments.
- When mismatch happens and `pre > 0`, we do `pre = lpsArr[pre-1]`:
  - `pre` strictly decreases.
- `pre` can increase at most `n-1` times (only on matches).
- So total decreases (fallbacks) across the whole run are also bounded by `O(n)`.

Therefore, total operations are linear: **O(n)**.

---

### Best Case Example
**Example:** `s = "aaaaaa"`

What happens:
- Almost every comparison matches (`s[pre] == s[suf]`).
- `pre++` and `suf++` each step, with **no fallbacks**.

Work:
- `suf` moves from `1` to `n-1` once.

**Time:** `O(n)`  
**Behavior:** minimal branching, mostly straight matches.

---

### Average Case Example
**Example:** `s = "abacabad"` (mixed repetitions)

What happens:
- Some matches and some mismatches.
- Occasional fallbacks, but not too many.

Still:
- `suf` moves forward `O(n)` times.
- Total fallbacks remain `O(n)`.

**Time:** `O(n)`  
**Behavior:** mix of match + mismatch, but still linear overall.

---

### Worst Case Example (many fallbacks)
**Example:** `s = "aaaaabaaaaa"` or classic: `s = "ababababx"`

What happens:
- Long partial matches build up `pre`.
- Then a mismatch causes multiple fallbacks (`pre` jumps back using `lpsArr`).
- This ‚Äúfallback chain‚Äù can happen multiple times.

Even then:
- Every fallback reduces `pre`, and total fallback reductions across the whole algorithm are bounded by how much `pre` can increase (‚â§ `n`).

**Time:** `O(n)`  
**Behavior:** maximum number of fallback operations, but still linear.

---

### Space Complexity: O(n) in all cases
- `lpsArr` of size `n` ‚Üí `O(n)`
- extra variables ‚Üí `O(1)`

**Space:** `O(n)`

---

### Summary Table

| Case    | Example String     | Time | Why |
|---------|---------------------|------|-----|
| Best    | `"aaaaaa"`          | O(n) | mostly matches, no fallbacks |
| Average | `"abacabad"`        | O(n) | some matches, some fallbacks |
| Worst   | `"ababababx"`       | O(n) | many fallbacks, but bounded overall |
