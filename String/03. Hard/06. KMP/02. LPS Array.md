# ðŸ“ LPS Array (Longest Prefix Suffix Array)

### What is the LPS array?
For a pattern string `pat`, the **LPS array** (`lps[i]`) stores:

> the length of the **longest proper prefix** of `pat[0..i]` that is also a **suffix** of `pat[0..i]`.

- **Prefix:** starts at index `0`
- **Suffix:** ends at index `i`
- **Proper:** not equal to the whole substring

### Why is it useful?
The LPS array is used in **KMP (Knuthâ€“Morrisâ€“Pratt)** string matching to avoid re-checking characters after a mismatch, making the algorithm efficient.

### ðŸ’¡ Example
`pat = "ababaca"`

`lps = [0, 0, 1, 2, 3, 0, 1]`

Meaning:
- `lps[0] = 0` â†’ `"a"` has no proper prefix=suffix
- `lps[3] = 2` â†’ `"abab"` has `"ab"` as both prefix and suffix
- `lps[4] = 3` â†’ `"ababa"` has `"aba"` as both prefix and suffix

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Returns the length of the Longest Proper Prefix which is also a Suffix (LPS) for the whole string
    int lps(string s) {
        int n = (int)s.size();
        if (n == 0) return 0;

        vector<int> lpsArr(n, 0);

        int pre = 0;  // length/index of current matched prefix
        int suf = 1;  // current index to compute lpsArr[suf]

        while (suf < n) {
            // Match case: extend the current prefix-suffix match
            if (s[pre] == s[suf]) {
                lpsArr[suf] = pre + 1;
                pre++;
                suf++;
            }
            // Not match case
            else {
                // If no prefix to fall back to
                if (pre == 0) {
                    lpsArr[suf] = 0;
                    suf++;
                } 
                // Fall back to the previous best prefix length
                else {
                    pre = lpsArr[pre - 1];
                }
            }
        }

        // lpsArr[n-1] is the answer for the entire string
        return lpsArr[n - 1];
    }
};

int main() {
    Solution sol;

    string s = "ababa";
    cout << "String: " << s << "\n";
    cout << "LPS length (for whole string): " << sol.lps(s) << "\n"; // expected 3

    return 0;
}
```
### Complexity Analysis (KMP LPS computation)

Let `n = s.length`.

 **Time Complexity: `O(n)`:**
- The loop runs while `suf < n`.
- `suf` only moves forward (`suf++`) and never goes back.
- `pre` can move back when there is a mismatch (`pre = lpsArr[pre-1]`), but each fallback strictly decreases `pre`.
- Across the whole algorithm, the total number of increments of `suf` is `n-1`, and the total number of fallbacks of `pre` is also bounded by `O(n)`.

So total character comparisons/updates are linear.

**Time = `O(n)`**

**Space Complexity: `O(n)`:**
- `lpsArr` is of size `n`.
- Other variables use constant space.

**Space = `O(n)`**
