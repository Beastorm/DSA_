## üìù Longest Happy Prefix

**Problem Statement:**  
Given a string `s`, return the **longest happy prefix** of `s`.

A **happy prefix** is a string that is both:
- a **proper prefix**, and
- a **proper suffix**

If no such prefix exists, return an empty string `""`.

> **Note:** A proper prefix/proper suffix is a prefix/suffix that is **not equal to the entire string**.


---

>### üí° Examples:

### Example 1:
**Input:** `s = "ababab"`  
**Output:** `"abab"`  

**Explanation:**  
`"abab"` is the longest prefix that is also a suffix. They can overlap in the original string.

### Example 2:
**Input:** `s = "aaaa"`  
**Output:** `"aaa"`  

**Explanation:**  
`"aaa"` is the longest proper prefix which is also a proper suffix in `"aaaa"`.

---

### üê¢ Brute Force Approach

### Algorithm:
The goal is to find the longest substring that exists at both the start and end of the string, but it must not be the entire string itself.  
In brute force, we try all possible lengths of such substrings, starting from the longest and moving to shorter ones.  
At each step, we compare the prefix from the beginning with the suffix from the end. As soon as we find a match, we return it (since we search from longest to shortest). This approach is simple but not optimal for very large strings.

### Steps:
- Check every possible substring starting from the beginning of the string.
- For each such substring, check if the same substring also appears at the end of the string.
- Start checking from the longest possible substring and move to shorter ones.
- Return the first substring that appears at both the start and end.
- If no such substring exists, return an empty result.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the longest happy prefix
    string longestPrefix(string s) {
        int n = s.size();

        // Loop through all possible prefix-suffix lengths
        for (int len = n - 1; len > 0; len--) {
            // Compare prefix and suffix of current length
            if (s.substr(0, len) == s.substr(n - len, len)) {
                return s.substr(0, len);
            }
        }

        // Return empty string if no happy prefix found
        return "";
    }
};

int main() {
    Solution sol;
    string s = "levellevel";
    cout << sol.longestPrefix(s) << endl;
    return 0;
}

```
### üìä Complexity Analysis:

- **Time Complexity: `O(n^2)`**  
    For each of the `n` possible lengths, we may compare up to `n` characters.

- **Space Complexity: `O(n)`**  
    Extra space can be used for storing substrings during comparison.

---

### üß† Approach (Using KMP / LPS):
### Intuition:
A ‚Äúhappy prefix‚Äù is a prefix that is also a suffix (but not the whole string).
We want the **longest** such prefix.

KMP‚Äôs **LPS array** tells for every position `i` the length of the longest prefix that matches a suffix ending at `i`.
So the last value `lps[n-1]` directly gives the length of the longest happy prefix for the whole string.

### Algorithm Steps:
1. Build the `lps` array using KMP:
   - Use two pointers: `pre` (matched prefix length) and `suf` (current index).
   - If `s[pre] == s[suf]`, increase both and set `lps[suf]`.
   - If mismatch:
     - if `pre > 0`, move `pre` to `lps[pre-1]` (fallback)
     - else set `lps[suf] = 0` and move `suf`.
2. Let `L = lps[n-1]`.
3. Return `s.substr(0, L)`.


``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Build LPS array (KMP preprocessing)
    static vector<int> buildLPS(const string& s) {
        int n = (int)s.size();
        vector<int> lpsArr(n, 0);

        int pre = 0;  // length of current matched prefix
        int suf = 1;  // current index

        while (suf < n) {
            if (s[pre] == s[suf]) {
                lpsArr[suf] = pre + 1;
                pre++;
                suf++;
            } else {
                if (pre == 0) {
                    lpsArr[suf] = 0;
                    suf++;
                } else {
                    pre = lpsArr[pre - 1];
                }
            }
        }
        return lpsArr;
    }

    // Longest Happy Prefix = longest proper prefix which is also suffix
    string longestPrefix(string s) {
        int n = (int)s.size();
        if (n == 0) return "";

        vector<int> lpsArr = buildLPS(s);
        int L = lpsArr[n - 1];
        return s.substr(0, L);
    }
};

int main() {
    Solution sol;

    string s = "levellevel";
    cout << sol.longestPrefix(s) << "\n";   // expected: "level"

    return 0;
}
```
### Complexity Analysis:

Let `n = s.length`.

- **Time Complexity: `O(n)`**  
    - The `suf` pointer moves from `1` to `n-1` (only forward).
    - The `pre` pointer may move back using `lps[pre-1]`, but across the whole run, total fallback moves are bounded by `O(n)`.
    - So total character comparisons/updates are linear.
    
    **Time = `O(n)`**

- **Space Complexity: `O(n)`**  
    - We store the `lps` array of size `n`.
    
    **Space = `O(n)`**
