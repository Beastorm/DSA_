## üìù Minimum Number of Bracket Reversals Needed to Make an Expression Balanced

**Problem Statement:**  
Given a string `s` consisting of only opening and closing brackets `'('` and `')'`, find the *minimum number of reversals* required to convert the string into a *balanced expression*.

If it is not possible to make the brackets balanced, return `-1`.  
A reversal means changing `'('` to `')'` or vice-versa.


>### üí° Examples:

**Input:** `s = ")(())((("`  
**Output:** `3`  
**Explanation:** One way to balance is: `"((())())"`. There is no balanced sequence that can be formed in fewer reversals.

**Input:** `s = "(()((()(())(("`  
**Output:** `-1`  
**Explanation:** There's no way we can balance this sequence of braces.

---

## üß† Approach

### Algorithm:
- To be balanced, every opening bracket must be matched with a closing bracket.
- If the string has an *odd length*, it‚Äôs impossible to balance (pairs require an even count) ‚Üí return `-1`.
- Traverse the string:
  - Increase an `opening` counter for `'('`.
  - For `')'`:
    - If there is an unmatched `'('` available, cancel it (`opening--`).
    - Otherwise, this is an unmatched closing bracket ‚Üí increase a `closing` counter.
- After traversal:
  - `opening` = unmatched opening brackets
  - `closing` = unmatched closing brackets
- Minimum reversals required:

  `(opening + 1) / 2 + (closing + 1) / 2`
  

### Important Clarification:


I cannot guarantee every string with counts `open = 3`, `close = 1` is literally `")((("` (for example, `"((()"` isn‚Äôt).

What I can guarantee is:

- After removing all matched pairs, the *unmatched part* can be treated as:
  - `close` times `')'` followed by `open` times `'('`
- The formula `(open + 1) / 2 + (close + 1) / 2` is derived for that *reduced unmatched part*.

That‚Äôs why earlier the case `open = 3`, `close = 1` corresponds to the reduced form `")((("`, even though `"((()"` itself needs only `1` reversal.  

*Question: Why can't we pair with left over opening with the leftover closing?*
No, because an unmatched opening and an unmatched closing (after the cancellation step) are in the wrong order, so they can‚Äôt pair as `()`.

After cancellation, the leftover always looks like:

`))))...((((...`

So an unmatched closing comes before an unmatched opening, like:

`) (`

That sequence is not balanced and cannot be fixed without reversals.

*Example: 1 close and 1 open*  
Leftover: `")("`

- This is not balanced.
- It needs `1` reversal:
  - Flipping the first `)` to `(` gives `"(("` (still not balanced)
  - Better: flip the second `(` to `)` ‚Üí `"()"` (balanced)

So even though counts match (`1` open, `1` close), *order* makes it invalid, so you still need reversals.

That‚Äôs why we can‚Äôt just ‚Äúpair 1 opening with 1 closing‚Äù unless they appear as `"()"` in the correct order.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate the minimum number of reversals to balance the expression
    int minReversalsToBalance(string expression) {
        // Count of unmatched '(' brackets
        int openBrackets = 0;
        
        // Count of unmatched ')' brackets
        int closeBrackets = 0;

        // Traverse the string
        for (char ch : expression) {
            if (ch == '(') {
                // Consider '(' as unmatched for now
                openBrackets++;
            } else {
                if (openBrackets > 0) {
                    // Match this ')' with a previous '('
                    openBrackets--;
                } else {
                    // No matching '(' exists, so this ')' is unmatched
                    closeBrackets++;
                }
            }
        }

        // If the total number of unmatched brackets is odd, return -1
        if ((openBrackets + closeBrackets) % 2 != 0) return -1;

        // Return minimum reversals required
        return (openBrackets + 1) / 2 + (closeBrackets + 1) / 2;
    }
};

int main() {
    // Input expression
    string expression = "(()))(";

    // Create object of Solution
    Solution solver;

    // Get result from function
    int result = solver.minReversalsToBalance(expression);

    // Print the result
    cout << "Minimum reversals required: " << result << endl;

    return 0;
}

```

### üìä Complexity Analysis:

- **Time Complexity: `O(N)`**  
  We traverse the string once, processing each bracket in constant time.

- **Space Complexity: `O(1)`**  
  Only constant extra space is used.
