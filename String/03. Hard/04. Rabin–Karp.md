## 沒 String Matching  

**Problem Statement:** [ref](https://www.youtube.com/watch?v=qQ8vS2btsxI&list=PLgUcNmqSvVXDbO-2shqCF1JmsNgpvTi6C&index=1)   
Given a text string `txt` and a pattern string `pat`, find all starting indices in `txt` where `pat` occurs as a substring.


## 汾｢ Brute Force (Naive Matching)

### Idea:
Try matching the pattern starting at every position in the text.

### Algorithm:
- For each start index `i` in `txt` from `0` to `n - m`:
  - Compare `txt[i + j]` with `pat[j]` for all `j` from `0` to `m - 1`.
  - If all match, record `i`

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> naiveSearch(const string& txt, const string& pat) {
    int n = (int)txt.size();
    int m = (int)pat.size();
    vector<int> ans;

    if (m == 0 || m > n) return ans;

    for (int i = 0; i <= n - m; i++) {
        int j = 0;
        while (j < m && txt[i + j] == pat[j]) j++;
        if (j == m) ans.push_back(i);
    }
    return ans;
}

int main() {
    string txt = "ababcabcabababd";
    string pat = "ababd";
    auto idx = naiveSearch(txt, pat);
    for (int i : idx) cout << i << " ";
    cout << "\n";
}
```
### 沒 Complexity Analysis:

- **Time:** `O(n * m)` (worst case)
- **Space:** `O(1)` extra


---

## 洫 Rabin窶適arp String Matching Algorithm

### 汳｡ Core Idea:
Rabin窶適arp uses **hashing** to compare the pattern with substrings of the text efficiently.

- Compute the hash of `pat`.
- Compute the hash of the first window of `txt` having length `m = pat.length()`.
- Slide the window one character at a time and update the hash in **O(1)** using a **rolling hash**
- If the hash matches, verify by direct comparison to avoid collision errors


### Rolling Hash (Typical Form):
Treat strings as numbers in base `d` (alphabet size) under modulus `q`:

- `d` = 256 (ASCII)
- `q` = large prime (e.g., `1e9+7`, `101`, etc.)

Hash of length `m` string:
`H = (s[0]*d^(m-1) + s[1]*d^(m-2) + ... + s[m-1]) % q`

Rolling update when window moves from `[i..i+m-1]` to `[i+1..i+m]`:
`Hnext = (d*(H - txt[i]*d^(m-1)) + txt[i+m]) % q`


### Algorithm Steps:
1. Let `n = txt.length()`, `m = pat.length()`.
2. If `m > n`, return no matches.
3. Precompute `h = d^(m-1) % q`.
4. Compute initial hash of:
   - `pat` (call it `pHash`)
   - first window of `txt` of length `m` (call it `tHash`)
5. For each window, start `i` from `0` to `n-m`:
   - If `pHash == tHash`:
     - Verify characters one-by-one (to handle collisions)
     - If equal, store index `i`
   - If `i < n-m`, compute rolling hash for next window.

> **Note:** **Rabin窶適arp Fingerprint Function (Rolling Hash)**  
> A common Rabin窶適arp fingerprint (hash) for a string `s` of length `m` is:  
> `H(s) = (s[0]*d^(m-1) + s[1]*d^(m-2) + ... + s[m-1]) mod q`  
>  
> Where:  
> - `d` = alphabet size (often `256` for ASCII)  
> - `q` = a large prime modulus  
> - `s[i]` = numeric value of the character (often its ASCII code)  
>  
> **Rolling Update (sliding the window by 1):**  
> If the current window hash is `H`, remove the leftmost character and add the new rightmost character:  
> `H_next = (d * (H - txt[i]*d^(m-1)) + txt[i+m]) mod q`

> **Note:** We take modulo (`% q`) in Rabin窶適arp hashing because:
> - **Prevents overflow:** Values like `d^(m-1)` grow extremely fast; modulo keeps numbers within a safe range.
> - **Keeps hashes bounded:** The hash always stays in `[0, q-1]`, making computations manageable.
> - **Makes rolling update possible:** While sliding the window, we repeatedly subtract/multiply/add; modulo keeps the value stable.
> - **Reduces collisions (with a good q):** Using a large prime modulus spreads hash values better and lowers collision chances.

> **Note:** A **spurious hit** (in Rabin窶適arp) is a **false match** where the hash of the pattern equals the hash of a text window, but the actual strings are different (hash collision).  
> Rabin窶適arp handles this by doing a **character-by-character verification** whenever the hashes match.

---

>### Notes: Why `hash = hash*d + s[i]` Works (Horner窶冱 Method)

**1) Original polynomial hash:**  
- For a string `s` of length `m`:
  - `H = s0*d^(m-1) + s1*d^(m-2) + ... + s(m-1)`  
  - (then usually take `mod q`)

**2) Rewrite using Horner窶冱 method (nested form):**  
- Same hash can be written as:
  - `H = (...((s0*d + s1)*d + s2)*d + ... + s(m-1))`

**3) Convert nested form to a loop (iterative formula):**  
- Start:
  - `h = 0`
- For each character `s[i]`:
  - `h = h*d + s[i]`
- With modulo:
  - `h = (h*d + s[i]) % q`

**4) Small expansion example (m = 3):**  
- Polynomial form:
  - `H = s0*d^2 + s1*d + s2`
- Nested form:
  - `H = ((s0*d + s1)*d + s2)`
- Expansion check:
  - `((s0*d + s1)*d + s2) = s0*d^2 + s1*d + s2`

**5) Example with numbers (easy):**  
- Let `d = 10`, and `s0=1, s1=2, s2=3`
- Polynomial:
  - `H = 1*10^2 + 2*10 + 3 = 123`
- Iterative:
  - `h=0`
  - `h=0*10+1 = 1`
  - `h=1*10+2 = 12`
  - `h=12*10+3 = 123`

**6) Meaning of multiplying by `d`:**  
- `h * d` = **shift left** by one position (like base-10: `12*10 = 120`)
- `+ s[i]` = put the new character value in the last position
---

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> rabinKarp(const string& txt, const string& pat) {
        const int d = 256;             // alphabet size (ASCII)
        const long long q = 1000000007; // large prime modulus

        int n = (int)txt.size();
        int m = (int)pat.size();
        vector<int> matches;

        if (m == 0) return matches;      // optional: define empty pattern behavior
        if (m > n) return matches;

        long long h = 1; // d^(m-1) % q
        for (int i = 0; i < m - 1; i++) {
            h = (h * d) % q;
        }

        long long pHash = 0; // pattern hash
        long long tHash = 0; // text window hash

        // Initial hash computation
        for (int i = 0; i < m; i++) {
            pHash = (pHash * d + (unsigned char)pat[i]) % q;
            tHash = (tHash * d + (unsigned char)txt[i]) % q;
        }

        // Slide the pattern over the text
        for (int i = 0; i <= n - m; i++) {
            // If hash matches, verify to avoid collision
            if (pHash == tHash) {
                bool ok = true;
                for (int j = 0; j < m; j++) {
                    if (txt[i + j] != pat[j]) {
                        ok = false;
                        break;
                    }
                }
                if (ok) matches.push_back(i);
            }

            // Compute hash for next window
            if (i < n - m) {
                long long removeVal = ((unsigned char)txt[i] * h) % q;
                tHash = (tHash - removeVal) % q;
                if (tHash < 0) tHash += q;

                tHash = (tHash * d + (unsigned char)txt[i + m]) % q;
            }
        }

        return matches;
    }
};

int main() {
    Solution sol;
    string txt = "ababcabcabababd";
    string pat = "ababd";

    vector<int> idx = sol.rabinKarp(txt, pat);
    for (int i : idx) cout << i << " ";
    cout << "\n";
    return 0;
}
```
### 沒 Complexity Analysis:

- **Average Time Complexity: `O(n + m)`**  
    Rolling hash update is `O(1)` per shift; verification is rare on average.

- **Worst Time Complexity: `O(n * m)`**  
    If many hash collisions occur, we may verify many times.

- **Space Complexity: `O(1)`**  
    Constant extra space is used (excluding the output indices).
