# üìù Isomorphic String

**Problem Statement** [ref](https://www.youtube.com/watch?v=2ISNCDJEgqQ)  
Given two strings `s` and `t`, determine if they are **isomorphic**.

Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.

- All occurrences of a character must be replaced with another character while preserving the order of characters.
- No two characters may map to the same character.
- A character may map to itself.

---

### üí° Examples

### Example 1
**Input:**  
`s = "paper", t = "title"`

**Output:**  
`true`

**Explanation:**  
The characters in `s` can be mapped one-to-one to characters in `t`:

- `'p'` ‚Üí `'t'`
- `'a'` ‚Üí `'i'`
- `'e'` ‚Üí `'l'`
- `'r'` ‚Üí `'e'`

Since the mapping is consistent and unique for each character, the strings are isomorphic.

### Example 2
**Input:**  
`s = "foo", t = "bar"`

**Output:**  
`false`

**Explanation:**  
- `'f'` ‚Üí `'b'` is fine.
- `'o'` ‚Üí `'a'` for the first `'o'`, but the second `'o'` in `s` would need to map to `'r'` in `t`, which conflicts with the earlier mapping of `'o'` ‚Üí `'a'`.

This inconsistency makes it impossible to convert `s` to `t` using a one-to-one character mapping.

---

## üß† Approach -I

### Intuition
Two strings are **isomorphic** if they follow the **same repeat pattern**.

- If a letter repeats in `s`, the corresponding letter must repeat in `t` at the same positions.
- If a new letter appears in `s`, the corresponding letter must also be new in `t`.

**Trick to Remember:**  
**‚ÄúSame pattern of repeats.‚Äù**  
Example:  
`paper` ‚Üí p repeats at positions (0,2)  
`title` ‚Üí t repeats at positions (0,2)  
So it works.

**How does the code check it?**  
- Store the **last seen index** of each character in both strings.
- At index `i`, compare:
  - `lastSeenS[s[i]]` and `lastSeenT[t[i]]`
- If they are different ‚Üí pattern breaks ‚Üí not isomorphic.
- Then update both last seen to `i+1`.

**Trick for `i+1`**  
Use `i+1` so that:
- `0` means **never seen**
- index `0` can be stored as `1` (no confusion)

### Algorithm
- Think of isomorphism as a consistent one-to-one mapping between characters of two strings.
- The goal is to ensure the pattern of appearances and repetitions is identical in both strings.
- Use two fixed-size arrays (size `256`) to track the last-seen positions of characters from each string.
- While scanning both strings together, compare if the characters at the current position have been seen at the same relative positions before.
- If not, it indicates inconsistent mapping (one character maps to multiple others) ‚Üí return `false`.
- If consistent, update the last seen position of both characters to ensure future checks remain valid.
- This approach confirms isomorphic structure by comparing character occurrence patterns, not the characters themselves.

``` cpp
#include <bits/stdc++.h>
  using namespace std;
  
  class Solution {
  public:
      // Method to check if two strings are isomorphic
      bool isomorphicString(string s, string t) {
          // Arrays to store last seen positions of characters in s and t
          int m1[256] = {0}, m2[256] = {0}; 
          
          // Get the length of the strings
          int n = s.size(); 
          
          // Traverse each character of the strings
          for (int i = 0; i < n; ++i) {
              // If previous positions of current characters differ, return false
              if (m1[s[i]] != m2[t[i]]) return false;
              
              // Update the position with current index + 1
              m1[s[i]] = i + 1;
              m2[t[i]] = i + 1;
          }
          
          // If no mismatch is found, return true
          return true;
      }
  };
  
  // Main function to test the method
  int main() {
      // Create object of Solution
      Solution solution;
      
      // Sample input strings
      string s = "paper";
      string t = "title";
      
      // Check if strings are isomorphic
      if (solution.isomorphicString(s, t)) {
          cout << "Strings are isomorphic." << endl;
      } else {
          cout << "Strings are not isomorphic." << endl;
      }
      
      return 0;
  }
```
### üìä Complexity Analysis

**Time Complexity: `O(N)`**  
`N` is the length of the input strings. We iterate through each character once using a single loop.

**Space Complexity: `O(1)`**  
The arrays are fixed size (`256`), so the extra space remains constant regardless of input size.

---
### Dry Run:

**`s = "1111111"`, `t = "2222222"`**  

All `m1[]` and `m2[]` start as `0`.

| i | s[i] | t[i] | m1[s[i]] before | m2[t[i]] before | check | update m1[s[i]] | update m2[t[i]] |
|---|------|------|------------------|------------------|-------|-----------------|-----------------|
| 0 | '1'  | '2'  | 0                | 0                | ok    | m1['1']=1       | m2['2']=1       |
| 1 | '1'  | '2'  | 1                | 1                | ok    | m1['1']=2       | m2['2']=2       |
| 2 | '1'  | '2'  | 2                | 2                | ok    | m1['1']=3       | m2['2']=3       |
| 3 | '1'  | '2'  | 3                | 3                | ok    | m1['1']=4       | m2['2']=4       |
| 4 | '1'  | '2'  | 4                | 4                | ok    | m1['1']=5       | m2['2']=5       |
| 5 | '1'  | '2'  | 5                | 5                | ok    | m1['1']=6       | m2['2']=6       |
| 6 | '1'  | '2'  | 6                | 6                | ok    | m1['1']=7       | m2['2']=7       |

‚úÖ No mismatch occurs ‚Üí strings are `isomorphic`.


**`s = "1234"`, `t = "4321"`**  

All `m1[]` and `m2[]` start as `0`.

| i | s[i] | t[i] | m1[s[i]] before | m2[t[i]] before | check | update m1[s[i]] | update m2[t[i]] |
|---|------|------|------------------|------------------|-------|-----------------|-----------------|
| 0 | '1'  | '4'  | 0                | 0                | ok    | m1['1']=1       | m2['4']=1       |
| 1 | '2'  | '3'  | 0                | 0                | ok    | m1['2']=2       | m2['3']=2       |
| 2 | '3'  | '2'  | 0                | 0                | ok    | m1['3']=3       | m2['2']=3       |
| 3 | '4'  | '1'  | 0                | 0                | ok    | m1['4']=4       | m2['1']=4       |

‚úÖ No mismatch occurs ‚Üí strings are `isomorphic`.

**`s = "foo"`, `t = "bar"`**  

All `m1[]` and `m2[]` start as `0`.

| i | s[i] | t[i] | m1[s[i]] before | m2[t[i]] before | check         | update m1[s[i]] | update m2[t[i]] |
|---|------|------|------------------|------------------|--------------|-----------------|-----------------|
| 0 | f    | b    | 0                | 0                | ok           | m1[f] = 1       | m2[b] = 1       |
| 1 | o    | a    | 0                | 0                | ok           | m1[o] = 2       | m2[a] = 2       |
| 2 | o    | r    | 2                | 0                | fail (2 != 0)| -               | -               |

 >At i = 2, o is repeating in s (seen before), but r is new in t, so the patterns don‚Äôt match ‚Üí not isomorphic.



---

## üß† Approach- II
### Algorithm Steps (Isomorphic Strings using Hash Maps)

1. Create two hash maps:
   - `mp1` to store mapping from characters of `s` to characters of `t` (`s -> t`)
   - `mp2` to store reverse mapping from characters of `t` to characters of `s` (`t -> s`)

2. Traverse both strings from left to right (same index `i`):
   - Let `ch1 = s[i]` and `ch2 = t[i]`.

3. Check mapping consistency:
   - If `ch1` already exists in `mp1`, then `mp1[ch1]` must be equal to `ch2`.  
     Otherwise return `false`.
   - If `ch2` already exists in `mp2`, then `mp2[ch2]` must be equal to `ch1`.  
     Otherwise return `false`.

4. If checks pass, store/update both mappings:
   - `mp1[ch1] = ch2`
   - `mp2[ch2] = ch1`

5. If the loop completes with no conflicts, return `true`.

> **Note:** No two characters may map to the same character.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    bool isIsomorphic(string s, string t) {
        // If lengths differ, they can never be isomorphic
        if (s.size() != t.size()) return false;

        // Map for forward mapping: s -> t
        unordered_map<char, char> mp1;

        // Map for reverse mapping: t -> s
        unordered_map<char, char> mp2;

        // Traverse both strings together
        for (int i = 0; i < (int)s.size(); i++) {
            char ch1 = s[i]; // current character in s
            char ch2 = t[i]; // corresponding character in t

            // Check consistency of existing mappings
            if ((mp1.find(ch1) != mp1.end() && mp1[ch1] != ch2) ||
                (mp2.find(ch2) != mp2.end() && mp2[ch2] != ch1)) {
                return false; // conflict found
            }

            // Store/update mappings in both directions
            mp1[ch1] = ch2;
            mp2[ch2] = ch1;
        }

        return true; // all mappings consistent
    }
};

int main() {
    Solution sol;

    // Example 1
    string s1 = "paper", t1 = "title";
    cout << "s = " << s1 << ", t = " << t1 << " -> "
         << (sol.isIsomorphic(s1, t1) ? "true" : "false") << "\n";

    // Example 2
    string s2 = "foo", t2 = "bar";
    cout << "s = " << s2 << ", t = " << t2 << " -> "
         << (sol.isIsomorphic(s2, t2) ? "true" : "false") << "\n";

    return 0;
}
```
## üìä Complexity Analysis

**Time Complexity: `O(N)`**  
We traverse both strings once. Each hash map lookup/insert is `O(1)` on average, so total time is `O(N)` where `N` is the length of the strings.

**Space Complexity: `O(1)`**  
At most, we store mappings for each unique character. For a fixed character set (like ASCII), this is bounded by a constant (e.g., `256`). Hence, auxiliary space is `O(1)` (ignoring the input strings).






