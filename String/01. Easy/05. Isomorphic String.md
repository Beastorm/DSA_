# üìù Isomorphic String

**Problem Statement** [ref](https://www.youtube.com/watch?v=2ISNCDJEgqQ)  
Given two strings `s` and `t`, determine if they are **isomorphic**.

Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.

- All occurrences of a character must be replaced with another character while preserving the order of characters.
- No two characters may map to the same character.
- A character may map to itself.

---

### üí° Examples

### Example 1
**Input:**  
`s = "paper", t = "title"`

**Output:**  
`true`

**Explanation:**  
The characters in `s` can be mapped one-to-one to characters in `t`:

- `'p'` ‚Üí `'t'`
- `'a'` ‚Üí `'i'`
- `'e'` ‚Üí `'l'`
- `'r'` ‚Üí `'e'`

Since the mapping is consistent and unique for each character, the strings are isomorphic.

### Example 2
**Input:**  
`s = "foo", t = "bar"`

**Output:**  
`false`

**Explanation:**  
- `'f'` ‚Üí `'b'` is fine.
- `'o'` ‚Üí `'a'` for the first `'o'`, but the second `'o'` in `s` would need to map to `'r'` in `t`, which conflicts with the earlier mapping of `'o'` ‚Üí `'a'`.

This inconsistency makes it impossible to convert `s` to `t` using a one-to-one character mapping.

---

## üß† Approach -I

### Algorithm
- Think of isomorphism as a consistent one-to-one mapping between characters of two strings.
- The goal is to ensure the pattern of appearances and repetitions is identical in both strings.
- Use two fixed-size arrays (size `256`) to track the last-seen positions of characters from each string.
- While scanning both strings together, compare if the characters at the current position have been seen at the same relative positions before.
- If not, it indicates inconsistent mapping (one character maps to multiple others) ‚Üí return `false`.
- If consistent, update the last seen position of both characters to ensure future checks remain valid.
- This approach confirms isomorphic structure by comparing character occurrence patterns, not the characters themselves.

``` cpp
#include <bits/stdc++.h>
  using namespace std;
  
  class Solution {
  public:
      // Method to check if two strings are isomorphic
      bool isomorphicString(string s, string t) {
          // Arrays to store last seen positions of characters in s and t
          int m1[256] = {0}, m2[256] = {0}; 
          
          // Get the length of the strings
          int n = s.size(); 
          
          // Traverse each character of the strings
          for (int i = 0; i < n; ++i) {
              // If previous positions of current characters differ, return false
              if (m1[s[i]] != m2[t[i]]) return false;
              
              // Update the position with current index + 1
              m1[s[i]] = i + 1;
              m2[t[i]] = i + 1;
          }
          
          // If no mismatch is found, return true
          return true;
      }
  };
  
  // Main function to test the method
  int main() {
      // Create object of Solution
      Solution solution;
      
      // Sample input strings
      string s = "paper";
      string t = "title";
      
      // Check if strings are isomorphic
      if (solution.isomorphicString(s, t)) {
          cout << "Strings are isomorphic." << endl;
      } else {
          cout << "Strings are not isomorphic." << endl;
      }
      
      return 0;
  }
```
### üìä Complexity Analysis

**Time Complexity: `O(N)`**  
`N` is the length of the input strings. We iterate through each character once using a single loop.

**Space Complexity: `O(1)`**  
The arrays are fixed size (`256`), so the extra space remains constant regardless of input size.

---

## üß† Approach- II
### Algorithm Steps (Isomorphic Strings using Hash Maps)

1. Create two hash maps:
   - `mp1` to store mapping from characters of `s` to characters of `t` (`s -> t`)
   - `mp2` to store reverse mapping from characters of `t` to characters of `s` (`t -> s`)

2. Traverse both strings from left to right (same index `i`):
   - Let `ch1 = s[i]` and `ch2 = t[i]`.

3. Check mapping consistency:
   - If `ch1` already exists in `mp1`, then `mp1[ch1]` must be equal to `ch2`.  
     Otherwise return `false`.
   - If `ch2` already exists in `mp2`, then `mp2[ch2]` must be equal to `ch1`.  
     Otherwise return `false`.

4. If checks pass, store/update both mappings:
   - `mp1[ch1] = ch2`
   - `mp2[ch2] = ch1`

5. If the loop completes with no conflicts, return `true`.

> **Note:** No two characters may map to the same character.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    bool isIsomorphic(string s, string t) {
        // If lengths differ, they can never be isomorphic
        if (s.size() != t.size()) return false;

        // Map for forward mapping: s -> t
        unordered_map<char, char> mp1;

        // Map for reverse mapping: t -> s
        unordered_map<char, char> mp2;

        // Traverse both strings together
        for (int i = 0; i < (int)s.size(); i++) {
            char ch1 = s[i]; // current character in s
            char ch2 = t[i]; // corresponding character in t

            // Check consistency of existing mappings
            if ((mp1.find(ch1) != mp1.end() && mp1[ch1] != ch2) ||
                (mp2.find(ch2) != mp2.end() && mp2[ch2] != ch1)) {
                return false; // conflict found
            }

            // Store/update mappings in both directions
            mp1[ch1] = ch2;
            mp2[ch2] = ch1;
        }

        return true; // all mappings consistent
    }
};

int main() {
    Solution sol;

    // Example 1
    string s1 = "paper", t1 = "title";
    cout << "s = " << s1 << ", t = " << t1 << " -> "
         << (sol.isIsomorphic(s1, t1) ? "true" : "false") << "\n";

    // Example 2
    string s2 = "foo", t2 = "bar";
    cout << "s = " << s2 << ", t = " << t2 << " -> "
         << (sol.isIsomorphic(s2, t2) ? "true" : "false") << "\n";

    return 0;
}
```
## üìä Complexity Analysis

**Time Complexity: `O(N)`**  
We traverse both strings once. Each hash map lookup/insert is `O(1)` on average, so total time is `O(N)` where `N` is the length of the strings.

**Space Complexity: `O(1)`**  
At most we store mappings for each unique character. For a fixed character set (like ASCII), this is bounded by a constant (e.g., `256`). Hence, auxiliary space is `O(1)` (ignoring the input strings).
