## Hashing in Strings ğŸ˜

### Introduction
**String hashing** is a technique that converts a string into a fixed-size numeric value called a **hash value**.  
Instead of comparing or processing the whole string repeatedly, we work with this numeric â€œfingerprintâ€ ğŸ”.

Hashing is widely used in:
- fast string comparison âš¡
- dictionary/unordered_map lookups ğŸ§ 
- substring/pattern searching (Rabinâ€“Karp) ğŸ§©
- detecting duplicates, anagrams, repeated substrings âœ…

---

## Why do we need hashing? ğŸ¤”

### 1) Efficient comparisons
Comparing two strings directly can take **O(L)** time (`L` = length).  
With hashes, comparing becomes comparing two numbers â†’ **O(1)** time âš¡  
(assuming no collision; otherwise, we verify.)

### 2) Faster lookups
Hash tables (`unordered_map`, `unordered_set`) store keys using hash values, so lookup/insert/delete is **O(1) average** ğŸš€.

### 3) Detect duplicates/anagrams
- Duplicate strings: compare hashes quickly âœ…
- Anagrams: hash a normalized form or use frequency signature ğŸ”

### 4) Pattern matching
Algorithms like **Rabinâ€“Karp** use hashing to find substrings efficiently ğŸ”.

---

## How does string hashing work? ğŸ› ï¸

We convert characters into numbers and combine them so that:
- different strings likely get different values ğŸ¯
- order matters (`"ab"` â‰  `"ba"`)

### Polynomial Rolling Hash
A common hashing method is:

`Hash(s) = (s[0] * p^0 + s[1] * p^1 + ... + s[n-1] * p^(n-1)) % m`

Where:
- `s[i]` is a numeric value for the character (like `'a' = 1`) ğŸ”¢
- `p` is a prime base (commonly `31` or `53`) ğŸ§®
- `m` is a large prime modulus (like `1e9+7` or `1e9+9`) ğŸ§±

### Why do we use modulo `m`?
Powers grow very fast ğŸ’¥. Modulo keeps values small and helps reduce collisions.

## Choosing `p` and `m` ğŸ›ï¸

### Base `p`
Common choices:
- `p = 31` â†’ good for lowercase English letters ğŸ”¤
- `p = 53` â†’ useful when uppercase + lowercase are present ğŸ” 

### Modulus `m`
Big primes reduce collisions and avoid overflow:
- `m = 1,000,000,007 (1e9+7)`
- `m = 1,000,000,009 (1e9+9)`

---

## Collisions: what and why? ğŸ’¥

A **collision** means two different strings produce the same hash value.

To reduce collisions:
- Use large prime modulus `m` ğŸ§±
- Use a good base `p` ğŸ¯
- Use **double hashing** (two different `(p, m)` pairs) âœ…âœ…
- Verify by direct comparison if needed ğŸ”

---

## Worked Example: Hash of `"abc"` ğŸ§¾

Given:
- `s = "abc"`
- mapping: `'a' = 1`, `'b' = 2`, `'c' = 3`
- `p = 31`
- `m = 1e9 + 9`

Compute powers:
- `31^0 = 1`
- `31^1 = 31`
- `31^2 = 961`

Now:

`Hash(s) = (1 * 1 + 2 * 31 + 3 * 961) % (1e9+9)`  
`Hash(s) = (1 + 62 + 2883) % (1e9+9)`  
`Hash(s) = 2946`

So `"abc"` gets hashed to value `2946` âœ…

---

## Extra: Why polynomial hashing is popular âœ¨
With prefix hashes + precomputed powers of `p`, we can compute any substring hash in **O(1)** time â±ï¸, useful for:
- substring comparisons ğŸ§©
- Rabinâ€“Karp pattern matching ğŸ”
- repeated substring detection ğŸ”
