# ğŸ“ Count and Say

**Problem Statement:**  
The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:

- `countAndSay(1) = "1"`
- `countAndSay(n)` is the **run-length encoding (RLE)** of `countAndSay(n - 1)`.

**Run-length encoding (RLE)** replaces consecutive identical characters with the concatenation of the **count** and the **character**.  
Example: `"3322251"` becomes:
- `"33"` â†’ `"23"`
- `"222"` â†’ `"32"`
- `"5"` â†’ `"15"`
- `"1"` â†’ `"11"`

So the compressed string becomes `"23321511"`.

Given a positive integer `n`, return the `n`th element of the count-and-say sequence.


### ğŸ’¡ Examples

### Example 1
**Input:** `4`  
**Output:** `"1211"`  

**Explanation:**
- `countAndSay(1) = "1"`
- `countAndSay(2) = RLE("1") = "11"`
- `countAndSay(3) = RLE("11") = "21"`
- `countAndSay(4) = RLE("21") = "1211"`

### Example 2
**Input:** `1`  
**Output:** `"1"`  

**Explanation:**  
This is the base case.

---

## ğŸ§  Approach

### Algorithm
We generate each term by **describing the previous term**.

- Start from the first term: `"1"`.
- For each new term:
  - Scan the previous term from left to right.
  - Count how many times the current digit appears **consecutively**.
  - Append the **count** followed by the **digit** to build the next term.
- Repeat until reaching the required term `n`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to generate the nth term of the count-and-say sequence
    string countAndSay(int n) {
        string result = "1";

        // Generate the sequence up to the nth term
        for (int i = 1; i < n; ++i) {
            string current = "";
            int count = 1;

            // Traverse the previous result
            for (int j = 1; j < result.size(); ++j) {
                // If current character matches previous, increment count
                if (result[j] == result[j - 1]) {
                    count++;
                } else {
                    // Append count and character to current result
                    current += to_string(count) + result[j - 1];
                    count = 1;
                }
            }

            // Append the last group
            current += to_string(count) + result.back();

            // Update result for next iteration
            result = current;
        }

        // Return the final result
        return result;
    }
};

int main() {
    Solution solver;
    int n = 5;
    cout << "Count and Say term " << n << ": " << solver.countAndSay(n) << endl;
    return 0;
}
```
### ğŸ“Š Complexity Analysis

**Time Complexity: `O(n * 2^n)`**  
There are `n` iterations, and the string length can grow up to `2^n` in the worst case, so processing each term leads to `O(n * 2^n)` time.

**Space Complexity: `O(2^n)`**  
The final generated string can be as large as `2^n` in the worst case.
