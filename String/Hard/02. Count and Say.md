# üìù Count and Say

**Problem Statement:** [ref](https://www.youtube.com/watch?v=5uJitfSM3vk)  
The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:

- `countAndSay(1) = "1"`
- `countAndSay(n)` is the **run-length encoding (RLE)** of `countAndSay(n - 1)`.

**Run-length encoding (RLE)** replaces consecutive identical characters with the concatenation of the **count** and the **character**.  
Example: `"3322251"` becomes:
- `"33"` ‚Üí `"23"`
- `"222"` ‚Üí `"32"`
- `"5"` ‚Üí `"15"`
- `"1"` ‚Üí `"11"`

So the compressed string becomes `"23321511"`.

Given a positive integer `n`, return the `n`th element of the count-and-say sequence.


### üí° Examples

### Example 1
**Input:** `4`  
**Output:** `"1211"`  

**Explanation:**
- `countAndSay(1) = "1"`
- `countAndSay(2) = RLE("1") = "11"`
- `countAndSay(3) = RLE("11") = "21"`
- `countAndSay(4) = RLE("21") = "1211"`

### Example 2
**Input:** `1`  
**Output:** `"1"`  

**Explanation:**  
This is the base case.

---

## üß† Approach - I

### Algorithm
We generate each term by **describing the previous term**.

- Start from the first term: `"1"`.
- For each new term:
  - Scan the previous term from left to right.
  - Count how many times the current digit appears **consecutively**.
  - Append the **count** followed by the **digit** to build the next term.
- Repeat until reaching the required term `n`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to generate the nth term of the count-and-say sequence
    string countAndSay(int n) {
        string result = "1";

        // Generate the sequence up to the nth term
        for (int i = 1; i < n; ++i) {
            string current = "";
            int count = 1;

            // Traverse the previous result
            for (int j = 1; j < result.size(); ++j) {
                // If current character matches previous, increment count
                if (result[j] == result[j - 1]) {
                    count++;
                } else {
                    // Append count and character to current result
                    current += to_string(count) + result[j - 1];
                    count = 1;
                }
            }

            // Append the last group
            current += to_string(count) + result.back();

            // Update result for next iteration
            result = current;
        }

        // Return the final result
        return result;
    }
};

int main() {
    Solution solver;
    int n = 5;
    cout << "Count and Say term " << n << ": " << solver.countAndSay(n) << endl;
    return 0;
}
```
### üìä Complexity Analysis

**Time Complexity: `O(n * 2^n)`**  
There are `n` iterations, and the string length can grow up to `2^n` in the worst case, so processing each term leads to `O(n * 2^n)` time.

**Space Complexity: `O(2^n)`**  
The final generated string can be as large as `2^n` in the worst case.

---
## üß† Approach - II (Recursion)

### Algorithm Steps

- If `n == 1`, return `"1"` (base case).
- Recursively compute the previous term: `say = countAndSay(n - 1)`.
- Build the current term using run-length encoding:
  - Initialize `result = ""`.
  - Traverse `say` with index `i`:
    - Set `ch = say[i]` and `count = 1`.
    - While the next character is the same (`say[i] == say[i+1]`), increment `count` and move `i` forward.
    - Append `count` and `ch` to `result` using: `to_string(count) + string(1, ch)`.
- Return `result`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Returns the nth term of the Count and Say sequence
    string countAndSay(int n) {
        // Base case: first term is always "1"
        if (n == 1) return "1";

        // Get the previous term
        string say = countAndSay(n - 1);

        // Build the current term using run-length encoding
        string result = "";

        // Traverse the previous term
        for (int i = 0; i < (int)say.length(); i++) {
            char ch = say[i];   // current character
            int count = 1;      // count occurrences of ch

            // Count consecutive same characters
            while (i < (int)say.length() - 1 && say[i] == say[i + 1]) {
                count++;
                i++;
            }

            // Append "count" followed by the character
            result += to_string(count) + string(1, ch);
        }

        return result;
    }
};

int main() {
    Solution sol;

    int n = 4; // sample input
    cout << "Input: " << n << "\n";
    cout << "Output: " << sol.countAndSay(n) << "\n"; // expected: 1211

    return 0;
}
```
### üìä Complexity Analysis

**Time Complexity: `O(L1 + L2 + ... + Ln)`**  
Each term is scanned once to build the next term. If `Ln` is the length of the `n`th term, total time is the sum of lengths across all generated terms. This is often described as **exponential growth** in `n`.

**Space Complexity: `O(Ln)`**  
The final string of length `Ln` is stored.  
*(If counting recursion stack, add `O(n)` for recursion depth.)*
