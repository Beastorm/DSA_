# Rabin–Karp String Matching Algorithm

**Problem Statement:** [ref](https://www.youtube.com/watch?v=qQ8vS2btsxI&list=PLgUcNmqSvVXDbO-2shqCF1JmsNgpvTi6C&index=1)  
Given a text string `txt` and a pattern string `pat`, find all starting indices in `txt` where `pat` occurs as a substring.


### Core Idea
Rabin–Karp uses **hashing** to compare the pattern with substrings of the text efficiently.

- Compute the hash of `pat`
- Compute the hash of the first window of `txt` having length `m = pat.length()`
- Slide the window one character at a time and update the hash in **O(1)** using a **rolling hash**
- If the hash matches, verify by direct comparison to avoid collision errors


### Rolling Hash (Typical Form)
Treat strings as numbers in base `d` (alphabet size) under modulus `q`:

- `d` = 256 (ASCII)
- `q` = large prime (e.g., `1e9+7`, `101`, etc.)

Hash of length `m` string:
`H = (s[0]*d^(m-1) + s[1]*d^(m-2) + ... + s[m-1]) % q`

Rolling update when window moves from `[i..i+m-1]` to `[i+1..i+m]`:
`Hnext = (d*(H - txt[i]*d^(m-1)) + txt[i+m]) % q`

---

## Algorithm Steps
1. Let `n = txt.length()`, `m = pat.length()`.
2. If `m > n`, return no matches.
3. Precompute `h = d^(m-1) % q`.
4. Compute initial hash of:
   - `pat` (call it `pHash`)
   - first window of `txt` of length `m` (call it `tHash`)
5. For each window, start `i` from `0` to `n-m`:
   - If `pHash == tHash`:
     - Verify characters one-by-one (to handle collisions)
     - If equal, store index `i`
   - If `i < n-m`, compute rolling hash for next window.

---

### C++ Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> rabinKarp(const string& txt, const string& pat) {
        const int d = 256;             // alphabet size (ASCII)
        const long long q = 1000000007; // large prime modulus

        int n = (int)txt.size();
        int m = (int)pat.size();
        vector<int> matches;

        if (m == 0) return matches;      // optional: define empty pattern behavior
        if (m > n) return matches;

        long long h = 1; // d^(m-1) % q
        for (int i = 0; i < m - 1; i++) {
            h = (h * d) % q;
        }

        long long pHash = 0; // pattern hash
        long long tHash = 0; // text window hash

        // Initial hash computation
        for (int i = 0; i < m; i++) {
            pHash = (pHash * d + (unsigned char)pat[i]) % q;
            tHash = (tHash * d + (unsigned char)txt[i]) % q;
        }

        // Slide the pattern over the text
        for (int i = 0; i <= n - m; i++) {
            // If hash matches, verify to avoid collision
            if (pHash == tHash) {
                bool ok = true;
                for (int j = 0; j < m; j++) {
                    if (txt[i + j] != pat[j]) {
                        ok = false;
                        break;
                    }
                }
                if (ok) matches.push_back(i);
            }

            // Compute hash for next window
            if (i < n - m) {
                long long removeVal = ((unsigned char)txt[i] * h) % q;
                tHash = (tHash - removeVal) % q;
                if (tHash < 0) tHash += q;

                tHash = (tHash * d + (unsigned char)txt[i + m]) % q;
            }
        }

        return matches;
    }
};

int main() {
    Solution sol;
    string txt = "ababcabcabababd";
    string pat = "ababd";

    vector<int> idx = sol.rabinKarp(txt, pat);
    for (int i : idx) cout << i << " ";
    cout << "\n";
    return 0;
}
```
