# Minimum Number of Bracket Reversals Needed to Make an Expression Balanced

**Problem Statement:**
Given a string `s` consisting of only opening and closing brackets `'('` and `')'`, find the **minimum number of reversals** required to convert the string into a **balanced expression**.

If it is not possible to make the brackets balanced, return `-1`.  
A reversal means changing `'('` to `')'` or vice-versa.


### Examples

**Input:** `s = ")(())((("`  
**Output:** `3`  
**Explanation:** One way to balance is: `"((())())"`. There is no balanced sequence that can be formed in fewer reversals.

**Input:** `s = "(()((()(())(("`  
**Output:** `-1`  
**Explanation:** There's no way we can balance this sequence of braces.

---

## Approach

### Algorithm
- To be balanced, every opening bracket must be matched with a closing bracket.
- If the string has an **odd length**, it’s impossible to balance (pairs require an even count) → return `-1`.
- Traverse the string:
  - Increase an `opening` counter for `'('`.
  - For `')'`:
    - If there is an unmatched `'('` available, cancel it (`opening--`).
    - Otherwise, this is an unmatched closing bracket → increase a `closing` counter.
- After traversal:
  - `opening` = unmatched opening brackets
  - `closing` = unmatched closing brackets
- Minimum reversals required:

  `(opening + 1) / 2 + (closing + 1) / 2`

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate the minimum number of reversals to balance the expression
    int minReversalsToBalance(string expression) {
        // Count of unmatched '(' brackets
        int openBrackets = 0;
        
        // Count of unmatched ')' brackets
        int closeBrackets = 0;

        // Traverse the string
        for (char ch : expression) {
            if (ch == '(') {
                // Consider '(' as unmatched for now
                openBrackets++;
            } else {
                if (openBrackets > 0) {
                    // Match this ')' with a previous '('
                    openBrackets--;
                } else {
                    // No matching '(' exists, so this ')' is unmatched
                    closeBrackets++;
                }
            }
        }

        // If total number of unmatched brackets is odd, return -1
        if ((openBrackets + closeBrackets) % 2 != 0) return -1;

        // Return minimum reversals required
        return (openBrackets + 1) / 2 + (closeBrackets + 1) / 2;
    }
};

int main() {
    // Input expression
    string expression = "(()))(";

    // Create object of Solution
    Solution solver;

    // Get result from function
    int result = solver.minReversalsToBalance(expression);

    // Print the result
    cout << "Minimum reversals required: " << result << endl;

    return 0;
}

```

### Complexity Analysis

**Time Complexity: `O(N)`**  
We traverse the string once, processing each bracket in constant time.

**Space Complexity: `O(1)`**  
Only constant extra space is used.
