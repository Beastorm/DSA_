# ðŸ“ Z-Algorithm

**Problem Statement:** 1: [ref](https://www.youtube.com/watch?v=Sk1pZYBmQRM) 2: [ref](https://www.youtube.com/watch?v=ZrWAfg1FONE)  
Given two strings, one is a **text** string, and the other is a **pattern** string. Print the indices of all occurrences of the pattern string in the text string using the **Z-function algorithm**. Use **0-based indexing** while returning the indices.


### ðŸ’¡ Examples

### Example 1
**Input:** `text = "xyzabxyzabxyz"`, `pattern = "xyz"`  
**Output:** `[0, 5, 10]`  

**Explanation:**  
The pattern `"xyz"` occurs three times in the text, starting at indices `0`, `5`, and `10`.

### Example 2
**Input:** `text = "cabcdab"`, `pattern = "abc"`  
**Output:** `[1]`  

**Explanation:**  
The pattern `"abc"` occurs one time in the text, starting at index `1`.

---

### Why do we use the Z-Function Algorithm?
When we want to find all occurrences of a pattern in a large text, the Z-function provides a fast and elegant way to do it in **linear time**. Unlike Rabinâ€“Karp (which uses hashing), the Z-algorithm relies on **prefix matching** using a sliding window.

The idea is to construct a new string by concatenating the pattern, a special separator (like `$`), and the text. We then compute the **Z-array**, which tells us for each position in this string, how many characters match the prefix of the entire string.

A full match (Z-value equal to pattern length) tells us that the pattern occurs in the text at that position.

This method is fast because it reuses previous comparisons using a window-based approach and avoids unnecessary checks.

---

## ðŸ§  Algorithm
**Intuition (Z Algorithm + Pattern Matching):**   
The Z-array for a string `S` stores, for every position `i`, how many characters from `S[i...]` match the prefix `S[0...]`.
So `Z[i]` tells: **prefix-match length starting at i**.

To use this for pattern matching:
- We want to know where `pat` matches inside `text`.
- Build one combined string:  
  `S = pat + '$' + text`
  where `$` is a separator character that does **not** appear in `pat` or `text`.
- Now, any match of `pat` in `text` becomes a prefix match of length `|pat|` somewhere inside `S`.
- So, if at some index `i` in `S`, `Z[i] == |pat|`, it means `pat` occurs starting at:
  `i - (|pat| + 1)` in `text`.

**Algorithm Steps:**  

**A) Build Z-array for a string `S`:**  
1. Create `Z` array of size `n`, set `Z[0] = 0`.
2. Maintain a window `[L, R]` (called a Z-box) such that `S[L..R]` matches `S[0..R-L]`.
3. For each `i` from `1` to `n-1`:
   - **Case 1: i > R (outside Z-box)**  
     - Set `L = R = i`
     - While `R < n` and `S[R-L] == S[R]`, increment `R`
     - Set `Z[i] = R - L`
     - Decrement `R` by 1 (to keep it as the last matched index)
   - **Case 2: i <= R (inside Z-box)**
     - Let `k = i - L` (mirror index in prefix)
     - If `Z[k] < R - i + 1`, then set `Z[i] = Z[k]` (fully inside the box)
     - Otherwise:
       - Set `L = i`
       - Extend matches beyond `R` using the same while loop
       - Update `Z[i]` accordingly

**B) Pattern matching using Z:**  
1. Build combined string: `S = pat + '$' + text`
2. Compute `Z` for `S`
3. For every index `i` in `S`:
   - If `Z[i] == |pat|`, then a match occurs at:
     `i - (|pat| + 1)` in `text`
4. Return all such starting indices.

``` cpp
#include <bits/stdc++.h>
using namespace std;

/*
  Z-Algorithm:
  z[i] = length of the longest substring starting at i
         which is also a prefix of s.

  Standard O(n) construction using [L, R] window.
*/
vector<int> buildZ(const string& s) {
    int n = (int)s.size();
    vector<int> z(n, 0);
    if (n == 0) return z;

    int L = 0, R = 0; // current Z-box [L, R]

    for (int i = 1; i < n; i++) {
        if (i > R) {
            // Outside current Z-box: start a new box at i
            L = R = i;
            while (R < n && s[R - L] == s[R]) R++;
            z[i] = R - L;
            R--; // last matching index
        } else {
            // Inside Z-box: reuse previously computed values
            int k = i - L; // corresponding index inside prefix

            if (z[k] < R - i + 1) {
                z[i] = z[k];
            } else {
                // Need to extend beyond R
                L = i;
                while (R + 1 < n && s[R + 1 - L] == s[R + 1]) R++;
                z[i] = R - L + 1;
            }
        }
    }
    return z;
}

/*
  Pattern matching using Z:
  Build combined string: pat + '$' + text
  Any position i where z[i] == pat.length() indicates a match starting at:
     i - (pat.length() + 1) in the text.
*/
vector<int> findOccurrencesZ(const string& text, const string& pat) {
    if (pat.empty()) return {}; // not expected usually, but safe

    string combined = pat + '$' + text; // '$' must not appear in pat/text; ok for lowercase inputs
    vector<int> z = buildZ(combined);

    vector<int> pos;
    int m = (int)pat.size();
    for (int i = 0; i < (int)combined.size(); i++) {
        if (z[i] == m) {
            int startInText = i - (m + 1);
            pos.push_back(startInText);
        }
    }
    return pos;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // Driver:
    // Input:
    //   text
    //   pat
    // Output:
    //   1) Z array of (pat + '$' + text)
    //   2) all match starting indices in text (0-indexed)
    //
    // Example:
    // text:    aabxaabxcaabxaabxay
    // pat:     aabxaabx
    // matches: 0 9
    string text, pat;
    cin >> text >> pat;

    string combined = pat + '$' + text;
    vector<int> z = buildZ(combined);

    // Print Z-array for combined string
    for (int i = 0; i < (int)z.size(); i++) {
        if (i) cout << ' ';
        cout << z[i];
    }
    cout << "\n";

    // Print occurrences (0-indexed)
    vector<int> occ = findOccurrencesZ(text, pat);
    if (occ.empty()) {
        cout << "-1\n";
    } else {
        for (int i = 0; i < (int)occ.size(); i++) {
            if (i) cout << ' ';
            cout << occ[i];
        }
        cout << "\n";
    }

    return 0;
}
```
### ðŸ“Š Complexity Analysis
Let:
- `m = |pat|`
- `n = |text|`
- Combined string length `N = m + 1 + n` (the `+1` is for `$`)

**Time Complexity:**  
1. Building the combined string `pat + '$' + text`: `O(N)`
2. Computing the Z-array for the combined string:
   - Each character is compared a constant number of times overall because the `[L, R]` window only moves forward.
   - So Z construction runs in `O(N)`.
3. Scanning the Z-array to collect matches: `O(N)`

Total time:  
**O(N) = O(m + n)**

**Space Complexity:**  
- Z-array of size `N`: `O(N)`
- Combined string of size `N`: `O(N)`
- Output list of occurrences: up to `O(n)` in worst case (e.g., repeated pattern)

Total auxiliary space:  
**O(N) = O(m + n)** (plus output).
