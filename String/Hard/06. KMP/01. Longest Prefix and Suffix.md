# ðŸ“ Longest Prefix and Suffix (LPS)

### Meaning
For a string `s`, the **Longest Prefix and Suffix (LPS)** is the **longest proper prefix** of `s` that is also a **suffix** of `s`.

- **Prefix:** starts at index `0`
- **Suffix:** ends at the last index
- **Proper prefix:** cannot be the whole string itself

### ðŸ’¡ Example
`s = "ababa"`

- **Prefixes:** `a`, `ab`, `aba`, `abab`
- **Suffixes:** `a`, `ba`, `aba`, `baba`

Common prefix & suffix: `a`, `aba`  
Longest is `"aba"` â†’ length = `3`

## ðŸ¢ Algorithm Steps (Brute Force)

1. Let `n` be the length of the string `s`.
2. For each possible length `len` from `n - 1` down to `1`:
   - Compare the prefix `s[0 .. len-1]` with the suffix `s[n-len .. n-1]`.
   - If they match completely, return `len` (this is the longest proper prefix which is also a suffix).
3. If no length matches, return `0`.

> **Note:** Why not just compare 1 length string, and if not equal, we can exit and return 0?
> You canâ€™t return `0` just because the length `1` doesnâ€™t match, because you might think a longer prefix-suffix could still match.  
> However, for prefix-suffix matching, if any length `L >= 1` matches, then **the first and last characters must match**.  
> So if length `1` fails (`s[0] != s[n-1]`), then **no longer length can succeed**.

> **Reason:** Any prefix and suffix of length `>= 1` must share the same first/last character match requirement.

> âœ… You can early return `0` if: `s[0] != s[n-1]`  
> Checking length `1` is equivalent to this condition.

> **Why start checking from `n-1`?**  
> Starting from `n-1` gives the **longest match directly**.  
> If you start from `1`, you would still need to check all larger lengths to find the maximum (unless you only care whether any match exists).

> **So:**  
> - If you want the **maximum length**, donâ€™t return early after checking length `1`.  
> - You may early return `0` only if `s[0] != s[n-1]`.

```cpp
#include <bits/stdc++.h>
using namespace std;

// Brute force: longest proper prefix of s that is also a suffix
int longestPrefixSuffixBrute(const string& s) {
    int n = (int)s.size();

    // Try lengths from n-1 down to 1 (proper prefix can't be full length)
    for (int len = n - 1; len >= 1; len--) {
        bool ok = true;

        // Compare prefix s[0..len-1] with suffix s[n-len..n-1]
        for (int i = 0; i < len; i++) {
            if (s[i] != s[n - len + i]) {
                ok = false;
                break;
            }
        }

        if (ok) return len;
    }

    return 0; // no proper prefix equals suffix
}

int main() {
    string s = "ababa";
    cout << longestPrefixSuffixBrute(s) << "\n"; // 3 ("aba")
    return 0;
}
```
### ðŸ“Š Complexity Analysis (Brute Force)

**Time Complexity: `O(n^2)`**  
We try all possible lengths from `n-1` down to `1` (up to `n` checks), and for each length we may compare up to `n` characters.

**Space Complexity: `O(1)`**  
Only constant extra space is used.
