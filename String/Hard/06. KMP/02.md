# ðŸ“ LPS Array (Longest Prefix Suffix Array)

### What is the LPS array?
For a pattern string `pat`, the **LPS array** (`lps[i]`) stores:

> the length of the **longest proper prefix** of `pat[0..i]` that is also a **suffix** of `pat[0..i]`.

- **Prefix:** starts at index `0`
- **Suffix:** ends at index `i`
- **Proper:** not equal to the whole substring

### Why is it useful?
The LPS array is used in **KMP (Knuthâ€“Morrisâ€“Pratt)** string matching to avoid re-checking characters after a mismatch, making the algorithm efficient.

### ðŸ’¡ Example
`pat = "ababaca"`

`lps = [0, 0, 1, 2, 3, 0, 1]`

Meaning:
- `lps[0] = 0` â†’ `"a"` has no proper prefix=suffix
- `lps[3] = 2` â†’ `"abab"` has `"ab"` as both prefix and suffix
- `lps[4] = 3` â†’ `"ababa"` has `"aba"` as both prefix and suffix

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> buildLPS(const string& pat) {
    int m = (int)pat.size();
    vector<int> lps(m, 0);

    int len = 0; // length of current longest prefix-suffix
    int i = 1;

    while (i < m) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1]; // fallback using previous LPS
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

int main() {
    string pat = "ababaca";
    vector<int> lps = buildLPS(pat);

    for (int x : lps) cout << x << " ";
    cout << "\n";
    return 0;
}
```
### ðŸ“Š Complexity Analysis (LPS Array Construction)

**Time Complexity: `O(m)`**  
`m` is the length of the pattern. Each character is processed at most a constant number of times due to the fallback using previously computed LPS values.

**Space Complexity: `O(m)`**  
We store the `lps` array of size `m`.
