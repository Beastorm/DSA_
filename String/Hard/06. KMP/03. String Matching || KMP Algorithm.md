# ğŸ“ String Matching

**Problem Statement:**
String matching means finding whether a **pattern (needle)** appears inside a **text (haystack)** as a **continuous substring**.
Usually, we return the **0-based index of the first occurrence** of the pattern in the text, or `-1` if it does not exist.

ğŸ’¡ **Example:**  
Text = `"hello"`, Pattern = `"ll"` â†’ output = `2` (because `"ll"` starts at index `2`).

## ğŸ¢ Bruteforce
### Algorithm Steps

1. Let `n = haystack.length()` and `m = needle.length()`.
2. If `needle` is empty, return `0`.
3. For each index `i` from `0` to `n - m`:
   - Set `first = i` (pointer in `haystack`) and `second = 0` (pointer in `needle`).
   - While `second < m`:
     - If `haystack[first] != needle[second]`, stop (mismatch).
     - Otherwise, increment both pointers.
   - If `second == m`, it means the whole `needle` matched â†’ return `i`.
4. If no match is found after the loop, return `-1`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

/*
Brute Force implementation of substring search (like strStr):
Return the first index where `needle` occurs in `haystack`,
or -1 if it does not occur.
*/

class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = (int)haystack.size();
        int m = (int)needle.size();

        // Edge case: empty needle is found at index 0
        if (m == 0) return 0;

        // If pattern longer than text, can't match
        if (m > n) return -1;

        // Try matching needle starting at every possible position
        for (int i = 0; i <= n - m; i++) {
            int first = i;   // pointer in haystack
            int second = 0;  // pointer in needle

            // Compare characters one by one
            while (second < m) {
                if (haystack[first] != needle[second]) {
                    break; // mismatch
                }
                first++;
                second++;
            }

            // If we matched all characters of needle
            if (second == m) {
                return first - second; // starting index of match
            }
        }

        return -1; // no match found
    }
};

int main() {
    Solution sol;

    string haystack = "hello";
    string needle = "ll";

    int idx = sol.strStr(haystack, needle);

    cout << "haystack: " << haystack << "\n";
    cout << "needle: " << needle << "\n";
    cout << "first occurrence index: " << idx << "\n"; // expected: 2

    return 0;
}
```
### ğŸ“Š Complexity Analysis

**Time Complexity: `O(n * m)`**  
- Outer loop tries all start positions: `n - m + 1` â‰ˆ `O(n)`
- Inner loop can compare up to `m` characters each time: `O(m)`
  So total time = `O(n) * O(m) = O(n * m)`

**Space Complexity: `O(1)`**  
Only constant extra space is used.
