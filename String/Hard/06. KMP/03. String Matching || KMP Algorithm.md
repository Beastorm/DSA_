# ğŸ“ String Matching

**Problem Statement:**
String matching means finding whether a **pattern (needle)** appears inside a **text (haystack)** as a **continuous substring**.
Usually, we return the **0-based index of the first occurrence** of the pattern in the text, or `-1` if it does not exist.

ğŸ’¡ **Example:**  
Text = `"hello"`, Pattern = `"ll"` â†’ output = `2` (because `"ll"` starts at index `2`).

## ğŸ¢ Bruteforce
### Algorithm Steps

1. Let `n = haystack.length()` and `m = needle.length()`.
2. If `needle` is empty, return `0`.
3. For each index `i` from `0` to `n - m`:
   - Set `first = i` (pointer in `haystack`) and `second = 0` (pointer in `needle`).
   - While `second < m`:
     - If `haystack[first] != needle[second]`, stop (mismatch).
     - Otherwise, increment both pointers.
   - If `second == m`, it means the whole `needle` matched â†’ return `i`.
4. If no match is found after the loop, return `-1`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

/*
Brute Force implementation of substring search (like strStr):
Return the first index where `needle` occurs in `haystack`,
or -1 if it does not occur.
*/

class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = (int)haystack.size();
        int m = (int)needle.size();

        // Edge case: empty needle is found at index 0
        if (m == 0) return 0;

        // If pattern longer than text, can't match
        if (m > n) return -1;

        // Try matching needle starting at every possible position
        for (int i = 0; i <= n - m; i++) {
            int first = i;   // pointer in haystack
            int second = 0;  // pointer in needle

            // Compare characters one by one
            while (second < m) {
                if (haystack[first] != needle[second]) {
                    break; // mismatch
                }
                first++;
                second++;
            }

            // If we matched all characters of needle
            if (second == m) {
                return first - second; // starting index of match
            }
        }

        return -1; // no match found
    }
};

int main() {
    Solution sol;

    string haystack = "hello";
    string needle = "ll";

    int idx = sol.strStr(haystack, needle);

    cout << "haystack: " << haystack << "\n";
    cout << "needle: " << needle << "\n";
    cout << "first occurrence index: " << idx << "\n"; // expected: 2

    return 0;
}
```
### ğŸ“Š Complexity Analysis

**Time Complexity: `O(n * m)`**  
- Outer loop tries all start positions: `n - m + 1` â‰ˆ `O(n)`
- Inner loop can compare up to `m` characters each time: `O(m)`
  So total time = `O(n) * O(m) = O(n * m)`

**Space Complexity: `O(1)`**  
Only constant extra space is used.

---

## ğŸ§  KMP String Matching

### Algorithm 

1. If `needle` is empty, return `0`.
2. Build the **LPS array** for `needle`:
   - `lps[i]` = length of the longest proper prefix of `needle[0..i]` that is also a suffix.
3. Use two pointers:
   - `first` for `haystack`
   - `second` for `needle`
4. While `first < haystack.length()`:
   - If `haystack[first] == needle[second]`:
     - increment both pointers
     - if `second == needle.length()`, a full match is found â†’ return `first - second`
   - Else (mismatch):
     - if `second == 0`, move `first++`
     - otherwise set `second = lps[second - 1]` (jump using LPS)
5. If the loop ends without a full match, return `-1`.

``` cpp
#include <bits/stdc++.h>
using namespace std;

// KMP-based string matching (strStr): find first occurrence of needle in haystack
class Solution {
private:
    // Build LPS (Longest Prefix Suffix) array for pattern
    vector<int> buildLPS(const string& pat) {
        int m = (int)pat.size();
        vector<int> lps(m, 0);

        int pre = 0;   // length of the current longest prefix-suffix
        int suf = 1;   // current index being processed

        while (suf < m) {
            if (pat[pre] == pat[suf]) {
                lps[suf] = pre + 1;
                pre++;
                suf++;
            } else {
                if (pre == 0) {
                    lps[suf] = 0;
                    suf++;
                } else {
                    pre = lps[pre - 1]; // fallback
                }
            }
        }
        return lps;
    }

public:
    int strStr(string haystack, string needle) {
        int n = (int)haystack.size();
        int m = (int)needle.size();

        // Edge case: empty pattern
        if (m == 0) return 0;
        if (m > n) return -1;

        vector<int> lps = buildLPS(needle);

        int first = 0;   // pointer for haystack
        int second = 0;  // pointer for needle

        while (first < n) {
            if (haystack[first] == needle[second]) {
                first++;
                second++;

                // Full pattern matched
                if (second == m) {
                    return first - second; // starting index
                }
            } else {
                if (second == 0) {
                    first++; // move in haystack if no partial match
                } else {
                    second = lps[second - 1]; // jump using lps
                }
            }
        }

        return -1;
    }
};

int main() {
    Solution sol;

    string haystack = "ababcabcabababd";
    string needle = "ababd";

    int idx = sol.strStr(haystack, needle);

    cout << "haystack: " << haystack << "\n";
    cout << "needle: " << needle << "\n";
    cout << "first occurrence index: " << idx << "\n"; // expected: 10

    return 0;
}
```
### ğŸ“Š Complexity Analysis (KMP)

**Time Complexity: `O(n + m)`**  
- Building the LPS array takes `O(m)` where `m` is the length of `needle`.  
- Searching through `haystack` takes `O(n)` where `n` is the length of `haystack`, because pointers only move forward with efficient jumps using LPS.

**Space Complexity: `O(m)`**  
We store the LPS array of size `m`.
