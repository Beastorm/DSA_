# ðŸ“ Integer to Roman

> **Note:** `1 <= num <= 3999`
**Problem Statement**
Given an integer `num`, convert it to a Roman numeral.

Roman numerals use the following symbols:

- `I = 1`
- `V = 5`
- `X = 10`
- `L = 50`
- `C = 100`
- `D = 500`
- `M = 1000`

Subtractive cases:
- `IV = 4`, `IX = 9`
- `XL = 40`, `XC = 90`
- `CD = 400`, `CM = 900`


### ðŸ’¡ Examples

### Example 1
**Input:** `num = 58`  
**Output:** `"LVIII"`  
**Explanation:** `50 (L) + 5 (V) + 3 (III)`

### Example 2
**Input:** `num = 1994`  
**Output:** `"MCMXCIV"`  
**Explanation:** `1000 (M) + 900 (CM) + 90 (XC) + 4 (IV)`

---

## ðŸ§  Approach

### Algorithm
- Keep a list of Roman values and symbols in descending order, including subtractive pairs.
- Start from the largest value and subtract it from `num` while possible.
- Append the corresponding Roman symbol each time you subtract.
- Continue until `num` becomes `0`.

Roman numerals use only **7 base symbols**: `I, V, X, L, C, D, M`.  
To write numbers correctly, there are **6 special subtractive pairs**: `IV`, `IX`, `XL`, `XC`, `CD`, `CM`.

So the mapping list includes:

- **Base values:** `1, 5, 10, 50, 100, 500, 1000`
- **Subtractive values:** `4, 9, 40, 90, 400, 900`

These are the only â€œbuilding blocksâ€ needed; all other numbers are formed by repeating/combining them.

Subtractive values come from the Roman rule: a smaller symbol can go before a larger one **only to form 4 or 9 at each place value**.

So:

- **Ones:** `IV = 4`, `IX = 9`
- **Tens:** `XL = 40`, `XC = 90`
- **Hundreds:** `CD = 400`, `CM = 900`

Thatâ€™s why the subtractive values are exactly: `4, 9, 40, 90, 400, 900`.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    string intToRoman(int num) {
        vector<pair<int, string>> val = {
            {1000, "M"}, {900, "CM"}, {500, "D"}, {400, "CD"},
            {100, "C"},  {90, "XC"},  {50, "L"},  {40, "XL"},
            {10, "X"},   {9, "IX"},   {5, "V"},   {4, "IV"},
            {1, "I"}
        };

        string ans;
        for (auto &p : val) {
            int v = p.first;
            string sym = p.second;

            while (num >= v) {
                ans += sym;
                num -= v;
            }
        }
        return ans;
    }
};

int main() {
    Solution sol;
    int num = 1994;
    cout << sol.intToRoman(num) << "\n";
    return 0;
}
```
### ðŸ“Š Complexity Analysis

**Time Complexity: `O(1)`**  
The list of Roman symbols is of constant size, so the number of iterations is bounded.

**Space Complexity: `O(1)`**  
Extra space used is constant (ignoring the output string).
