# üìù Implement Atoi

**Problem Statement:**  
Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer.

The algorithm for `myAtoi(string s)` is as follows:

1. **Whitespace:** Ignore any leading whitespace (`" "`).
2. **Signedness:** Determine the sign by checking if the next character is `'-'` or `'+'`, assuming positivity if neither is present.
3. **Conversion:** Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is `0`.
4. **Rounding:** If the integer is out of the 32-bit signed integer range `[-2^31, 2^31 - 1]`, then round the integer to remain in the range:
   - If less than `-2^31`, return `-2^31`
   - If greater than `2^31 - 1`, return `2^31 - 1`

Return the integer as the final result.


### üí° Examples

### Example 1
**Input:**  
`s = "1337c0d3"`

**Output:**  
`1337`

**Explanation:**
- Step 1: `"1337c0d3"` (no leading whitespace)
- Step 2: `"1337c0d3"` (no sign character)
- Step 3: `"1337c0d3"` (`"1337"` is read; stop at `'c'`)

### Example 2
**Input:**  
`s = "words and 987"`

**Output:**  
`0`

**Explanation:**  
Reading stops at the first non-digit character `'w'`.

---

## üß† Approach

### Algorithm
- Ignore any leading whitespace to find where the number actually begins.
- Determine if the number is meant to be positive or negative by checking the sign symbol.
- Scan the digits one by one to build the number progressively from left to right.
- Each new digit contributes to the overall number by shifting the previous digits left (base 10).
- Watch for overflow by checking before each addition whether the next step would exceed integer limits.
- Once digit parsing ends, apply the sign and return the final result.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int myAtoi(string s) {
        // Initialize index, sign, and result
        int i = 0, sign = 1;
         // Use long to handle overflow
        long res = 0;

        // Skip leading whitespaces
        while (i < s.size() && s[i] == ' ') i++;

        // Return 0 if only spaces are found
        if (i == s.size()) return 0;

        // Check for optional '+' or '-' sign
        if (s[i] == '-') {
            sign = -1;
            i++;
        } else if (s[i] == '+') {
            i++;
        }

        // Convert characters to integer while valid digits
        while (i < s.size() && isdigit(s[i])) {
            res = res * 10 + (s[i] - '0');

            // Clamp to INT_MAX if overflow occurs
            if (sign * res > INT_MAX) return INT_MAX;

            // Clamp to INT_MIN if underflow occurs
            if (sign * res < INT_MIN) return INT_MIN;

            i++;
        }

        // Return final result after applying the sign
        return (int)(sign * res);
    }
};

int main() {
    Solution sol;
    
    string input = "   -42";

    int result = sol.myAtoi(input);
    cout << "Converted integer: " << result << endl;

    return 0;
}
```
### üìä Complexity Analysis

**Time Complexity: `O(N)`**  
`N` is the length of the string. We scan the string at most once.

**Space Complexity: `O(1)`**  
Only constant extra space is used.
