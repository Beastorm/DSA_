# ðŸ“ Remove Outermost Parentheses

 **Problem Statement**
A valid parentheses string is defined by the following rules:

- It is the empty string `""`.
- If `A` is a valid parentheses string, then so is `"(" + A + ")"`.
- If `A` and `B` are valid parentheses strings, then `A + B` is also valid.

A primitive valid parentheses string is a non-empty valid parentheses string that cannot be split into two or more non-empty valid parentheses strings.

Given a valid parentheses string `s`, your task is to remove the outermost parentheses from every primitive component of `s` and return the resulting string.

### ðŸ’¡ Examples

### Example 1
**Input:** `s = "((()))"`  
**Output:** `"(())"`  
**Explanation:** The input string is a single primitive: `"((()))"`. Removing the outermost layer yields `"(())"`.

### Example 2
**Input:** `s = "()(()())(())"`  
**Output:** `"(()())()"`  
**Explanation:** Primitive decomposition: `"()" + "(()())" + "(())"`  
After removing outermost parentheses: `"" + "()()" + "()"`  
Final result: `"(()())()"`.

---

## ðŸ§  Approach

### Algorithm / Intuition
We want to remove only the outermost parentheses of each primitive block.

Maintain:
- A result string `result`.
- An integer `level` to track the current nesting depth.

Traverse the string character by character:
- If the current character is `'('`:
  - If `level > 0`, we are already inside a primitive, so append `'('` to `result`.
  - Increment `level`.
- If the current character is `')'`:
  - Decrement `level`.
  - If `level > 0` after decrementing, we are still inside a primitive, so append `')'` to `result`.

The outermost parentheses of each primitive correspond to transitions:
- From `level = 0` to `1` on `'('` (skip adding this `'('`).
- From `level = 1` to `0` on `')'` (skip adding this `')'`).

After traversal, `result` contains the string with all primitive outermost parentheses removed.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to remove outer parentheses
    string removeOuterParentheses(string s) {
        // Initialize result string
        string result = "";
        // Initialize nesting level counter
        int level = 0;

        // Traverse the string
        for (char ch : s) {
            // If we encounter '(', increase the level
            if (ch == '(') {
                // If we're inside a primitive, add '(' to result
                if (level > 0) result += ch;
                // Increase the nesting level for '('
                level++;
            }
            // If we encounter ')', decrease the level
            else if (ch == ')') {
                // Decrease the nesting level for ')'
                level--;
                // If we're inside a primitive, add ')' to result
                if (level > 0) result += ch;
            }
        }

        // Return the final result after removing the outer parentheses
        return result;
    }
};

int main() {
    string s = "(()())(())";
    // Create object of Solution class
    Solution sol;

    // Get result
    string ans = sol.removeOuterParentheses(s);

    // Print result
    cout << "The result is: " << ans << endl;

    return 0;
}
```
### ðŸ“Š Complexity Analysis

**Time Complexity: `O(N)`**  
We traverse the string once, where `N` is the length of `s`.

**Space Complexity: `O(N)`**  
We store the resulting string, which in the worst case is proportional to the input size. Extra auxiliary space (besides output) is `O(1)`.

---

## ðŸ§  Approach -II: Stack-based Algorithm (Remove Outermost Parentheses)

### Initialize
- an empty string `result`
- an empty stack `st`

### Steps
Traverse the string `s` from left to right. For each character `ch`:

- If `ch == '('`:
  - If `st` is **not empty**, append `'('` to `result` (because it is **not** an outermost `(`).
  - Push `'('` onto the stack.

- Else if `ch == ')'`:
  - Pop the stack once (matching a previous `'('`).
  - If `st` is **not empty** after popping, append `')'` to `result` (because it is **not** an outermost `)`).

### Return
- Return `result`.

### Why it works
- The first `'('` of each primitive is the one encountered when the stack is empty â†’ we skip it.
- The last `')'` of each primitive makes the stack empty after popping â†’ we skip it.  
[video ref](https://www.youtube.com/watch?v=I0osO1BqiGw)

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    string removeOuterParentheses(string s) {
        string result;
        stack<char> st;

        for (char ch : s) {
            if (ch == '(') {
                // If stack is not empty, this '(' is NOT outermost => keep it
                if (!st.empty()) result += '(';
                st.push('(');
            } else { // ch == ')'
                st.pop();
                // After popping, if stack is still not empty, this ')' is NOT outermost => keep it
                if (!st.empty()) result += ')';
            }
        }
        return result;
    }
};

int main() {
    Solution sol;
    string s = "()(()())(())";
    cout << sol.removeOuterParentheses(s) << "\n"; // expected: (()())()
    return 0;
}
```
### ðŸ“Š Complexity
- **Time:** `O(N)` (one pass)
- **Space:** `O(N)` worst case for the stack (deep nesting) + output string
