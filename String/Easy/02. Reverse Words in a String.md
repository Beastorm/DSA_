# üìù Reverse Words in a String

**Problem Statement**
Given an input string containing upper-case and lower-case letters, digits, and spaces (`' '`):

- A **word** is defined as a sequence of non-space characters.
- Words in `s` are separated by **at least one space**.

Return a string with the words in **reverse order**, concatenated by a **single space**.

---

### üí° Examples

### Example 1
**Input:** `s = "welcome to the jungle"`  
**Output:** `"jungle the to welcome"`  

**Explanation:**  
The words are `"welcome"`, `"to"`, `"the"`, and `"jungle"`.  
Reversing their order gives `"jungle the to welcome"`.  
The output must contain **exactly one space** between words.

### Example 2
**Input:** `s = " amazing coding skills "`  
**Output:** `"skills coding amazing"`  

**Explanation:**  
The input has leading/trailing spaces and multiple spaces between words.  
After trimming and reducing spaces, the words are `"amazing"`, `"coding"`, `"skills"`.  
Reversing them gives `"skills coding amazing"`.  
The output has **no leading/trailing spaces** and **exactly one space** between words.

---

## üê¢ Brute Force Approach

### Algorithm
In the brute force method, we manually parse the string to extract words (without directly using high-level split functions). The idea is:

- Read the string character by character.
- Identify sequences of non-space characters as words.
- Ignore extra spaces (including leading/trailing spaces).
- Store all words, reverse them, and join with a single space.

### Steps
1. Initialize an empty list to store words.
2. Traverse the string character by character.
3. Identify consecutive non-space characters as a word.
4. Ignore extra spaces and leading/trailing spaces while collecting words.
5. Append each identified word to the list.
6. Reverse the list of words.
7. Join the reversed list into a single string using a single space.
8. Return the resulting string.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to reverse the order of words in a string
    string reverseWords(string s) {
        // Vector to store words
        vector<string> words;
        
        // Temporary string to store a single word
        string word = "";
        
        // Traverse the string character by character
        for (int i = 0; i < s.size(); i++) {
            // If the character is not a space, add it to the current word
            if (s[i] != ' ') {
                word += s[i];
            } 
            // If we encounter a space and have a word collected
            else if (!word.empty()) {
                // Push the collected word to words list
                words.push_back(word);
                // Reset word for next word collection
                word = "";
            }
        }
        
        // Push the last word if it exists
        if (!word.empty()) {
            words.push_back(word);
        }
        
        // Reverse the list of words
        reverse(words.begin(), words.end());
        
        // Join the words into a single string separated by spaces
        string result = "";
        for (int i = 0; i < words.size(); i++) {
            result += words[i];
            // Add a space if it's not the last word
            if (i < words.size() - 1) {
                result += " ";
            }
        }
        
        return result;
    }
};

// Driver code
int main() {
    Solution obj;
    string s = " amazing coding skills ";
    cout << obj.reverseWords(s) << endl;
    return 0;
}

```
### üìä Complexity Analysis

**Time Complexity: `O(N)`**  
We traverse the string once to collect words (`O(N)`) and once more to reverse and join them (`O(N)`). Hence, total time is `O(N)`.

**Space Complexity: `O(N)`**  
We store all words in a separate list/array, requiring extra space proportional to the number of characters.

---

## üß† Optimal Approach

### Algorithm
Instead of splitting into words and then reversing, we can scan the string from right to left and build the output directly. By starting at the end and identifying each word, we can append it to our result string immediately. We skip multiple spaces, handle leading/trailing spaces naturally, and avoid reversing the list separately which removes one extra pass. This reduces unnecessary data movement and avoids building a list to reverse later.

### Steps
- Initialize an empty result string.
- Set a pointer at the last character of the string.
- While the pointer is within the string:
  - Skip all spaces to move to the end of a word.
  - Mark the end position of the word.
  - Move the pointer backward until a space or start of string is found.
  - Extract the word and append it to the result string.
  - If result is not empty, add a space before appending the next word.
- Return the result string.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to reverse the order of words 
    string reverseWords(string s) {
        // Result string to store final output
        string result = "";
        
        // Pointer starting from the last character
        int i = s.size() - 1;
        
        // Traverse string from right to left
        while (i >= 0) {
            // Skip spaces at the current position
            while (i >= 0 && s[i] == ' ') {
                i--;
            }
            
            // If pointer is out of bounds, break
            if (i < 0) break;
            
            // Mark the end of the current word
            int end = i;
            
            // Move left until a space or start of string is found
            while (i >= 0 && s[i] != ' ') {
                i--;
            }
            
            // Extract the current word
            string word = s.substr(i + 1, end - i);
            
            // Add space before appending next word if result is not empty
            if (!result.empty()) {
                result += " ";
            }
            
            // Append the word to the result
            result += word;
        }
        
        return result;
    }
};

// Driver code
int main() {
    Solution obj;
    string s = " amazing coding skills ";
    cout << obj.reverseWords(s) << endl;
    return 0;
}

```
### üìä Complexity Analysis

**Time Complexity: `O(N)`**  
We traverse the string once from right to left and construct the result directly without extra passes.

**Space Complexity: `O(1)`**  
Ignoring the output string, no additional data structures proportional to input size are used.
