# üìù Largest Odd Number in a String

**Problem Statement**
Given a string `s` representing a large integer, return the **largest-valued odd integer** (as a string) that is a **substring** of `s`.

- The returned number should **not** have leading zeros.
- The given input string **may** have leading zeros.

---

### üí° Examples

### Example 1
**Input:**  
`s = "5347"`

**Output:**  
`"5347"`

**Explanation:**  
The odd numbers formed by the given string are ‚Üí `5`, `3`, `53`, `347`, `5347`.  
The largest odd number without leading zeroes is `"5347"`.

### Example 2
**Input:**  
`s = "0214638"`

**Output:**  
`"21463"`

**Explanation:**  
The odd numbers formed by the string are ‚Üí `1`, `3`, `21`, `63`, `463`, `1463`, `21463`.  
We can't use numbers starting with `0`, so the largest valid odd number is `"21463"`.  


### What are NOT ‚Äúlargest odd‚Äù (common wrong picks)

- **Even-ending substrings are not valid odd numbers**  
  Example: `"...8"`, `"...0"`, `"...2"` ‚Üí not odd.

- **Substrings that start with `0` are not allowed as the returned number**  
  Example: in `"0214638"`, `"021463"` is odd but invalid due to leading `0`.

- **A smaller odd substring when a bigger one exists**  
  Example: `s = "5347"`  
  Odd substrings include `"5"`, `"53"`, `"347"`, `"5347"`.  
  `"347"` is odd but not largest because `"5347"` is bigger.

- **Non-contiguous selections are not substrings**  
  Example: from `"12345"`, choosing `"135"` is not allowed (you skipped digits).


---

## üß† Approach

### Algorithm
- Focus on finding the **longest** valid odd number starting from the original string.
- An odd number must end with an **odd digit**, so scan from the end to find the **last odd digit**.
- Leading zeroes don‚Äôt add value to the number, so remove them for a cleaner representation.
- Once the endpoint (last odd digit) is determined:
  - Identify the starting point by skipping any leading zeroes before it.
- Extract the substring between these two positions. This gives the largest possible odd integer from the string.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Returns the largest odd number substring from the given string
    string largeOddNum(string& s) {
        int ind = -1;

        // Find the last odd digit in the string
        int i;
        for (i = s.length() - 1; i >= 0; i--) {
            if ((s[i] - '0') % 2 == 1) {
                ind = i;
                break;
            }
        }

        // Skip leading zeroes up to the odd digit
        i = 0;
        while (i <= ind && s[i] == '0') i++;

        // Return substring from first non-zero to odd digit
        return s.substr(i, ind - i + 1);
    }
};

int main() {
    Solution solution;
    string num = "504";
    string result = solution.largeOddNum(num);
    cout << "Largest odd number: " << result << endl;
    return 0;
}
```
### üìä Complexity Analysis

**Time Complexity: `O(N)`**  
The loop runs once through the string of length `N`.

**Space Complexity: `O(1)`**  
We use only a constant amount of extra space.
