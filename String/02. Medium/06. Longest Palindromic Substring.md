# ğŸ“ Longest Palindromic Substring

**Problem Statement:**  [ref](https://www.youtube.com/watch?v=vTlVtLvPQo4)  
Given a string `s`, return the **longest palindromic substring** in `s`.

### ğŸ’¡ Examples

### Example 1
**Input:**  
`s = "babad"`

**Output:**  
`"bab"`

**Explanation:**  
It is the longest palindromic substring. `"aba"` is also a valid answer.

### Example 2
**Input:**  
`s = "cbbd"`

**Output:**  
`"bb"`

**Explanation:**  
It is the longest palindromic substring.

---

## ğŸ§  Approach

### Intuition 
A palindrome looks the same from left and right, so it has a **center**.

- For every index, treat it as the center of an **odd** palindrome (like `"aba"`).
- Also treat the gap between two indices as the center of an **even** palindrome (like `"abba"`).
- Expand outward while the characters match.
- Keep the longest palindrome found.

### Algorithm
- The goal is to find the longest palindromic substring by treating each character (and each pair) as a potential **center**.
- Every palindrome is symmetric, so we **expand outward** from a center to check for symmetry.
- There are two types of centers to consider:
  - One at a character (**odd-length** palindrome)
  - One between two characters (**even-length** palindrome)
- For each center, expand left and right while the characters on both sides match.
- Keep track of the maximum length palindrome found by updating its start and end indices.
- The final result is the substring between the recorded boundaries of the longest expansion.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    string longestPalindrome(string str) {
        int start = 0, end = 0;

        // Iterate through each character as center
        for (int center = 0; center < str.length(); center++) {
            // Expand around odd-length palindrome
            int lenOdd = expandFromCenter(str, center, center);
            // Expand around even length palindrome
            int lenEven = expandFromCenter(str, center, center + 1);
            // Get the max of both lengths
            int maxLen = max(lenOdd, lenEven);

            // Update the longest palindrome boundaries
            if (maxLen > end - start) {
                start = center - (maxLen - 1) / 2;
                end = center + maxLen / 2;
            }
        }

        // Return the longest palindromic substring
        return str.substr(start, end - start + 1);
    }

private:
    int expandFromCenter(const string& str, int left, int right) {
        // Expand while characters match and within bounds
        while (left >= 0 && right < str.length() && str[left] == str[right]) {
            left--;
            right++;
        }
        // Return the length of the palindrome
        return right - left - 1;
    }
};

int main() {
    Solution sol;
    string input = "babad";
    cout << "Longest Palindromic Substring: " << sol.longestPalindrome(input) << endl;
    return 0;
}
```
### ğŸ“Š Complexity Analysis

**Time Complexity: `O(NÂ²)`**  
For each character (and pair of characters), expanding around the center could take up to `O(N)`.

**Space Complexity: `O(1)`**  
No extra space is used.

---

### Dry Run (Expand Around Center)
Input: `str = "babad"`  
Index:   0 1 2 3 4    
Chars:   b a b a d  

Initial: `start = 0, end = 0` (current best = `"b"`)  

---

### center = 0 (`'b'`)
**Odd (0,0):**  
- match `b==b` â†’ expand to `(-1,1)` stop  
`lenOdd = 1`

**Even (0,1):**  
- `b != a` stop  
`lenEven = 0`

`maxLen = 1`
- current best length = `end-start = 0`
- `1 > 0` â†’ update:
  - `start = 0 - (1-1)/2 = 0`
  - `end   = 0 + 1/2     = 0`
Best: `"b"`

---

### center = 1 (`'a'`)
**Odd (1,1):**  
- `a==a` â†’ expand (0,2)  
- `b==b` â†’ expand (-1,3) stop   
`lenOdd = 3` (substring `"bab"`)  

**Even (1,2):**  
- `a != b` stop  
`lenEven = 0`  

`maxLen = 3`  
- current best length = `0`  
- `3 > 0` â†’ update:  
  - `start = 1 - (3-1)/2 = 1 - 1 = 0`  
  - `end   = 1 + 3/2     = 1 + 1 = 2`  
Best: `"bab"`  

---

### center = 2 (`'b'`)  
**Odd (2,2):**  
- `b==b` â†’ expand (1,3)  
- `a==a` â†’ expand (0,4)  
- `b != d` stop    
`lenOdd = 3` (substring `"aba"`)  

**Even (2,3):**  
- `b != a` stop  
`lenEven = 0`  

`maxLen = 3`  
- current best length = `end-start = 2`  
- check: `3 > 2` â†’ update (ties could go either way, but here it updates):  
  - `start = 2 - (3-1)/2 = 2 - 1 = 1`  
  - `end   = 2 + 3/2     = 2 + 1 = 3`  
Best: `"aba"`  

---

### center = 3 (`'a'`)  
**Odd (3,3):**  
- `a==a` â†’ expand (2,4)  
- `b != d` stop   
`lenOdd = 1`  

**Even (3,4):**  
- `a != d` stop  
`lenEven = 0`  

`maxLen = 1`  
- `1 > (end-start=2)`? no â†’ no update  
Best remains: `"aba"`  

---

### center = 4 (`'d'`)
**Odd (4,4):**  
- `d==d` â†’ expand (3,5) stop  
`lenOdd = 1`  

**Even (4,5):**  
out of bounds â†’ `lenEven = 0`  

`maxLen = 1` â†’ no update  

---

### Final Answer  
`start = 1`, `end = 3` â†’ substring = `"aba"`  

(For `"babad"`, `"bab"` is also a valid longest palindrome of length 3, but this run ends with `"aba"`.)  
