# üìù Count Number of Substrings

**Problem Statement:** [ref](https://www.youtube.com/watch?v=CBSeilNvZHs)  
You are given a string `s` and a positive integer `k`.  
Return the number of substrings that contain **exactly `k` distinct characters**.


### üí° Examples

### Example 1
**Input:**  
`s = "pqpqs", k = 2`

**Output:**  
`7`

**Explanation:**  
All substrings with exactly `2` distinct characters:  
`"pq"`, `"pqp"`, `"pqpq"`, `"qp"`, `"qpq"`, `"pqs"`, `"qs"`  
Total = `7`.

### Example 2
**Input:**  
`s = "abcbaa", k = 3`

**Output:**  
`5`

**Explanation:**    
All substrings with exactly `3` distinct characters:  
`"abc"`, `"abcb"`, `"abcba"`, `"bcba"`, `"cbaa"`  
Total = `5`.

---
### Why `exactly k = atMost(k) - atMost(k-1)`?

- `atMost(k)` counts substrings with **1, 2, ..., up to k** distinct characters.
- `atMost(k-1)` counts substrings with **1, 2, ..., up to k-1** distinct characters.

So if you subtract them:

- `(substrings with ‚â§ k distinct)`  
  minus  
- `(substrings with ‚â§ k-1 distinct)`

You remove everything that has **k-1 or fewer** distinct characters, and what remains are only substrings with **exactly k** distinct characters.

**In short:**  
`(‚â§ k) - (‚â§ k-1) = (= k)`

### Tiny Example
String: `"aa"`
- Substrings: `"a"`, `"a"`, `"aa"` ‚Üí all have **1** distinct character
- `atMost(2) = 3`, `atMost(1) = 3`
- `exactly 2 = 3 - 3 = 0`
---

## üß† Approach

### Algorithm
Define a helper function `atMostKDistinct(s, k)`:

- Use a sliding window with two pointers (`left` and `right`) and a frequency map.
- Expand the window by moving the `right` pointer and counting characters.
- If the count of distinct characters exceeds `k`, shrink the window by moving the `left` pointer.
- For each valid window, add `(right - left + 1)` to the result.

To find substrings with **exactly** `k` distinct characters, calculate:

`atMostKDistinct(s, k) - atMostKDistinct(s, k - 1)`

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Function to count substrings with at most k distinct characters
int atMostKDistinct(string s, int k) {
    // Left pointer and result
    int left = 0, res = 0;
    // Frequency map
    unordered_map<char, int> freq;

    // Iterate through string with right pointer
    for (int right = 0; right < s.size(); right++) {
        // Add current character
        freq[s[right]]++;

        // Shrink window if distinct characters exceed k
        while (freq.size() > k) {
            freq[s[left]]--;
            if (freq[s[left]] == 0) freq.erase(s[left]);
            left++;
        }

        // Count substrings in current window
        res += (right - left + 1);
    }
    return res;
}

// Function to count substrings with exactly k distinct characters
int countSubstrings(string s, int k) {
    // Exactly k = atMost(k) - atMost(k-1)
    return atMostKDistinct(s, k) - atMostKDistinct(s, k - 1);
}

int main() {
    // Sample test
    string s = "pqpqs";
    int k = 2;

    // Output the result
    cout << "Count: " << countSubstrings(s, k) << endl; // Output: 7
    return 0;
}
```
### üìä Complexity Analysis

**Time Complexity:** `O(n)` for each call to `atMostKDistinct`.

**Space Complexity:** `O(1)` since the map size is bounded (at most `26` characters for alphabets).

---
### Dry Run for `s = "pqpqs"`, `k = 2`

We compute:

- `exactlyK = atMostKDistinct(s, 2) - atMostKDistinct(s, 1)`

---

### 1) `atMostKDistinct("pqpqs", 2)`

- `left = 0`, `res = 0`, `freq = {}`

At each `right`, we:
1) add `s[right]` to `freq`
2) shrink while `freq.size() > k`
3) add `(right - left + 1)` to `res`

### right = 0, char = 'p'
- freq = `{p:1}` (distinct=1)
- add `right-left+1 = 1`
- res = `1`

### right = 1, char = 'q'
- freq = `{p:1, q:1}` (distinct=2)
- add `2`
- res = `3`

### right = 2, char = 'p'
- freq = `{p:2, q:1}` (distinct=2)
- add `3`
- res = `6`

### right = 3, char = 'q'
- freq = `{p:2, q:2}` (distinct=2)
- add `4`
- res = `10`

### right = 4, char = 's'
- freq = `{p:2, q:2, s:1}` (distinct=3 > 2) ‚Üí shrink
  - left=0 ('p'): `{p:1,q:2,s:1}` distinct=3, left=1
  - left=1 ('q'): `{p:1,q:1,s:1}` distinct=3, left=2
  - left=2 ('p'): `{p:0,q:1,s:1}` remove p ‚Üí `{q:1,s:1}` distinct=2, left=3
- valid window: `s[3..4] = "qs"`
- add `right-left+1 = 2`
- res = `12`

‚úÖ `atMostKDistinct(s, 2) = 12`

---

### 2) `atMostKDistinct("pqpqs", 1)`

- `left = 0`, `res = 0`, `freq = {}`

### right = 0, char = 'p'
- freq = `{p:1}` distinct=1
- add `1`
- res = `1`

### right = 1, char = 'q'
- freq = `{p:1,q:1}` distinct=2 > 1 ‚Üí shrink
  - left=0 ('p'): `{p:0,q:1}` remove p ‚Üí `{q:1}`, left=1
- add `1`
- res = `2`

### right = 2, char = 'p'
- freq = `{q:1,p:1}` distinct=2 > 1 ‚Üí shrink
  - left=1 ('q'): `{q:0,p:1}` remove q ‚Üí `{p:1}`, left=2
- add `1`
- res = `3`

### right = 3, char = 'q'
- freq = `{p:1,q:1}` distinct=2 > 1 ‚Üí shrink
  - left=2 ('p'): `{p:0,q:1}` remove p ‚Üí `{q:1}`, left=3
- add `1`
- res = `4`

### right = 4, char = 's'
- freq = `{q:1,s:1}` distinct=2 > 1 ‚Üí shrink
  - left=3 ('q'): `{q:0,s:1}` remove q ‚Üí `{s:1}`, left=4
- add `1`
- res = `5`

‚úÖ `atMostKDistinct(s, 1) = 5`

---

### 3) Exactly `k = 2` distinct
- `exactly 2 = atMost(2) - atMost(1)`
- `= 12 - 5`
- `= 7`

‚úÖ Final Answer: `7`

