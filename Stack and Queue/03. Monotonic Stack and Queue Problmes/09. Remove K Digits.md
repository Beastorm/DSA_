## Remove `K` Digits

**Problem Statement:**  
Given a string `nums` representing a non-negative integer, and an integer `k`, find the smallest possible integer after removing `k` digits from `num`.

---

>### Examples:

**Example 1:**  
**Input:** nums = "541892", k = 2  
**Output:** "1892"  
**Explanation:** Removing the two digits 5 and 4 yields the smallest number, 1892.

**Example 2:**  
**Input:** nums = "1002991", k = 3  
**Output:** "21"  
**Explanation:** Remove the three digits 1 (leading one), 9, and 9 to form the new number 21 (Note that the output must not contain leading zeroes), which is the smallest.

---

## Approach

### Algorithm:

1. Use a stack to store the digits of the resulting number.
2. Iterate through each digit of the input string.
3. While the stack is not empty, the current digit is smaller than the top of the stack, and `k` is greater than `0`, pop from the stack and decrement `k`.
4. Push the current digit onto the stack.
5. If `k` is still greater than `0` after the iteration, remove digits from the end of the stack.
6. Collect the remaining digits from the stack to form the result.
7. Remove any leading `zeroes` from the result.
8. If the result is empty after removing zeroes, return `0`.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the smallest possible integer after removing k digits
    string removeKdigits(string nums, int k) {
        
        stack <char> st; // Stack
        
        // Traverse on the given string
        for(int i=0; i < nums.size(); i++) {
            
            // Current digit
            char digit = nums[i];
            
            // Pop last digits (when possible) if a smaller digit is found
            while(!st.empty() && k > 0
                  && st.top() > digit) {

                st.pop(); // Pop the last digit
                k--; // Decrement K by 1
            }
            
            // Push the current digit
            st.push(digit);
        }
        
        // If more digits can be removed
        while(!st.empty() && k > 0) {
            
            st.pop(); // Pop the last added digits
            k--; // Decrement K by 1
        }
        
        // Handling edge case
        if(st.empty()) return "0";
        
        // To store the result
        string res = "";
        
        // Adding digits in the stack to the result
        while(!st.empty()) {
            res.push_back(st.top());
            st.pop();
        }
        
        // Trimming the zeroes at the back
        while(res.size() > 0 && 
              res.back() == '0') {

            res.pop_back();
        }
        
        // Reverse to get the actual number
        reverse(res.begin(), res.end());
        
        // Edge case
        if(res.empty()) return "0";
        
        // Return the stored result
        return res;
    }
};

int main() {
    string nums = "541892";
    int k = 2;
    
    // Creating an instance of the Solution class
    Solution sol; 
    
    // Function call to find the smallest possible integer after removing k digits
    string ans = sol.removeKdigits(nums, k);
    
    cout << "The smallest possible integer after removing k digits is: " << ans;
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** $O(N)$  
  Traversing the given string takes $O(N)$ time. Each element is pushed onto and popped from the stack at most once, which is $O(N)$. Removing the remaining digits (if `k > 0`) takes $O(k)$ time, which can go up to $O(N)$ in the worst case. Forming the result, trimming the zeros, and reversing the digits also takes $O(N)$ time. Thus, the overall time complexity is $O(N)$.

- **Space Complexity:** $O(N)$  
  We are using a stack 
