## Maximal Rectangles

**Problem Statement:**  
Given an `m x n` binary matrix filled with `0's` and `1's`, find the largest rectangle containing only `1's` and return its area.

---

>### Examples:

**Example 1:**  
**Input:**    
matrix = [[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]  
**Output:**   6  
**Explanation:**    
The largest rectangle of only 1's has an area of 6, formed by the 2Ã—3 block of 1's in rows 1 and 2, columns 2 to 4.

**Example 2:**  
**Input:**    
matrix = [[1]]  
**Output:**   1  
**Explanation:**    
In this case, there is only one rectangle with an area of 1.

<img src="https://static.takeuforward.org/content/1.png-OQ0q1fFP" alt="Maximal Rectangle Example" width="420"/>

---

## Approach

### Algorithm:

1. Convert the binary matrix into a matrix of histogram heights using the prefix sum technique.
2. For each cell in the histogram matrix, calculate the height of consecutive 1's ending at that cell.
3. If a cell contains a 0, reset the height to 0.
4. For each row in the histogram matrix, treat it as a histogram and compute the largest rectangle area.
5. Use a stack-based approach to find the largest rectangle in the histogram for each row.
6. Track the maximum rectangle area found across all rows.
7. Return the maximum rectangle area as the result.


``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Function to find the largest rectangle area
    int largestRectangleArea(vector<int> &heights) {
        
        int n = heights.size(); // Size of array
        
        // Stack 
        stack<int> st;
        
        // To store largest area
        int largestArea = 0;
        
        // To store current area
        int area;
        
        /* To store the indices of next 
        and previous smaller elements */
        int nse, pse;
        
        // Traverse on the array
        for(int i=0; i < n; i++) {
            
            /* Pop the elements in the stack until 
            the stack is not empty and the top 
            elements is not the smaller element */
            while(!st.empty() && 
                  heights[st.top()] >= heights[i]){
                      
                // Get the index of top of stack
                int ind = st.top(); 
                st.pop();
                
                /* Update the index of 
                previous smaller element */
                pse = st.empty() ? -1 : st.top();
                
                /* Next smaller element index for 
                the popped element is current index */
                nse = i;
                
                // Calculate the area of the popped element
                area = heights[ind] * (nse-pse-1);
                
                // Update the maximum area
                largestArea = max(largestArea, area);
            }
            
            // Push the current index in stack
            st.push(i);
        }
        
        // For elements that are not popped from stack
        while(!st.empty()) {
            
            // NSE for such elements is size of array
            nse = n;
            
            // Get the index of top of stack
            int ind = st.top(); 
            st.pop();
            
            // Update the previous smaller element
            pse = st.empty() ? -1 : st.top();
            
            // Calculate the area of the popped element
            area = heights[ind] * (nse-pse-1);
            
            // Update the maximum area
            largestArea = max(largestArea, area);
        }
        
        // Return largest area found
        return largestArea;
    }
    
public:
    /* Function to find the largest 
    rectangle area containing all 1s */ 
    int maximalAreaOfSubMatrixOfAll1(vector<vector<int>> &matrix){
        
        // Determine the size of the matrix
        int n = matrix.size();
        int m = matrix[0].size();
        
        /* Prefix sum matrix to store heights 
        for different ground levels */
        vector<vector<int>> prefixSum(n, vector<int>(m));
        
        // Fill up the prefix sum matrix column-wise
        for(int j=0; j < m; j++) {
            int sum = 0;
            
            for(int i=0; i < n; i++) {
                sum += matrix[i][j];
                
                // If there is no base present
                if(matrix[i][j] == 0) {
                    prefixSum[i][j] = 0;
                    sum = 0;
                }
                
                // Store the height
                prefixSum[i][j] = sum;
            }
        }
        
        // To store the maximum area
        int maxArea = 0;
        
        // Traverse for different levels of ground
        for(int i = 0; i < n; i++) {
            
            // Get the largest area for current level
            int area = largestRectangleArea(prefixSum[i]);
            
            // Update the maximum area
            maxArea = max(area, maxArea);
        }
        
        // Return the maximum area
        return maxArea;
    }
};

int main() {
    vector<vector<int>> matrix = {
        {1, 0, 1, 0, 0}, 
        {1, 0, 1, 1, 1}, 
        {1, 1, 1, 1, 1}, 
        {1, 0, 0, 1, 0}
    };
    
    /* Creating an instance of 
    Solution class */
    Solution sol; 
    
    /* Function call to find the largest 
    rectangle area containing all 1s */
    int ans = 
        sol.maximalAreaOfSubMatrixOfAll1(matrix);
    
    cout << "The largest rectangle area containing all 1s is: " << ans;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N*M)  
  Filling the prefix sum matrix takes O(N*M) time, and for each of the N rows, we treat it as a histogram and find the largest rectangle in O(M) time using a stack. Thus, the overall time complexity is O(N*M).

- **Space Complexity:** O(N*M)  
  The prefix sum array takes O(N*M) space, and finding the largest rectangle in each histogram (of length M) takes O(M) space due to the stack. The total space complexity is O(N*M).
