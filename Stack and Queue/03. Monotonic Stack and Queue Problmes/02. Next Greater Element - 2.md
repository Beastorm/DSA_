## Next Greater Element - 2

**Problem Statement:**  
Given a circular integer array `arr`, return the next greater element for every element in `arr`.  
The next greater element for an element `x` is the first element greater than `x` that we come across while traversing the array in a clockwise manner.  
If it doesn't exist, return `-1` for that element.

---

>### Examples:

**Example 1:**  
**Input:** arr = [3, 10, 4, 2, 1, 2, 6, 1, 7, 2, 9]   
**Output:**  [10, -1, 6, 6, 2, 6, 7, 7, 9, 9, 10]   

**Example 2:**  
**Input:**  arr = [5, 7, 1, 7, 6, 0]  
**Output:**   [7, -1, 7, -1, 7, 5]

---

## Brute Force

### Algorithm:

1. Create an array to store the answer of the same size as the input array, filled with `-1`.
2. Iterate through each element at index `i` from `0` to `n-1`.
3. For each element, start a second loop from `1` to `n-1` to check the next elements in circular order using `(i + j) % n`.
4. If a greater element than the current one is found during the inner loop, assign it to `answer[i]` and exit the inner loop.
5. After completing both loops, return the answer array containing the next greater elements.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:

    /* Function to find the next greater element
    for each element in the circular array */
    vector<int> nextGreaterElements(vector<int> arr) {
       
        int n = arr.size(); // size of array
        
        // To store the next greater elements
        vector<int> ans(n, -1);
        
        for(int i=0; i < n; i++) {
            
            // Get the current element
            int currEle = arr[i];
             
            // Nested loop to get the next greater element
            for(int j=1; j < n; j++) {
                
                // Getting the hypothetical index
                int ind = (j+i) % n;
                
                // If the next greater element is found
                if(arr[ind] > currEle) {
                    
                    // Store the next greater element
                    ans[i] = arr[ind];
                    
                    // Break from the loop
                    break;
                }    
            }
        }
       
        // Return the answer
        return ans;
    }
};

int main() {
    int n = 6;
    vector<int> arr = {5, 7, 1, 7, 6, 0};
   
    // Creating an instance of the Solution class
    Solution sol; 
   
    /* Function call to find the next greater element
    for each element in the circular array */
    vector<int> ans = sol.nextGreaterElements(arr);
   
    cout << "The next greater elements are: ";
    for(int i=0; i < n; i++) {
        cout << ans[i] << " ";
    }
   
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N^2)  
  Since we are using two nested for loops to find the next greater elements.

- **Space Complexity:** O(N)  
  The space required to store the answer is O(N).

---

## Optimal Approach

### Algorithm:

1. Initialize an answer array with default values of `-1`.
2. Initialize an empty stack to keep track of elements.
3. Traverse from `2n - 1` down to `0` (where `n` is the length of the array) using modulus to simulate circular indexing.
4. While the stack is not empty and the top of the stack is less than or equal to the current element, pop from the stack.
5. If the index is in the original array range (i.e., `i < n`), assign the top of the stack to the answer if the stack is not empty, else keep `-1`.
6. Push the current element onto the stack.
7. After traversal ends, return the answer array.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:

    /* Function to find the next greater 
    element for each element in the array */
    vector<int> nextGreaterElements(vector<int> arr) {
        
        int n = arr.size(); //size of array
        
        // To store the next greater elements
        vector<int> ans(n);
        
        // Stack to get elements in LIF fashion
        stack<int> st;
        
        // Start traversing from the back
        for(int i = 2*n-1; i >= 0; i--) {
            
            // Get the actual index
            int ind = i % n;
            
            // Get the current element
            int currEle = arr[ind];
            
            /* Pop the elements in the stack until 
            The stack is not empty, and the top 
            element is not the greater element */
            while(!st.empty() && st.top() <= currEle) {
                st.pop();
            }
            
            // Store the answer for the second half
            if(i < n) {
                
                /* If the greater element is not 
                found, stack will be empty */
                if(st.empty()) 
                    ans[i] = -1;
                    
                // Else store the answer
                else 
                    ans[i] = st.top();
            }
            
            /* Push the current element in the stack 
            maintaining the decreasing order */
            st.push(currEle);
        }
        
        // Return the result
        return ans;
    }
};

int main() {
    int n = 6;
    vector<int> arr = {5, 7, 1, 7, 6, 0};
    
    // Creating an instance of the Solution class
    Solution sol; 
    
    /* Function call to find the next greater 
    element for each element in the array */
    vector<int> ans = sol.nextGreaterElements(arr);
    
    cout << "The next greater elements are: ";
    for(int i=0; i < n; i++) {
        cout << ans[i] << " ";
    }
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(N)
  - The loop runs from `2n-1` down to `0`, i.e., `2N` iterations, but each element is pushed and popped from the stack at most once.
  - For each element, we may pop several elements from the stack, but each element is pushed and popped only once in total.
  - Thus, the total number of stack operations is O(N).
  - Therefore, the overall time complexity is O(N).

- **Space Complexity:** O(N)
  - The answer array `ans` uses O(N) space to store the next greater elements.
  - The stack `st` can hold up to N elements in the worst case (e.g., if the array is strictly decreasing).
  - Thus, the total space used is O(N) for the answer array plus O(N) for the stack, which is O(N) overall.
