## Sum of Subarray Ranges

**Problem Statement:**  
Given an integer array `nums`, determine the range of a subarray, defined as the difference between the largest and smallest elements within the subarray. Calculate and return the sum of all subarray ranges of `nums`.

A subarray is defined as a contiguous, non-empty sequence of elements within the array.

---

>### Examples:

**Example 1:**  
**Input:** nums = [1, 2, 3]  
**Output:** 4  
**Explanation:**
```
The 6 subarrays of nums are the following:  
[1], range = 1 - 1 = 0  
[2], range = 2 - 2 = 0  
[3], range = 3 - 3 = 0  
[1,2], range = 2 - 1 = 1  
[2,3], range = 3 - 2 = 1  
[1,2,3], range = 3 - 1 = 2  
Sum = 0 + 0 + 0 + 1 + 1 + 2 = 4
```

**Example 2:**  
**Input:** nums = [1, 3, 3]  
**Output:**  4  
**Explanation:**  
```
The 6 subarrays of nums are the following:  
[1], range = 1 - 1 = 0  
[3], range = 3 - 3 = 0  
[3], range = 3 - 3 = 0  
[1,3], range = 3 - 1 = 2  
[3,3], range = 3 - 3 = 0  
[1,3,3], range = 3 - 1 = 2  
Sum = 0 + 0 + 0 + 2 + 0 + 2 = 4
```
---

## Brute Force

### Algorithm:

1. Initialize a variable to store the total sum as 0.
2. Loop through the array to fix the starting index of the subarray.
3. Initialize two variables to track the minimum and maximum for the current subarray.
4. Use an inner loop to extend the subarray to the right.
5. Update the minimum and maximum values as the subarray grows.
6. Calculate the range as maximum minus minimum, and add it to the total sum.
7. Repeat this for all possible subarrays.
8. Return the total sum after processing all subarrays.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:

    // Function to find the sum of subarray ranges in each subarray 
    long long subArrayRanges(vector<int> &arr) {
        
        // Size of array
        int n = arr.size();
        
        // To store the sum
        long long sum = 0;
        
        // Traverse the array
        for(int i=0; i < n; i++) {
            
            // To store the smallest value of the subarray
            int smallest = arr[i];
            
            // To store the largest value of the subarray
            int largest = arr[i];
            
            // Nested loop to get all subarrays starting from index i
            for(int j=i; j < n; j++) {
                
                // Update the smallest value
                smallest = min(smallest, arr[j]);
                
                // Update the largest value
                largest = max(largest, arr[j]);
                
                // Update the sum
                sum += (largest - smallest);
            }
        }
        
        // Return the computed sum
        return sum;
    }
};

int main() {
    vector<int> arr = {1, 2, 3};
    
    // Creating an instance of the Solution class
    Solution sol; 
    
    // Function call to find the sum of subarray ranges in each subarray 
    long long ans = sol.subArrayRanges(arr);
    
    cout << "The sum of subarray ranges is: " << ans;
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(NÂ²)  
  Since we are using two nested loops to consider all possible subarrays.

- **Space Complexity:** O(1)  
  Since we are using only a couple of variables for tracking min, max, and the total sum.

---
## Optimal Approach

### Algorithm:

1. *Find the index of the next smaller element to the right (NSE) for each element* using a stack.
2. *Find the index of the previous smaller or equal element to the left (PSEE) for each element* using a stack.
3. *Find the index of the next greater element to the right (NGE) for each element* using a stack.
4. *Find the index of the previous greater or equal element to the left (PGEE) for each element* using a stack.
5. *Calculate the total contribution of each element as the minimum in subarrays* using NSE and PSEE indices.
6. *Calculate the total contribution of each element as the maximum in subarrays* using NGE and PGEE indices.
7. *Subtract the total of subarray minimums from the total of subarray maximums* to get the sum of ranges of all subarrays.
8. *Return the result* as the sum of ranges of all subarrays.


### C+++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Function to find the indices of next smaller elements
    vector<int> findNSE(vector<int> &arr) {
        
        // Size of array
        int n = arr.size();
        
        // To store the answer
        vector<int> ans(n);
        
        // Stack 
        stack<int> st;
        
        // Start traversing from the back
        for(int i = n - 1; i >= 0; i--) {
            
            // Get the current element
            int currEle = arr[i];
            
            // Pop the elements in the stack until the stack is not empty, and the top element is not the smaller element
            while(!st.empty() && arr[st.top()] >= currEle){
                st.pop();
            }
            
            // Update the answer
            ans[i] = !st.empty() ? st.top() : n;
            
            // Push the index of the current element in the stack
            st.push(i);
        }
        
        // Return the answer
        return ans;
    }
    
    // Function to find the indices of next greater elements 
    vector<int> findNGE(vector<int> &arr) {
        
        // Size of array
        int n = arr.size();
        
        // To store the answer
        vector<int> ans(n);
        
        // Stack 
        stack<int> st;
        
        // Start traversing from the back
        for(int i = n - 1; i >= 0; i--) {
            
            // Get the current element
            int currEle = arr[i];
            
            // Pop the elements in the stack until the stack is not empty, and the top element is not the greater element
            while(!st.empty() && arr[st.top()] <= currEle){
                st.pop();
            }
            
            // Update the answer
            ans[i] = !st.empty() ? st.top() : n;
            
            // Push the index of the current element in the stack
            st.push(i);
        }
        
        // Return the answer
        return ans;
    }
    
    // Function to find the indices of previous smaller or equal elements 
    vector<int> findPSEE(vector<int> &arr) {
        
        // Size of array
        int n = arr.size();
        
        // To store the answer
        vector<int> ans(n);
        
        // Stack 
        stack<int> st;
        
        // Traverse the array
        for(int i=0; i < n; i++) {
            
            // Get the current element
            int currEle = arr[i];
            
            // Pop the elements in the stack until the stack is not empty, and the top elements are greater than the current element
            while(!st.empty() && arr[st.top()] > currEle){
                st.pop();
            }
            
            // Update the answer
            ans[i] = !st.empty() ? st.top() : -1;
            
            // Push the index of the current element in the stack 
            st.push(i);
        }
        
        // Return the answer
        return ans;
    }
    
    // Function to find the indices of previous greater than or equal elements
    vector<int> findPGEE(vector<int> &arr) {
        
        // Size of array
        int n = arr.size();
        
        // To store the answer
        vector<int> ans(n);
        
        // Stack 
        stack<int> st;
        
        // Traverse the array
        for(int i=0; i < n; i++) {
            
            // Get the current element
            int currEle = arr[i];
            
            // Pop the elements in the stack until the stack is not empty, and the top elements are smaller than the current element
            while(!st.empty() && arr[st.top()] < currEle){
                st.pop();
            }
            
            // Update the answer
            ans[i] = !st.empty() ? st.top() : -1;
            
            // Push the index of the current element in the stack
            st.push(i);
        }
        
        // Return the answer
        return ans;
    }
    
    // Function to find the sum of the minimum value in each subarray
    long long sumSubarrayMins(vector<int> &arr) {
        
        vector<int> nse = findNSE(arr);
        
        vector<int> psee = findPSEE(arr);
        
        // Size of array
        int n = arr.size();
        
        // To store the sum
        long long sum = 0;
        
        // Traverse the array
        for(int i=0; i < n; i++) {
            
            // Count of first type of subarrays
            int left = i - psee[i];
            
            // Count of the second type of subarrays
            int right = nse[i] - i;
            
            // Count of subarrays where the current element is the minimum 
            long long freq = left*right*1LL;
            
            // Contribution due to the current element 
            long long val = (freq*arr[i]*1LL);
            
            // Updating the sum
            sum += val;
        }
        
        // Return the computed sum
        return sum;
    }
    
    // Function to find the sum of the maximum value in each subarray
    long long sumSubarrayMaxs(vector<int> &arr) {
        
        vector<int> nge = findNGE(arr);
        
        vector<int> pgee = findPGEE(arr);
        
        // Size of array
        int n = arr.size();
        
        // To store the sum
        long long sum = 0;
        
        // Traverse the array
        for(int i=0; i < n; i++) {
            
            // Count of first type of subarrays
            int left = i - pgee[i];
            
            // Count of the second type of subarrays
            int right = nge[i] - i;
            
            // Count of subarrays where the current element is the minimum
            long long freq = left*right*1LL;
            
            // Contribution due to the current element 
            long long val = (freq*arr[i]*1LL);
            
            // Updating the sum
            sum += val;
        }
        
        // Return the computed sum
        return sum;
    }
    
public:
    // Function to find the sum of subarray ranges in each subarray
    long long subArrayRanges(vector<int> &arr) {
        
        // Return the result
        return ( sumSubarrayMaxs(arr) - sumSubarrayMins(arr) );
    }
};

int main() {
    vector<int> arr = {1, 2, 3};
    
    // Creating an instance of the Solution class
    Solution sol; 
    
    // Function call to find the sum of subarray ranges in each subarray
    long long ans = sol.subArrayRanges(arr);
    
    cout << "The sum of subarray ranges is: " << ans;
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** $O(N)$  
  Calculating the sum of subarray maximums takes $O(N)$ time, and calculating the sum of subarray minimums also takes $O(N)$ time, resulting in an overall linear time complexity.

- **Space Complexity:** $O(N)$  
  Calculating the sum of subarray maximums and minimums requires $O(N)$ space each for storing indices and stack data, resulting in an overall linear space complexity.
