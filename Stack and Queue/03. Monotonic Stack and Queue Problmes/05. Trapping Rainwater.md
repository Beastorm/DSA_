## Trapping Rainwater

**Problem Statement:**  
Given an array of non-negative integers representing the elevation of the ground, your task is to find the water that can be trapped after rain.

---

>### Examples:

<img src="https://static.takeuforward.org/content/1.png-SCrFDeNZ" alt="Trapping Rainwater Example" width="420"/>

**Input:**  
height = [0,1,0,2,1,0,1,3,2,1,2,1]  
**Output:** 6  
**Explanation:** Water is trapped in the dips between bars. The total trapped water units add up to 6 (1+1+2+1+1).

**Input:**  
height = [4,2,0,3,2,5]  
**Output:** 9  
**Explanation:** The elevation map traps 9 units of water in total, as water fills the spaces between higher bars on both sides.

---

## Brute Force Approach

### Algorithm:

1. For each bar in the array, find the maximum height bar on its left.
2. Find the maximum height bar on its right.
3. Calculate the trapped water on the current bar as `min(maxLeft, maxRight) - current height`.
4. If the current bar is taller than both sides, no water can be trapped there.
5. Sum all trapped water from each bar to get the total amount of trapped water.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate trapped rainwater using a brute force approach
    int trap(vector<int>& height) {
        int n = height.size();
        
        // Variable to store total trapped water
        int totalWater = 0;
        
        // Iterate over each bar in the elevation map
        for (int i = 0; i < n; i++) {
            // Initialize max heights to the left and right of the current bar
            int maxLeft = 0;
            int maxRight = 0;
            
            // Find maximum height to the left of the current bar
            for (int j = 0; j <= i; j++) {
                if (height[j] > maxLeft) {
                    maxLeft = height[j];
                }
            }
            
            // Find maximum height to the right of the current bar
            for (int j = i; j < n; j++) {
                if (height[j] > maxRight) {
                    maxRight = height[j];
                }
            }
            
            // Water trapped on current bar is min of maxLeft and maxRight minus current height
            totalWater += min(maxLeft, maxRight) - height[i];
        }
        
        // Return total trapped water
        return totalWater;
    }
};

// Driver code
int main() {
    // Input elevation map
    vector<int> height = {0,1,0,2,1,0,1,3,2,1,2,1};
    
    // Create Solution object
    Solution sol;
    
    // Calculate trapped water
    int result = sol.trap(height);
    
    // Print the result
    cout << "Trapped Rainwater: " << result << endl;
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(nÂ²)  
  For each bar, we scan all bars to its left and right to find the maximum height, resulting in nested loops.

- **Space Complexity:** O(1)  
  No additional data structures are used proportional to input size, only variables to track max heights and total water.

---
## Better Approach

### Intuition:

To determine how much water can be trapped at each position, we need to know the tallest bar to the left and the tallest bar to the right. The water trapped at each position is determined by the minimum of these two heights minus the height of the current bar. By precomputing the maximum heights to the left and right for each position, we can efficiently calculate the trapped water for the entire array.


### Algorithm Steps:

1. **Compute Prefix Maximums:**  
   - For each position, store the maximum height to its left (including itself) in a prefixMax array.

2. **Compute Suffix Maximums:**  
   - For each position, store the maximum height to its right (including itself) in a suffixMax array.

3. **Calculate Trapped Water:**  
   - For each position, the trapped water is `min(prefixMax[i], suffixMax[i]) - arr[i]` if the current bar is lower than both sides.
   - Sum up the trapped water for all positions.

4. **Return the Total:**  
   - Return the total trapped water.
  
``` cpp
#include <bits/stdc++.h>
using namespace std;

int trapRainWater(vector<int>& arr) {
    int n = arr.size();
    if (n == 0) return 0;

    vector<int> prefixMax(n), suffixMax(n);

    // Compute prefix max for each position
    prefixMax[0] = arr[0];
    for (int i = 1; i < n; i++)
        prefixMax[i] = max(prefixMax[i - 1], arr[i]);

    // Compute suffix max for each position
    suffixMax[n - 1] = arr[n - 1];
    for (int i = n - 2; i >= 0; i--)
        suffixMax[i] = max(suffixMax[i + 1], arr[i]);

    int total = 0;
    // Calculate trapped water at each position
    for (int i = 0; i < n; i++) {
        int leftMax = prefixMax[i];
        int rightMax = suffixMax[i];
        // Water can only be trapped if the current bar is lower than both sides
        if (arr[i] < leftMax && arr[i] < rightMax)
            total += min(leftMax, rightMax) - arr[i];
    }
    return total;
}

int main() {
    vector<int> arr = {0,1,0,2,1,0,1,3,2,1,2,1};
    cout << "Total trapped rainwater: " << trapRainWater(arr) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(n)  
  - Calculating prefixMax and suffixMax arrays each takes O(n) time.
  - The final loop to calculate trapped water also takes O(n) time.
  - Total time is O(n).

- **Space Complexity:** O(n)  
  - O(n) space for the prefixMax array.
  - O(n) space for the suffixMax array.
  - Total space is O(n).

---

## Optimal Approach

### Algorithm:

The optimal approach uses two pointers to efficiently calculate the trapped water without extra space for arrays. The key insight is that the amount of water trapped at any position depends on the tallest bars to the left and right of that position. By maintaining two pointers starting from both ends of the elevation array and tracking the maximum heights encountered so far from both sides, we can determine the trapped water at each step. If the left height is smaller or equal to the right height, the trapped water depends on the left side's maximum; otherwise, it depends on the right side's maximum. This two-pointer technique lets us compute trapped water in one pass while using constant extra space.

1. Initialize two pointers: one at the start (`left`) and one at the end (`right`) of the array.
2. Initialize two variables to track the maximum height encountered so far from the left (`maxLeft`) and from the right (`maxRight`).
3. Initialize a variable to store the total trapped water (`totalWater`).
4. While the left pointer is less than or equal to the right pointer:
    - If the height at the left pointer is less than or equal to the height at the right pointer:
        - If the height at `left` is greater than or equal to `maxLeft`, update `maxLeft`.
        - Else, add the difference between `maxLeft` and the current height at `left` to `totalWater`.
        - Move the left pointer one step right.
    - Otherwise (height at `right` is smaller):
        - If the height at `right` is greater than or equal to `maxRight`, update `maxRight`.
        - Else, add the difference between `maxRight` and the current height at `right` to `totalWater`.
        - Move the right pointer one step left.
5. Return `totalWater` as the total trapped rainwater.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to calculate trapped rainwater using the optimal two-pointer approach
    int trap(vector<int>& height) {
        int n = height.size();
        
        // Initialize two pointers at both ends of the array
        int left = 0;
        int right = n - 1;
        
        // Variables to track the maximum height to the left and right
        int maxLeft = 0;
        int maxRight = 0;
        
        // Variable to store total trapped water
        int totalWater = 0;
        
        // Iterate until the left pointer meets the right pointer
        while (left <= right) {
            // If the left bar is smaller than or equal to the right bar
            if (height[left] <= height[right]) {
                // If the current left bar is higher than maxLeft, update maxLeft
                if (height[left] >= maxLeft) {
                    maxLeft = height[left];
                } else {
                    // Water trapped on the left is the difference between maxLeft and the current height
                    totalWater += maxLeft - height[left];
                }
                left++; // Move left pointer to the right
            } else {
                // If the current right bar is higher than maxRight, update maxRight
                if (height[right] >= maxRight) {
                    maxRight = height[right];
                } else {
                    // Water trapped on the right is the difference between maxRight and the current height
                    totalWater += maxRight - height[right];
                }
                right--; // Move right pointer to the left
            }
        }
        
        // Return total trapped water
        return totalWater;
    }
};

// Driver code
int main() {
    // Input elevation map
    vector<int> height = {0,1,0,2,1,0,1,3,2,1,2,1};
    
    // Create Solution object
    Solution sol;
    
    // Calculate trapped water
    int result = sol.trap(height);
    
    // Print the result
    cout << "Trapped Rainwater: " << result << endl;
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(n)  
  Because the two pointers traverse the array only once, each pointer moves inward and covers the entire array in total linear time.

- **Space Complexity:** O(1)  
  As only constant extra space is used for pointers and variables, regardless of input size.
