## Area of Largest Rectangle in Histogram

**Problem Statement:**  
Given an array of integers `heights` representing the histogram's bar height, where the width of each bar is 1, return the area of the largest rectangle in the histogram.

---

>### Example:

**Input:**  
N = 6, heights[] = {2, 1, 5, 6, 2, 3}  
**Output:**  
10

---

## Brute Force

### Algorithm:

1. For each bar, find the index of the first smaller bar to the left and the first smaller bar to the right.
2. The width of the rectangle using the current bar as the smallest bar is `(right - left - 1)`.
3. The area is `height[i] * width`.
4. Repeat for all bars and return the maximum area found.

**Dry Run:**  
Considering the width of each bar as 1 unit:
- For first bar, area possible = 2 * 1 = 2 sq.units
- For second bar, area possible = 1 * 6 = 6 sq.units
- For third bar, area possible = 5 * 2 = 10 sq.units
- For fourth bar, area possible = 6 * 1 = 6 sq.units
- For fifth bar, area possible = 2 * 4 = 8 sq.units
- For sixth bar, area possible = 3 * 1 = 3 sq.units

So, the maximum area possible = 10 sq units.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

// Brute Force Approach to find the largest rectangle area in a Histogram
int largestarea(int arr[], int n) {
    int maxArea = 0;  // Variable to store maximum area found

    // Outer loop to set the starting index of the subarray
    for (int i = 0; i < n; i++) {
        int minHeight = INT_MAX;  // To track minimum height in the subarray

        // Inner loop to set the ending index of the subarray
        for (int j = i; j < n; j++) {
            // Update minimum height in the current window
            minHeight = min(minHeight, arr[j]);

            // Calculate area = height * width
            int width = j - i + 1;
            int area = minHeight * width;

            // Update maxArea if this area is larger
            maxArea = max(maxArea, area);
        }
    }

    return maxArea;  // Return the largest area found
}

int main() {
    int arr[] = {2, 1, 5, 6, 2, 3, 1};  // Histogram bar heights
    int n = 7;  // Size of the histogram

    // Call the function and print the result
    cout << "The largest area in the histogram is " << largestarea(arr, n) << endl;
    return 0;
}
```

## Complexity Analysis:

- **Time Complexity:** O(N^2)  
  Since nested for loops are used to find the left and right smaller elements for each bar.

- **Space Complexity:** O(1)  
  No extra space is used apart from a few variables.

---
## Optimised Approach 1

### Algorithm:

The intuition behind this approach is the same as finding the smaller element on both sides, but in an optimized way using the concept of the Next Smaller Element (NSE) and the Previous Smaller Element (PSE).

**Steps:**
1. For each bar, use a stack to efficiently find:
   - The index of the next smaller element to the right (NSE).
   - The index of the previous smaller element to the left (PSE).
2. For each bar, calculate the width as `(NSE[i] - PSE[i] - 1)`.
3. The area for each bar is `heights[i] * width`.
4. Track and return the maximum area found.

---

### Dry Run:

After finding the right smaller and left smaller of each subsequent array element, we have:
- For each bar, the largest rectangle that can be formed with that bar as the smallest height is determined by the distance to the next smaller bar on both sides.
- This allows us to compute the area for each bar efficiently and find the maximum.

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int largestRectangleArea(vector<int> &heights) {
        int n = heights.size();
        stack<int> st;

        int leftsmall[n], rightsmall[n];

        // Compute Nearest Smaller to Left (NSL) for each bar
        for (int i = 0; i < n; i++) {
            // Pop until a smaller element is found or the stack is empty
            while (!st.empty() && heights[st.top()] >= heights[i]) {
                st.pop();
            }

            // If the stack is empty, no smaller element on the left
            leftsmall[i] = st.empty() ? 0 : st.top() + 1;

            // Push current index to stack
            st.push(i);
        }

        // Clear stack to reuse for NSR
        while (!st.empty()) st.pop();

        // Compute Nearest Smaller to Right (NSR) for each bar
        for (int i = n - 1; i >= 0; i--) {
            while (!st.empty() && heights[st.top()] >= heights[i]) {
                st.pop();
            }

            // If the stack is empty, no smaller to the right
            rightsmall[i] = st.empty() ? n - 1 : st.top() - 1;

            st.push(i);
        }

        // Calculate max area using NSL and NSR
        int maxA = 0;
        for (int i = 0; i < n; i++) {
            int width = rightsmall[i] - leftsmall[i] + 1;
            maxA = max(maxA, heights[i] * width);
        }

        return maxA;
    }
};

int main() {
    vector<int> heights = {2, 1, 5, 6, 2, 3, 1};
    Solution obj;

    // Output the largest area
    cout << "The largest area in the histogram is " << obj.largestRectangleArea(heights) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N)  
  A single pass is used to find the next and previous smaller elements for each bar using stacks, and another pass to compute the area, resulting in overall linear time.

- **Space Complexity:** O(3N)  
  O(N) space each for the stack, the left smaller array, and the right smaller array.

  ---
## Optimised Approach 2

### Algorithm:

This approach is a single-pass approach instead of a two-pass approach. When we traverse the array to find the next smaller element, we notice that some elements are inserted into the stack, which signifies that after them, the smallest element is themselves.

**Steps:**
1. Initialize a stack to keep track of indices of the histogram bars.
2. Traverse the array from left to right:
   - While the stack is not empty and the current bar is smaller than the bar at the top of the stack:
     - Pop the top index from the stack.
     - The height of the rectangle is the value at the popped index.
     - The right boundary is the current index.
     - The left boundary is the index now at the top of the stack (or -1 if the stack is empty).
     - Calculate the area as `height * (right - left - 1)` and update the maximum area.
   - Push the current index onto the stack.
3. After the loop, process any remaining indices in the stack as if the right boundary is the end of the array.
4. Return the maximum area found.


### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
  public:
    int largestRectangleArea(vector<int> &histo) {
        stack<int> st; // Stack to store indices of the histogram bars
        int maxA = 0;  // Variable to keep track of the maximum area
        int n = histo.size();

        // Loop through each bar, including an imaginary bar at the end
        for (int i = 0; i <= n; i++) {
            // While current bar is smaller than the top of the stack or we reached the end
            while (!st.empty() && (i == n || histo[st.top()] >= histo[i])) {
                int height = histo[st.top()]; // Get the height of the bar at the top of the stack
                st.pop(); // Remove that bar

                int width;
                if (st.empty()) {
                    width = i; // All bars before were higher
                } else {
                    width = i - st.top() - 1; // Width between current index and index at top of stack
                }

                // Calculate area and update maximum area
                maxA = max(maxA, width * height);
            }
            // Push current index into stack
            st.push(i);
        }
        return maxA;
    }
};

int main() {
    vector<int> histo = {2, 1, 5, 6, 2, 3, 1}; // Input histogram
    Solution obj;
    cout << "The largest area in the histogram is " << obj.largestRectangleArea(histo) << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N) + O(N)  
  The main for loop traverses the array once, and the while loop inside ensures that each element is pushed and popped from the stack at most once, resulting in overall linear time.

- **Space Complexity:** O(N)  
  Space is used for the stack to store indices of the histogram bars.
