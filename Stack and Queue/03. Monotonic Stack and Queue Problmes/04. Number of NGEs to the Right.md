## Number of NGEs to the Right

**Problem Statement:**  
Given an array `arr` of size `n`, for each element, count how many elements to its right are greater than it (i.e., the number of Next Greater Elements to the right).

---

>### Examples:

**Example 1:**  
**Input:** arr = [4, 5, 2, 10, 8]  
**Output:**  [3, 2, 2, 0, 0]   
**Explanation:**  
- For 4, the greater elements to the right are 5, 10, 8 (**3** elements)
- For 5, the greater elements to the right are 10, 8 (**2** elements)
- For 2, the greater elements to the right are 10, 8 (**2** elements)
- For 10, there are no greater elements to the right (**0** elements)
- For 8, there are no greater elements to the right (**0** elements)

**Example 2:**  
**Input:**  arr = [1, 2, 3, 4]  
**Output:**  [3, 2, 1, 0]  
**Explanation:**  
- For 1, the greater elements to the right are 2, 3, 4 (**3** elements)
- For 2, the greater elements to the right are 3, 4 (**2** elements)
- For 3, the greater element to the right is 4 (**1** element)
- For 4, there are no greater elements to the right (**0** elements)

---

## Brute Force

### Algorithm:

1. Initialize an array `answer` with all elements set to -1 to store the next greater elements.
2. Traverse the array using a for loop to select the current element.
3. Use a nested for loop to traverse the right side of the array (from the current element) to find the next greater element.
4. If a next greater element is found, store it in the answer array and break from the inner loop.
5. Once the outer for loop ends, return the answer array containing the results.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:

    /* Function to find the next greater 
    element for each element in the array */
    vector<int> nextLargerElement(vector<int> arr) {
        
        int n = arr.size(); // size of array
        
        // To store the next greater elements
        vector<int> ans(n, -1);
        
        for(int i=0; i < n; i++) {
            
            // Get the current element+
            int currEle = arr[i];
            
            /* Nested loop to get the 
            next greater element */
            for(int j=i+1; j < n; j++) {
                
                // If the next greater element is found
                if(arr[j] > currEle) {
                    
                    // Store the next greater element
                    ans[i] = arr[j];
                    
                    // Break from the loop
                    break;
                }    
            }
        }
        
        // Return the answer
        return ans;
    }
};

int main() {
    int n = 4;
    vector<int> arr = {1, 3, 2, 4};

    /* Creating an instance of 
    Solution class */
    Solution sol; 
    
    /* Function call to find the next greater element
    for each element in the circular array */
    vector<int> ans = sol.nextLargerElement(arr);
    
    cout << "The next greater elements are: ";
    for(int i=0; i < n; i++) {
        cout << ans[i] << " ";
    }
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N^2)  
  (where N is the size of the given array). Using two nested for loops to find the next greater elements.

- **Space Complexity:** O(N)  
  The space required to store the answer is O(N).

---

## Optimal Approach

### Algorithm:

1. Initialize an answer array to store the next greater elements for the given array.
2. Declare a stack data structure to help with the traversal.
3. Start traversing the array from the back (right to left).
4. For the current element, pop elements from the stack until the top is less than or equal to the current element.
5. If a greater element is found, store it in the answer array; otherwise, store -1.
6. Push the current element into the stack while maintaining a decreasing order of elements.
7. Once the traversal is complete, the answer array will contain the results.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:

    /* Function to find the next greater 
    element for each element in the array */
    vector<int> nextLargerElement(vector<int> arr) {
        
        int n = arr.size(); //size of array
        
        // To store the next greater elements
        vector<int> ans(n);
        
        // Stack to get elements in LIFO fashion
        stack<int> st;
        
        // Start traversing from the back
        for(int i=n-1; i >= 0; i--) {
            
            // Get the current element
            int currEle = arr[i];
            
            /* Pop the elements in the stack until 
            The stack is not empty, and the top 
            element is not the greater element */
            while(!st.empty() && st.top() <= currEle) {
                st.pop();
            }
            
            /* If the greater element is not 
            found, stack will be empty */
            if(st.empty()) 
                ans[i] = -1;
                
            // Else store the answer
            else 
                ans[i] = st.top();
            
            /* Push the current element in the stack 
            maintaining the decreasing order */
            st.push(currEle);
        }
        
        // Return the result
        return ans;
    }
};

int main() {
    int n = 4;
    vector<int> arr = {1, 3, 2, 4};
    
    /* Creating an instance of 
    Solution class */
    Solution sol; 
    
    /* Function call to find the next greater 
    element for each element in the array */
    vector<int> ans = sol.nextLargerElement(arr);
    
    cout << "The next greater elements are: ";
    for(int i=0; i < n; i++) {
        cout << ans[i] << " ";
    }
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N)  
  (where N is the size of the array). We traverse the array once from right to left, and each element is pushed and popped from the stack at most once, resulting in overall O(N) operations.

- **Space Complexity:** O(N)  
  The answer array takes O(N) space, and the stack can hold up to O(N) elements in the worst case.
