## Number of NGEs to the Right

**Problem Statement:**  
Given an array `arr` of size `n`, for each element, count how many elements to its right are greater than it (i.e., the number of Next Greater Elements to the right).

---

>### Examples:

**Example 1:**  
**Input:** arr = [4, 5, 2, 10, 8]  
**Output:**  [3, 2, 2, 0, 0]   
**Explanation:**  
- For 4, the greater elements to the right are 5, 10, 8 (**3** elements)
- For 5, the greater elements to the right are 10, 8 (**2** elements)
- For 2, the greater elements to the right are 10, 8 (**2** elements)
- For 10, there are no greater elements to the right (**0** elements)
- For 8, there are no greater elements to the right (**0** elements)

**Example 2:**  
**Input:**  arr = [1, 2, 3, 4]  
**Output:**  [3, 2, 1, 0]  
**Explanation:**  
- For 1, the greater elements to the right are 2, 3, 4 (**3** elements)
- For 2, the greater elements to the right are 3, 4 (**2** elements)
- For 3, the greater element to the right is 4 (**1** element)
- For 4, there are no greater elements to the right (**0** elements)

---

## Brute Force

### Algorithm:

1. Initialize an array `answer` with all elements set to 0 to store the count of greater elements to the right.
2. Traverse the array using a for loop to select the current element.
3. Use a nested for loop to traverse the right side of the array (from the current element) and count how many elements are greater than the current element.
4. Store the count in the `answer` array for the current element.
5. Once the outer for loop ends, return the `answer` array containing the results.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to count the number of greater elements to the right for each element
    vector<int> countNGEsToRight(vector<int> arr) {
        int n = arr.size();
        vector<int> ans(n, 0);

        for (int i = 0; i < n; i++) {
            int count = 0;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] > arr[i]) {
                    count++;
                }
            }
            ans[i] = count;
        }
        return ans;
    }
};

int main() {
    int n = 4;
    vector<int> arr = {1, 3, 2, 4};

    Solution sol;
    vector<int> ans = sol.countNGEsToRight(arr);

    cout << "The number of NGEs to the right are: ";
    for (int i = 0; i < n; i++) {
        cout << ans[i] << " ";
    }
    cout << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N^2)  
  (where N is the size of the given array). We use two nested for loops to count the number of greater elements to the right for each element.

- **Space Complexity:** O(N)  
  The space required to store the answer is O(N), as we use an output array of size N.
---

## Optimal Approach

### Algorithm:

1. Initialize an answer array to store the next greater elements for the given array.
2. Declare a stack data structure to help with the traversal.
3. Start traversing the array from the back (right to left).
4. For the current element, pop elements from the stack until the top is less than or equal to the current element.
5. If a greater element is found, store it in the answer array; otherwise, store -1.
6. Push the current element into the stack while maintaining a decreasing order of elements.
7. Once the traversal is complete, the answer array will contain the results.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:

    /* Function to find the next greater 
    element for each element in the array */
    vector<int> nextLargerElement(vector<int> arr) {
        
        int n = arr.size(); //size of array
        
        // To store the next greater elements
        vector<int> ans(n);
        
        // Stack to get elements in LIFO fashion
        stack<int> st;
        
        // Start traversing from the back
        for(int i=n-1; i >= 0; i--) {
            
            // Get the current element
            int currEle = arr[i];
            
            /* Pop the elements in the stack until 
            The stack is not empty, and the top 
            element is not the greater element */
            while(!st.empty() && st.top() <= currEle) {
                st.pop();
            }
            
            /* If the greater element is not 
            found, stack will be empty */
            if(st.empty()) 
                ans[i] = -1;
                
            // Else store the answer
            else 
                ans[i] = st.top();
            
            /* Push the current element in the stack 
            maintaining the decreasing order */
            st.push(currEle);
        }
        
        // Return the result
        return ans;
    }
};

int main() {
    int n = 4;
    vector<int> arr = {1, 3, 2, 4};
    
    /* Creating an instance of 
    Solution class */
    Solution sol; 
    
    /* Function call to find the next greater 
    element for each element in the array */
    vector<int> ans = sol.nextLargerElement(arr);
    
    cout << "The next greater elements are: ";
    for(int i=0; i < n; i++) {
        cout << ans[i] << " ";
    }
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N)  
  (where N is the size of the array). We traverse the array once from right to left, and each element is pushed and popped from the stack at most once, resulting in overall O(N) operations.

- **Space Complexity:** O(N)  
  The answer array takes O(N) space, and the stack can hold up to O(N) elements in the worst case.
