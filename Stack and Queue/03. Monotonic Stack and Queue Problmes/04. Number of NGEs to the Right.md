## Number of NGEs to the Right

**Problem Statement:**  
Given an array `arr` of size `n`, for each element, count how many elements to its right are greater than it (i.e., the number of Next Greater Elements to the right).

---

>### Examples:

**Example 1:**  
**Input:** arr = [4, 5, 2, 10, 8]  
**Output:**  [3, 2, 2, 0, 0]   
**Explanation:**  
- For 4, the greater elements to the right are 5, 10, 8 (**3** elements)
- For 5, the greater elements to the right are 10, 8 (**2** elements)
- For 2, the greater elements to the right are 10, 8 (**2** elements)
- For 10, there are no greater elements to the right (**0** elements)
- For 8, there are no greater elements to the right (**0** elements)

**Example 2:**  
**Input:**  arr = [1, 2, 3, 4]  
**Output:**  [3, 2, 1, 0]  
**Explanation:**  
- For 1, the greater elements to the right are 2, 3, 4 (**3** elements)
- For 2, the greater elements to the right are 3, 4 (**2** elements)
- For 3, the greater element to the right is 4 (**1** element)
- For 4, there are no greater elements to the right (**0** elements)

---

## Brute Force

### Algorithm:

1. Initialize an array `answer` with all elements set to 0 to store the count of greater elements to the right.
2. Traverse the array using a for loop to select the current element.
3. Use a nested for loop to traverse the right side of the array (from the current element) and count how many elements are greater than the current element.
4. Store the count in the `answer` array for the current element.
5. Once the outer for loop ends, return the `answer` array containing the results.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to count the number of greater elements to the right for each element
    vector<int> countNGEsToRight(vector<int> arr) {
        int n = arr.size();
        vector<int> ans(n, 0);

        for (int i = 0; i < n; i++) {
            int count = 0;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] > arr[i]) {
                    count++;
                }
            }
            ans[i] = count;
        }
        return ans;
    }
};

int main() {
    int n = 4;
    vector<int> arr = {1, 3, 2, 4};

    Solution sol;
    vector<int> ans = sol.countNGEsToRight(arr);

    cout << "The number of NGEs to the right are: ";
    for (int i = 0; i < n; i++) {
        cout << ans[i] << " ";
    }
    cout << endl;

    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N^2)  
  (where N is the size of the given array). We use two nested for loops to count the number of greater elements to the right for each element.

- **Space Complexity:** O(N)  
  The space required to store the answer is O(N), as we use an output array of size N.
---

## Optimal Approach

### Intuition:

The idea is to use a stack to efficiently find the index of the next greater element (NGE) for each element in the array. Once we have the NGE index for every element, we can "jump" from one NGE to the next, counting how many such jumps we can make before reaching the end of the array. This way, for each element, we count the number of NGEs to its right by following the chain of next greater elements.


### Algorithm:

1. **Find Next Greater Index for Each Element:**
   - Initialize a stack and an array `ngeIndex` of size `n` (length of input array), filled with `n` (meaning "no NGE").
   - Traverse the array from right to left.
   - For each element, pop elements from the stack until the stack is empty or the top of the stack is greater than the current element.
   - If the stack is not empty, set `ngeIndex[i] = st.top()` (the index of the next greater element).
   - Push the current index onto the stack.

2. **Count Number of NGEs to the Right:**
   - Initialize an answer array `ans` of size `n` with all zeros.
   - For each index `i` from 0 to n-1:
     - Set `count = 0` and `j = ngeIndex[i]`.
     - While `j < n`:
       - Increment `count`.
       - Set `j = ngeIndex[j]` (jump to the next greater index).
     - Set `ans[i] = count`.

3. **Return the answer array.**

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> countNGEsToRight(vector<int>& arr) {
        int n = arr.size();
        vector<int> ngeIndex(n, n); // Index of next greater element, default n (no NGE)
        stack<int> st;

        // Find next greater index for each element
        for (int i = n - 1; i >= 0; --i) {
            while (!st.empty() && arr[st.top()] <= arr[i]) {
                st.pop();
            }
            if (!st.empty()) {
                ngeIndex[i] = st.top();
            }
            st.push(i);
        }

        // Count the number of NGEs to the right for each element
        vector<int> ans(n, 0);
        for (int i = 0; i < n; ++i) {
            int count = 0;
            int j = ngeIndex[i];
            while (j < n) {
                count++;
                j = ngeIndex[j];
            }
            ans[i] = count;
        }
        return ans;
    }
};

int main() {
    vector<int> arr = {1, 3, 2, 4};
    Solution sol;
    vector<int> ans = sol.countNGEsToRight(arr);

    cout << "The number of NGEs to the right are: ";
    for (int x : ans) cout << x << " ";
    cout << endl;
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N^2) in the worst case  
  - Finding the next greater index for each element using a stack is O(N).
  - However, for each element, we may need to follow a chain of next greater indices, and in the worst case (e.g., strictly increasing array), this chain can be as long as N for each element, resulting in O(N^2) total time.

- **Space Complexity:** O(N)  
  - O(N) space for the stack.
  - O(N) space for the `ngeIndex` array.
  - O(N) space for the answer array.
  - Total space used is O(N).
