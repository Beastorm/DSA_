## Asteroid Collision

**Problem Statement:**  
Given an array of integers `asteroids`, where each integer represents an asteroid in a row, determine the state of the asteroids after all collisions.  
- The absolute value represents the size of the asteroid.
- The sign represents its direction (positive = right, negative = left).
- All asteroids move at the same speed.
- When two asteroids meet, the smaller one will explode. If they are the same size, both will explode. Asteroids moving in the same direction will never meet.

---

>### Examples:

**Example 1:**  
Input:  
asteroids = [2, -2]  
Output:  
[]  
Explanation:  
The asteroid with size 2 and the one with size -2 collide, exploding into each other.

**Example 2:**  
Input:  
asteroids = [10, 20, -10]  
Output:  
[10, 20]  
Explanation:  
The asteroid with size 20 and the one with size -10 collide, resulting in the remaining asteroid with size 20. The asteroids with sizes 10 and 20 never collide.

---

## Approach

### Algorithm:

1. Initialize an empty stack to track asteroids after collisions.
2. Loop through each asteroid in the input array:
   - If the asteroid is moving right (positive), push it onto the stack.
   - If the asteroid is moving left (negative), check for collisions with top elements of the stack:
     - While the top of the stack is a smaller right-moving asteroid, pop it from the stack.
     - If the top of the stack is a right-moving asteroid of equal size, pop it and do not push the current asteroid.
     - If the stack is empty or the top is a left-moving asteroid, push the current asteroid.
3. After the loop ends, return the stack as the final result.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:

    /* Function to determine the state of 
    asteroids after all collisions */
    vector<int> asteroidCollision(vector<int> &asteroids){
        
        // Size of the array
        int n = asteroids.size();
        
        // List implementation of stack
        vector<int> st;  
        
        // Traverse all the asteroids
        for(int i=0; i < n; i++) {
            
            /* Push the asteroid in the stack if a 
            right-moving asteroid is seen */
            if(asteroids[i] > 0) {
                st.push_back(asteroids[i]);
            }
            
            /* Else if the asteroid is moving 
            right, perform the collisions */
            else {
                
                /* Until the right moving asteroids are 
                smaller in size, keep on destroying them */ 
                while(!st.empty() && st.back() > 0 && 
                      st.back() < abs(asteroids[i])) {
                    
                    // Destroy the asteroid
                    st.pop_back();
                }
                
                /* If there is right moving asteroid 
                which is of the same size */
                if(!st.empty() && 
                    st.back() == abs(asteroids[i])) {
                    
                    // Destroy both the asteroids
                    st.pop_back();
                }
                
                /* Otherwise, if there is no left
                moving asteroid, the right moving 
                asteroid will not be destroyed */
                else if(st.empty() ||
                        st.back() < 0){
                    
                    // Storing the array in the final state
                    st.push_back(asteroids[i]);
                }
            }
        }
        
        // Return the final state of asteroids
        return st;
    }
};

int main() {
    vector<int> arr = {10, 20, -10};
    
    /* Creating an instance of 
    Solution class */
    Solution sol; 
    
    /* Function call to determine the state of 
    asteroids after all collisions */
    vector<int> ans = sol.asteroidCollision(arr);
    
    cout << "The state of asteroids after collisions is: ";
    for(int i=0; i < ans.size(); i++) {
        cout << ans[i] << " ";
    }
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(N)  
  Since traversing all the asteroids takes O(N) time.

- **Space Complexity:** O(N)  
  In the worst case, all asteroids will be stored in the stack if there are no collisions, leading to a space requirement of O(N).
