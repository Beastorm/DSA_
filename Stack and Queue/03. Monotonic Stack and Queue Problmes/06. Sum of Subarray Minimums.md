## Sum of Subarray Minimums

**Problem Statement:**  
Given an array of integers `arr` of size `n`, calculate the sum of the minimum value in each (contiguous) subarray of `arr`. Since the result may be large, return the answer modulo `10⁹ + 7`.

---

>### Examples:

**Example 1:**  
**Input:** arr = [3, 1, 2, 5]  
**Output:** 18  
**Explanation:**    
```
The minimum of subarrays: 
[3], [1], [2], [5], [3, 1], [1, 2], [2, 5], [3, 1, 2], [1, 2, 5], [3, 1, 2, 5] 
are 3, 1, 2, 5, 1, 1, 2, 1, 1, 1 respectively, and their sum is 18.
```

**Example 2:**  
**Input:** arr = [2, 3, 1]  
**Output:** 10  
**Explanation:**
```
The minimum of subarrays: [2], [3], [1], [2,3], [3,1], [2,3,1] 
are 2, 3, 1, 2, 1, 1 respectively, and their sum is 10.
```

---

## Brute Force

### Algorithm:

1. Initialize a variable to hold the total sum, starting from `0`.
2. Start a loop to fix the starting index of the subarray.
3. Initialize a variable to keep track of the minimum element in the current subarray.
4. Use an inner loop to extend the subarray to the right.
5. Update the minimum element as the subarray grows.
6. Add the current minimum to the total sum.
7. Repeat this process for all possible subarrays.
8. Return the total sum after all subarrays are processed.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:

   // Function to find the sum of the minimum value in each subarray
   int sumSubarrayMins(vector<int> &arr) {
       
       // Size of array
       int n = arr.size();
       
       int mod = 1e9 + 7; // Mod value
       
       // To store the sum
       int sum = 0;
       
       // Traverse the array
       for(int i=0; i < n; i++) {
           
           // To store the minimum of the subarray
           int mini = arr[i];
           
           // Nested loop to get all subarrays starting from index i
           for(int j=i; j < n; j++) {
               
               // Update the minimum value
               mini = min(mini, arr[j]);
               
               // Update the sum
               sum = (sum + mini) % mod;
           }
       }
       
       // Return the computed sum
       return sum;
   }
};

int main() {
   vector<int> arr = {3, 1, 2, 5};
   
   // Creating an instance of the Solution class
   Solution sol; 
   
   // Function call to find the sum of the minimum value in each subarray
   int ans = sol.sumSubarrayMins(arr);
   
   cout << "The sum of minimum value in each subarray is: " << ans;
   
   return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N²)  
  Since we are using two nested loops to consider all possible subarrays.

- **Space Complexity:** O(1)  
  As we are not using any extra space except for the input array and a few variables.

---

## Optimal Approach

### Algorithm:

1. Use a stack to find the index of the next smaller element to the right (NSE) for each position in the array.
2. Use another stack to find the index of the previous smaller or equal element to the left (PSEE) for each position in the array.
3. For each element, determine how many subarrays it appears in as the minimum using its NSE and PSEE indices.
4. Calculate the contribution of each element by multiplying its value by its frequency (i.e., the number of subarrays where it is the minimum).
5. Add each contribution to a total sum.
6. Return the total sum modulo `10^9 + 7`.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    // Function to find the indices of next smaller elements
    vector<int> findNSE(vector<int> &arr) {
        
        // Size of array
        int n = arr.size();
        
        // To store the answer
        vector<int> ans(n);
        
        // Stack 
        stack<int> st;
        
        // Start traversing from the back
        for(int i = n - 1; i >= 0; i--) {
            
            // Get the current element
            int currEle = arr[i];
            
            /* Pop the elements in the stack until 
            The stack is not empty, and the top 
            element is not the smaller element */
            while(!st.empty() && arr[st.top()] >= arr[i]){
                st.pop();
            }
            
            // Update the answer
            ans[i] = !st.empty() ? st.top() : n;
            
            // Push the index of the current element in the stack
            st.push(i);
        }
        
        // Return the answer
        return ans;
    }
    
    // Function to find the indices of previous smaller or equal elements
    vector<int> findPSEE(vector<int> &arr) {
        
        // Size of array
        int n = arr.size();
        
        // To store the answer
        vector<int> ans(n);
        
        // Stack 
        stack<int> st;
        
        // Traverse the array
        for(int i=0; i < n; i++) {
            
            // Get the current element
            int currEle = arr[i];
            
            /* Pop the elements in the stack until 
            The stack is not empty, and the top 
            elements are greater than the current element */
            while(!st.empty() && arr[st.top()] > arr[i]){
                st.pop();
            }
            
            // Update the answer
            ans[i] = !st.empty() ? st.top() : -1;
            
            // Push the index of the current element in the stack
            st.push(i);
        }
        
        // Return the answer
        return ans;
    }
    
public:

    // Function to find the sum of the minimum value in each subarray 
    int sumSubarrayMins(vector<int> &arr) {
        
        vector<int> nse = findNSE(arr);
        
        vector<int> psee = findPSEE(arr);
        
        // Size of array
        int n = arr.size();
        
        int mod = 1e9 + 7; // Mod value
        
        // To store the sum
        int sum = 0;
        
        // Traverse the array
        for(int i=0; i < n; i++) {
            
            // Count of first type of subarrays
            int left = i - psee[i];
            
            // Count of the second type of subarrays
            int right = nse[i] - i;
            
            // Count of subarrays where the current element is the minimum 
            long long freq = left*right*1LL;
            
            // Contribution due to the current element 
            int val = (freq*arr[i]*1LL) % mod;
            
            // Updating the sum
            sum = (sum + val) % mod;
        }
        
        // Return the computed sum
        return sum;
    }
};

int main() {
    vector<int> arr = {3, 1, 2, 5};
    
    // Creating an instance of the Solution class
    Solution sol; 
    
    // Function call to find the sum of the minimum value in each subarray 
    int ans = sol.sumSubarrayMins(arr);
    
    cout << "The sum of minimum value in each subarray is: " << ans;
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(N)  
  Finding the indices of next smaller elements and previous smaller elements takes O(2N) time each, and calculating the sum of subarray minimums takes O(N) time. Thus, the total time complexity is O(N).

- **Space Complexity:** O(N)  
  Finding the indices of the next smaller elements and previous smaller elements takes O(N) space each due to stack space, and storing the indices also takes O(N) space each. Thus, the total space complexity is O(N).
  
