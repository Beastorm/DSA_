## Check for Balanced Parentheses

**Problem Statement:**  
Given a string `str` containing just the characters '(', ')', '{', '}', '[' and ']', check if the input string is valid and return true if the string is balanced, otherwise return false.

**Note:**
- Open brackets must be closed by the same type of brackets.
- Open brackets must be closed in the correct order.

### What are Not Balanced Parentheses? (Examples)

A string of parentheses is **not balanced** if:
- An opening bracket does not have a corresponding closing bracket.
- A closing bracket appears before its matching opening bracket.
- Brackets are not closed in the correct order or type.

1. **Unmatched Opening Bracket**
   - Input: `"((("`
   - Output: `False`
   - Explanation: All opening brackets, no closing brackets.

2. **Unmatched Closing Bracket**
   - Input: `"())"`
   - Output: `False`
   - Explanation: One extra closing bracket.

3. **Wrong Order**
   - Input: `"(]"`
   - Output: `False`
   - Explanation: Opened with `(` but closed with `]`.

4. **Wrong Nesting**
   - Input: `"[ ( ] )"`
   - Output: `False`
   - Explanation: The most recent opening `(` is closed by `]`, which is incorrect.

5. **Closing Before Opening**
   - Input: `")("`
   - Output: `False`
   - Explanation: The closing bracket comes before any opening bracket.

6. **Mismatched Types**
   - Input: `"{ [ ( ] ) }"`
   - Output: `False`
   - Explanation: The brackets are not closed in the correct order.

7. **Extra Opening or Closing**
   - Input: `"{ [ } ]"`
   - Output: `False`
   - Explanation: The `{` is closed by `}` before the `[` is closed.

**Summary:**  
A string is not balanced if any bracket is left unmatched, closed in the wrong order, or mismatched in type.

---

>### Examples:

**Example 1:**  
Input: str = "( )[ { } ( ) ]"  
Output: True  
Explanation: As every open bracket has its corresponding close bracket. Matched parentheses are in correct order, hence they are balanced.

**Example 2:**  
Input: str = "[ ( )"  
Output: False  
Explanation: As ‘[‘ does not have ‘]’, hence it is not valid and will return false.

---

## Approach

### Algorithm & Intuition:

- We need to keep track of previous as well as most recent opening brackets, and also keep in mind the sequence, as after opening of the bracket, there should be opposite pairs of brackets.
- Handle corner cases like `[ ) ( ]` where a closing bracket occurs first and an opening bracket after it (invalid), as well as `[ ( ] )` where the most recent opening didn't get its opposite pair (also invalid).
- Use a stack to keep track of the opening brackets (LIFO structure).

**Steps:**
1. Whenever we get an opening bracket, push it onto the stack: `{`, `[`, `(`.
2. Whenever we get a closing bracket:
   - If the stack is empty, return false.
   - If the stack is not empty, check if the topmost element of the stack is the opposite pair of the closing bracket.
     - If not, return false.
     - If yes, pop the stack and continue.
3. After processing the entire string, the stack must be empty for the string to be valid. If not, return false; otherwise, return true.


``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class containing the isValid method
class Solution {
public:
    // Function to check if the input string has valid parentheses
    bool isValid(string s) {
        stack<char> st;  // Stack to store opening brackets

        for (auto it : s) {
            if (it == '(' || it == '{' || it == '[')
                st.push(it);  // Push opening brackets to stack
            else {
                if (st.empty()) return false;  // No matching opening bracket
                char ch = st.top();
                st.pop();

                // Check for a matching pair
                if ((it == ')' && ch == '(') ||
                    (it == ']' && ch == '[') ||
                    (it == '}' && ch == '{'))
                    continue;
                else
                    return false;
            }
        }
        return st.empty();  // True if all brackets matched
    }
};

int main() {
    Solution sol;
    string s = "()[{}()]";

    if (sol.isValid(s))
        cout << "True" << endl;
    else
        cout << "False" << endl;

    return 0;
}

```
### Complexity Analysis:

- **Time Complexity:** O(n)  
  A single for loop is used to traverse the string of length n.

- **Space Complexity:** O(n)  
  Stack space is used to store opening brackets; in the worst case, all characters could be opening brackets.
