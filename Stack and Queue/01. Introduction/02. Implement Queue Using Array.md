## Implement Queue Using Array

**Problem Statement:**  
Implement a `First-In-First-Out` (FIFO) queue using an array. The implemented queue should support the following operations: `push`, `pop`, `peek`, and `isEmpty`.

_Implement the ArrayQueue class:_

- `void push(int x)`: Adds element `x` to the end of the queue.
- `int pop()`: Removes and returns the front element of the queue.
- `int peek()`: Returns the front element of the queue without removing it.
- `boolean isEmpty()`: Returns true if the queue is empty, false otherwise.

---

>### Examples:

**Example 1:**  
**Input:**
```
["ArrayQueue", "push", "push", "peek", "pop", "isEmpty"]  
[[], [5], [10], [], [], []]
```
**Output:** ```[null, null, null, 5, 5, false]```  
**Explanation:**  
```
ArrayQueue queue = new ArrayQueue();  
- queue.push(5);  
- queue.push(10);  
- queue.peek(); // returns 5  
- queue.pop(); // returns 5  
- queue.isEmpty(); // returns false  
```
**Example 2:**  
**Input:**    
```
["ArrayQueue", "isEmpty"]  
[[]] 
```
**Output:** ```[null, true]```  
**Explanation:**  
``` 
ArrayQueue queue = new ArrayQueue();  
- queue.isEmpty(); // returns true
```
---

## Approach

### Algorithm:

1. **Declare an Array of a Particular Size:**  
   Declare an array to store the elements of the queue. The size of this array is determined when the queue is initialized.

2. **Define Variables:**  
   - `start`: Tracks the index of the front element.
   - `end`: Tracks the index of the last element.
   - `size`: Keeps the current number of elements in the queue.
   - `capacity`: The maximum number of elements the queue can hold.

3. **Push Operation (`push(int x)`):**  
   - Check if the queue is full by comparing the size with the capacity. If not full:
     - Increment the end using modular arithmetic to wrap around if necessary.
     - Insert the element at the rear index.
     - Increment the size.

4. **Pop Operation (`pop()`):**  
   - Check if the queue is empty by comparing its size with `0`. If not empty:
     - Return the element at the front index.
     - Increment the start using modular arithmetic to wrap around if necessary.
     - Decrement the size.

5. **Peek Operation (`peek()`):**  
   - Check if the queue is empty. If not empty, return the element at the front index.

6. **IsEmpty Operation (`isEmpty()`):**  
   - Check if size is `0` to determine if the queue is empty.

### C++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Class implementing Queue using Arrays
class ArrayQueue {
    int* arr;
    int start, end;
    int currSize, maxSize;

public:
    ArrayQueue(int size = 10) {
        arr = new int[size];
        start = -1;
        end = -1;
        currSize = 0;
        maxSize = size;
    }

    ~ArrayQueue() {
        delete[] arr;
    }

    void push(int x) {
        if (currSize == maxSize) {
            cout << "Queue is full" << endl;
            return;
        }
        if (end == -1) {
            start = 0;
            end = 0;
        } else {
            end = (end + 1) % maxSize;
        }
        arr[end] = x;
        currSize++;
    }

    int pop() {
        if (isEmpty()) {
            cout << "Queue is empty" << endl;
            return -1;
        }
        int popped = arr[start];
        if (currSize == 1) {
            start = -1;
            end = -1;
        } else {
            start = (start + 1) % maxSize;
        }
        currSize--;
        return popped;
    }

    int peek() {
        if (isEmpty()) {
            cout << "Queue is empty" << endl;
            return -1;
        }
        return arr[start];
    }

    bool isEmpty() {
        return currSize == 0;
    }

    int size() {
        return currSize;
    }

    void printQueue() {
        cout << "Queue (front -> rear): ";
        if (isEmpty()) {
            cout << "empty" << endl;
            return;
        }
        int i = start, count = 0;
        while (count < currSize) {
            cout << arr[i] << " ";
            i = (i + 1) % maxSize;
            count++;
        }
        cout << endl;
    }
};

int main() {
    ArrayQueue queue(5);

    cout << "Push 5" << endl;
    queue.push(5);
    queue.printQueue();

    cout << "Push 10" << endl;
    queue.push(10);
    queue.printQueue();

    cout << "Peek: " << queue.peek() << endl;
    queue.printQueue();

    cout << "Pop: " << queue.pop() << endl;
    queue.printQueue();

    cout << "Is the queue empty? " << (queue.isEmpty() ? "true" : "false") << endl;

    cout << "Pop: " << queue.pop() << endl;
    queue.printQueue();

    cout << "Is the queue empty? " << (queue.isEmpty() ? "true" : "false") << endl;

    cout << "Pop from empty queue: " << queue.pop() << endl;

    cout << "Push 20, 30, 40, 50, 60 (test overflow)" << endl;
    queue.push(20);
    queue.push(30);
    queue.push(40);
    queue.push(50);
    queue.push(60); // Should trigger overflow
    queue.printQueue();

    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(1)  
  for all operations (`push`, `pop`, `peek`, `isEmpty`) since they involve simple index manipulations and array accesses.

- **Space Complexity:** O(1)  
  since we are using a fixed-size array and a few variables.
