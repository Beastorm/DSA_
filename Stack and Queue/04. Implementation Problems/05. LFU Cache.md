## LFU Cache

**Problem Statement:**  
Design and implement a data structure for a Least Frequently Used (LFU) cache.

Implement the LFUCache class with the following functions:
- `LFUCache(int capacity)`: Initialize the object with the specified capacity.
- `int get(int key)`: Retrieve the value of the key if it exists in the cache; otherwise, return `-1`.
- `void put(int key, int value)`: Update the value of the key if it is present in the cache, or insert the key if it is not already present. If the cache has reached its capacity, invalidate and remove the least frequently used key before inserting a new item. In case of a tie (i.e., two or more keys with the same frequency), invalidate the least recently used key.

A use counter is maintained for each key in the cache to determine the least frequently used key. The key with the smallest use counter is considered the least frequently used.

When a key is first inserted into the cache, its use counter is set to `1` due to the put operation. The use counter for a key in the cache is incremented whenever a get or put operation is called on it. Ensure that the functions get and put run in `O(1)` average time complexity.

---

>### Examples:

**Example 1:**   
**Input:**    
``` ["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]```   

**Output:**    
``` [null, null, null, 1, null, -1, 3, null, -1, 3, 4]```   

**Explanation:**    
```
LFUCache lfu = new LFUCache(2);
- lfu.put(1, 1); // Cache: [1], cnt(1)=1
- lfu.put(2, 2); // Cache: [2, 1], cnt(2)=1, cnt(1)=1
- lfu.get(1);    // Returns 1, cnt(1)=2
- lfu.put(3, 3); // Evicts 2, Cache: [3, 1], cnt(3)=1, cnt(1)=2
- lfu.get(2);    // Returns -1
- lfu.get(3);    // Returns 3, cnt(3)=2
- lfu.put(4, 4); // Evicts 1, Cache: [4, 3], cnt(4)=1, cnt(3)=2
- lfu.get(1);    // Returns -1
- lfu.get(3);    // Returns 3, cnt(3)=3
- lfu.get(4);    // Returns 4, cnt(4)=2
```

**Example 2:**   
**Input:**    
``` ["LFUCache", "put", "put", "put", "put", "put", "get", "get", "get", "get", "get"]```   

**Output:**    
``` [null, null, null, null, null, null, 3, 4, 5, -1, -1]```   

**Explanation:**    
```
LFUCache lfu = new LFUCache(3);
- lfu.put(5, 7); // Cache: [5], cnt(5)=1
- lfu.put(4, 6); // Cache: [4, 5], cnt(4)=1, cnt(5)=1
- lfu.put(3, 5); // Cache: [3, 4, 5], cnt(3)=1, cnt(4)=1, cnt(5)=1
- lfu.put(2, 4); // Evicts 5, Cache: [2, 3, 4], cnt(2)=1, cnt(3)=1, cnt(4)=1
- lfu.put(1, 3); // Evicts 4, Cache: [1, 2, 3], cnt(1)=1, cnt(2)=1, cnt(3)=1
- lfu.get(1);    // Returns 3, cnt(1)=2
- lfu.get(2);    // Returns 4, cnt(2)=2
- lfu.get(3);    // Returns 5, cnt(3)=2
- lfu.get(4);    // Returns -1
- lfu.get(5);    // Returns -1
```
---

## Approach

### Algorithm:

1. Initialize the cache with a specified capacity.
2. Create dummy head and tail nodes for each frequency list to simplify edge case handling.
3. For updating frequency, when a node is accessed or updated:
   - Remove the node from its current frequency list.
   - If this were the only node in the minimum frequency list, increment the minimum frequency.
   - Increment the node's frequency and add it to the front of the list corresponding to the new frequency.
   - Update both hash maps (`keyNode` and `freqNode`) to reflect the changes.
4. For the `get` operation, check if the key exists in the `keyNode` map:
   - If present, retrieve the node, update its frequency, and return its value.
   - If not present, return -1.
5. For the `put` operation:
   - If the key already exists in `keyNode`, update its value, update its frequency, and return.
   - If not present, check if the cache is at capacity.
   - If at capacity, remove the least frequently used node (node with the minimum frequency and least recent usage).
   - Create a new node for the key-value pair, set its frequency to 1, and add it to the front of the frequency list for nodes with frequency 1.
   - Update both hash maps to reflect the addition of the new node.

### C+++ Code:

``` cpp
#include <bits/stdc++.h>
using namespace std;

// Node in a doubly linked list (stores key, value, frequency)
struct Node {
    int key, value, cnt;
    Node *next, *prev;
    Node(int _key, int _value) : key(_key), value(_value), cnt(1), next(nullptr), prev(nullptr) {}
};

// Doubly linked list for each frequency
struct List {
    int size;
    Node *head, *tail;
    List() {
        head = new Node(0, 0); // Dummy head
        tail = new Node(0, 0); // Dummy tail
        head->next = tail;
        tail->prev = head;
        size = 0;
    }
    // Add node right after head (front of list)
    void addFront(Node *node) {
        Node *temp = head->next;
        node->next = temp;
        node->prev = head;
        head->next = node;
        temp->prev = node;
        size++;
    }
    // Remove a node from the list
    void removeNode(Node *delnode) {
        Node *prevNode = delnode->prev;
        Node *nextNode = delnode->next;
        prevNode->next = nextNode;
        nextNode->prev = prevNode;
        size--;
    }
};

class LFUCache {
private:
    map<int, Node*> keyNode;         // Key to node mapping
    map<int, List*> freqListMap;     // Frequency to list mapping
    int maxSizeCache, minFreq, curSize;

public:
    LFUCache(int capacity) {
        maxSizeCache = capacity; // Set cache capacity
        minFreq = 0;             // Track minimum frequency in cache
        curSize = 0;             // Track current cache size
    }

    // Update node's frequency and move it to the correct list
    // Call updateFreqListMap(node) whenever a node is accessed or updated, to increment its frequency, 
    // and move it to the correct frequency list.
    void updateFreqListMap(Node *node) {
        keyNode.erase(node->key); // Remove old mapping
        freqListMap[node->cnt]->removeNode(node); // Remove from old freq list

        // If this was the last node with minFreq, increment minFreq
        if (node->cnt == minFreq && freqListMap[node->cnt]->size == 0) minFreq++;

        // Get or create the list for the next higher frequency
        List *nextHigherFreqList;
        if (freqListMap.find(node->cnt + 1) != freqListMap.end()) {
            nextHigherFreqList = freqListMap[node->cnt + 1];
        } else {
            nextHigherFreqList = new List();
            freqListMap[node->cnt + 1] = nextHigherFreqList;
        }

        node->cnt += 1; // Increment frequency
        nextHigherFreqList->addFront(node); // Add to new freq list
        keyNode[node->key] = node; // Update mapping
    }

    // Get value for key, update frequency if found
    int get(int key) {
        if (keyNode.find(key) != keyNode.end()) {
            Node *node = keyNode[key];
            int val = node->value;
            updateFreqListMap(node); // Move node to higher freq list
            return val;
        }
        return -1; // Not found
    }

    // Put key-value in cache, evict if needed
    void put(int key, int value) {
        if (maxSizeCache == 0) return; // No capacity

        if (keyNode.find(key) != keyNode.end()) {
            // Key exists: update value and frequency
            Node *node = keyNode[key];
            node->value = value;
            updateFreqListMap(node);
        } else {
            // Key does not exist: may need to evict
            if (curSize == maxSizeCache) {
                // Evict least frequently used node (LRU among minFreq)
                List *list = freqListMap[minFreq];
                keyNode.erase(list->tail->prev->key);
                freqListMap[minFreq]->removeNode(list->tail->prev);
                curSize--;
            }
            curSize++;
            minFreq = 1; // New node will have freq 1

            // Get or create list for freq 1
            List *listFreq;
            if (freqListMap.find(minFreq) != freqListMap.end()) {
                listFreq = freqListMap[minFreq];
            } else {
                listFreq = new List();
                freqListMap[minFreq] = listFreq;
            }

            Node *node = new Node(key, value); // Create new node
            listFreq->addFront(node);          // Add to freq 1 list
            keyNode[key] = node;               // Add to key-node map
        }
    }
};

int main() {
    LFUCache cache(2);
    cache.put(1, 1);
    cache.put(2, 2);
    cout << cache.get(1) << " ";
    cache.put(3, 3);
    cout << cache.get(2) << " ";
    cout << cache.get(3) << " ";
    cache.put(4, 4);
    cout << cache.get(1) << " ";
    cout << cache.get(3) << " ";
    cout << cache.get(4) << " ";
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N)  
  Where N is the number of queries on the LFU cache. Each `get` and `put` method takes an average of constant time, making the overall complexity O(N).

- **Space Complexity:** O(cap)  
  Where `cap` is the capacity of the LFU cache. The cache can store a maximum of `cap` data items, taking O(cap) space.
