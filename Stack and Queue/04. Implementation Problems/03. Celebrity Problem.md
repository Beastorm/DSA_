## Celebrity Problem

**Problem Statement:**  
A celebrity is a person who is known by everyone else at the party but does not know anyone in return. Given a square matrix `M` of size `N x N` where `M[i][j]` is `1` if person `i` knows person `j`, and `0` otherwise, determine if there is a celebrity at the party. Return the index of the celebrity or `-1` if no such person exists.

_Note that_: `M[i][i]` is always 0.

---

>### Examples:

**Example 1:**    
**Input:**  M = [ [0, 1, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0], [0, 1, 1, 0] ]    
**Output:**  1    
**Explanation:**  Person 1 does not know anyone and is known by persons 0, 2, and 3. Therefore, person 1 is the celebrity.     

**Example 2:**  
**Input:**  M = [ [0, 1], [1, 0] ]    
**Output:** -1    
**Explanation:** Both people know each other, so there is no celebrity.   

---

## Brute Force

### Algorithm:

1. Create two lists to track how many people each person knows and how many people know each person.
2. Iterate through the matrix, updating the counters based on whether a person knows another person.
3. After populating the counters, iterate through the lists to find a person who is known by everyone else but knows no one.
4. If such a person is found, return their index as the celebrity.
5. If no such person exists, return `-1`, indicating there is no celebrity.

### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the index of the celebrity
    int celebrity(vector<vector<int>> &M){
        
        // Size of given matrix
        int n = M.size();
        
        // To store the count of people who know the person of index i
        vector<int> knowMe(n, 0);
        
        // To store the count of people whom the person of index i knows
        vector<int> Iknow(n, 0);
        
        // Traverse on the given matrix
        for(int i=0; i < n; i++) {
            for(int j=0; j < n; j++) {
                
                // If person i knows person j
                if(M[i][j] == 1) {
                    knowMe[j]++;
                    Iknow[i]++;
                }
            }
        }
        
        // Traverse for all persons to find the celebrity
        for(int i=0; i < n; i++) {
            
            // Return the index of the celebrity
            if(knowMe[i] == n-1 && Iknow[i] == 0) {
                return i;  
            }
        }
        
        // Return -1 if no celebrity is found
        return -1;
    }
};

int main() {
    vector<vector<int>> M = {
         {0, 1, 1, 0}, 
         {0, 0, 0, 0}, 
         {1, 1, 0, 0}, 
         {0, 1, 1, 0}
    };
    
    // Creating an instance of the Solution class
    Solution sol; 
    
    // Function call to find the index of the celebrity
    int ans = sol.celebrity(M);
    
    cout << "The index of celebrity is: " << ans;
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** $O(NÂ²)$  
  Since we are using two nested loops to traverse the square matrix to populate the lists.

- **Space Complexity:** $O(N)$  
  Since we are using two lists of size `N` to store the count of how many people each person knows and how many people know each person.

---

## Optimal Approach

### Algorithm:

1. Initialize two pointers, one at the top (start) and one at the bottom (end) of the matrix.
2. Compare the individuals at the top and bottom pointers:
   - If the person at the top pointer knows the person at the bottom pointer, move the top pointer down (the top person cannot be the celebrity).
   - If the person at the bottom pointer knows the person at the top pointer, move the bottom pointer up (the bottom person cannot be the celebrity).
   - If neither knows the other, increment both pointers (neither can be the celebrity).
3. After the traversal, the remaining candidate at the top pointer is the potential celebrity.
4. Check if the candidate is a valid celebrity by ensuring that everyone knows this person and this person knows no one.
5. If the candidate is valid, return the index; otherwise, return `-1`, indicating no celebrity.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the index of the celebrity
    int celebrity(vector<vector<int>> &M){
        
        // Size of given matrix
        int n = M.size();
        
        // Top and Down pointers
        int top = 0, down = n-1;
        
        // Traverse for all the people
        while(top < down) {
            
            // If the top knows down, it can not be a celebrity
            if(M[top][down] == 1) {
                top = top + 1;
            }
            
            // If down knowns top, it can not be a celebrity
            else if(M[down][top] == 1) {
                down = down - 1;
            }
            
            // If both does not know each other, neither can be the celebrity 
            else {
                top++;
                down--;
            }
        }
        
        // Return -1 if no celebrity is found
        if(top > down) return -1;
        
        // Check if the person pointed to by the top is a celebrity
        for(int i=0; i < n; i++) {
            if(i == top) continue;
            
            // Check if it is not a celebrity
            if(M[top][i] == 1 || M[i][top] == 0) {
                return -1;
            }
        }
        
        // Return the index of the celebrity
        return top;
    }
};

int main() {
    vector<vector<int>> M = {
         {0, 1, 1, 0}, 
         {0, 0, 0, 0}, 
         {1, 1, 0, 0}, 
         {0, 1, 1, 0}
    };
    
    // Creating an instance of the Solution class
    Solution sol; 
    
    // Function call to find the index of the celebrity
    int ans = sol.celebrity(M);
    
    cout << "The index of celebrity is: " << ans;
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** $O(N)$  
  Eliminating persons to find the candidate and checking if the last candidate is a celebrity both take $O(N)$ time.

- **Space Complexity:** $O(1)$  
  Since we are using only a couple of variables and not any extra data structures.
