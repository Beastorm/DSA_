## Stock Span Problem

**Problem Statement:**  
Given an array `arr` of size `n`, where each element `arr[i]` represents the stock price on day `i`, calculate the span of stock prices for each day.

The span Sᵢ for a specific day i is defined as the maximum number of consecutive previous days (including the current day) for which the stock price was less than or equal to the price on day i.

---

>### Examples:

**Example 1:**  
**Input:**  
n = 7, arr = [120, 100, 60, 80, 90, 110, 115]  
**Output:**  
1 1 1 2 3 5 6

**Explanation:**   
_Traversing the given input span:_
120 is greater than or equal to 120, and there are no more elements behind it, so the span is 1.
100 is greater than or equal to 100 and smaller than 120, so the span is 1.
60 is greater than or equal to 60 and smaller than 100, so the span is 1.
80 is greater than or equal to 60, 8,0 and smaller than 10,0 so the span is 2.
90 is greater than or equal to 60, 80, and 90, and smaller than 100, so the span is 3.
110 is greater than or equal to 60, 80, 90, 100, 110, and smaller than 120, so the span is 5.
115 is greater than or equal to all previous elements and smaller than 120, so the span is 6.
Hence, the output will be 1 1 1 2 3 5 6.

**Example 2:**  
**Input:**   
n = 6, arr = [15, 13, 12, 14, 16, 20]  
**Output:**    
1 1 1 3 5 6

**Explanation:**  _
Traversing the given input span:_
15 is greater than or equal to 15, and there are no more elements behind it, so the span is 1.
13 is smaller than 15, so the span is 1.
12 is smaller than 13, so the span is 1.
14 is greater than or equal to 12 and 13, but smaller than 15, so the span is 3 (days with values 12, 13, and 14).
16 is greater than or equal to 14, 12, 13, and 15, so the span is 5.
20 is greater than or equal to all previous elements, so the span is 6.
Hence, the output will be 1 1 1 3 5 6.

---

## Brute Force

### Algorithm:

1. Initialize an array to store the stock span for each day.
2. Start traversing the given stock prices array.
3. For each element, traverse backward to find the previous day with a stock price less than or equal to the current day's price.
4. Calculate the span by counting the number of consecutive days with stock prices greater than or equal to the current day's price.
5. Store the calculated stock span for each day in the array.
6. Once the traversal is complete, return the array containing the stock spans.


### C++ Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // Function to find the span of stock prices for each day
    vector <int> stockSpan(vector<int> arr, int n) {
        
        // To store the answer
        vector<int> ans(n);
        
        // Traverse on the array
        for(int i=0; i < n; i++) {
            
            // To store the current span of stocks
            int currSpan = 0;
            
            // Traversing backwards to find stock span
            for(int j=i; j >= 0; j--) {
            
                // Update stock span
                if(arr[j] <= arr[i]) {
                    currSpan++;
                }
                
                // Else break out from loop
                else break;
            }
            
            // Store the current span
            ans[i] = currSpan;
        }
        
        // Return the result
        return ans;
    }
};

int main() {
    int n = 7;
    vector<int> arr = {120, 100, 60, 80, 90, 110, 115};
    
    /* Creating an instance of 
    Solution class */
    Solution sol; 
    
    /* Function call to find the span 
    of stock prices for each day */
    vector<int> ans = sol.stockSpan(arr, n);
    
    cout << "The span of stock prices is: ";
    for(int i=0; i < n; i++) {
        cout << ans[i] << " ";
    }
    
    return 0;
}
```
### Complexity Analysis:

- **Time Complexity:** O(N²)  
  Since we are using two nested loops to calculate the span for each day.

- **Space Complexity:** O(1)  
  Since we are using only a couple of variables (excluding the output array).

  ---
## Optimal Approach

### Algorithm:

1. Initialize an empty stack to maintain indices of elements in decreasing order.
2. Traverse through the given stock prices array.
3. For each element:
   - Pop elements from the stack until the current price is less than or equal to the price at the top of the stack.
   - If the stack is not empty, the index at the top of the stack is the previous greater element.
   - Calculate the stock span as the difference between the current index and the index of the previous greater element.
   - If the stack is empty, the current stock price is the largest so far, and the span is the current index + 1.
   - Push the current index onto the stack.
4. After completing the traversal, return the array of stock spans.


### C++ Code:
  ``` cpp
  #include <bits/stdc++.h>
using namespace std;

class Solution {
private:
    /* Function to find the indices of previous 
    greater element for each element in the array */
    vector<int> findPGE(vector<int> arr) {
        
        int n = arr.size(); //size of array
        
        // To store the previous greater elements
        vector<int> ans(n);
        
        // Stack to get elements in LIFO fashion
        stack<int> st;
        
        // Start traversing from the front
        for(int i=0; i < n; i++) {
            
            // Get the current element
            int currEle = arr[i];
            
            /* Pop the elements in the stack until 
            the stack is not empty and the top 
            element is not the greater element */
            while(!st.empty() && arr[st.top()] <= currEle) {
                st.pop();
            }
            
            /* If the greater element is not 
            found, stack will be empty */
            if(st.empty()) 
                ans[i] = -1;
                
            // Else store the answer
            else 
                ans[i] = st.top();
            
            // Push the current index in the stack 
            st.push(i);
        }
        
        // Return the result
        return ans;
    }
    
public:
    // Function to find the span of stock prices for each day
    vector <int> stockSpan(vector<int> arr, int n) {
        
        // Get the indices of previous greater elements
        vector<int> PGE = findPGE(arr);
        
        
        // To store the answer
        vector<int> ans(n);
        
        // Compute the result
        for(int i=0; i < n; i++) {
            ans[i] = i - PGE[i];
        }
        
        // Return the result
        return ans;
    }
};

int main() {
    int n = 7;
    vector<int> arr = {120, 100, 60, 80, 90, 110, 115};
    
    /* Creating an instance of 
    Solution class */
    Solution sol; 
    
    /* Function call to find the span 
    of stock prices for each day */
    vector<int> ans = sol.stockSpan(arr, n);
    
    cout << "The span of stock prices is: ";
    for(int i=0; i < n; i++) {
        cout << ans[i] << " ";
    }
    
    return 0;
}
```

### Complexity Analysis:

- **Time Complexity:** O(N)  
  Finding the indices of previous greater elements takes O(N) time, and we traverse the array once to compute the stock span, which also takes O(N) time.

- **Space Complexity:** O(N)  
  The stack space used to find the previous greater elements can go up to O(N) in the worst case.
